
ifeq "$(wildcard distrib/)" ""

# We're in a bindist

.PHONY: default
default:
	@echo 'Run "make install" to install'
	@false

.PHONY: install
install:
	$(MAKE) -r --no-print-directory -f ghc.mk install BINDIST=YES NO_INCLUDE_DEPS=YES

.PHONY: show
show:
	$(MAKE) -r --no-print-directory -f ghc.mk $@

else

# The problem we need to solve is as follows.  
#
# GNU make supports included Makefiles, and it is clever enough to try
# to update those Makefiles when they are out-of-date or missing.  It
# first reads all the Makefiles, and then tries to build each one if
# it is out-of-date, using the rules in the Makefiles themselves.
# When it has brought all the Makefiles up-to-date, it restarts itself
# to read the newly-generated Makefiles.
#
# This works fine, unless there are dependencies *between* the
# Makefiles.  For example in the GHC build, for each package we have a
# package-data.mk file which is generated by the ghc-cabal program,
# and we have a .depend file.  The .depend file cannot be generated
# until package-data.mk has been generated and make has been restarted
# to read in its contents, because it is the package-data.mk file that
# tells us which modules are in the package.  But make always makes
# all the Makefiles before restarting - it doesn't take into account a
# dependency between Makefiles and restart itself earlier.

# Consider the following makefile:

# --------------------
# all :
#
# include inc1.mk
# 
# inc1.mk : Makefile
# 	echo "X = C" >$@
# 
# include inc2.mk
# 
# inc2.mk : inc1.mk
# 	echo "Y = $(X)" >$@
# --------------------

# Now try it:
# 
# $ make -f fail.mk
# fail.mk:3: inc1.mk: No such file or directory
# fail.mk:8: inc2.mk: No such file or directory
# echo "X = C" >inc1.mk
# echo "Y = " >inc2.mk
# make: Nothing to be done for `all'.

# make built both inc1.mk and inc2.mk without restarting itself
# between the two (even though we added a dependency on inc1.mk from
# inc2.mk).
#
# The solution we adopt in the GHC build system is essentially this:

# --------------------
# PHASE = 0
# 
# ifeq "$(PHASE)" "0"
# all :
# 	$(MAKE) PHASE=1
# else
# all :
# endif
# 
# -include inc1.mk
# 
# inc1.mk : Makefile
# 	echo "X = C" >$@
# 
# ifneq "$(PHASE)" "0"
# include inc2.mk
# 
# inc2.mk : inc1.mk
# 	echo "Y = $(X)" >$@
# endif
# 
# clean :
# 	rm -f inc1.mk inc2.mk
# --------------------

# That is, every time make is invoked, we force it to update inc1.mk
# and then restart.  In the GHC build system we need to divide the
# build into 4 phases in fact, with a restart between each phase.  See
# ghc.mk for the details on what happens in each phase and why.

default : all
	@:

# No need to update makefiles for these targets:
REALGOALS=$(filter-out clean clean_% distclean maintainer-clean show,$(MAKECMDGOALS))

# NB. not the same as saying '%: ...', which doesn't do the right thing:
# it does nothing if we specify a target that already exists.
.PHONY: $(REALGOALS)
$(REALGOALS) all:
	@echo "===--- updating makefiles phase 0"
	$(MAKE) -r --no-print-directory -f ghc.mk phase=0 just-makefiles
	@echo "===--- updating makefiles phase 1"
	$(MAKE) -r --no-print-directory -f ghc.mk phase=1 just-makefiles
	@echo "===--- updating makefiles phase 2"
	$(MAKE) -r --no-print-directory -f ghc.mk phase=2 just-makefiles
	@echo "===--- updating makefiles phase 3"
	$(MAKE) -r --no-print-directory -f ghc.mk phase=3 just-makefiles
	@echo "===--- finished updating makefiles"
	$(MAKE) -r --no-print-directory -f ghc.mk $@

binary-dist:
	rm -f bindist-list
	$(MAKE) -r --no-print-directory -f ghc.mk bindist BINDIST=YES
	$(MAKE) -r --no-print-directory -f ghc.mk binary-dist

clean distclean maintainer-clean:
	$(MAKE) -r --no-print-directory -f ghc.mk $@
	test ! -d testsuite || $(MAKE) -C testsuite $@

$(filter clean_%, $(MAKECMDGOALS)) : clean_% :
	$(MAKE) -r --no-print-directory -f ghc.mk $@

show:
	$(MAKE) -r --no-print-directory -f ghc.mk $@

# If the user says 'make A B', then we don't want to invoke two
# instances of the rule above in parallel:
.NOTPARALLEL:

endif

