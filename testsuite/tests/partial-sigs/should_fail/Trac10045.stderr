
Trac10045.hs:6:17: error:
    Found type wildcard ‘_’ standing for ‘t1 -> a -> t2’
    Where: ‘t1’ is a rigid type variable bound by
             the inferred type of copy :: Num a => t1 -> a -> t2
             at Trac10045.hs:7:9
           ‘t2’ is a rigid type variable bound by
             the inferred type of copy :: Num a => t1 -> a -> t2
             at Trac10045.hs:7:9
           ‘a’ is a rigid type variable bound by
             the inferred type of copy :: Num a => t1 -> a -> t2
             at Trac10045.hs:7:9
    To use the inferred type, enable PartialTypeSignatures
    Relevant bindings include
      copy :: t1 -> a -> t2 (bound at Trac10045.hs:7:9)
      ws1 :: () (bound at Trac10045.hs:5:11)
      foo :: Meta -> t (bound at Trac10045.hs:5:1)
    In the type signature:
      copy :: _
    In the expression:
      let
        copy :: _
        copy w from = copy w 1
      in copy ws1 1
    In an equation for ‘foo’:
        foo (Meta ws1)
          = let
              copy :: _
              copy w from = copy w 1
            in copy ws1 1

Trac10045.hs:7:9: error:
    No instance for (Num a)
    When checking that the inferred type
      copy :: forall t t1 a. Num a => t -> a -> t1
    is as general as its (partial) signature
      copy :: forall t t1 a. t -> a -> t1
    In the expression:
      let
        copy :: _
        copy w from = copy w 1
      in copy ws1 1
    In an equation for ‘foo’:
        foo (Meta ws1)
          = let
              copy :: _
              copy w from = copy w 1
            in copy ws1 1
