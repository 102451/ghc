[1 of 1] Compiling Main             ( landmines.hs, landmines.o )

==================== Parser ====================
module Main where
import Data.Data
import System.IO
import GHC
import MonadUtils
import Outputable
import Bag ( filterBag, isEmptyBag )
import System.Directory ( removeFile )
import System.Environment ( getArgs )
main :: IO ()
main
  = do { [libdir] <- getArgs;
         testOneFile libdir "MineFixity";
         testOneFile libdir "MineKind";
         testOneFile libdir "MineNames";
         testOneFile libdir "MineType" }
testOneFile libdir fileName
  = do { (p, r, ts) <- runGhc (Just libdir)
                       $ do { dflags <- getSessionDynFlags;
                              setSessionDynFlags dflags;
                              let mn = mkModuleName fileName;
                              addTarget
                                Target
                                  {targetId = TargetModule mn, targetAllowObjCode = True,
                                   targetContents = Nothing};
                              load LoadAllTargets;
                              modSum <- getModSummary mn;
                              p <- parseModule modSum;
                              t <- typecheckModule p;
                              d <- desugarModule t;
                              l <- loadModule d;
                              let ts = typecheckedSource l
                                  r = renamedSource l;
                              return (pm_parsed_source p, r, ts) };
         let pCount = gq p
             rCount = gq r
             tsCount = gq ts;
         print (pCount, rCount, tsCount) }
  where
      gq ast = length $ everything (++) ([] `mkQ` worker) ast
      worker (s@(RealSrcSpan _)) = [s]
      worker _ = []
type GenericQ r = forall a. Data a => a -> r
mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
(r `mkQ` br) a
  = case cast a of {
      Just b -> br b
      Nothing -> r }
everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
everything k f x = foldl k (f x) (gmapQ (everything k f) x)



==================== Source Statistics ====================
ExportAll        1
Imports          8
  ImpAll         5
  ImpPartial     3
TypeDecls        1
TypeSigs         3
FunBinds         4



==================== Desugar (before optimization) ====================
Result size of Desugar (before optimization)
  = {terms: 617, types: 951, coercions: 243}

Rec {
-- RHS size: {terms: 1, types: 0, coercions: 0}
$dMonad_aebb :: Monad IO
[LclId, Str=DmdType]
$dMonad_aebb = $dMonad_aeaH

-- RHS size: {terms: 1, types: 0, coercions: 0}
$dMonad_aeb3 :: Monad IO
[LclId, Str=DmdType]
$dMonad_aeb3 = $dMonad_aeaH

-- RHS size: {terms: 1, types: 0, coercions: 0}
$dMonad_aeaV :: Monad IO
[LclId, Str=DmdType]
$dMonad_aeaV = $dMonad_aeaH

-- RHS size: {terms: 1, types: 0, coercions: 0}
$dMonad_aeaO :: Monad IO
[LclId, Str=DmdType]
$dMonad_aeaO = $dMonad_aeaH

-- RHS size: {terms: 1, types: 0, coercions: 0}
$dMonad_aeaH :: Monad IO
[LclId, Str=DmdType]
$dMonad_aeaH = GHC.Base.$fMonadIO

-- RHS size: {terms: 53, types: 64, coercions: 0}
everything
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO) -> GenericQ r_a3PO -> GenericQ r_a3PO
[LclIdX, Str=DmdType]
everything =
  \ (@ r_a4XV) ->
    letrec {
      everything_a55x
        :: (r_a4XV -> r_a4XV -> r_a4XV)
           -> GenericQ r_a4XV -> GenericQ r_a4XV
      [LclId, Str=DmdType]
      everything_a55x =
        \ (dk_aecm :: r_a4XV -> r_a4XV -> r_a4XV)
          (dk_aecn :: GenericQ r_a4XV)
          (@ a_a55z)
          ($dData_a55A :: Data a_a55z) ->
          (let {
             $dData_a56a :: Data a_a55z
             [LclId, Str=DmdType]
             $dData_a56a = $dData_a55A } in
           let {
             $dData_a565 :: Data a_a55z
             [LclId, Str=DmdType]
             $dData_a565 = $dData_a55A } in
           let {
             $dFoldable_a55Z :: Foldable []
             [LclId, Str=DmdType]
             $dFoldable_a55Z = Data.Foldable.$fFoldable[] } in
           let {
             $dTypeable_aeci :: Typeable a_a55z
             [LclId, Str=DmdType]
             $dTypeable_aeci = Data.Data.$p1Data @ a_a55z $dData_a55A } in
           \ (k_a4WN :: r_a4XV -> r_a4XV -> r_a4XV)
             (f_a4WO :: GenericQ r_a4XV)
             (x_a4WP :: a_a55z) ->
             foldl
               @ []
               $dFoldable_a55Z
               @ r_a4XV
               @ r_a4XV
               k_a4WN
               (f_a4WO @ a_a55z $dData_a565 x_a4WP)
               (gmapQ
                  @ a_a55z
                  $dData_a56a
                  @ r_a4XV
                  (\ (@ d_a56e) ($dData_a56f :: Data d_a56e) ->
                     let {
                       $dData_a56k :: Data d_a56e
                       [LclId, Str=DmdType]
                       $dData_a56k = $dData_a56f } in
                     let {
                       $dTypeable_aecj :: Typeable d_a56e
                       [LclId, Str=DmdType]
                       $dTypeable_aecj = Data.Data.$p1Data @ d_a56e $dData_a56f } in
                     (\ (di_aecw :: r_a4XV -> r_a4XV -> r_a4XV)
                        (di_aecx :: GenericQ r_a4XV) ->
                        everything @ r_a4XV di_aecw di_aecx @ d_a56e $dData_a56k)
                       k_a4WN
                       (\ (@ a_a56m) ($dData_a56n :: Data a_a56m) ->
                          let {
                            $dData_a56q :: Data a_a56m
                            [LclId, Str=DmdType]
                            $dData_a56q = $dData_a56n } in
                          let {
                            $dTypeable_aeck :: Typeable a_a56m
                            [LclId, Str=DmdType]
                            $dTypeable_aeck = Data.Data.$p1Data @ a_a56m $dData_a56n } in
                          f_a4WO @ a_a56m $dData_a56q))
                  x_a4WP))
            dk_aecm dk_aecn; } in
    everything_a55x

-- RHS size: {terms: 26, types: 31, coercions: 0}
mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Typeable a_a3PP, Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX, Str=DmdType]
mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v :: Typeable a_a4Yh)
    ($dTypeable_a56w :: Typeable b_a4Yi) ->
    let {
      $dTypeable_a56F :: Typeable b_a4Yi
      [LclId, Str=DmdType]
      $dTypeable_a56F = $dTypeable_a56w } in
    let {
      $dTypeable_a56E :: Typeable a_a4Yh
      [LclId, Str=DmdType]
      $dTypeable_a56E = $dTypeable_a56v } in
    letrec {
      mkQ_a56x :: r_a4Yj -> (b_a4Yi -> r_a4Yj) -> a_a4Yh -> r_a4Yj
      [LclId, Str=DmdType]
      mkQ_a56x =
        \ (r_a4Ww :: r_a4Yj)
          (br_a4Wx :: b_a4Yi -> r_a4Yj)
          (a_a4Wy :: a_a4Yh) ->
          let {
            ds_dedx :: Maybe b_a4Yi
            [LclId, Str=DmdType]
            ds_dedx =
              cast @ a_a4Yh @ b_a4Yi $dTypeable_a56E $dTypeable_a56F a_a4Wy } in
          case ds_dedx of wild_00 {
            Nothing -> r_a4Ww;
            Just b_a4WM -> br_a4Wx b_a4WM
          }; } in
    mkQ_a56x

-- RHS size: {terms: 469, types: 784, coercions: 243}
testOneFile :: FilePath -> String -> IO ()
[LclIdX, Str=DmdType]
testOneFile =
  let {
    cobox_a9qp :: String ~ String
    [LclId, Str=DmdType]
    cobox_a9qp =
      Eq# @ * @ String @ String @~ (<String>_N :: String ~# String) } in
  let {
    $dShow_aeau :: Show Int
    [LclId, Str=DmdType]
    $dShow_aeau = GHC.Show.$fShowInt } in
  let {
    $dShow_aeav :: Show Int
    [LclId, Str=DmdType]
    $dShow_aeav = $dShow_aeau } in
  let {
    $dShow_aeaw :: Show Int
    [LclId, Str=DmdType]
    $dShow_aeaw = $dShow_aeau } in
  let {
    $dShow_ae3q :: Show (Int, Int, Int)
    [LclId, Str=DmdType]
    $dShow_ae3q =
      GHC.Show.$fShow(,,)
        @ Int @ Int @ Int $dShow_aeau $dShow_aeav $dShow_aeaw } in
  let {
    $dTypecheckedMod_aakq :: TypecheckedMod DesugaredModule
    [LclId, Str=DmdType]
    $dTypecheckedMod_aakq = GHC.$fTypecheckedModDesugaredModule } in
  let {
    $dGhcMonad_a9q4 :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9q4 = GhcMonad.$fGhcMonadGhc } in
  let {
    $dGhcMonad_a9qm :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9qm = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_a9qJ :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9qJ = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aaiO :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aaiO = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aaj9 :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aaj9 = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajq :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajq = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajH :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajH = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajY :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajY = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aakr :: GhcMonad Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aakr = $dGhcMonad_a9q4 } in
  let {
    $dMonad_a6SJ :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_a6SJ = GhcMonad.$fMonadGhc } in
  let {
    $dMonad_a9qf :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_a9qf = $dMonad_a6SJ } in
  let {
    $dMonad_a9qy :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_a9qy = $dMonad_a6SJ } in
  let {
    $dMonad_a9Gu :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_a9Gu = $dMonad_a6SJ } in
  let {
    $dMonad_aaj2 :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_aaj2 = $dMonad_a6SJ } in
  let {
    $dMonad_aajj :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_aajj = $dMonad_a6SJ } in
  let {
    $dMonad_aajA :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_aajA = $dMonad_a6SJ } in
  let {
    $dMonad_aajR :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_aajR = $dMonad_a6SJ } in
  let {
    $dMonad_aak8 :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_aak8 = $dMonad_a6SJ } in
  let {
    $dMonad_abWp :: Monad Ghc
    [LclId, Str=DmdType]
    $dMonad_abWp = $dMonad_a6SJ } in
  let {
    $dMonad_a6Q1 :: Monad IO
    [LclId, Str=DmdType]
    $dMonad_a6Q1 = GHC.Base.$fMonadIO } in
  letrec {
    testOneFile_a56I :: FilePath -> String -> IO ()
    [LclId, Str=DmdType]
    testOneFile_a56I =
      \ (libdir_a3SP :: FilePath) (fileName_a3SQ :: String) ->
        letrec {
          worker_a3SS :: SrcSpan -> [SrcSpan]
          [LclId, Str=DmdType]
          worker_a3SS =
            letrec {
              worker_a56N :: SrcSpan -> [SrcSpan]
              [LclId, Str=DmdType]
              worker_a56N =
                \ (s_a41A :: SrcSpan) ->
                  let {
                    fail_dedK :: Void# -> [SrcSpan]
                    [LclId, Str=DmdType]
                    fail_dedK = \ (ds_dedL [OS=OneShot] :: Void#) -> [] @ SrcSpan } in
                  case s_a41A of wild_00 {
                    __DEFAULT -> fail_dedK void#;
                    RealSrcSpan ds_dedJ -> : @ SrcSpan s_a41A ([] @ SrcSpan)
                  }; } in
            worker_a56N; } in
        letrec {
          gq_a3SR :: forall a_a5bd. Data a_a5bd => a_a5bd -> Int
          [LclId, Str=DmdType]
          gq_a3SR =
            \ (@ a_a5bd) ($dData_a6PB :: Data a_a5bd) ->
              let {
                $dData_a5bf :: Data a_a5bd
                [LclId, Str=DmdType]
                $dData_a5bf = $dData_a6PB } in
              let {
                $dTypeable_aeax :: Typeable a_a5bd
                [LclId, Str=DmdType]
                $dTypeable_aeax = Data.Data.$p1Data @ a_a5bd $dData_a6PB } in
              let {
                cobox_a6Pz :: SrcSpan ~ SrcSpan
                [LclId, Str=DmdType]
                cobox_a6Pz =
                  Eq#
                    @ * @ SrcSpan @ SrcSpan @~ (<SrcSpan>_N :: SrcSpan ~# SrcSpan) } in
              let {
                $dFoldable_a5b8 :: Foldable []
                [LclId, Str=DmdType]
                $dFoldable_a5b8 = Data.Foldable.$fFoldable[] } in
              letrec {
                gq_a5b1 :: a_a5bd -> Int
                [LclId, Str=DmdType]
                gq_a5b1 =
                  \ (ast_a3ST :: a_a5bd) ->
                    $ @ [SrcSpan]
                      @ Int
                      (length @ [] $dFoldable_a5b8 @ SrcSpan)
                      ((\ (di_aecF :: [SrcSpan] -> [SrcSpan] -> [SrcSpan])
                          (di_aecG :: GenericQ [SrcSpan]) ->
                          everything @ [SrcSpan] di_aecF di_aecG @ a_a5bd $dData_a5bf)
                         (++ @ SrcSpan)
                         (\ (@ a_a5bk) ($dData_a5bl :: Data a_a5bk) ->
                            let {
                              $dTypeable_a5br :: Typeable SrcSpan
                              [LclId, Str=DmdType]
                              $dTypeable_a5br =
                                D:Typeable
                                  @ *
                                  @ SrcSpan
                                  (let {
                                     ds_dedF :: TypeRep
                                     [LclId, Str=DmdType]
                                     ds_dedF =
                                       mkPolyTyConApp
                                         SrcLoc.$tcSrcSpan ([] @ TypeRep) ([] @ TypeRep) } in
                                   \ (wild_00 :: Proxy# SrcSpan) -> ds_dedF) } in
                            let {
                              cobox_a5bs :: SrcSpan ~ SrcSpan
                              [LclId, Str=DmdType]
                              cobox_a5bs =
                                Eq#
                                  @ *
                                  @ SrcSpan
                                  @ SrcSpan
                                  @~ (<SrcSpan>_N :: SrcSpan ~# SrcSpan) } in
                            let {
                              $dTypeable_a6Py :: Typeable a_a5bk
                              [LclId, Str=DmdType]
                              $dTypeable_a6Py = Data.Data.$p1Data @ a_a5bk $dData_a5bl } in
                            let {
                              $dTypeable_a5bq :: Typeable a_a5bk
                              [LclId, Str=DmdType]
                              $dTypeable_a5bq = $dTypeable_a6Py } in
                            mkQ
                              @ a_a5bk
                              @ SrcSpan
                              @ [SrcSpan]
                              $dTypeable_a5bq
                              $dTypeable_a5br
                              ([] @ SrcSpan)
                              (case cobox_a5bs of cobox_a5bs { Eq# cobox_dedH -> worker_a3SS }))
                         ast_a3ST); } in
              gq_a5b1; } in
        >>=
          @ IO
          $dMonad_a6Q1
          @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
          @ ()
          ($ @ (Ghc (ParsedSource, Maybe RenamedSource, TypecheckedSource))
             @ (IO (ParsedSource, Maybe RenamedSource, TypecheckedSource))
             (runGhc
                @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                (Just @ FilePath libdir_a3SP))
             (>>=
                @ Ghc
                $dMonad_a6SJ
                @ DynFlags
                @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                (getSessionDynFlags @ Ghc $dGhcMonad_a9q4)
                (\ (dflags_a4fE :: DynFlags) ->
                   >>
                     @ Ghc
                     $dMonad_a9qf
                     @ [UnitId]
                     @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                     (setSessionDynFlags @ Ghc $dGhcMonad_a9qm dflags_a4fE)
                     (letrec {
                        mn_a4fF :: ModuleName
                        [LclId, Str=DmdType]
                        mn_a4fF =
                          letrec {
                            mn_a9qo :: ModuleName
                            [LclId, Str=DmdType]
                            mn_a9qo =
                              mkModuleName
                                (case cobox_a9qp of cobox_a9qp { Eq# cobox_dee6 ->
                                 fileName_a3SQ
                                 }); } in
                          mn_a9qo; } in
                      >>
                        @ Ghc
                        $dMonad_a9qy
                        @ ()
                        @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                        (addTarget
                           @ Ghc
                           $dGhcMonad_a9qJ
                           (HscTypes.Target
                              (HscTypes.TargetModule mn_a4fF)
                              True
                              (Nothing
                                 @ (StringBuffer.StringBuffer,
                                    time-1.5.0.1:Data.Time.Clock.UTC.UTCTime))))
                        (>>
                           @ Ghc
                           $dMonad_a9Gu
                           @ SuccessFlag
                           @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                           (load @ Ghc $dGhcMonad_aaiO GhcMake.LoadAllTargets)
                           (>>=
                              @ Ghc
                              $dMonad_aaj2
                              @ ModSummary
                              @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                              (getModSummary @ Ghc $dGhcMonad_aaj9 mn_a4fF)
                              (\ (modSum_a4Wj :: ModSummary) ->
                                 >>=
                                   @ Ghc
                                   $dMonad_aajj
                                   @ ParsedModule
                                   @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                   (parseModule @ Ghc $dGhcMonad_aajq modSum_a4Wj)
                                   (\ (p_a4Wk :: ParsedModule) ->
                                      >>=
                                        @ Ghc
                                        $dMonad_aajA
                                        @ TypecheckedModule
                                        @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                        (typecheckModule @ Ghc $dGhcMonad_aajH p_a4Wk)
                                        (\ (t_a4Wl :: TypecheckedModule) ->
                                           >>=
                                             @ Ghc
                                             $dMonad_aajR
                                             @ DesugaredModule
                                             @ (ParsedSource, Maybe RenamedSource,
                                                TypecheckedSource)
                                             (desugarModule @ Ghc $dGhcMonad_aajY t_a4Wl)
                                             (\ (d_a4Wm :: DesugaredModule) ->
                                                >>=
                                                  @ Ghc
                                                  $dMonad_aak8
                                                  @ DesugaredModule
                                                  @ (ParsedSource, Maybe RenamedSource,
                                                     TypecheckedSource)
                                                  (loadModule
                                                     @ DesugaredModule
                                                     @ Ghc
                                                     $dTypecheckedMod_aakq
                                                     $dGhcMonad_aakr
                                                     d_a4Wm)
                                                  (\ (l_a4Wn :: DesugaredModule) ->
                                                     letrec {
                                                       r_a4Wp :: Maybe RenamedSource
                                                       [LclId, Str=DmdType]
                                                       r_a4Wp =
                                                         let {
                                                           $dTypecheckedMod_aakw
                                                             :: TypecheckedMod DesugaredModule
                                                           [LclId, Str=DmdType]
                                                           $dTypecheckedMod_aakw =
                                                             GHC.$fTypecheckedModDesugaredModule } in
                                                         letrec {
                                                           r_aakt :: Maybe RenamedSource
                                                           [LclId, Str=DmdType]
                                                           r_aakt =
                                                             renamedSource
                                                               @ DesugaredModule
                                                               $dTypecheckedMod_aakw
                                                               l_a4Wn; } in
                                                         r_aakt; } in
                                                     letrec {
                                                       ts_a4Wo :: TypecheckedSource
                                                       [LclId, Str=DmdType]
                                                       ts_a4Wo =
                                                         let {
                                                           $dTypecheckedMod_abre
                                                             :: TypecheckedMod DesugaredModule
                                                           [LclId, Str=DmdType]
                                                           $dTypecheckedMod_abre =
                                                             GHC.$fTypecheckedModDesugaredModule } in
                                                         letrec {
                                                           ts_abrb :: TypecheckedSource
                                                           [LclId, Str=DmdType]
                                                           ts_abrb =
                                                             typecheckedSource
                                                               @ DesugaredModule
                                                               $dTypecheckedMod_abre
                                                               l_a4Wn; } in
                                                         ts_abrb; } in
                                                     return
                                                       @ Ghc
                                                       $dMonad_abWp
                                                       @ (ParsedSource, Maybe RenamedSource,
                                                          TypecheckedSource)
                                                       (pm_parsed_source p_a4Wk, r_a4Wp,
                                                        ts_a4Wo))))))))))))
          (\ (ds_dedD
                :: (ParsedSource, Maybe RenamedSource, TypecheckedSource)) ->
             case ds_dedD of wild_00 { (p_a4Wq, r_a4Wr, ts_a4Ws) ->
             letrec {
               tsCount_a4Wv :: Int
               [LclId, Str=DmdType]
               tsCount_a4Wv =
                 let {
                   $dData_adT3 :: Data TcEvidence.HsWrapper
                   [LclId, Str=DmdType]
                   $dData_adT3 = TcEvidence.$fDataHsWrapper } in
                 let {
                   $dData_adT8 :: Data ConLike.ConLike
                   [LclId, Str=DmdType]
                   $dData_adT8 = ConLike.$fDataConLike } in
                 let {
                   $dData_adT2 :: Data [ConLike.ConLike]
                   [LclId, Str=DmdType]
                   $dData_adT2 = Data.Data.$fData[] @ ConLike.ConLike $dData_adT8 } in
                 let {
                   $dData_adSZ :: Data Coercion.Coercion
                   [LclId, Str=DmdType]
                   $dData_adSZ = Coercion.$fDataCoercion } in
                 let {
                   $dData_adSY :: Data Type
                   [LclId, Str=DmdType]
                   $dData_adSY = TypeRep.$fDataType } in
                 let {
                   $dData_adT1 :: Data [Type]
                   [LclId, Str=DmdType]
                   $dData_adT1 = Data.Data.$fData[] @ Type $dData_adSY } in
                 let {
                   $dData_adSU :: Data Bool
                   [LclId, Str=DmdType]
                   $dData_adSU = Data.Data.$fDataBool } in
                 let {
                   $dData_adST :: Data GHC.Fixity
                   [LclId, Str=DmdType]
                   $dData_adST = BasicTypes.$fDataFixity } in
                 let {
                   $dData_adT7 :: Data Name
                   [LclId, Str=DmdType]
                   $dData_adT7 = Name.$fDataName } in
                 let {
                   $dData_adSV :: Data Name
                   [LclId, Str=DmdType]
                   $dData_adSV = $dData_adT7 } in
                 let {
                   $dData_adSW :: Data [Name]
                   [LclId, Str=DmdType]
                   $dData_adSW = Data.Data.$fData[] @ Name $dData_adT7 } in
                 let {
                   $dData_adT9 :: Data (FieldLabel.FieldLbl Name)
                   [LclId, Str=DmdType]
                   $dData_adT9 = FieldLabel.$fDataFieldLbl @ Name $dData_adT7 } in
                 let {
                   $dData_adT4 :: Data [FieldLabel.FieldLabel]
                   [LclId, Str=DmdType]
                   $dData_adT4 =
                     Data.Data.$fData[] @ (FieldLabel.FieldLbl Name) $dData_adT9 } in
                 let {
                   $dData_adSS :: Data (UniqFM.UniqFM Name)
                   [LclId, Str=DmdType]
                   $dData_adSS = UniqFM.$fDataUniqFM @ Name $dData_adT7 } in
                 let {
                   $dData_adSR :: Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adSR = Var.$fDataVar } in
                 let {
                   $dData_adSX :: Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adSX = $dData_adSR } in
                 let {
                   $dData_adT0 :: Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adT0 = $dData_adSR } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adSQ
                     :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                         Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                         Data Coercion.Coercion, Data Var.Var, Data [Type],
                         Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                         Data [FieldLabel.FieldLabel])
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adSQ =
                     ($dData_adSR, $dData_adSS, $dData_adST, $dData_adSU, $dData_adSV,
                      $dData_adSW, $dData_adSX, $dData_adSY, $dData_adSZ, $dData_adT0,
                      $dData_adT1, $dData_adT2, $dData_adT3, $dData_adT4) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adMZ :: DataId Var.Var
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adMZ =
                     $d(%,,,,,,,,,,,,,%)_adSQ
                     `cast` ((<Data Var.Var>_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnVarty[0] <UniqFM.UniqFM Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                 Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                                 Data Coercion.Coercion, Data Var.Var, Data [Type],
                                 Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                                 Data [FieldLabel.FieldLabel])
                                ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                     Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                     Data (PostRn Id Name), Data (PostRn Id [Name]),
                                     Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                     Data (PostTc Id Coercion.Coercion), Data (PostTc Id Var.Var),
                                     Data (PostTc Id [Type]), Data (PostTc Id [ConLike.ConLike]),
                                     Data (PostTc Id TcEvidence.HsWrapper),
                                     Data (PostTc Id [FieldLabel.FieldLabel]))) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adMY :: DataId Var.Var
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adMY =
                     $d(%,,,,,,,,,,,,,%)_adSQ
                     `cast` ((<Data Var.Var>_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnVarty[0] <UniqFM.UniqFM Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                 Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                                 Data Coercion.Coercion, Data Var.Var, Data [Type],
                                 Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                                 Data [FieldLabel.FieldLabel])
                                ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                     Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                     Data (PostRn Id Name), Data (PostRn Id [Name]),
                                     Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                     Data (PostTc Id Coercion.Coercion), Data (PostTc Id Var.Var),
                                     Data (PostTc Id [Type]), Data (PostTc Id [ConLike.ConLike]),
                                     Data (PostTc Id TcEvidence.HsWrapper),
                                     Data (PostTc Id [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_accn :: Data (HsBindLR Id Id)
                   [LclId, Str=DmdType]
                   $dData_accn =
                     HsBinds.$fDataHsBindLR
                       @ Var.Var
                       @ Var.Var
                       $d(%,,,,,,,,,,,,,%)_adMY
                       $d(%,,,,,,,,,,,,,%)_adMZ } in
                 let {
                   $dData_accm :: Data SrcSpan
                   [LclId, Str=DmdType]
                   $dData_accm = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_accl :: Data (GenLocated SrcSpan (HsBindLR Id Id))
                   [LclId, Str=DmdType]
                   $dData_accl =
                     SrcLoc.$fDataGenLocated
                       @ SrcSpan @ (HsBindLR Id Id) $dData_accm $dData_accn } in
                 let {
                   $dData_aca0 :: Data TypecheckedSource
                   [LclId, Str=DmdType]
                   $dData_aca0 =
                     Bag.$fDataBag
                       @ (GenLocated SrcSpan (HsBindLR Id Id)) $dData_accl } in
                 letrec {
                   tsCount_ac9X :: Int
                   [LclId, Str=DmdType]
                   tsCount_ac9X =
                     gq_a3SR @ TypecheckedSource $dData_aca0 ts_a4Ws; } in
                 tsCount_ac9X; } in
             letrec {
               rCount_a4Wu :: Int
               [LclId, Str=DmdType]
               rCount_a4Wu =
                 let {
                   $dData_adTR :: Data HsDocString
                   [LclId, Str=DmdType]
                   $dData_adTR = HsDoc.$fDataHsDocString } in
                 let {
                   $dData_adTL :: Data SrcSpan
                   [LclId, Str=DmdType]
                   $dData_adTL = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_adTQ :: Data (GenLocated SrcSpan HsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTQ =
                     SrcLoc.$fDataGenLocated
                       @ SrcSpan @ HsDocString $dData_adTL $dData_adTR } in
                 let {
                   $dData_adTn :: Data (Maybe LHsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTn =
                     Data.Data.$fDataMaybe
                       @ (GenLocated SrcSpan HsDocString) $dData_adTQ } in
                 let {
                   $dData_adTD :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTD = PlaceHolder.$fDataPlaceHolder } in
                 let {
                   $dData_adTE :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTE = $dData_adTD } in
                 let {
                   $dData_adTF :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTF = $dData_adTD } in
                 let {
                   $dData_adTG :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTG = $dData_adTD } in
                 let {
                   $dData_adTH :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTH = $dData_adTD } in
                 let {
                   $dData_adTI :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTI = $dData_adTD } in
                 let {
                   $dData_adTJ :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTJ = $dData_adTD } in
                 let {
                   $dData_adTz :: Data Bool
                   [LclId, Str=DmdType]
                   $dData_adTz = Data.Data.$fDataBool } in
                 let {
                   $dData_adTy :: Data GHC.Fixity
                   [LclId, Str=DmdType]
                   $dData_adTy = BasicTypes.$fDataFixity } in
                 let {
                   $dData_adTw :: Data Name
                   [LclId, Str=DmdType]
                   $dData_adTw = Name.$fDataName } in
                 let {
                   $dData_adTx :: Data (UniqFM.UniqFM Name)
                   [LclId, Str=DmdType]
                   $dData_adTx = UniqFM.$fDataUniqFM @ Name $dData_adTw } in
                 let {
                   $dData_adTA :: Data Name
                   [LclId, Str=DmdType]
                   $dData_adTA = $dData_adTw } in
                 let {
                   $dData_adTB :: Data [Name]
                   [LclId, Str=DmdType]
                   $dData_adTB = Data.Data.$fData[] @ Name $dData_adTw } in
                 let {
                   $dData_adTC :: Data Name
                   [LclId, Str=DmdType]
                   $dData_adTC = $dData_adTw } in
                 let {
                   $dData_adTM :: Data (ImportDecl Name)
                   [LclId, Str=DmdType]
                   $dData_adTM = HsImpExp.$fDataImportDecl @ Name $dData_adTw } in
                 let {
                   $dData_adTK :: Data (GenLocated SrcSpan (ImportDecl Name))
                   [LclId, Str=DmdType]
                   $dData_adTK =
                     SrcLoc.$fDataGenLocated
                       @ SrcSpan @ (ImportDecl Name) $dData_adTL $dData_adTM } in
                 let {
                   $dData_adTl :: Data [LImportDecl Name]
                   [LclId, Str=DmdType]
                   $dData_adTl =
                     Data.Data.$fData[]
                       @ (GenLocated SrcSpan (ImportDecl Name)) $dData_adTK } in
                 let {
                   $dData_adTP :: Data (IE Name)
                   [LclId, Str=DmdType]
                   $dData_adTP = HsImpExp.$fDataIE @ Name $dData_adTw } in
                 let {
                   $dData_adTO :: Data (GenLocated SrcSpan (IE Name))
                   [LclId, Str=DmdType]
                   $dData_adTO =
                     SrcLoc.$fDataGenLocated
                       @ SrcSpan @ (IE Name) $dData_adTL $dData_adTP } in
                 let {
                   $dData_adTN :: Data [LIE Name]
                   [LclId, Str=DmdType]
                   $dData_adTN =
                     Data.Data.$fData[]
                       @ (GenLocated SrcSpan (IE Name)) $dData_adTO } in
                 let {
                   $dData_adTm :: Data (Maybe [LIE Name])
                   [LclId, Str=DmdType]
                   $dData_adTm = Data.Data.$fDataMaybe @ [LIE Name] $dData_adTN } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adTv
                     :: (Data Name, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                         Data Bool, Data Name, Data [Name], Data Name, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder, Data PlaceHolder)
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adTv =
                     ($dData_adTw, $dData_adTx, $dData_adTy, $dData_adTz, $dData_adTA,
                      $dData_adTB, $dData_adTC, $dData_adTD, $dData_adTE, $dData_adTF,
                      $dData_adTG, $dData_adTH, $dData_adTI, $dData_adTJ) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adTo :: DataId Name
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adTo =
                     $d(%,,,,,,,,,,,,,%)_adTv
                     `cast` ((<Data Name>_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnNamety[0] <UniqFM.UniqFM Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Fixity>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Bool>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name]>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Type>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0] <Coercion.Coercion>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <[Type]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0] <[ConLike.ConLike]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data Name, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                 Data Bool, Data Name, Data [Name], Data Name, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder)
                                ~R# (Data Name, Data (PostRn Name (UniqFM.UniqFM Name)),
                                     Data (PostRn Name GHC.Fixity), Data (PostRn Name Bool),
                                     Data (PostRn Name Name), Data (PostRn Name [Name]),
                                     Data (PostRn Name Name), Data (PostTc Name Type),
                                     Data (PostTc Name Coercion.Coercion), Data (PostTc Name Name),
                                     Data (PostTc Name [Type]),
                                     Data (PostTc Name [ConLike.ConLike]),
                                     Data (PostTc Name TcEvidence.HsWrapper),
                                     Data (PostTc Name [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_adTk :: Data (HsGroup Name)
                   [LclId, Str=DmdType]
                   $dData_adTk =
                     HsDecls.$fDataHsGroup @ Name $d(%,,,,,,,,,,,,,%)_adTo } in
                 let {
                   $dData_adTj
                     :: Data
                          (HsGroup Name, [LImportDecl Name], Maybe [LIE Name],
                           Maybe LHsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTj =
                     Data.Data.$fData(,,,)
                       @ (HsGroup Name)
                       @ [LImportDecl Name]
                       @ (Maybe [LIE Name])
                       @ (Maybe LHsDocString)
                       $dData_adTk
                       $dData_adTl
                       $dData_adTm
                       $dData_adTn } in
                 let {
                   $dData_adTh :: Data (Maybe RenamedSource)
                   [LclId, Str=DmdType]
                   $dData_adTh =
                     Data.Data.$fDataMaybe
                       @ (HsGroup Name, [LImportDecl Name], Maybe [LIE Name],
                          Maybe LHsDocString)
                       $dData_adTj } in
                 letrec {
                   rCount_adTe :: Int
                   [LclId, Str=DmdType]
                   rCount_adTe =
                     gq_a3SR @ (Maybe RenamedSource) $dData_adTh r_a4Wr; } in
                 rCount_adTe; } in
             letrec {
               pCount_a4Wt :: Int
               [LclId, Str=DmdType]
               pCount_a4Wt =
                 let {
                   $dData_adU8 :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adU8 = PlaceHolder.$fDataPlaceHolder } in
                 let {
                   $dData_adU9 :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adU9 = $dData_adU8 } in
                 let {
                   $dData_adUa :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUa = $dData_adU8 } in
                 let {
                   $dData_adUb :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUb = $dData_adU8 } in
                 let {
                   $dData_adUc :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUc = $dData_adU8 } in
                 let {
                   $dData_adUd :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUd = $dData_adU8 } in
                 let {
                   $dData_adUe :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUe = $dData_adU8 } in
                 let {
                   $dData_adUf :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUf = $dData_adU8 } in
                 let {
                   $dData_adUg :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUg = $dData_adU8 } in
                 let {
                   $dData_adUh :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUh = $dData_adU8 } in
                 let {
                   $dData_adUi :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUi = $dData_adU8 } in
                 let {
                   $dData_adUj :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUj = $dData_adU8 } in
                 let {
                   $dData_adUk :: Data PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUk = $dData_adU8 } in
                 let {
                   $dData_adU7 :: Data RdrName
                   [LclId, Str=DmdType]
                   $dData_adU7 = RdrName.$fDataRdrName } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adU6
                     :: (Data RdrName, Data PlaceHolder, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                         Data PlaceHolder, Data PlaceHolder)
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adU6 =
                     ($dData_adU7, $dData_adU8, $dData_adU9, $dData_adUa, $dData_adUb,
                      $dData_adUc, $dData_adUd, $dData_adUe, $dData_adUf, $dData_adUg,
                      $dData_adUh, $dData_adUi, $dData_adUj, $dData_adUk) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adU3 :: DataId RdrName
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adU3 =
                     $d(%,,,,,,,,,,,,,%)_adU6
                     `cast` ((<Data RdrName>_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <UniqFM.UniqFM Name>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Fixity>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Bool>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name]>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <Type>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <Coercion.Coercion>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[Type]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[ConLike.ConLike]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data RdrName, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder)
                                ~R# (Data RdrName, Data (PostRn RdrName (UniqFM.UniqFM Name)),
                                     Data (PostRn RdrName GHC.Fixity), Data (PostRn RdrName Bool),
                                     Data (PostRn RdrName Name), Data (PostRn RdrName [Name]),
                                     Data (PostRn RdrName RdrName), Data (PostTc RdrName Type),
                                     Data (PostTc RdrName Coercion.Coercion),
                                     Data (PostTc RdrName RdrName), Data (PostTc RdrName [Type]),
                                     Data (PostTc RdrName [ConLike.ConLike]),
                                     Data (PostTc RdrName TcEvidence.HsWrapper),
                                     Data (PostTc RdrName [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_adU2 :: Data (HsModule RdrName)
                   [LclId, Str=DmdType]
                   $dData_adU2 =
                     HsSyn.$fDataHsModule @ RdrName $d(%,,,,,,,,,,,,,%)_adU3 } in
                 let {
                   $dData_adU1 :: Data SrcSpan
                   [LclId, Str=DmdType]
                   $dData_adU1 = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_adTZ :: Data ParsedSource
                   [LclId, Str=DmdType]
                   $dData_adTZ =
                     SrcLoc.$fDataGenLocated
                       @ SrcSpan @ (HsModule RdrName) $dData_adU1 $dData_adU2 } in
                 letrec {
                   pCount_adTW :: Int
                   [LclId, Str=DmdType]
                   pCount_adTW = gq_a3SR @ ParsedSource $dData_adTZ p_a4Wq; } in
                 pCount_adTW; } in
             print
               @ (Int, Int, Int)
               $dShow_ae3q
               (pCount_a4Wt, rCount_a4Wu, tsCount_a4Wv)
             }); } in
  testOneFile_a56I

-- RHS size: {terms: 46, types: 30, coercions: 0}
main :: IO ()
[LclIdX, Str=DmdType]
main =
  letrec {
    main_aeaB :: IO ()
    [LclId, Str=DmdType]
    main_aeaB =
      >>=
        @ IO
        $dMonad_aeaH
        @ [String]
        @ ()
        getArgs
        (\ (ds_dedZ :: [String]) ->
           let {
             fail_dee1 :: Void# -> IO ()
             [LclId, Str=DmdType]
             fail_dee1 =
               \ (ds_dee2 [OS=OneShot] :: Void#) ->
                 fail
                   @ IO
                   $dMonad_aeaO
                   @ ()
                   (unpackCString#
                      "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
           case ds_dedZ of wild_00 {
             __DEFAULT -> fail_dee1 void#;
             : libdir_a3SO ds_dee0 ->
               case ds_dee0 of wild_00 {
                 __DEFAULT -> fail_dee1 void#;
                 [] ->
                   >>
                     @ IO
                     $dMonad_aeaV
                     @ ()
                     @ ()
                     (testOneFile libdir_a3SO (unpackCString# "MineFixity"#))
                     (>>
                        @ IO
                        $dMonad_aeb3
                        @ ()
                        @ ()
                        (testOneFile libdir_a3SO (unpackCString# "MineKind"#))
                        (>>
                           @ IO
                           $dMonad_aebb
                           @ ()
                           @ ()
                           (testOneFile libdir_a3SO (unpackCString# "MineNames"#))
                           (testOneFile libdir_a3SO (unpackCString# "MineType"#))))
               }
           }); } in
  main_aeaB

-- RHS size: {terms: 5, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId], Str=DmdType]
Main.$trModule = Module (TrNameS "main"#) (TrNameS "Main"#)

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX, Str=DmdType]
:Main.main = runMainIO @ () main
end Rec }




==================== Occurrence analysis ====================
Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId], Str=DmdType]
Main.$trModule =
  GHC.Types.Module
    (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Main"#)

Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX, Str=DmdType]
Main.mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v [Occ=Once]
       :: Data.Typeable.Internal.Typeable a_a4Yh)
    ($dTypeable_a56w [Occ=Once]
       :: Data.Typeable.Internal.Typeable b_a4Yi) ->
    let {
      $dTypeable_a56F [Occ=OnceL]
        :: Data.Typeable.Internal.Typeable b_a4Yi
      [LclId, Str=DmdType]
      $dTypeable_a56F = $dTypeable_a56w } in
    let {
      $dTypeable_a56E [Occ=OnceL]
        :: Data.Typeable.Internal.Typeable a_a4Yh
      [LclId, Str=DmdType]
      $dTypeable_a56E = $dTypeable_a56v } in
    let {
      mkQ_a56x [Occ=Once]
        :: r_a4Yj -> (b_a4Yi -> r_a4Yj) -> a_a4Yh -> r_a4Yj
      [LclId, Str=DmdType]
      mkQ_a56x =
        \ (r_a4Ww [Occ=Once] :: r_a4Yj)
          (br_a4Wx [Occ=Once!] :: b_a4Yi -> r_a4Yj)
          (a_a4Wy [Occ=Once] :: a_a4Yh) ->
          let {
            ds_dedx [Occ=Once!] :: GHC.Base.Maybe b_a4Yi
            [LclId, Str=DmdType]
            ds_dedx =
              Data.Typeable.cast
                @ a_a4Yh @ b_a4Yi $dTypeable_a56E $dTypeable_a56F a_a4Wy } in
          case ds_dedx of _ [Occ=Dead] {
            GHC.Base.Nothing -> r_a4Ww;
            GHC.Base.Just b_a4WM [Occ=Once] -> br_a4Wx b_a4WM
          } } in
    mkQ_a56x

Rec {
Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[LclIdX, Str=DmdType]
Main.everything =
  \ (@ r_a4XV) ->
    let {
      everything_a55x [Occ=Once]
        :: (r_a4XV -> r_a4XV -> r_a4XV)
           -> Main.GenericQ r_a4XV -> Main.GenericQ r_a4XV
      [LclId, Str=DmdType]
      everything_a55x =
        \ (dk_aecm [Occ=Once] :: r_a4XV -> r_a4XV -> r_a4XV)
          (dk_aecn [Occ=Once] :: Main.GenericQ r_a4XV)
          (@ a_a55z)
          ($dData_a55A :: Data.Data.Data a_a55z) ->
          (let {
             $dData_a56a [Occ=OnceL] :: Data.Data.Data a_a55z
             [LclId, Str=DmdType]
             $dData_a56a = $dData_a55A } in
           let {
             $dData_a565 [Occ=OnceL] :: Data.Data.Data a_a55z
             [LclId, Str=DmdType]
             $dData_a565 = $dData_a55A } in
           let {
             $dFoldable_a55Z [Occ=OnceL] :: Data.Foldable.Foldable []
             [LclId, Str=DmdType]
             $dFoldable_a55Z = Data.Foldable.$fFoldable[] } in
           \ (k_a4WN [OS=OneShot] :: r_a4XV -> r_a4XV -> r_a4XV)
             (f_a4WO [OS=OneShot] :: Main.GenericQ r_a4XV)
             (x_a4WP :: a_a55z) ->
             Data.Foldable.foldl
               @ []
               $dFoldable_a55Z
               @ r_a4XV
               @ r_a4XV
               k_a4WN
               (f_a4WO @ a_a55z $dData_a565 x_a4WP)
               (Data.Data.gmapQ
                  @ a_a55z
                  $dData_a56a
                  @ r_a4XV
                  (\ (@ d_a56e) ($dData_a56f [Occ=Once] :: Data.Data.Data d_a56e) ->
                     let {
                       $dData_a56k [Occ=Once] :: Data.Data.Data d_a56e
                       [LclId, Str=DmdType]
                       $dData_a56k = $dData_a56f } in
                     (\ (di_aecw [Occ=Once, OS=OneShot] :: r_a4XV -> r_a4XV -> r_a4XV)
                        (di_aecx [Occ=Once, OS=OneShot] :: Main.GenericQ r_a4XV) ->
                        Main.everything @ r_a4XV di_aecw di_aecx @ d_a56e $dData_a56k)
                       k_a4WN
                       (\ (@ a_a56m) ($dData_a56n [Occ=Once] :: Data.Data.Data a_a56m) ->
                          let {
                            $dData_a56q [Occ=Once] :: Data.Data.Data a_a56m
                            [LclId, Str=DmdType]
                            $dData_a56q = $dData_a56n } in
                          f_a4WO @ a_a56m $dData_a56q))
                  x_a4WP))
            dk_aecm dk_aecn } in
    everything_a55x
end Rec }

Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[LclIdX, Str=DmdType]
Main.testOneFile =
  let {
    cobox_a9qp [Occ=OnceL!] :: GHC.Base.String ~ GHC.Base.String
    [LclId, Str=DmdType]
    cobox_a9qp =
      GHC.Types.Eq#
        @ *
        @ GHC.Base.String
        @ GHC.Base.String
        @~ (<GHC.Base.String>_N
            :: GHC.Base.String GHC.Prim.~# GHC.Base.String) } in
  let {
    $dShow_aeau :: GHC.Show.Show GHC.Types.Int
    [LclId, Str=DmdType]
    $dShow_aeau = GHC.Show.$fShowInt } in
  let {
    $dShow_aeav :: GHC.Show.Show GHC.Types.Int
    [LclId, Str=DmdType]
    $dShow_aeav = $dShow_aeau } in
  let {
    $dShow_aeaw :: GHC.Show.Show GHC.Types.Int
    [LclId, Str=DmdType]
    $dShow_aeaw = $dShow_aeau } in
  let {
    $dShow_ae3q [Occ=OnceL]
      :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
    [LclId, Str=DmdType]
    $dShow_ae3q =
      GHC.Show.$fShow(,,)
        @ GHC.Types.Int
        @ GHC.Types.Int
        @ GHC.Types.Int
        $dShow_aeau
        $dShow_aeav
        $dShow_aeaw } in
  let {
    $dTypecheckedMod_aakq [Occ=OnceL]
      :: GHC.TypecheckedMod GHC.DesugaredModule
    [LclId, Str=DmdType]
    $dTypecheckedMod_aakq = GHC.$fTypecheckedModDesugaredModule } in
  let {
    $dGhcMonad_a9q4 :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9q4 = GhcMonad.$fGhcMonadGhc } in
  let {
    $dGhcMonad_a9qm [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9qm = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_a9qJ [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_a9qJ = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aaiO [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aaiO = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aaj9 [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aaj9 = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajq [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajq = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajH [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajH = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aajY [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aajY = $dGhcMonad_a9q4 } in
  let {
    $dGhcMonad_aakr [Occ=OnceL] :: GhcMonad.GhcMonad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dGhcMonad_aakr = $dGhcMonad_a9q4 } in
  let {
    $dMonad_a6SJ :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_a6SJ = GhcMonad.$fMonadGhc } in
  let {
    $dMonad_a9qf [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_a9qf = $dMonad_a6SJ } in
  let {
    $dMonad_a9qy [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_a9qy = $dMonad_a6SJ } in
  let {
    $dMonad_a9Gu [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_a9Gu = $dMonad_a6SJ } in
  let {
    $dMonad_aaj2 [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_aaj2 = $dMonad_a6SJ } in
  let {
    $dMonad_aajj [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_aajj = $dMonad_a6SJ } in
  let {
    $dMonad_aajA [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_aajA = $dMonad_a6SJ } in
  let {
    $dMonad_aajR [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_aajR = $dMonad_a6SJ } in
  let {
    $dMonad_aak8 [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_aak8 = $dMonad_a6SJ } in
  let {
    $dMonad_abWp [Occ=OnceL] :: GHC.Base.Monad GhcMonad.Ghc
    [LclId, Str=DmdType]
    $dMonad_abWp = $dMonad_a6SJ } in
  let {
    $dMonad_a6Q1 [Occ=OnceL] :: GHC.Base.Monad GHC.Types.IO
    [LclId, Str=DmdType]
    $dMonad_a6Q1 = GHC.Base.$fMonadIO } in
  let {
    testOneFile_a56I [Occ=Once]
      :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
    [LclId, Str=DmdType]
    testOneFile_a56I =
      \ (libdir_a3SP [Occ=Once] :: GHC.IO.FilePath)
        (fileName_a3SQ [Occ=OnceL] :: GHC.Base.String) ->
        let {
          worker_a3SS [Occ=OnceL] :: SrcLoc.SrcSpan -> [SrcLoc.SrcSpan]
          [LclId, Str=DmdType]
          worker_a3SS =
            let {
              worker_a56N [Occ=Once] :: SrcLoc.SrcSpan -> [SrcLoc.SrcSpan]
              [LclId, Str=DmdType]
              worker_a56N =
                \ (s_a41A [Occ=Once!] :: SrcLoc.SrcSpan) ->
                  let {
                    fail_dedK [Occ=Once!] :: GHC.Prim.Void# -> [SrcLoc.SrcSpan]
                    [LclId, Str=DmdType]
                    fail_dedK =
                      \ _ [Occ=Dead, OS=OneShot] -> GHC.Types.[] @ SrcLoc.SrcSpan } in
                  case s_a41A of wild_00 {
                    __DEFAULT -> fail_dedK GHC.Prim.void#;
                    SrcLoc.RealSrcSpan _ [Occ=Dead] ->
                      let {
                        s_a41A [Occ=Once] :: SrcLoc.SrcSpan
                        [LclId, Str=DmdType]
                        s_a41A = wild_00 } in
                      GHC.Types.: @ SrcLoc.SrcSpan s_a41A (GHC.Types.[] @ SrcLoc.SrcSpan)
                  } } in
            worker_a56N } in
        let {
          gq_a3SR
            :: forall a_a5bd. Data.Data.Data a_a5bd => a_a5bd -> GHC.Types.Int
          [LclId, Str=DmdType]
          gq_a3SR =
            \ (@ a_a5bd) ($dData_a6PB [Occ=Once] :: Data.Data.Data a_a5bd) ->
              let {
                $dData_a5bf [Occ=OnceL] :: Data.Data.Data a_a5bd
                [LclId, Str=DmdType]
                $dData_a5bf = $dData_a6PB } in
              let {
                $dFoldable_a5b8 [Occ=OnceL] :: Data.Foldable.Foldable []
                [LclId, Str=DmdType]
                $dFoldable_a5b8 = Data.Foldable.$fFoldable[] } in
              let {
                gq_a5b1 [Occ=Once] :: a_a5bd -> GHC.Types.Int
                [LclId, Str=DmdType]
                gq_a5b1 =
                  \ (ast_a3ST [Occ=Once] :: a_a5bd) ->
                    GHC.Base.$
                      @ [SrcLoc.SrcSpan]
                      @ GHC.Types.Int
                      (Data.Foldable.length @ [] $dFoldable_a5b8 @ SrcLoc.SrcSpan)
                      ((\ (di_aecF [Occ=Once, OS=OneShot]
                             :: [SrcLoc.SrcSpan] -> [SrcLoc.SrcSpan] -> [SrcLoc.SrcSpan])
                          (di_aecG [Occ=Once, OS=OneShot]
                             :: Main.GenericQ [SrcLoc.SrcSpan]) ->
                          Main.everything
                            @ [SrcLoc.SrcSpan] di_aecF di_aecG @ a_a5bd $dData_a5bf)
                         (GHC.Base.++ @ SrcLoc.SrcSpan)
                         (\ (@ a_a5bk) ($dData_a5bl [Occ=Once] :: Data.Data.Data a_a5bk) ->
                            let {
                              $dTypeable_a5br [Occ=Once]
                                :: Data.Typeable.Internal.Typeable SrcLoc.SrcSpan
                              [LclId, Str=DmdType]
                              $dTypeable_a5br =
                                Data.Typeable.Internal.D:Typeable
                                  @ *
                                  @ SrcLoc.SrcSpan
                                  (let {
                                     ds_dedF [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                                     [LclId, Str=DmdType]
                                     ds_dedF =
                                       Data.Typeable.Internal.mkPolyTyConApp
                                         SrcLoc.$tcSrcSpan
                                         (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                                         (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } in
                                   \ _ [Occ=Dead] -> ds_dedF) } in
                            let {
                              cobox_a5bs [Occ=Once!] :: SrcLoc.SrcSpan ~ SrcLoc.SrcSpan
                              [LclId, Str=DmdType]
                              cobox_a5bs =
                                GHC.Types.Eq#
                                  @ *
                                  @ SrcLoc.SrcSpan
                                  @ SrcLoc.SrcSpan
                                  @~ (<SrcLoc.SrcSpan>_N
                                      :: SrcLoc.SrcSpan GHC.Prim.~# SrcLoc.SrcSpan) } in
                            let {
                              $dTypeable_a6Py [Occ=Once]
                                :: Data.Typeable.Internal.Typeable a_a5bk
                              [LclId, Str=DmdType]
                              $dTypeable_a6Py = Data.Data.$p1Data @ a_a5bk $dData_a5bl } in
                            let {
                              $dTypeable_a5bq [Occ=Once]
                                :: Data.Typeable.Internal.Typeable a_a5bk
                              [LclId, Str=DmdType]
                              $dTypeable_a5bq = $dTypeable_a6Py } in
                            Main.mkQ
                              @ a_a5bk
                              @ SrcLoc.SrcSpan
                              @ [SrcLoc.SrcSpan]
                              $dTypeable_a5bq
                              $dTypeable_a5br
                              (GHC.Types.[] @ SrcLoc.SrcSpan)
                              (case cobox_a5bs of _ [Occ=Dead] { GHC.Types.Eq# _ [Occ=Dead] ->
                               worker_a3SS
                               }))
                         ast_a3ST) } in
              gq_a5b1 } in
        GHC.Base.>>=
          @ GHC.Types.IO
          $dMonad_a6Q1
          @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
             GHC.TypecheckedSource)
          @ ()
          (GHC.Base.$
             @ (GhcMonad.Ghc
                  (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                   GHC.TypecheckedSource))
             @ (GHC.Types.IO
                  (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                   GHC.TypecheckedSource))
             (GHC.runGhc
                @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                   GHC.TypecheckedSource)
                (GHC.Base.Just @ GHC.IO.FilePath libdir_a3SP))
             (GHC.Base.>>=
                @ GhcMonad.Ghc
                $dMonad_a6SJ
                @ DynFlags.DynFlags
                @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                   GHC.TypecheckedSource)
                (GhcMonad.getSessionDynFlags @ GhcMonad.Ghc $dGhcMonad_a9q4)
                (\ (dflags_a4fE [Occ=Once] :: DynFlags.DynFlags) ->
                   GHC.Base.>>
                     @ GhcMonad.Ghc
                     $dMonad_a9qf
                     @ [Module.UnitId]
                     @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                        GHC.TypecheckedSource)
                     (GHC.setSessionDynFlags @ GhcMonad.Ghc $dGhcMonad_a9qm dflags_a4fE)
                     (let {
                        mn_a4fF :: Module.ModuleName
                        [LclId, Str=DmdType]
                        mn_a4fF =
                          let {
                            mn_a9qo [Occ=Once] :: Module.ModuleName
                            [LclId, Str=DmdType]
                            mn_a9qo =
                              Module.mkModuleName
                                (case cobox_a9qp of _ [Occ=Dead] { GHC.Types.Eq# _ [Occ=Dead] ->
                                 fileName_a3SQ
                                 }) } in
                          mn_a9qo } in
                      GHC.Base.>>
                        @ GhcMonad.Ghc
                        $dMonad_a9qy
                        @ ()
                        @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                           GHC.TypecheckedSource)
                        (GHC.addTarget
                           @ GhcMonad.Ghc
                           $dGhcMonad_a9qJ
                           (HscTypes.Target
                              (HscTypes.TargetModule mn_a4fF)
                              GHC.Types.True
                              (GHC.Base.Nothing
                                 @ (StringBuffer.StringBuffer, Data.Time.Clock.UTC.UTCTime))))
                        (GHC.Base.>>
                           @ GhcMonad.Ghc
                           $dMonad_a9Gu
                           @ BasicTypes.SuccessFlag
                           @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                              GHC.TypecheckedSource)
                           (GhcMake.load
                              @ GhcMonad.Ghc $dGhcMonad_aaiO GhcMake.LoadAllTargets)
                           (GHC.Base.>>=
                              @ GhcMonad.Ghc
                              $dMonad_aaj2
                              @ HscTypes.ModSummary
                              @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                 GHC.TypecheckedSource)
                              (GHC.getModSummary @ GhcMonad.Ghc $dGhcMonad_aaj9 mn_a4fF)
                              (\ (modSum_a4Wj [Occ=Once] :: HscTypes.ModSummary) ->
                                 GHC.Base.>>=
                                   @ GhcMonad.Ghc
                                   $dMonad_aajj
                                   @ GHC.ParsedModule
                                   @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                      GHC.TypecheckedSource)
                                   (GHC.parseModule @ GhcMonad.Ghc $dGhcMonad_aajq modSum_a4Wj)
                                   (\ (p_a4Wk :: GHC.ParsedModule) ->
                                      GHC.Base.>>=
                                        @ GhcMonad.Ghc
                                        $dMonad_aajA
                                        @ GHC.TypecheckedModule
                                        @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                           GHC.TypecheckedSource)
                                        (GHC.typecheckModule @ GhcMonad.Ghc $dGhcMonad_aajH p_a4Wk)
                                        (\ (t_a4Wl [Occ=Once] :: GHC.TypecheckedModule) ->
                                           GHC.Base.>>=
                                             @ GhcMonad.Ghc
                                             $dMonad_aajR
                                             @ GHC.DesugaredModule
                                             @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                GHC.TypecheckedSource)
                                             (GHC.desugarModule
                                                @ GhcMonad.Ghc $dGhcMonad_aajY t_a4Wl)
                                             (\ (d_a4Wm [Occ=Once] :: GHC.DesugaredModule) ->
                                                GHC.Base.>>=
                                                  @ GhcMonad.Ghc
                                                  $dMonad_aak8
                                                  @ GHC.DesugaredModule
                                                  @ (GHC.ParsedSource,
                                                     GHC.Base.Maybe GHC.RenamedSource,
                                                     GHC.TypecheckedSource)
                                                  (GHC.loadModule
                                                     @ GHC.DesugaredModule
                                                     @ GhcMonad.Ghc
                                                     $dTypecheckedMod_aakq
                                                     $dGhcMonad_aakr
                                                     d_a4Wm)
                                                  (\ (l_a4Wn :: GHC.DesugaredModule) ->
                                                     let {
                                                       r_a4Wp [Occ=Once]
                                                         :: GHC.Base.Maybe GHC.RenamedSource
                                                       [LclId, Str=DmdType]
                                                       r_a4Wp =
                                                         let {
                                                           $dTypecheckedMod_aakw [Occ=Once]
                                                             :: GHC.TypecheckedMod
                                                                  GHC.DesugaredModule
                                                           [LclId, Str=DmdType]
                                                           $dTypecheckedMod_aakw =
                                                             GHC.$fTypecheckedModDesugaredModule } in
                                                         let {
                                                           r_aakt [Occ=Once]
                                                             :: GHC.Base.Maybe GHC.RenamedSource
                                                           [LclId, Str=DmdType]
                                                           r_aakt =
                                                             GHC.renamedSource
                                                               @ GHC.DesugaredModule
                                                               $dTypecheckedMod_aakw
                                                               l_a4Wn } in
                                                         r_aakt } in
                                                     let {
                                                       ts_a4Wo [Occ=Once] :: GHC.TypecheckedSource
                                                       [LclId, Str=DmdType]
                                                       ts_a4Wo =
                                                         let {
                                                           $dTypecheckedMod_abre [Occ=Once]
                                                             :: GHC.TypecheckedMod
                                                                  GHC.DesugaredModule
                                                           [LclId, Str=DmdType]
                                                           $dTypecheckedMod_abre =
                                                             GHC.$fTypecheckedModDesugaredModule } in
                                                         let {
                                                           ts_abrb [Occ=Once]
                                                             :: GHC.TypecheckedSource
                                                           [LclId, Str=DmdType]
                                                           ts_abrb =
                                                             GHC.typecheckedSource
                                                               @ GHC.DesugaredModule
                                                               $dTypecheckedMod_abre
                                                               l_a4Wn } in
                                                         ts_abrb } in
                                                     GHC.Base.return
                                                       @ GhcMonad.Ghc
                                                       $dMonad_abWp
                                                       @ (GHC.ParsedSource,
                                                          GHC.Base.Maybe GHC.RenamedSource,
                                                          GHC.TypecheckedSource)
                                                       (GHC.pm_parsed_source p_a4Wk, r_a4Wp,
                                                        ts_a4Wo))))))))))))
          (\ (ds_dedD [Occ=Once!]
                :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                    GHC.TypecheckedSource)) ->
             case ds_dedD
             of _ [Occ=Dead]
             { (p_a4Wq [Occ=Once], r_a4Wr [Occ=Once], ts_a4Ws [Occ=Once]) ->
             let {
               tsCount_a4Wv [Occ=Once] :: GHC.Types.Int
               [LclId, Str=DmdType]
               tsCount_a4Wv =
                 let {
                   $dData_adT3 :: Data.Data.Data TcEvidence.HsWrapper
                   [LclId, Str=DmdType]
                   $dData_adT3 = TcEvidence.$fDataHsWrapper } in
                 let {
                   $dData_adT8 :: Data.Data.Data ConLike.ConLike
                   [LclId, Str=DmdType]
                   $dData_adT8 = ConLike.$fDataConLike } in
                 let {
                   $dData_adT2 :: Data.Data.Data [ConLike.ConLike]
                   [LclId, Str=DmdType]
                   $dData_adT2 = Data.Data.$fData[] @ ConLike.ConLike $dData_adT8 } in
                 let {
                   $dData_adSZ :: Data.Data.Data Coercion.Coercion
                   [LclId, Str=DmdType]
                   $dData_adSZ = Coercion.$fDataCoercion } in
                 let {
                   $dData_adSY :: Data.Data.Data TypeRep.Type
                   [LclId, Str=DmdType]
                   $dData_adSY = TypeRep.$fDataType } in
                 let {
                   $dData_adT1 :: Data.Data.Data [TypeRep.Type]
                   [LclId, Str=DmdType]
                   $dData_adT1 = Data.Data.$fData[] @ TypeRep.Type $dData_adSY } in
                 let {
                   $dData_adSU :: Data.Data.Data GHC.Types.Bool
                   [LclId, Str=DmdType]
                   $dData_adSU = Data.Data.$fDataBool } in
                 let {
                   $dData_adST :: Data.Data.Data BasicTypes.Fixity
                   [LclId, Str=DmdType]
                   $dData_adST = BasicTypes.$fDataFixity } in
                 let {
                   $dData_adT7 :: Data.Data.Data Name.Name
                   [LclId, Str=DmdType]
                   $dData_adT7 = Name.$fDataName } in
                 let {
                   $dData_adSV :: Data.Data.Data Name.Name
                   [LclId, Str=DmdType]
                   $dData_adSV = $dData_adT7 } in
                 let {
                   $dData_adSW :: Data.Data.Data [Name.Name]
                   [LclId, Str=DmdType]
                   $dData_adSW = Data.Data.$fData[] @ Name.Name $dData_adT7 } in
                 let {
                   $dData_adT9 :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adT9 =
                     FieldLabel.$fDataFieldLbl @ Name.Name $dData_adT7 } in
                 let {
                   $dData_adT4 :: Data.Data.Data [FieldLabel.FieldLabel]
                   [LclId, Str=DmdType]
                   $dData_adT4 =
                     Data.Data.$fData[]
                       @ (FieldLabel.FieldLbl Name.Name) $dData_adT9 } in
                 let {
                   $dData_adSS :: Data.Data.Data (UniqFM.UniqFM Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adSS = UniqFM.$fDataUniqFM @ Name.Name $dData_adT7 } in
                 let {
                   $dData_adSR :: Data.Data.Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adSR = Var.$fDataVar } in
                 let {
                   $dData_adSX :: Data.Data.Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adSX = $dData_adSR } in
                 let {
                   $dData_adT0 :: Data.Data.Data Var.Var
                   [LclId, Str=DmdType]
                   $dData_adT0 = $dData_adSR } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adSQ
                     :: (Data.Data.Data Var.Var,
                         Data.Data.Data (UniqFM.UniqFM Name.Name),
                         Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                         Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                         Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                         Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                         Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                         Data.Data.Data TcEvidence.HsWrapper,
                         Data.Data.Data [FieldLabel.FieldLabel])
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adSQ =
                     ($dData_adSR, $dData_adSS, $dData_adST, $dData_adSU, $dData_adSV,
                      $dData_adSW, $dData_adSX, $dData_adSY, $dData_adSZ, $dData_adT0,
                      $dData_adT1, $dData_adT2, $dData_adT3, $dData_adT4) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adMZ :: PlaceHolder.DataId Var.Var
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adMZ =
                     $d(%,,,,,,,,,,,,,%)_adSQ
                     `cast` ((<Data.Data.Data Var.Var>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnVarty[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data Var.Var,
                                 Data.Data.Data (UniqFM.UniqFM Name.Name),
                                 Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                 Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                 Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                 Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                 Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                 Data.Data.Data TcEvidence.HsWrapper,
                                 Data.Data.Data [FieldLabel.FieldLabel])
                                ~R# (Data.Data.Data Var.Var,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel]))) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adMY :: PlaceHolder.DataId Var.Var
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adMY =
                     $d(%,,,,,,,,,,,,,%)_adSQ
                     `cast` ((<Data.Data.Data Var.Var>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnVarty[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcVarty[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data Var.Var,
                                 Data.Data.Data (UniqFM.UniqFM Name.Name),
                                 Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                 Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                 Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                 Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                 Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                 Data.Data.Data TcEvidence.HsWrapper,
                                 Data.Data.Data [FieldLabel.FieldLabel])
                                ~R# (Data.Data.Data Var.Var,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                     Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                     Data.Data.Data (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_accn :: Data.Data.Data (HsBinds.HsBindLR Var.Id Var.Id)
                   [LclId, Str=DmdType]
                   $dData_accn =
                     HsBinds.$fDataHsBindLR
                       @ Var.Var
                       @ Var.Var
                       $d(%,,,,,,,,,,,,,%)_adMY
                       $d(%,,,,,,,,,,,,,%)_adMZ } in
                 let {
                   $dData_accm :: Data.Data.Data SrcLoc.SrcSpan
                   [LclId, Str=DmdType]
                   $dData_accm = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_accl
                     :: Data.Data.Data
                          (SrcLoc.GenLocated SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                   [LclId, Str=DmdType]
                   $dData_accl =
                     SrcLoc.$fDataGenLocated
                       @ SrcLoc.SrcSpan
                       @ (HsBinds.HsBindLR Var.Id Var.Id)
                       $dData_accm
                       $dData_accn } in
                 let {
                   $dData_aca0 [Occ=Once] :: Data.Data.Data GHC.TypecheckedSource
                   [LclId, Str=DmdType]
                   $dData_aca0 =
                     Bag.$fDataBag
                       @ (SrcLoc.GenLocated
                            SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                       $dData_accl } in
                 let {
                   tsCount_ac9X [Occ=Once] :: GHC.Types.Int
                   [LclId, Str=DmdType]
                   tsCount_ac9X =
                     gq_a3SR @ GHC.TypecheckedSource $dData_aca0 ts_a4Ws } in
                 tsCount_ac9X } in
             let {
               rCount_a4Wu [Occ=Once] :: GHC.Types.Int
               [LclId, Str=DmdType]
               rCount_a4Wu =
                 let {
                   $dData_adTR :: Data.Data.Data HsDoc.HsDocString
                   [LclId, Str=DmdType]
                   $dData_adTR = HsDoc.$fDataHsDocString } in
                 let {
                   $dData_adTL :: Data.Data.Data SrcLoc.SrcSpan
                   [LclId, Str=DmdType]
                   $dData_adTL = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_adTQ
                     :: Data.Data.Data
                          (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTQ =
                     SrcLoc.$fDataGenLocated
                       @ SrcLoc.SrcSpan @ HsDoc.HsDocString $dData_adTL $dData_adTR } in
                 let {
                   $dData_adTn :: Data.Data.Data (GHC.Base.Maybe HsDoc.LHsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTn =
                     Data.Data.$fDataMaybe
                       @ (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                       $dData_adTQ } in
                 let {
                   $dData_adTD :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTD = PlaceHolder.$fDataPlaceHolder } in
                 let {
                   $dData_adTE :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTE = $dData_adTD } in
                 let {
                   $dData_adTF :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTF = $dData_adTD } in
                 let {
                   $dData_adTG :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTG = $dData_adTD } in
                 let {
                   $dData_adTH :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTH = $dData_adTD } in
                 let {
                   $dData_adTI :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTI = $dData_adTD } in
                 let {
                   $dData_adTJ :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adTJ = $dData_adTD } in
                 let {
                   $dData_adTz :: Data.Data.Data GHC.Types.Bool
                   [LclId, Str=DmdType]
                   $dData_adTz = Data.Data.$fDataBool } in
                 let {
                   $dData_adTy :: Data.Data.Data BasicTypes.Fixity
                   [LclId, Str=DmdType]
                   $dData_adTy = BasicTypes.$fDataFixity } in
                 let {
                   $dData_adTw :: Data.Data.Data Name.Name
                   [LclId, Str=DmdType]
                   $dData_adTw = Name.$fDataName } in
                 let {
                   $dData_adTx :: Data.Data.Data (UniqFM.UniqFM Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adTx = UniqFM.$fDataUniqFM @ Name.Name $dData_adTw } in
                 let {
                   $dData_adTA :: Data.Data.Data Name.Name
                   [LclId, Str=DmdType]
                   $dData_adTA = $dData_adTw } in
                 let {
                   $dData_adTB :: Data.Data.Data [Name.Name]
                   [LclId, Str=DmdType]
                   $dData_adTB = Data.Data.$fData[] @ Name.Name $dData_adTw } in
                 let {
                   $dData_adTC :: Data.Data.Data Name.Name
                   [LclId, Str=DmdType]
                   $dData_adTC = $dData_adTw } in
                 let {
                   $dData_adTM :: Data.Data.Data (HsImpExp.ImportDecl Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adTM =
                     HsImpExp.$fDataImportDecl @ Name.Name $dData_adTw } in
                 let {
                   $dData_adTK
                     :: Data.Data.Data
                          (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                   [LclId, Str=DmdType]
                   $dData_adTK =
                     SrcLoc.$fDataGenLocated
                       @ SrcLoc.SrcSpan
                       @ (HsImpExp.ImportDecl Name.Name)
                       $dData_adTL
                       $dData_adTM } in
                 let {
                   $dData_adTl :: Data.Data.Data [HsImpExp.LImportDecl Name.Name]
                   [LclId, Str=DmdType]
                   $dData_adTl =
                     Data.Data.$fData[]
                       @ (SrcLoc.GenLocated
                            SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                       $dData_adTK } in
                 let {
                   $dData_adTP :: Data.Data.Data (HsImpExp.IE Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adTP = HsImpExp.$fDataIE @ Name.Name $dData_adTw } in
                 let {
                   $dData_adTO
                     :: Data.Data.Data
                          (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                   [LclId, Str=DmdType]
                   $dData_adTO =
                     SrcLoc.$fDataGenLocated
                       @ SrcLoc.SrcSpan
                       @ (HsImpExp.IE Name.Name)
                       $dData_adTL
                       $dData_adTP } in
                 let {
                   $dData_adTN :: Data.Data.Data [HsImpExp.LIE Name.Name]
                   [LclId, Str=DmdType]
                   $dData_adTN =
                     Data.Data.$fData[]
                       @ (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                       $dData_adTO } in
                 let {
                   $dData_adTm
                     :: Data.Data.Data (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                   [LclId, Str=DmdType]
                   $dData_adTm =
                     Data.Data.$fDataMaybe @ [HsImpExp.LIE Name.Name] $dData_adTN } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adTv
                     :: (Data.Data.Data Name.Name,
                         Data.Data.Data (UniqFM.UniqFM Name.Name),
                         Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                         Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                         Data.Data.Data Name.Name, Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder)
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adTv =
                     ($dData_adTw, $dData_adTx, $dData_adTy, $dData_adTz, $dData_adTA,
                      $dData_adTB, $dData_adTC, $dData_adTD, $dData_adTE, $dData_adTF,
                      $dData_adTG, $dData_adTH, $dData_adTI, $dData_adTJ) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adTo :: PlaceHolder.DataId Name.Name
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adTo =
                     $d(%,,,,,,,,,,,,,%)_adTv
                     `cast` ((<Data.Data.Data Name.Name>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnNamety[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnNamety[0] <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0] <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0] <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data Name.Name,
                                 Data.Data.Data (UniqFM.UniqFM Name.Name),
                                 Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                 Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                 Data.Data.Data Name.Name, Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder)
                                ~R# (Data.Data.Data Name.Name,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn Name.Name (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn Name.Name BasicTypes.Fixity),
                                     Data.Data.Data (PlaceHolder.PostRn Name.Name GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                     Data.Data.Data (PlaceHolder.PostRn Name.Name [Name.Name]),
                                     Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                     Data.Data.Data (PlaceHolder.PostTc Name.Name TypeRep.Type),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Name.Name Coercion.Coercion),
                                     Data.Data.Data (PlaceHolder.PostTc Name.Name Name.Name),
                                     Data.Data.Data (PlaceHolder.PostTc Name.Name [TypeRep.Type]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Name.Name [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Name.Name TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc Name.Name [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_adTk :: Data.Data.Data (HsDecls.HsGroup Name.Name)
                   [LclId, Str=DmdType]
                   $dData_adTk =
                     HsDecls.$fDataHsGroup @ Name.Name $d(%,,,,,,,,,,,,,%)_adTo } in
                 let {
                   $dData_adTj
                     :: Data.Data.Data
                          (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                           GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                           GHC.Base.Maybe HsDoc.LHsDocString)
                   [LclId, Str=DmdType]
                   $dData_adTj =
                     Data.Data.$fData(,,,)
                       @ (HsDecls.HsGroup Name.Name)
                       @ [HsImpExp.LImportDecl Name.Name]
                       @ (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                       @ (GHC.Base.Maybe HsDoc.LHsDocString)
                       $dData_adTk
                       $dData_adTl
                       $dData_adTm
                       $dData_adTn } in
                 let {
                   $dData_adTh [Occ=Once]
                     :: Data.Data.Data (GHC.Base.Maybe GHC.RenamedSource)
                   [LclId, Str=DmdType]
                   $dData_adTh =
                     Data.Data.$fDataMaybe
                       @ (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                          GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                          GHC.Base.Maybe HsDoc.LHsDocString)
                       $dData_adTj } in
                 let {
                   rCount_adTe [Occ=Once] :: GHC.Types.Int
                   [LclId, Str=DmdType]
                   rCount_adTe =
                     gq_a3SR
                       @ (GHC.Base.Maybe GHC.RenamedSource) $dData_adTh r_a4Wr } in
                 rCount_adTe } in
             let {
               pCount_a4Wt [Occ=Once] :: GHC.Types.Int
               [LclId, Str=DmdType]
               pCount_a4Wt =
                 let {
                   $dData_adU8 :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adU8 = PlaceHolder.$fDataPlaceHolder } in
                 let {
                   $dData_adU9 :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adU9 = $dData_adU8 } in
                 let {
                   $dData_adUa :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUa = $dData_adU8 } in
                 let {
                   $dData_adUb :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUb = $dData_adU8 } in
                 let {
                   $dData_adUc :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUc = $dData_adU8 } in
                 let {
                   $dData_adUd :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUd = $dData_adU8 } in
                 let {
                   $dData_adUe :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUe = $dData_adU8 } in
                 let {
                   $dData_adUf :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUf = $dData_adU8 } in
                 let {
                   $dData_adUg :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUg = $dData_adU8 } in
                 let {
                   $dData_adUh :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUh = $dData_adU8 } in
                 let {
                   $dData_adUi :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUi = $dData_adU8 } in
                 let {
                   $dData_adUj :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUj = $dData_adU8 } in
                 let {
                   $dData_adUk :: Data.Data.Data PlaceHolder.PlaceHolder
                   [LclId, Str=DmdType]
                   $dData_adUk = $dData_adU8 } in
                 let {
                   $dData_adU7 :: Data.Data.Data RdrName.RdrName
                   [LclId, Str=DmdType]
                   $dData_adU7 = RdrName.$fDataRdrName } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adU6
                     :: (Data.Data.Data RdrName.RdrName,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder,
                         Data.Data.Data PlaceHolder.PlaceHolder)
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adU6 =
                     ($dData_adU7, $dData_adU8, $dData_adU9, $dData_adUa, $dData_adUb,
                      $dData_adUc, $dData_adUd, $dData_adUe, $dData_adUf, $dData_adUg,
                      $dData_adUh, $dData_adUi, $dData_adUj, $dData_adUk) } in
                 let {
                   $d(%,,,,,,,,,,,,,%)_adU3 :: PlaceHolder.DataId RdrName.RdrName
                   [LclId, Str=DmdType]
                   $d(%,,,,,,,,,,,,,%)_adU3 =
                     $d(%,,,,,,,,,,,,,%)_adU6
                     `cast` ((<Data.Data.Data RdrName.RdrName>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data RdrName.RdrName,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder)
                                ~R# (Data.Data.Data RdrName.RdrName,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn
                                          RdrName.RdrName (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName BasicTypes.Fixity),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn RdrName.RdrName Name.Name),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName [Name.Name]),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TypeRep.Type),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName Coercion.Coercion),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [TypeRep.Type]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc
                                          RdrName.RdrName [FieldLabel.FieldLabel]))) } in
                 let {
                   $dData_adU2 :: Data.Data.Data (HsSyn.HsModule RdrName.RdrName)
                   [LclId, Str=DmdType]
                   $dData_adU2 =
                     HsSyn.$fDataHsModule
                       @ RdrName.RdrName $d(%,,,,,,,,,,,,,%)_adU3 } in
                 let {
                   $dData_adU1 :: Data.Data.Data SrcLoc.SrcSpan
                   [LclId, Str=DmdType]
                   $dData_adU1 = SrcLoc.$fDataSrcSpan } in
                 let {
                   $dData_adTZ [Occ=Once] :: Data.Data.Data GHC.ParsedSource
                   [LclId, Str=DmdType]
                   $dData_adTZ =
                     SrcLoc.$fDataGenLocated
                       @ SrcLoc.SrcSpan
                       @ (HsSyn.HsModule RdrName.RdrName)
                       $dData_adU1
                       $dData_adU2 } in
                 let {
                   pCount_adTW [Occ=Once] :: GHC.Types.Int
                   [LclId, Str=DmdType]
                   pCount_adTW = gq_a3SR @ GHC.ParsedSource $dData_adTZ p_a4Wq } in
                 pCount_adTW } in
             System.IO.print
               @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
               $dShow_ae3q
               (pCount_a4Wt, rCount_a4Wu, tsCount_a4Wv)
             }) } in
  testOneFile_a56I

$dMonad_aeaH :: GHC.Base.Monad GHC.Types.IO
[LclId, Str=DmdType]
$dMonad_aeaH = GHC.Base.$fMonadIO

$dMonad_aeaO [Occ=OnceL] :: GHC.Base.Monad GHC.Types.IO
[LclId, Str=DmdType]
$dMonad_aeaO = $dMonad_aeaH

$dMonad_aeaV [Occ=OnceL] :: GHC.Base.Monad GHC.Types.IO
[LclId, Str=DmdType]
$dMonad_aeaV = $dMonad_aeaH

$dMonad_aeb3 [Occ=OnceL] :: GHC.Base.Monad GHC.Types.IO
[LclId, Str=DmdType]
$dMonad_aeb3 = $dMonad_aeaH

$dMonad_aebb [Occ=OnceL] :: GHC.Base.Monad GHC.Types.IO
[LclId, Str=DmdType]
$dMonad_aebb = $dMonad_aeaH

Main.main :: GHC.Types.IO ()
[LclIdX, Str=DmdType]
Main.main =
  let {
    main_aeaB [Occ=Once] :: GHC.Types.IO ()
    [LclId, Str=DmdType]
    main_aeaB =
      GHC.Base.>>=
        @ GHC.Types.IO
        $dMonad_aeaH
        @ [GHC.Base.String]
        @ ()
        System.Environment.getArgs
        (\ (ds_dedZ [Occ=Once!] :: [GHC.Base.String]) ->
           let {
             fail_dee1 [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
             [LclId, Str=DmdType]
             fail_dee1 =
               \ _ [Occ=Dead, OS=OneShot] ->
                 GHC.Base.fail
                   @ GHC.Types.IO
                   $dMonad_aeaO
                   @ ()
                   (GHC.CString.unpackCString#
                      "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
           case ds_dedZ of _ [Occ=Dead] {
             __DEFAULT -> fail_dee1 GHC.Prim.void#;
             : libdir_a3SO ds_dee0 [Occ=Once!] ->
               case ds_dee0 of _ [Occ=Dead] {
                 __DEFAULT -> fail_dee1 GHC.Prim.void#;
                 [] ->
                   GHC.Base.>>
                     @ GHC.Types.IO
                     $dMonad_aeaV
                     @ ()
                     @ ()
                     (Main.testOneFile
                        libdir_a3SO (GHC.CString.unpackCString# "MineFixity"#))
                     (GHC.Base.>>
                        @ GHC.Types.IO
                        $dMonad_aeb3
                        @ ()
                        @ ()
                        (Main.testOneFile
                           libdir_a3SO (GHC.CString.unpackCString# "MineKind"#))
                        (GHC.Base.>>
                           @ GHC.Types.IO
                           $dMonad_aebb
                           @ ()
                           @ ()
                           (Main.testOneFile
                              libdir_a3SO (GHC.CString.unpackCString# "MineNames"#))
                           (Main.testOneFile
                              libdir_a3SO (GHC.CString.unpackCString# "MineType"#))))
               }
           }) } in
  main_aeaB

:Main.main :: GHC.Types.IO ()
[LclIdX, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main




==================== Desugar (after optimization) ====================
Result size of Desugar (after optimization)
  = {terms: 361, types: 649, coercions: 244}

-- RHS size: {terms: 5, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId], Str=DmdType]
Main.$trModule = Module (TrNameS "main"#) (TrNameS "Main"#)

-- RHS size: {terms: 18, types: 18, coercions: 0}
mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Typeable a_a3PP, Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX, Str=DmdType]
mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v :: Typeable a_a4Yh)
    ($dTypeable_a56w :: Typeable b_a4Yi)
    (r_a4Ww :: r_a4Yj)
    (br_a4Wx :: b_a4Yi -> r_a4Yj)
    (a_a4Wy :: a_a4Yh) ->
    case cast @ a_a4Yh @ b_a4Yi $dTypeable_a56v $dTypeable_a56w a_a4Wy
    of _ [Occ=Dead] {
      Nothing -> r_a4Ww;
      Just b_a4WM -> br_a4Wx b_a4WM
    }

Rec {
-- RHS size: {terms: 25, types: 26, coercions: 0}
everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO) -> GenericQ r_a3PO -> GenericQ r_a3PO
[LclIdX, Str=DmdType]
everything =
  \ (@ r_a4XV)
    (dk_aecm :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk_aecn :: GenericQ r_a4XV)
    (@ a_a55z)
    ($dData_a55A :: Data a_a55z) ->
    (\ (k_a4WN [OS=OneShot] :: r_a4XV -> r_a4XV -> r_a4XV)
       (f_a4WO [OS=OneShot] :: GenericQ r_a4XV)
       (x_a4WP :: a_a55z) ->
       foldl
         @ []
         Data.Foldable.$fFoldable[]
         @ r_a4XV
         @ r_a4XV
         k_a4WN
         (f_a4WO @ a_a55z $dData_a55A x_a4WP)
         (gmapQ
            @ a_a55z
            $dData_a55A
            @ r_a4XV
            (\ (@ d_a56e) ($dData_a56f :: Data d_a56e) ->
               everything @ r_a4XV k_a4WN f_a4WO @ d_a56e $dData_a56f)
            x_a4WP))
      dk_aecm dk_aecn
end Rec }

-- RHS size: {terms: 261, types: 545, coercions: 244}
testOneFile :: FilePath -> String -> IO ()
[LclIdX, Str=DmdType]
testOneFile =
  let {
    $dShow_ae3q :: Show (Int, Int, Int)
    [LclId, Str=DmdType]
    $dShow_ae3q =
      GHC.Show.$fShow(,,)
        @ Int
        @ Int
        @ Int
        GHC.Show.$fShowInt
        GHC.Show.$fShowInt
        GHC.Show.$fShowInt } in
  \ (libdir_a3SP :: FilePath) (fileName_a3SQ :: String) ->
    let {
      worker_a3SS :: SrcSpan -> [SrcSpan]
      [LclId, Str=DmdType]
      worker_a3SS =
        \ (s_a41A :: SrcSpan) ->
          case s_a41A of wild_00 {
            __DEFAULT -> (\ _ [Occ=Dead, OS=OneShot] -> [] @ SrcSpan) void#;
            RealSrcSpan _ [Occ=Dead] -> : @ SrcSpan wild_00 ([] @ SrcSpan)
          } } in
    let {
      gq_a3SR :: forall a_a5bd. Data a_a5bd => a_a5bd -> Int
      [LclId, Str=DmdType]
      gq_a3SR =
        \ (@ a_a5bd) ($dData_a6PB :: Data a_a5bd) (ast_a3ST :: a_a5bd) ->
          $ @ [SrcSpan]
            @ Int
            (length @ [] Data.Foldable.$fFoldable[] @ SrcSpan)
            (everything
               @ [SrcSpan]
               (++ @ SrcSpan)
               (\ (@ a_a5bk) ($dData_a5bl :: Data a_a5bk) ->
                  mkQ
                    @ a_a5bk
                    @ SrcSpan
                    @ [SrcSpan]
                    (Data.Data.$p1Data @ a_a5bk $dData_a5bl)
                    ((let {
                        ds_dedF :: TypeRep
                        [LclId, Str=DmdType]
                        ds_dedF =
                          mkPolyTyConApp SrcLoc.$tcSrcSpan ([] @ TypeRep) ([] @ TypeRep) } in
                      \ _ [Occ=Dead] -> ds_dedF)
                     `cast` (Sym (NTCo:Typeable[0] <*>_N <SrcSpan>_N)
                             :: (Proxy# SrcSpan -> TypeRep) ~R# Typeable SrcSpan))
                    ([] @ SrcSpan)
                    worker_a3SS)
               @ a_a5bd
               $dData_a6PB
               ast_a3ST) } in
    >>=
      @ IO
      GHC.Base.$fMonadIO
      @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
      @ ()
      ($ @ (Ghc (ParsedSource, Maybe RenamedSource, TypecheckedSource))
         @ (IO (ParsedSource, Maybe RenamedSource, TypecheckedSource))
         (runGhc
            @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
            (Just @ FilePath libdir_a3SP))
         (>>=
            @ Ghc
            GhcMonad.$fMonadGhc
            @ DynFlags
            @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
            (getSessionDynFlags @ Ghc GhcMonad.$fGhcMonadGhc)
            (\ (dflags_a4fE :: DynFlags) ->
               >>
                 @ Ghc
                 GhcMonad.$fMonadGhc
                 @ [UnitId]
                 @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                 (setSessionDynFlags @ Ghc GhcMonad.$fGhcMonadGhc dflags_a4fE)
                 (let {
                    mn_a4fF :: ModuleName
                    [LclId, Str=DmdType]
                    mn_a4fF = mkModuleName fileName_a3SQ } in
                  >>
                    @ Ghc
                    GhcMonad.$fMonadGhc
                    @ ()
                    @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                    (addTarget
                       @ Ghc
                       GhcMonad.$fGhcMonadGhc
                       (HscTypes.Target
                          (HscTypes.TargetModule mn_a4fF)
                          True
                          (Nothing
                             @ (StringBuffer.StringBuffer,
                                time-1.5.0.1:Data.Time.Clock.UTC.UTCTime))))
                    (>>
                       @ Ghc
                       GhcMonad.$fMonadGhc
                       @ SuccessFlag
                       @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                       (load @ Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets)
                       (>>=
                          @ Ghc
                          GhcMonad.$fMonadGhc
                          @ ModSummary
                          @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                          (getModSummary @ Ghc GhcMonad.$fGhcMonadGhc mn_a4fF)
                          (\ (modSum_a4Wj :: ModSummary) ->
                             >>=
                               @ Ghc
                               GhcMonad.$fMonadGhc
                               @ ParsedModule
                               @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                               (parseModule @ Ghc GhcMonad.$fGhcMonadGhc modSum_a4Wj)
                               (\ (p_a4Wk :: ParsedModule) ->
                                  >>=
                                    @ Ghc
                                    GhcMonad.$fMonadGhc
                                    @ TypecheckedModule
                                    @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                    (typecheckModule @ Ghc GhcMonad.$fGhcMonadGhc p_a4Wk)
                                    (\ (t_a4Wl :: TypecheckedModule) ->
                                       >>=
                                         @ Ghc
                                         GhcMonad.$fMonadGhc
                                         @ DesugaredModule
                                         @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                         (desugarModule @ Ghc GhcMonad.$fGhcMonadGhc t_a4Wl)
                                         (\ (d_a4Wm :: DesugaredModule) ->
                                            >>=
                                              @ Ghc
                                              GhcMonad.$fMonadGhc
                                              @ DesugaredModule
                                              @ (ParsedSource, Maybe RenamedSource,
                                                 TypecheckedSource)
                                              (loadModule
                                                 @ DesugaredModule
                                                 @ Ghc
                                                 GHC.$fTypecheckedModDesugaredModule
                                                 GhcMonad.$fGhcMonadGhc
                                                 d_a4Wm)
                                              (\ (l_a4Wn :: DesugaredModule) ->
                                                 return
                                                   @ Ghc
                                                   GhcMonad.$fMonadGhc
                                                   @ (ParsedSource, Maybe RenamedSource,
                                                      TypecheckedSource)
                                                   (pm_parsed_source p_a4Wk,
                                                    renamedSource
                                                      @ DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn,
                                                    typecheckedSource
                                                      @ DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn))))))))))))
      (\ (ds_dedD
            :: (ParsedSource, Maybe RenamedSource, TypecheckedSource)) ->
         case ds_dedD of _ [Occ=Dead] { (p_a4Wq, r_a4Wr, ts_a4Ws) ->
         print
           @ (Int, Int, Int)
           $dShow_ae3q
           (let {
              $d(%,,,,,,,,,,,,,%)_adU6
                :: (Data RdrName, Data PlaceHolder, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder)
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adU6 =
                (RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder) } in
            let {
              $dData_adU2 :: Data (HsModule RdrName)
              [LclId, Str=DmdType]
              $dData_adU2 =
                HsSyn.$fDataHsModule
                  @ RdrName
                  ($d(%,,,,,,,,,,,,,%)_adU6
                   `cast` ((<Data RdrName>_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                     <UniqFM.UniqFM Name>_N)))_N,
                            (Data
                               (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Fixity>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Bool>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name]>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <Type>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <Coercion.Coercion>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[Type]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[ConLike.ConLike]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                     <TcEvidence.HsWrapper>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data RdrName, Data PlaceHolder, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder)
                              ~R# (Data RdrName, Data (PostRn RdrName (UniqFM.UniqFM Name)),
                                   Data (PostRn RdrName GHC.Fixity), Data (PostRn RdrName Bool),
                                   Data (PostRn RdrName Name), Data (PostRn RdrName [Name]),
                                   Data (PostRn RdrName RdrName), Data (PostTc RdrName Type),
                                   Data (PostTc RdrName Coercion.Coercion),
                                   Data (PostTc RdrName RdrName), Data (PostTc RdrName [Type]),
                                   Data (PostTc RdrName [ConLike.ConLike]),
                                   Data (PostTc RdrName TcEvidence.HsWrapper),
                                   Data (PostTc RdrName [FieldLabel.FieldLabel])))) } in
            gq_a3SR
              @ ParsedSource
              (SrcLoc.$fDataGenLocated
                 @ SrcSpan @ (HsModule RdrName) SrcLoc.$fDataSrcSpan $dData_adU2)
              p_a4Wq,
            let {
              $dData_adTQ :: Data (GenLocated SrcSpan HsDocString)
              [LclId, Str=DmdType]
              $dData_adTQ =
                SrcLoc.$fDataGenLocated
                  @ SrcSpan
                  @ HsDocString
                  SrcLoc.$fDataSrcSpan
                  HsDoc.$fDataHsDocString } in
            let {
              $dData_adTn :: Data (Maybe LHsDocString)
              [LclId, Str=DmdType]
              $dData_adTn =
                Data.Data.$fDataMaybe
                  @ (GenLocated SrcSpan HsDocString) $dData_adTQ } in
            let {
              $dData_adTx :: Data (UniqFM.UniqFM Name)
              [LclId, Str=DmdType]
              $dData_adTx = UniqFM.$fDataUniqFM @ Name Name.$fDataName } in
            let {
              $dData_adTB :: Data [Name]
              [LclId, Str=DmdType]
              $dData_adTB = Data.Data.$fData[] @ Name Name.$fDataName } in
            let {
              $dData_adTM :: Data (ImportDecl Name)
              [LclId, Str=DmdType]
              $dData_adTM = HsImpExp.$fDataImportDecl @ Name Name.$fDataName } in
            let {
              $dData_adTK :: Data (GenLocated SrcSpan (ImportDecl Name))
              [LclId, Str=DmdType]
              $dData_adTK =
                SrcLoc.$fDataGenLocated
                  @ SrcSpan @ (ImportDecl Name) SrcLoc.$fDataSrcSpan $dData_adTM } in
            let {
              $dData_adTl :: Data [LImportDecl Name]
              [LclId, Str=DmdType]
              $dData_adTl =
                Data.Data.$fData[]
                  @ (GenLocated SrcSpan (ImportDecl Name)) $dData_adTK } in
            let {
              $dData_adTP :: Data (IE Name)
              [LclId, Str=DmdType]
              $dData_adTP = HsImpExp.$fDataIE @ Name Name.$fDataName } in
            let {
              $dData_adTO :: Data (GenLocated SrcSpan (IE Name))
              [LclId, Str=DmdType]
              $dData_adTO =
                SrcLoc.$fDataGenLocated
                  @ SrcSpan @ (IE Name) SrcLoc.$fDataSrcSpan $dData_adTP } in
            let {
              $dData_adTN :: Data [LIE Name]
              [LclId, Str=DmdType]
              $dData_adTN =
                Data.Data.$fData[]
                  @ (GenLocated SrcSpan (IE Name)) $dData_adTO } in
            let {
              $dData_adTm :: Data (Maybe [LIE Name])
              [LclId, Str=DmdType]
              $dData_adTm = Data.Data.$fDataMaybe @ [LIE Name] $dData_adTN } in
            let {
              $d(%,,,,,,,,,,,,,%)_adTv
                :: (Data Name, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                    Data Bool, Data Name, Data [Name], Data Name, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder)
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adTv =
                (Name.$fDataName, $dData_adTx, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adTB,
                 Name.$fDataName, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder) } in
            let {
              $dData_adTk :: Data (HsGroup Name)
              [LclId, Str=DmdType]
              $dData_adTk =
                HsDecls.$fDataHsGroup
                  @ Name
                  ($d(%,,,,,,,,,,,,,%)_adTv
                   `cast` ((<Data Name>_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnNamety[0] <UniqFM.UniqFM Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Fixity>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Bool>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name]>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Type>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <Coercion.Coercion>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <[Type]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <[ConLike.ConLike]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data Name, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                               Data Bool, Data Name, Data [Name], Data Name, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                               Data PlaceHolder, Data PlaceHolder, Data PlaceHolder)
                              ~R# (Data Name, Data (PostRn Name (UniqFM.UniqFM Name)),
                                   Data (PostRn Name GHC.Fixity), Data (PostRn Name Bool),
                                   Data (PostRn Name Name), Data (PostRn Name [Name]),
                                   Data (PostRn Name Name), Data (PostTc Name Type),
                                   Data (PostTc Name Coercion.Coercion), Data (PostTc Name Name),
                                   Data (PostTc Name [Type]), Data (PostTc Name [ConLike.ConLike]),
                                   Data (PostTc Name TcEvidence.HsWrapper),
                                   Data (PostTc Name [FieldLabel.FieldLabel])))) } in
            let {
              $dData_adTj
                :: Data
                     (HsGroup Name, [LImportDecl Name], Maybe [LIE Name],
                      Maybe LHsDocString)
              [LclId, Str=DmdType]
              $dData_adTj =
                Data.Data.$fData(,,,)
                  @ (HsGroup Name)
                  @ [LImportDecl Name]
                  @ (Maybe [LIE Name])
                  @ (Maybe LHsDocString)
                  $dData_adTk
                  $dData_adTl
                  $dData_adTm
                  $dData_adTn } in
            gq_a3SR
              @ (Maybe RenamedSource)
              (Data.Data.$fDataMaybe
                 @ (HsGroup Name, [LImportDecl Name], Maybe [LIE Name],
                    Maybe LHsDocString)
                 $dData_adTj)
              r_a4Wr,
            let {
              $dData_adT2 :: Data [ConLike.ConLike]
              [LclId, Str=DmdType]
              $dData_adT2 =
                Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
            let {
              $dData_adT1 :: Data [Type]
              [LclId, Str=DmdType]
              $dData_adT1 = Data.Data.$fData[] @ Type TypeRep.$fDataType } in
            let {
              $dData_adSW :: Data [Name]
              [LclId, Str=DmdType]
              $dData_adSW = Data.Data.$fData[] @ Name Name.$fDataName } in
            let {
              $dData_adT9 :: Data (FieldLabel.FieldLbl Name)
              [LclId, Str=DmdType]
              $dData_adT9 = FieldLabel.$fDataFieldLbl @ Name Name.$fDataName } in
            let {
              $dData_adT4 :: Data [FieldLabel.FieldLabel]
              [LclId, Str=DmdType]
              $dData_adT4 =
                Data.Data.$fData[] @ (FieldLabel.FieldLbl Name) $dData_adT9 } in
            let {
              $dData_adSS :: Data (UniqFM.UniqFM Name)
              [LclId, Str=DmdType]
              $dData_adSS = UniqFM.$fDataUniqFM @ Name Name.$fDataName } in
            let {
              $d(%,,,,,,,,,,,,,%)_adSQ
                :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                    Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                    Data Coercion.Coercion, Data Var.Var, Data [Type],
                    Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                    Data [FieldLabel.FieldLabel])
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adSQ =
                (Var.$fDataVar, $dData_adSS, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adSW, Var.$fDataVar,
                 TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                 $dData_adT1, $dData_adT2, TcEvidence.$fDataHsWrapper,
                 $dData_adT4) } in
            let {
              $dData_accn :: Data (HsBindLR Id Id)
              [LclId, Str=DmdType]
              $dData_accn =
                HsBinds.$fDataHsBindLR
                  @ Var.Var
                  @ Var.Var
                  ($d(%,,,,,,,,,,,,,%)_adSQ
                   `cast` ((<Data Var.Var>_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnVarty[0] <UniqFM.UniqFM Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                            (Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                            (Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                               Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                               Data Coercion.Coercion, Data Var.Var, Data [Type],
                               Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                               Data [FieldLabel.FieldLabel])
                              ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                   Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                   Data (PostRn Id Name), Data (PostRn Id [Name]),
                                   Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                   Data (PostTc Id Coercion.Coercion), Data (PostTc Id Var.Var),
                                   Data (PostTc Id [Type]), Data (PostTc Id [ConLike.ConLike]),
                                   Data (PostTc Id TcEvidence.HsWrapper),
                                   Data (PostTc Id [FieldLabel.FieldLabel]))))
                  ($d(%,,,,,,,,,,,,,%)_adSQ
                   `cast` ((<Data Var.Var>_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnVarty[0] <UniqFM.UniqFM Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                            (Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                            (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                            (Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                               Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                               Data Coercion.Coercion, Data Var.Var, Data [Type],
                               Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                               Data [FieldLabel.FieldLabel])
                              ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                   Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                   Data (PostRn Id Name), Data (PostRn Id [Name]),
                                   Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                   Data (PostTc Id Coercion.Coercion), Data (PostTc Id Var.Var),
                                   Data (PostTc Id [Type]), Data (PostTc Id [ConLike.ConLike]),
                                   Data (PostTc Id TcEvidence.HsWrapper),
                                   Data (PostTc Id [FieldLabel.FieldLabel])))) } in
            let {
              $dData_accl :: Data (GenLocated SrcSpan (HsBindLR Id Id))
              [LclId, Str=DmdType]
              $dData_accl =
                SrcLoc.$fDataGenLocated
                  @ SrcSpan @ (HsBindLR Id Id) SrcLoc.$fDataSrcSpan $dData_accn } in
            gq_a3SR
              @ TypecheckedSource
              (Bag.$fDataBag @ (GenLocated SrcSpan (HsBindLR Id Id)) $dData_accl)
              ts_a4Ws)
         })

-- RHS size: {terms: 44, types: 28, coercions: 0}
main :: IO ()
[LclIdX, Str=DmdType]
main =
  >>=
    @ IO
    GHC.Base.$fMonadIO
    @ [String]
    @ ()
    getArgs
    (\ (ds_dedZ :: [String]) ->
       let {
         fail_dee1 :: Void# -> IO ()
         [LclId, Str=DmdType]
         fail_dee1 =
           \ _ [Occ=Dead, OS=OneShot] ->
             fail
               @ IO
               GHC.Base.$fMonadIO
               @ ()
               (unpackCString#
                  "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
       case ds_dedZ of _ [Occ=Dead] {
         __DEFAULT -> fail_dee1 void#;
         : libdir_a3SO ds_dee0 ->
           case ds_dee0 of _ [Occ=Dead] {
             __DEFAULT -> fail_dee1 void#;
             [] ->
               >>
                 @ IO
                 GHC.Base.$fMonadIO
                 @ ()
                 @ ()
                 (testOneFile libdir_a3SO (unpackCString# "MineFixity"#))
                 (>>
                    @ IO
                    GHC.Base.$fMonadIO
                    @ ()
                    @ ()
                    (testOneFile libdir_a3SO (unpackCString# "MineKind"#))
                    (>>
                       @ IO
                       GHC.Base.$fMonadIO
                       @ ()
                       @ ()
                       (testOneFile libdir_a3SO (unpackCString# "MineNames"#))
                       (testOneFile libdir_a3SO (unpackCString# "MineType"#))))
           }
       })

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[LclIdX, Str=DmdType]
:Main.main = runMainIO @ () main




==================== Occurrence analysis ====================
Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId], Str=DmdType]
Main.$trModule =
  GHC.Types.Module
    (GHC.Types.TrNameS "main"#) (GHC.Types.TrNameS "Main"#)

Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX, Str=DmdType]
Main.mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v [Occ=Once]
       :: Data.Typeable.Internal.Typeable a_a4Yh)
    ($dTypeable_a56w [Occ=Once]
       :: Data.Typeable.Internal.Typeable b_a4Yi)
    (r_a4Ww [Occ=Once] :: r_a4Yj)
    (br_a4Wx [Occ=Once!] :: b_a4Yi -> r_a4Yj)
    (a_a4Wy [Occ=Once] :: a_a4Yh) ->
    case Data.Typeable.cast
           @ a_a4Yh @ b_a4Yi $dTypeable_a56v $dTypeable_a56w a_a4Wy
    of _ [Occ=Dead] {
      GHC.Base.Nothing -> r_a4Ww;
      GHC.Base.Just b_a4WM [Occ=Once] -> br_a4Wx b_a4WM
    }

Rec {
Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[LclIdX, Str=DmdType]
Main.everything =
  \ (@ r_a4XV)
    (dk_aecm [Occ=Once] :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk_aecn [Occ=Once] :: Main.GenericQ r_a4XV)
    (@ a_a55z)
    ($dData_a55A :: Data.Data.Data a_a55z) ->
    (\ (k_a4WN [OS=OneShot] :: r_a4XV -> r_a4XV -> r_a4XV)
       (f_a4WO [OS=OneShot] :: Main.GenericQ r_a4XV)
       (x_a4WP :: a_a55z) ->
       Data.Foldable.foldl
         @ []
         Data.Foldable.$fFoldable[]
         @ r_a4XV
         @ r_a4XV
         k_a4WN
         (f_a4WO @ a_a55z $dData_a55A x_a4WP)
         (Data.Data.gmapQ
            @ a_a55z
            $dData_a55A
            @ r_a4XV
            (\ (@ d_a56e) ($dData_a56f [Occ=Once] :: Data.Data.Data d_a56e) ->
               Main.everything @ r_a4XV k_a4WN f_a4WO @ d_a56e $dData_a56f)
            x_a4WP))
      dk_aecm dk_aecn
end Rec }

Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[LclIdX, Str=DmdType]
Main.testOneFile =
  let {
    $dShow_ae3q [Occ=OnceL]
      :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
    [LclId, Str=DmdType]
    $dShow_ae3q =
      GHC.Show.$fShow(,,)
        @ GHC.Types.Int
        @ GHC.Types.Int
        @ GHC.Types.Int
        GHC.Show.$fShowInt
        GHC.Show.$fShowInt
        GHC.Show.$fShowInt } in
  \ (libdir_a3SP [Occ=Once] :: GHC.IO.FilePath)
    (fileName_a3SQ [Occ=OnceL] :: GHC.Base.String) ->
    let {
      worker_a3SS [Occ=OnceL] :: SrcLoc.SrcSpan -> [SrcLoc.SrcSpan]
      [LclId, Str=DmdType]
      worker_a3SS =
        \ (s_a41A [Occ=Once!] :: SrcLoc.SrcSpan) ->
          case s_a41A of wild_00 {
            __DEFAULT ->
              (\ _ [Occ=Dead, OS=OneShot] -> GHC.Types.[] @ SrcLoc.SrcSpan)
                GHC.Prim.void#;
            SrcLoc.RealSrcSpan _ [Occ=Dead] ->
              GHC.Types.:
                @ SrcLoc.SrcSpan wild_00 (GHC.Types.[] @ SrcLoc.SrcSpan)
          } } in
    let {
      gq_a3SR
        :: forall a_a5bd. Data.Data.Data a_a5bd => a_a5bd -> GHC.Types.Int
      [LclId, Str=DmdType]
      gq_a3SR =
        \ (@ a_a5bd)
          ($dData_a6PB [Occ=Once] :: Data.Data.Data a_a5bd)
          (ast_a3ST [Occ=Once] :: a_a5bd) ->
          GHC.Base.$
            @ [SrcLoc.SrcSpan]
            @ GHC.Types.Int
            (Data.Foldable.length
               @ [] Data.Foldable.$fFoldable[] @ SrcLoc.SrcSpan)
            (Main.everything
               @ [SrcLoc.SrcSpan]
               (GHC.Base.++ @ SrcLoc.SrcSpan)
               (\ (@ a_a5bk) ($dData_a5bl [Occ=Once] :: Data.Data.Data a_a5bk) ->
                  Main.mkQ
                    @ a_a5bk
                    @ SrcLoc.SrcSpan
                    @ [SrcLoc.SrcSpan]
                    (Data.Data.$p1Data @ a_a5bk $dData_a5bl)
                    ((let {
                        ds_dedF [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                        [LclId, Str=DmdType]
                        ds_dedF =
                          Data.Typeable.Internal.mkPolyTyConApp
                            SrcLoc.$tcSrcSpan
                            (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                            (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } in
                      \ _ [Occ=Dead] -> ds_dedF)
                     `cast` (Sym
                               (Data.Typeable.Internal.NTCo:Typeable[0] <*>_N <SrcLoc.SrcSpan>_N)
                             :: (GHC.Prim.Proxy# SrcLoc.SrcSpan
                                 -> Data.Typeable.Internal.TypeRep)
                                ~R# Data.Typeable.Internal.Typeable SrcLoc.SrcSpan))
                    (GHC.Types.[] @ SrcLoc.SrcSpan)
                    worker_a3SS)
               @ a_a5bd
               $dData_a6PB
               ast_a3ST) } in
    GHC.Base.>>=
      @ GHC.Types.IO
      GHC.Base.$fMonadIO
      @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
         GHC.TypecheckedSource)
      @ ()
      (GHC.Base.$
         @ (GhcMonad.Ghc
              (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource))
         @ (GHC.Types.IO
              (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource))
         (GHC.runGhc
            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource)
            (GHC.Base.Just @ GHC.IO.FilePath libdir_a3SP))
         (GHC.Base.>>=
            @ GhcMonad.Ghc
            GhcMonad.$fMonadGhc
            @ DynFlags.DynFlags
            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource)
            (GhcMonad.getSessionDynFlags @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc)
            (\ (dflags_a4fE [Occ=Once] :: DynFlags.DynFlags) ->
               GHC.Base.>>
                 @ GhcMonad.Ghc
                 GhcMonad.$fMonadGhc
                 @ [Module.UnitId]
                 @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                    GHC.TypecheckedSource)
                 (GHC.setSessionDynFlags
                    @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc dflags_a4fE)
                 (let {
                    mn_a4fF :: Module.ModuleName
                    [LclId, Str=DmdType]
                    mn_a4fF = Module.mkModuleName fileName_a3SQ } in
                  GHC.Base.>>
                    @ GhcMonad.Ghc
                    GhcMonad.$fMonadGhc
                    @ ()
                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                       GHC.TypecheckedSource)
                    (GHC.addTarget
                       @ GhcMonad.Ghc
                       GhcMonad.$fGhcMonadGhc
                       (HscTypes.Target
                          (HscTypes.TargetModule mn_a4fF)
                          GHC.Types.True
                          (GHC.Base.Nothing
                             @ (StringBuffer.StringBuffer, Data.Time.Clock.UTC.UTCTime))))
                    (GHC.Base.>>
                       @ GhcMonad.Ghc
                       GhcMonad.$fMonadGhc
                       @ BasicTypes.SuccessFlag
                       @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                          GHC.TypecheckedSource)
                       (GhcMake.load
                          @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets)
                       (GHC.Base.>>=
                          @ GhcMonad.Ghc
                          GhcMonad.$fMonadGhc
                          @ HscTypes.ModSummary
                          @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                             GHC.TypecheckedSource)
                          (GHC.getModSummary @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc mn_a4fF)
                          (\ (modSum_a4Wj [Occ=Once] :: HscTypes.ModSummary) ->
                             GHC.Base.>>=
                               @ GhcMonad.Ghc
                               GhcMonad.$fMonadGhc
                               @ GHC.ParsedModule
                               @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                  GHC.TypecheckedSource)
                               (GHC.parseModule @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc modSum_a4Wj)
                               (\ (p_a4Wk :: GHC.ParsedModule) ->
                                  GHC.Base.>>=
                                    @ GhcMonad.Ghc
                                    GhcMonad.$fMonadGhc
                                    @ GHC.TypecheckedModule
                                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                       GHC.TypecheckedSource)
                                    (GHC.typecheckModule
                                       @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc p_a4Wk)
                                    (\ (t_a4Wl [Occ=Once] :: GHC.TypecheckedModule) ->
                                       GHC.Base.>>=
                                         @ GhcMonad.Ghc
                                         GhcMonad.$fMonadGhc
                                         @ GHC.DesugaredModule
                                         @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                            GHC.TypecheckedSource)
                                         (GHC.desugarModule
                                            @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc t_a4Wl)
                                         (\ (d_a4Wm [Occ=Once] :: GHC.DesugaredModule) ->
                                            GHC.Base.>>=
                                              @ GhcMonad.Ghc
                                              GhcMonad.$fMonadGhc
                                              @ GHC.DesugaredModule
                                              @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                 GHC.TypecheckedSource)
                                              (GHC.loadModule
                                                 @ GHC.DesugaredModule
                                                 @ GhcMonad.Ghc
                                                 GHC.$fTypecheckedModDesugaredModule
                                                 GhcMonad.$fGhcMonadGhc
                                                 d_a4Wm)
                                              (\ (l_a4Wn :: GHC.DesugaredModule) ->
                                                 GHC.Base.return
                                                   @ GhcMonad.Ghc
                                                   GhcMonad.$fMonadGhc
                                                   @ (GHC.ParsedSource,
                                                      GHC.Base.Maybe GHC.RenamedSource,
                                                      GHC.TypecheckedSource)
                                                   (GHC.pm_parsed_source p_a4Wk,
                                                    GHC.renamedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn,
                                                    GHC.typecheckedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn))))))))))))
      (\ (ds_dedD [Occ=Once!]
            :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                GHC.TypecheckedSource)) ->
         case ds_dedD
         of _ [Occ=Dead]
         { (p_a4Wq [Occ=Once], r_a4Wr [Occ=Once], ts_a4Ws [Occ=Once]) ->
         System.IO.print
           @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
           $dShow_ae3q
           (let {
              $d(%,,,,,,,,,,,,,%)_adU6 [Occ=Once]
                :: (Data.Data.Data RdrName.RdrName,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder)
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adU6 =
                (RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder) } in
            let {
              $dData_adU2 [Occ=Once]
                :: Data.Data.Data (HsSyn.HsModule RdrName.RdrName)
              [LclId, Str=DmdType]
              $dData_adU2 =
                HsSyn.$fDataHsModule
                  @ RdrName.RdrName
                  ($d(%,,,,,,,,,,,,,%)_adU6
                   `cast` ((<Data.Data.Data RdrName.RdrName>_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                     <UniqFM.UniqFM Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <BasicTypes.Fixity>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Types.Bool>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name.Name]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName.RdrName>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <TypeRep.Type>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <Coercion.Coercion>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName.RdrName>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[TypeRep.Type]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[ConLike.ConLike]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                     <TcEvidence.HsWrapper>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data.Data.Data RdrName.RdrName,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder)
                              ~R# (Data.Data.Data RdrName.RdrName,
                                   Data.Data.Data
                                     (PlaceHolder.PostRn RdrName.RdrName (UniqFM.UniqFM Name.Name)),
                                   Data.Data.Data
                                     (PlaceHolder.PostRn RdrName.RdrName BasicTypes.Fixity),
                                   Data.Data.Data
                                     (PlaceHolder.PostRn RdrName.RdrName GHC.Types.Bool),
                                   Data.Data.Data (PlaceHolder.PostRn RdrName.RdrName Name.Name),
                                   Data.Data.Data (PlaceHolder.PostRn RdrName.RdrName [Name.Name]),
                                   Data.Data.Data
                                     (PlaceHolder.PostRn RdrName.RdrName RdrName.RdrName),
                                   Data.Data.Data (PlaceHolder.PostTc RdrName.RdrName TypeRep.Type),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc RdrName.RdrName Coercion.Coercion),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc RdrName.RdrName RdrName.RdrName),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc RdrName.RdrName [TypeRep.Type]),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc RdrName.RdrName [ConLike.ConLike]),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc RdrName.RdrName TcEvidence.HsWrapper),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc
                                        RdrName.RdrName [FieldLabel.FieldLabel])))) } in
            gq_a3SR
              @ GHC.ParsedSource
              (SrcLoc.$fDataGenLocated
                 @ SrcLoc.SrcSpan
                 @ (HsSyn.HsModule RdrName.RdrName)
                 SrcLoc.$fDataSrcSpan
                 $dData_adU2)
              p_a4Wq,
            let {
              $dData_adTQ [Occ=Once]
                :: Data.Data.Data
                     (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
              [LclId, Str=DmdType]
              $dData_adTQ =
                SrcLoc.$fDataGenLocated
                  @ SrcLoc.SrcSpan
                  @ HsDoc.HsDocString
                  SrcLoc.$fDataSrcSpan
                  HsDoc.$fDataHsDocString } in
            let {
              $dData_adTn [Occ=Once]
                :: Data.Data.Data (GHC.Base.Maybe HsDoc.LHsDocString)
              [LclId, Str=DmdType]
              $dData_adTn =
                Data.Data.$fDataMaybe
                  @ (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                  $dData_adTQ } in
            let {
              $dData_adTx [Occ=Once] :: Data.Data.Data (UniqFM.UniqFM Name.Name)
              [LclId, Str=DmdType]
              $dData_adTx = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
            let {
              $dData_adTB [Occ=Once] :: Data.Data.Data [Name.Name]
              [LclId, Str=DmdType]
              $dData_adTB = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
            let {
              $dData_adTM [Occ=Once]
                :: Data.Data.Data (HsImpExp.ImportDecl Name.Name)
              [LclId, Str=DmdType]
              $dData_adTM =
                HsImpExp.$fDataImportDecl @ Name.Name Name.$fDataName } in
            let {
              $dData_adTK [Occ=Once]
                :: Data.Data.Data
                     (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
              [LclId, Str=DmdType]
              $dData_adTK =
                SrcLoc.$fDataGenLocated
                  @ SrcLoc.SrcSpan
                  @ (HsImpExp.ImportDecl Name.Name)
                  SrcLoc.$fDataSrcSpan
                  $dData_adTM } in
            let {
              $dData_adTl [Occ=Once]
                :: Data.Data.Data [HsImpExp.LImportDecl Name.Name]
              [LclId, Str=DmdType]
              $dData_adTl =
                Data.Data.$fData[]
                  @ (SrcLoc.GenLocated
                       SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                  $dData_adTK } in
            let {
              $dData_adTP [Occ=Once] :: Data.Data.Data (HsImpExp.IE Name.Name)
              [LclId, Str=DmdType]
              $dData_adTP = HsImpExp.$fDataIE @ Name.Name Name.$fDataName } in
            let {
              $dData_adTO [Occ=Once]
                :: Data.Data.Data
                     (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
              [LclId, Str=DmdType]
              $dData_adTO =
                SrcLoc.$fDataGenLocated
                  @ SrcLoc.SrcSpan
                  @ (HsImpExp.IE Name.Name)
                  SrcLoc.$fDataSrcSpan
                  $dData_adTP } in
            let {
              $dData_adTN [Occ=Once] :: Data.Data.Data [HsImpExp.LIE Name.Name]
              [LclId, Str=DmdType]
              $dData_adTN =
                Data.Data.$fData[]
                  @ (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                  $dData_adTO } in
            let {
              $dData_adTm [Occ=Once]
                :: Data.Data.Data (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
              [LclId, Str=DmdType]
              $dData_adTm =
                Data.Data.$fDataMaybe @ [HsImpExp.LIE Name.Name] $dData_adTN } in
            let {
              $d(%,,,,,,,,,,,,,%)_adTv [Occ=Once]
                :: (Data.Data.Data Name.Name,
                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                    Data.Data.Data Name.Name, Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder,
                    Data.Data.Data PlaceHolder.PlaceHolder)
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adTv =
                (Name.$fDataName, $dData_adTx, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adTB,
                 Name.$fDataName, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                 PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder) } in
            let {
              $dData_adTk [Occ=Once]
                :: Data.Data.Data (HsDecls.HsGroup Name.Name)
              [LclId, Str=DmdType]
              $dData_adTk =
                HsDecls.$fDataHsGroup
                  @ Name.Name
                  ($d(%,,,,,,,,,,,,,%)_adTv
                   `cast` ((<Data.Data.Data Name.Name>_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnNamety[0]
                                     <UniqFM.UniqFM Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnNamety[0] <BasicTypes.Fixity>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Types.Bool>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name.Name]>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <TypeRep.Type>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <Coercion.Coercion>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <[TypeRep.Type]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <[ConLike.ConLike]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcNamety[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data.Data.Data Name.Name,
                               Data.Data.Data (UniqFM.UniqFM Name.Name),
                               Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                               Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                               Data.Data.Data Name.Name, Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder,
                               Data.Data.Data PlaceHolder.PlaceHolder)
                              ~R# (Data.Data.Data Name.Name,
                                   Data.Data.Data
                                     (PlaceHolder.PostRn Name.Name (UniqFM.UniqFM Name.Name)),
                                   Data.Data.Data (PlaceHolder.PostRn Name.Name BasicTypes.Fixity),
                                   Data.Data.Data (PlaceHolder.PostRn Name.Name GHC.Types.Bool),
                                   Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                   Data.Data.Data (PlaceHolder.PostRn Name.Name [Name.Name]),
                                   Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                   Data.Data.Data (PlaceHolder.PostTc Name.Name TypeRep.Type),
                                   Data.Data.Data (PlaceHolder.PostTc Name.Name Coercion.Coercion),
                                   Data.Data.Data (PlaceHolder.PostTc Name.Name Name.Name),
                                   Data.Data.Data (PlaceHolder.PostTc Name.Name [TypeRep.Type]),
                                   Data.Data.Data (PlaceHolder.PostTc Name.Name [ConLike.ConLike]),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc Name.Name TcEvidence.HsWrapper),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc Name.Name [FieldLabel.FieldLabel])))) } in
            let {
              $dData_adTj [Occ=Once]
                :: Data.Data.Data
                     (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                      GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                      GHC.Base.Maybe HsDoc.LHsDocString)
              [LclId, Str=DmdType]
              $dData_adTj =
                Data.Data.$fData(,,,)
                  @ (HsDecls.HsGroup Name.Name)
                  @ [HsImpExp.LImportDecl Name.Name]
                  @ (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                  @ (GHC.Base.Maybe HsDoc.LHsDocString)
                  $dData_adTk
                  $dData_adTl
                  $dData_adTm
                  $dData_adTn } in
            gq_a3SR
              @ (GHC.Base.Maybe GHC.RenamedSource)
              (Data.Data.$fDataMaybe
                 @ (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                    GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                    GHC.Base.Maybe HsDoc.LHsDocString)
                 $dData_adTj)
              r_a4Wr,
            let {
              $dData_adT2 :: Data.Data.Data [ConLike.ConLike]
              [LclId, Str=DmdType]
              $dData_adT2 =
                Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
            let {
              $dData_adT1 :: Data.Data.Data [TypeRep.Type]
              [LclId, Str=DmdType]
              $dData_adT1 =
                Data.Data.$fData[] @ TypeRep.Type TypeRep.$fDataType } in
            let {
              $dData_adSW :: Data.Data.Data [Name.Name]
              [LclId, Str=DmdType]
              $dData_adSW = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
            let {
              $dData_adT9 :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
              [LclId, Str=DmdType]
              $dData_adT9 =
                FieldLabel.$fDataFieldLbl @ Name.Name Name.$fDataName } in
            let {
              $dData_adT4 :: Data.Data.Data [FieldLabel.FieldLabel]
              [LclId, Str=DmdType]
              $dData_adT4 =
                Data.Data.$fData[]
                  @ (FieldLabel.FieldLbl Name.Name) $dData_adT9 } in
            let {
              $dData_adSS :: Data.Data.Data (UniqFM.UniqFM Name.Name)
              [LclId, Str=DmdType]
              $dData_adSS = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
            let {
              $d(%,,,,,,,,,,,,,%)_adSQ
                :: (Data.Data.Data Var.Var,
                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                    Data.Data.Data TcEvidence.HsWrapper,
                    Data.Data.Data [FieldLabel.FieldLabel])
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adSQ =
                (Var.$fDataVar, $dData_adSS, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adSW, Var.$fDataVar,
                 TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                 $dData_adT1, $dData_adT2, TcEvidence.$fDataHsWrapper,
                 $dData_adT4) } in
            let {
              $dData_accn [Occ=Once]
                :: Data.Data.Data (HsBinds.HsBindLR Var.Id Var.Id)
              [LclId, Str=DmdType]
              $dData_accn =
                HsBinds.$fDataHsBindLR
                  @ Var.Var
                  @ Var.Var
                  ($d(%,,,,,,,,,,,,,%)_adSQ
                   `cast` ((<Data.Data.Data Var.Var>_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnVarty[0]
                                     <UniqFM.UniqFM Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <BasicTypes.Fixity>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data.Data.Data Var.Var,
                               Data.Data.Data (UniqFM.UniqFM Name.Name),
                               Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                               Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                               Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                               Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                               Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                               Data.Data.Data TcEvidence.HsWrapper,
                               Data.Data.Data [FieldLabel.FieldLabel])
                              ~R# (Data.Data.Data Var.Var,
                                   Data.Data.Data
                                     (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel]))))
                  ($d(%,,,,,,,,,,,,,%)_adSQ
                   `cast` ((<Data.Data.Data Var.Var>_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostRnVarty[0]
                                     <UniqFM.UniqFM Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <BasicTypes.Fixity>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Coercion.Coercion>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                            (Data.Data.Data
                               (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[ConLike.ConLike]>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0] <TcEvidence.HsWrapper>_N)))_N,
                            (Data.Data.Data
                               (Sym
                                  (PlaceHolder.TFCo:R:PostTcVarty[0]
                                     <[FieldLabel.FieldLabel]>_N)))_N)_R
                           :: (Data.Data.Data Var.Var,
                               Data.Data.Data (UniqFM.UniqFM Name.Name),
                               Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                               Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                               Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                               Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                               Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                               Data.Data.Data TcEvidence.HsWrapper,
                               Data.Data.Data [FieldLabel.FieldLabel])
                              ~R# (Data.Data.Data Var.Var,
                                   Data.Data.Data
                                     (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                   Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                   Data.Data.Data (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                   Data.Data.Data
                                     (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel])))) } in
            let {
              $dData_accl [Occ=Once]
                :: Data.Data.Data
                     (SrcLoc.GenLocated SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
              [LclId, Str=DmdType]
              $dData_accl =
                SrcLoc.$fDataGenLocated
                  @ SrcLoc.SrcSpan
                  @ (HsBinds.HsBindLR Var.Id Var.Id)
                  SrcLoc.$fDataSrcSpan
                  $dData_accn } in
            gq_a3SR
              @ GHC.TypecheckedSource
              (Bag.$fDataBag
                 @ (SrcLoc.GenLocated
                      SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                 $dData_accl)
              ts_a4Ws)
         })

Main.main :: GHC.Types.IO ()
[LclIdX, Str=DmdType]
Main.main =
  GHC.Base.>>=
    @ GHC.Types.IO
    GHC.Base.$fMonadIO
    @ [GHC.Base.String]
    @ ()
    System.Environment.getArgs
    (\ (ds_dedZ [Occ=Once!] :: [GHC.Base.String]) ->
       let {
         fail_dee1 [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
         [LclId, Str=DmdType]
         fail_dee1 =
           \ _ [Occ=Dead, OS=OneShot] ->
             GHC.Base.fail
               @ GHC.Types.IO
               GHC.Base.$fMonadIO
               @ ()
               (GHC.CString.unpackCString#
                  "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
       case ds_dedZ of _ [Occ=Dead] {
         __DEFAULT -> fail_dee1 GHC.Prim.void#;
         : libdir_a3SO ds_dee0 [Occ=Once!] ->
           case ds_dee0 of _ [Occ=Dead] {
             __DEFAULT -> fail_dee1 GHC.Prim.void#;
             [] ->
               GHC.Base.>>
                 @ GHC.Types.IO
                 GHC.Base.$fMonadIO
                 @ ()
                 @ ()
                 (Main.testOneFile
                    libdir_a3SO (GHC.CString.unpackCString# "MineFixity"#))
                 (GHC.Base.>>
                    @ GHC.Types.IO
                    GHC.Base.$fMonadIO
                    @ ()
                    @ ()
                    (Main.testOneFile
                       libdir_a3SO (GHC.CString.unpackCString# "MineKind"#))
                    (GHC.Base.>>
                       @ GHC.Types.IO
                       GHC.Base.$fMonadIO
                       @ ()
                       @ ()
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineNames"#))
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineType"#))))
           }
       })

:Main.main :: GHC.Types.IO ()
[LclIdX, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main




==================== Occurrence analysis ====================
a_seea :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
a_seea = GHC.Types.TrNameS "main"#

a_seeb :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
a_seeb = GHC.Types.TrNameS "Main"#

Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId],
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module a_seea a_seeb

Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 60 0] 80 0}]
Main.mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v [Occ=Once]
       :: Data.Typeable.Internal.Typeable a_a4Yh)
    ($dTypeable_a56w [Occ=Once]
       :: Data.Typeable.Internal.Typeable b_a4Yi)
    (r_a4Ww [Occ=Once] :: r_a4Yj)
    (br_a4Wx [Occ=Once!] :: b_a4Yi -> r_a4Yj)
    (a_a4Wy [Occ=Once] :: a_a4Yh) ->
    case Data.Typeable.cast
           @ a_a4Yh @ b_a4Yi $dTypeable_a56v $dTypeable_a56w a_a4Wy
    of _ [Occ=Dead] {
      GHC.Base.Nothing -> r_a4Ww;
      GHC.Base.Just b_a4WM [Occ=Once] -> br_a4Wx b_a4WM
    }

Rec {
Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[LclIdX,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 30 0] 170 0}]
Main.everything =
  \ (@ r_a4XV)
    (dk_aecm :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk_aecn :: Main.GenericQ r_a4XV)
    (@ a_a55z)
    ($dData_a55A :: Data.Data.Data a_a55z)
    (x_a4WP :: a_a55z) ->
    Data.Foldable.foldl
      @ []
      Data.Foldable.$fFoldable[]
      @ r_a4XV
      @ r_a4XV
      dk_aecm
      (dk_aecn @ a_a55z $dData_a55A x_a4WP)
      (Data.Data.gmapQ
         @ a_a55z
         $dData_a55A
         @ r_a4XV
         (\ (@ d_a56e) ($dData_a56f [Occ=Once] :: Data.Data.Data d_a56e) ->
            Main.everything @ r_a4XV dk_aecm dk_aecn @ d_a56e $dData_a56f)
         x_a4WP)
end Rec }

$dShow_ae3q [Occ=OnceL]
  :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 40 0}]
$dShow_ae3q =
  GHC.Show.$fShow(,,)
    @ GHC.Types.Int
    @ GHC.Types.Int
    @ GHC.Types.Int
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt

Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
Main.testOneFile =
  \ (libdir_a3SP [Occ=Once] :: GHC.IO.FilePath)
    (fileName_a3SQ [Occ=OnceL] :: GHC.Base.String) ->
    let {
      gq_a3SR
        :: forall a_a5bd. Data.Data.Data a_a5bd => a_a5bd -> GHC.Types.Int
      [LclId,
       Arity=2,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
               WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 290 0}]
      gq_a3SR =
        \ (@ a_a5bd)
          ($dData_a6PB [Occ=Once] :: Data.Data.Data a_a5bd)
          (ast_a3ST [Occ=Once] :: a_a5bd) ->
          Data.Foldable.length
            @ []
            Data.Foldable.$fFoldable[]
            @ SrcLoc.SrcSpan
            (Main.everything
               @ [SrcLoc.SrcSpan]
               (GHC.Base.++ @ SrcLoc.SrcSpan)
               (\ (@ a_a5bk) ($dData_a5bl :: Data.Data.Data a_a5bk) ->
                  let {
                    $dTypeable_a56v [Occ=OnceL]
                      :: Data.Typeable.Internal.Typeable a_a5bk
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
                    $dTypeable_a56v = Data.Data.$p1Data @ a_a5bk $dData_a5bl } in
                  let {
                    ds_dedF [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
                    ds_dedF =
                      Data.Typeable.Internal.mkPolyTyConApp
                        SrcLoc.$tcSrcSpan
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } in
                  let {
                    a_seeg [Occ=OnceL]
                      :: GHC.Prim.Proxy# SrcLoc.SrcSpan -> Data.Typeable.Internal.TypeRep
                    [LclId,
                     Arity=1,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                             WorkFree=True, Expandable=True,
                             Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
                    a_seeg = \ _ [Occ=Dead] -> ds_dedF } in
                  \ (a_a4Wy [Occ=Once] :: a_a5bk) ->
                    case Data.Typeable.cast
                           @ a_a5bk
                           @ SrcLoc.SrcSpan
                           $dTypeable_a56v
                           (a_seeg
                            `cast` (Sym
                                      (Data.Typeable.Internal.NTCo:Typeable[0]
                                         <*>_N <SrcLoc.SrcSpan>_N)
                                    :: (GHC.Prim.Proxy# SrcLoc.SrcSpan
                                        -> Data.Typeable.Internal.TypeRep)
                                       ~R# Data.Typeable.Internal.Typeable SrcLoc.SrcSpan))
                           a_a4Wy
                    of _ [Occ=Dead] {
                      GHC.Base.Nothing -> GHC.Types.[] @ SrcLoc.SrcSpan;
                      GHC.Base.Just b_a4WM [Occ=Once!] ->
                        case b_a4WM of wild_XT {
                          SrcLoc.RealSrcSpan _ [Occ=Dead] ->
                            GHC.Types.:
                              @ SrcLoc.SrcSpan wild_XT (GHC.Types.[] @ SrcLoc.SrcSpan);
                          SrcLoc.UnhelpfulSpan _ [Occ=Dead] -> GHC.Types.[] @ SrcLoc.SrcSpan
                        }
                    })
               @ a_a5bd
               $dData_a6PB
               ast_a3ST) } in
    GHC.Base.>>=
      @ GHC.Types.IO
      GHC.Base.$fMonadIO
      @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
         GHC.TypecheckedSource)
      @ ()
      (GHC.runGhc
         @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
            GHC.TypecheckedSource)
         (GHC.Base.Just @ GHC.IO.FilePath libdir_a3SP)
         (GHC.Base.>>=
            @ GhcMonad.Ghc
            GhcMonad.$fMonadGhc
            @ DynFlags.DynFlags
            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource)
            (GhcMonad.getSessionDynFlags @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc)
            (\ (dflags_a4fE [Occ=Once] :: DynFlags.DynFlags) ->
               GHC.Base.>>
                 @ GhcMonad.Ghc
                 GhcMonad.$fMonadGhc
                 @ [Module.UnitId]
                 @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                    GHC.TypecheckedSource)
                 (GHC.setSessionDynFlags
                    @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc dflags_a4fE)
                 (let {
                    mn_a4fF :: Module.ModuleName
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
                    mn_a4fF = Module.mkModuleName fileName_a3SQ } in
                  GHC.Base.>>
                    @ GhcMonad.Ghc
                    GhcMonad.$fMonadGhc
                    @ ()
                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                       GHC.TypecheckedSource)
                    (GHC.addTarget
                       @ GhcMonad.Ghc
                       GhcMonad.$fGhcMonadGhc
                       (HscTypes.Target
                          (HscTypes.TargetModule mn_a4fF)
                          GHC.Types.True
                          (GHC.Base.Nothing
                             @ (StringBuffer.StringBuffer, Data.Time.Clock.UTC.UTCTime))))
                    (GHC.Base.>>
                       @ GhcMonad.Ghc
                       GhcMonad.$fMonadGhc
                       @ BasicTypes.SuccessFlag
                       @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                          GHC.TypecheckedSource)
                       (GhcMake.load
                          @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets)
                       (GHC.Base.>>=
                          @ GhcMonad.Ghc
                          GhcMonad.$fMonadGhc
                          @ HscTypes.ModSummary
                          @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                             GHC.TypecheckedSource)
                          (GHC.getModSummary @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc mn_a4fF)
                          (\ (modSum_a4Wj [Occ=Once] :: HscTypes.ModSummary) ->
                             GHC.Base.>>=
                               @ GhcMonad.Ghc
                               GhcMonad.$fMonadGhc
                               @ GHC.ParsedModule
                               @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                  GHC.TypecheckedSource)
                               (GHC.parseModule @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc modSum_a4Wj)
                               (\ (p_a4Wk :: GHC.ParsedModule) ->
                                  GHC.Base.>>=
                                    @ GhcMonad.Ghc
                                    GhcMonad.$fMonadGhc
                                    @ GHC.TypecheckedModule
                                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                       GHC.TypecheckedSource)
                                    (GHC.typecheckModule
                                       @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc p_a4Wk)
                                    (\ (t_a4Wl [Occ=Once] :: GHC.TypecheckedModule) ->
                                       GHC.Base.>>=
                                         @ GhcMonad.Ghc
                                         GhcMonad.$fMonadGhc
                                         @ GHC.DesugaredModule
                                         @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                            GHC.TypecheckedSource)
                                         (GHC.desugarModule
                                            @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc t_a4Wl)
                                         (\ (d_a4Wm [Occ=Once] :: GHC.DesugaredModule) ->
                                            GHC.Base.>>=
                                              @ GhcMonad.Ghc
                                              GhcMonad.$fMonadGhc
                                              @ GHC.DesugaredModule
                                              @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                 GHC.TypecheckedSource)
                                              (GHC.loadModule
                                                 @ GHC.DesugaredModule
                                                 @ GhcMonad.Ghc
                                                 GHC.$fTypecheckedModDesugaredModule
                                                 GhcMonad.$fGhcMonadGhc
                                                 d_a4Wm)
                                              (\ (l_a4Wn :: GHC.DesugaredModule) ->
                                                 GHC.Base.return
                                                   @ GhcMonad.Ghc
                                                   GhcMonad.$fMonadGhc
                                                   @ (GHC.ParsedSource,
                                                      GHC.Base.Maybe GHC.RenamedSource,
                                                      GHC.TypecheckedSource)
                                                   (GHC.pm_parsed_source p_a4Wk,
                                                    GHC.renamedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn,
                                                    GHC.typecheckedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn))))))))))))
      (\ (ds_dedD [Occ=Once!]
            :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                GHC.TypecheckedSource)) ->
         case ds_dedD
         of _ [Occ=Dead]
         { (p_a4Wq [Occ=Once], r_a4Wr [Occ=Once], ts_a4Ws [Occ=Once]) ->
         System.IO.print
           @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
           $dShow_ae3q
           (gq_a3SR
              @ GHC.ParsedSource
              (SrcLoc.$fDataGenLocated
                 @ SrcLoc.SrcSpan
                 @ (HsSyn.HsModule RdrName.RdrName)
                 SrcLoc.$fDataSrcSpan
                 (HsSyn.$fDataHsModule
                    @ RdrName.RdrName
                    ((RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder)
                     `cast` ((<Data.Data.Data RdrName.RdrName>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data RdrName.RdrName,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder)
                                ~R# (Data.Data.Data RdrName.RdrName,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn
                                          RdrName.RdrName (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName BasicTypes.Fixity),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn RdrName.RdrName Name.Name),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName [Name.Name]),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TypeRep.Type),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName Coercion.Coercion),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [TypeRep.Type]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc
                                          RdrName.RdrName [FieldLabel.FieldLabel]))))))
              p_a4Wq,
            gq_a3SR
              @ (GHC.Base.Maybe GHC.RenamedSource)
              (Data.Data.$fDataMaybe
                 @ (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                    GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                    GHC.Base.Maybe HsDoc.LHsDocString)
                 (Data.Data.$fData(,,,)
                    @ (HsDecls.HsGroup Name.Name)
                    @ [HsImpExp.LImportDecl Name.Name]
                    @ (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                    @ (GHC.Base.Maybe HsDoc.LHsDocString)
                    (HsDecls.$fDataHsGroup
                       @ Name.Name
                       ((Name.$fDataName, UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName,
                         BasicTypes.$fDataFixity, Data.Data.$fDataBool, Name.$fDataName,
                         Data.Data.$fData[] @ Name.Name Name.$fDataName, Name.$fDataName,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder)
                        `cast` ((<Data.Data.Data Name.Name>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Name.Name,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Name.Name,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder)
                                   ~R# (Data.Data.Data Name.Name,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name BasicTypes.Fixity),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                        Data.Data.Data (PlaceHolder.PostTc Name.Name TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Name.Name Name.Name),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [FieldLabel.FieldLabel])))))
                    (Data.Data.$fData[]
                       @ (SrcLoc.GenLocated
                            SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                       (SrcLoc.$fDataGenLocated
                          @ SrcLoc.SrcSpan
                          @ (HsImpExp.ImportDecl Name.Name)
                          SrcLoc.$fDataSrcSpan
                          (HsImpExp.$fDataImportDecl @ Name.Name Name.$fDataName)))
                    (Data.Data.$fDataMaybe
                       @ [HsImpExp.LIE Name.Name]
                       (Data.Data.$fData[]
                          @ (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                          (SrcLoc.$fDataGenLocated
                             @ SrcLoc.SrcSpan
                             @ (HsImpExp.IE Name.Name)
                             SrcLoc.$fDataSrcSpan
                             (HsImpExp.$fDataIE @ Name.Name Name.$fDataName))))
                    (Data.Data.$fDataMaybe
                       @ (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                       (SrcLoc.$fDataGenLocated
                          @ SrcLoc.SrcSpan
                          @ HsDoc.HsDocString
                          SrcLoc.$fDataSrcSpan
                          HsDoc.$fDataHsDocString))))
              r_a4Wr,
            let {
              $dData_adT2 :: Data.Data.Data [ConLike.ConLike]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT2 =
                Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
            let {
              $dData_adT1 :: Data.Data.Data [TypeRep.Type]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT1 =
                Data.Data.$fData[] @ TypeRep.Type TypeRep.$fDataType } in
            let {
              $dData_adSW :: Data.Data.Data [Name.Name]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adSW = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
            let {
              $dData_adT9 :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT9 =
                FieldLabel.$fDataFieldLbl @ Name.Name Name.$fDataName } in
            let {
              $dData_adT4 :: Data.Data.Data [FieldLabel.FieldLabel]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT4 =
                Data.Data.$fData[]
                  @ (FieldLabel.FieldLbl Name.Name) $dData_adT9 } in
            let {
              $dData_adSS :: Data.Data.Data (UniqFM.UniqFM Name.Name)
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adSS = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
            let {
              $d(%,,,,,,,,,,,,,%)_adSQ
                :: (Data.Data.Data Var.Var,
                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                    Data.Data.Data TcEvidence.HsWrapper,
                    Data.Data.Data [FieldLabel.FieldLabel])
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                       WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 150}]
              $d(%,,,,,,,,,,,,,%)_adSQ =
                (Var.$fDataVar, $dData_adSS, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adSW, Var.$fDataVar,
                 TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                 $dData_adT1, $dData_adT2, TcEvidence.$fDataHsWrapper,
                 $dData_adT4) } in
            gq_a3SR
              @ GHC.TypecheckedSource
              (Bag.$fDataBag
                 @ (SrcLoc.GenLocated
                      SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                 (SrcLoc.$fDataGenLocated
                    @ SrcLoc.SrcSpan
                    @ (HsBinds.HsBindLR Var.Id Var.Id)
                    SrcLoc.$fDataSrcSpan
                    (HsBinds.$fDataHsBindLR
                       @ Var.Var
                       @ Var.Var
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data.Data.Data Var.Var>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Var.Var,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                    Data.Data.Data TcEvidence.HsWrapper,
                                    Data.Data.Data [FieldLabel.FieldLabel])
                                   ~R# (Data.Data.Data Var.Var,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel]))))
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data.Data.Data Var.Var>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Var.Var,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                    Data.Data.Data TcEvidence.HsWrapper,
                                    Data.Data.Data [FieldLabel.FieldLabel])
                                   ~R# (Data.Data.Data Var.Var,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel])))))))
              ts_a4Ws)
         })

Main.main :: GHC.Types.IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
Main.main =
  GHC.Base.>>=
    @ GHC.Types.IO
    GHC.Base.$fMonadIO
    @ [GHC.Base.String]
    @ ()
    System.Environment.getArgs
    (\ (ds_dedZ [Occ=Once!] :: [GHC.Base.String]) ->
       let {
         fail_dee1 [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
         [LclId,
          Arity=1,
          Str=DmdType,
          Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                  WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 220 0}]
         fail_dee1 =
           \ _ [Occ=Dead, OS=OneShot] ->
             GHC.Base.fail
               @ GHC.Types.IO
               GHC.Base.$fMonadIO
               @ ()
               (GHC.CString.unpackCString#
                  "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
       case ds_dedZ of _ [Occ=Dead] {
         [] -> fail_dee1 GHC.Prim.void#;
         : libdir_a3SO ds_dee0 [Occ=Once!] ->
           case ds_dee0 of _ [Occ=Dead] {
             [] ->
               GHC.Base.>>
                 @ GHC.Types.IO
                 GHC.Base.$fMonadIO
                 @ ()
                 @ ()
                 (Main.testOneFile
                    libdir_a3SO (GHC.CString.unpackCString# "MineFixity"#))
                 (GHC.Base.>>
                    @ GHC.Types.IO
                    GHC.Base.$fMonadIO
                    @ ()
                    @ ()
                    (Main.testOneFile
                       libdir_a3SO (GHC.CString.unpackCString# "MineKind"#))
                    (GHC.Base.>>
                       @ GHC.Types.IO
                       GHC.Base.$fMonadIO
                       @ ()
                       @ ()
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineNames"#))
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineType"#))));
             : _ [Occ=Dead] _ [Occ=Dead] -> fail_dee1 GHC.Prim.void#
           }
       })

:Main.main :: GHC.Types.IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main




==================== Occurrence analysis ====================
a_seea :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
a_seea = GHC.Types.TrNameS "main"#

a_seeb :: GHC.Types.TrName
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 30 20}]
a_seeb = GHC.Types.TrNameS "Main"#

Main.$trModule :: GHC.Types.Module
[LclIdX[ReflectionId],
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 30}]
Main.$trModule = GHC.Types.Module a_seea a_seeb

Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[LclIdX,
 Arity=5,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 0 0 60 0] 80 0}]
Main.mkQ =
  \ (@ a_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v [Occ=Once]
       :: Data.Typeable.Internal.Typeable a_a4Yh)
    ($dTypeable_a56w [Occ=Once]
       :: Data.Typeable.Internal.Typeable b_a4Yi)
    (r_a4Ww [Occ=Once] :: r_a4Yj)
    (br_a4Wx [Occ=Once!] :: b_a4Yi -> r_a4Yj)
    (a_a4Wy [Occ=Once] :: a_a4Yh) ->
    case Data.Typeable.cast
           @ a_a4Yh @ b_a4Yi $dTypeable_a56v $dTypeable_a56w a_a4Wy
    of _ [Occ=Dead] {
      GHC.Base.Nothing -> r_a4Ww;
      GHC.Base.Just b_a4WM [Occ=Once] -> br_a4Wx b_a4WM
    }

Rec {
Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[LclIdX,
 Arity=4,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True,
         Guidance=IF_ARGS [0 60 30 0] 190 0}]
Main.everything =
  \ (@ r_a4XV)
    (dk_aecm :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk_aecn :: Main.GenericQ r_a4XV)
    (@ a_a55z)
    ($dData_a55A :: Data.Data.Data a_a55z)
    (x_a4WP :: a_a55z) ->
    Data.Foldable.foldl
      @ []
      Data.Foldable.$fFoldable[]
      @ r_a4XV
      @ r_a4XV
      dk_aecm
      (dk_aecn @ a_a55z $dData_a55A x_a4WP)
      (Data.Data.gmapQ
         @ a_a55z
         $dData_a55A
         @ r_a4XV
         (\ (@ d_a56e)
            ($dData_a56f [Occ=Once] :: Data.Data.Data d_a56e)
            (eta_B1 [Occ=Once] :: d_a56e) ->
            Main.everything
              @ r_a4XV dk_aecm dk_aecn @ d_a56e $dData_a56f eta_B1)
         x_a4WP)
end Rec }

$dShow_ae3q [Occ=OnceL]
  :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
[LclId,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 40 0}]
$dShow_ae3q =
  GHC.Show.$fShow(,,)
    @ GHC.Types.Int
    @ GHC.Types.Int
    @ GHC.Types.Int
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt

Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[LclIdX,
 Arity=2,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=True, ConLike=True,
         WorkFree=True, Expandable=True, Guidance=NEVER}]
Main.testOneFile =
  \ (libdir_a3SP [Occ=Once] :: GHC.IO.FilePath)
    (fileName_a3SQ [Occ=OnceL] :: GHC.Base.String) ->
    let {
      gq_a3SR
        :: forall a_a5bd. Data.Data.Data a_a5bd => a_a5bd -> GHC.Types.Int
      [LclId,
       Arity=2,
       Str=DmdType,
       Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
               WorkFree=True, Expandable=True, Guidance=IF_ARGS [0 0] 290 0}]
      gq_a3SR =
        \ (@ a_a5bd)
          ($dData_a6PB [Occ=Once] :: Data.Data.Data a_a5bd)
          (ast_a3ST [Occ=Once] :: a_a5bd) ->
          Data.Foldable.length
            @ []
            Data.Foldable.$fFoldable[]
            @ SrcLoc.SrcSpan
            (Main.everything
               @ [SrcLoc.SrcSpan]
               (GHC.Base.++ @ SrcLoc.SrcSpan)
               (\ (@ a_a5bk) ($dData_a5bl :: Data.Data.Data a_a5bk) ->
                  let {
                    $dTypeable_a56v [Occ=OnceL]
                      :: Data.Typeable.Internal.Typeable a_a5bk
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
                    $dTypeable_a56v = Data.Data.$p1Data @ a_a5bk $dData_a5bl } in
                  let {
                    ds_dedF [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 40 0}]
                    ds_dedF =
                      Data.Typeable.Internal.mkPolyTyConApp
                        SrcLoc.$tcSrcSpan
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                        (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } in
                  let {
                    a_seeg [Occ=OnceL]
                      :: GHC.Prim.Proxy# SrcLoc.SrcSpan -> Data.Typeable.Internal.TypeRep
                    [LclId,
                     Arity=1,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                             WorkFree=True, Expandable=True,
                             Guidance=ALWAYS_IF(arity=1,unsat_ok=True,boring_ok=True)}]
                    a_seeg = \ _ [Occ=Dead] -> ds_dedF } in
                  \ (a_a4Wy [Occ=Once] :: a_a5bk) ->
                    case Data.Typeable.cast
                           @ a_a5bk
                           @ SrcLoc.SrcSpan
                           $dTypeable_a56v
                           (a_seeg
                            `cast` (Sym
                                      (Data.Typeable.Internal.NTCo:Typeable[0]
                                         <*>_N <SrcLoc.SrcSpan>_N)
                                    :: (GHC.Prim.Proxy# SrcLoc.SrcSpan
                                        -> Data.Typeable.Internal.TypeRep)
                                       ~R# Data.Typeable.Internal.Typeable SrcLoc.SrcSpan))
                           a_a4Wy
                    of _ [Occ=Dead] {
                      GHC.Base.Nothing -> GHC.Types.[] @ SrcLoc.SrcSpan;
                      GHC.Base.Just b_a4WM [Occ=Once!] ->
                        case b_a4WM of wild_XT {
                          SrcLoc.RealSrcSpan _ [Occ=Dead] ->
                            GHC.Types.:
                              @ SrcLoc.SrcSpan wild_XT (GHC.Types.[] @ SrcLoc.SrcSpan);
                          SrcLoc.UnhelpfulSpan _ [Occ=Dead] -> GHC.Types.[] @ SrcLoc.SrcSpan
                        }
                    })
               @ a_a5bd
               $dData_a6PB
               ast_a3ST) } in
    GHC.Base.>>=
      @ GHC.Types.IO
      GHC.Base.$fMonadIO
      @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
         GHC.TypecheckedSource)
      @ ()
      (GHC.runGhc
         @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
            GHC.TypecheckedSource)
         (GHC.Base.Just @ GHC.IO.FilePath libdir_a3SP)
         (GHC.Base.>>=
            @ GhcMonad.Ghc
            GhcMonad.$fMonadGhc
            @ DynFlags.DynFlags
            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
               GHC.TypecheckedSource)
            (GhcMonad.getSessionDynFlags @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc)
            (\ (dflags_a4fE [Occ=Once] :: DynFlags.DynFlags) ->
               GHC.Base.>>
                 @ GhcMonad.Ghc
                 GhcMonad.$fMonadGhc
                 @ [Module.UnitId]
                 @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                    GHC.TypecheckedSource)
                 (GHC.setSessionDynFlags
                    @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc dflags_a4fE)
                 (let {
                    mn_a4fF :: Module.ModuleName
                    [LclId,
                     Str=DmdType,
                     Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                             WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
                    mn_a4fF = Module.mkModuleName fileName_a3SQ } in
                  GHC.Base.>>
                    @ GhcMonad.Ghc
                    GhcMonad.$fMonadGhc
                    @ ()
                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                       GHC.TypecheckedSource)
                    (GHC.addTarget
                       @ GhcMonad.Ghc
                       GhcMonad.$fGhcMonadGhc
                       (HscTypes.Target
                          (HscTypes.TargetModule mn_a4fF)
                          GHC.Types.True
                          (GHC.Base.Nothing
                             @ (StringBuffer.StringBuffer, Data.Time.Clock.UTC.UTCTime))))
                    (GHC.Base.>>
                       @ GhcMonad.Ghc
                       GhcMonad.$fMonadGhc
                       @ BasicTypes.SuccessFlag
                       @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                          GHC.TypecheckedSource)
                       (GhcMake.load
                          @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets)
                       (GHC.Base.>>=
                          @ GhcMonad.Ghc
                          GhcMonad.$fMonadGhc
                          @ HscTypes.ModSummary
                          @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                             GHC.TypecheckedSource)
                          (GHC.getModSummary @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc mn_a4fF)
                          (\ (modSum_a4Wj [Occ=Once] :: HscTypes.ModSummary) ->
                             GHC.Base.>>=
                               @ GhcMonad.Ghc
                               GhcMonad.$fMonadGhc
                               @ GHC.ParsedModule
                               @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                  GHC.TypecheckedSource)
                               (GHC.parseModule @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc modSum_a4Wj)
                               (\ (p_a4Wk :: GHC.ParsedModule) ->
                                  GHC.Base.>>=
                                    @ GhcMonad.Ghc
                                    GhcMonad.$fMonadGhc
                                    @ GHC.TypecheckedModule
                                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                       GHC.TypecheckedSource)
                                    (GHC.typecheckModule
                                       @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc p_a4Wk)
                                    (\ (t_a4Wl [Occ=Once] :: GHC.TypecheckedModule) ->
                                       GHC.Base.>>=
                                         @ GhcMonad.Ghc
                                         GhcMonad.$fMonadGhc
                                         @ GHC.DesugaredModule
                                         @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                            GHC.TypecheckedSource)
                                         (GHC.desugarModule
                                            @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc t_a4Wl)
                                         (\ (d_a4Wm [Occ=Once] :: GHC.DesugaredModule) ->
                                            GHC.Base.>>=
                                              @ GhcMonad.Ghc
                                              GhcMonad.$fMonadGhc
                                              @ GHC.DesugaredModule
                                              @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                 GHC.TypecheckedSource)
                                              (GHC.loadModule
                                                 @ GHC.DesugaredModule
                                                 @ GhcMonad.Ghc
                                                 GHC.$fTypecheckedModDesugaredModule
                                                 GhcMonad.$fGhcMonadGhc
                                                 d_a4Wm)
                                              (\ (l_a4Wn :: GHC.DesugaredModule) ->
                                                 GHC.Base.return
                                                   @ GhcMonad.Ghc
                                                   GhcMonad.$fMonadGhc
                                                   @ (GHC.ParsedSource,
                                                      GHC.Base.Maybe GHC.RenamedSource,
                                                      GHC.TypecheckedSource)
                                                   (GHC.pm_parsed_source p_a4Wk,
                                                    GHC.renamedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn,
                                                    GHC.typecheckedSource
                                                      @ GHC.DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn))))))))))))
      (\ (ds_dedD [Occ=Once!]
            :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                GHC.TypecheckedSource)) ->
         case ds_dedD
         of _ [Occ=Dead]
         { (p_a4Wq [Occ=Once], r_a4Wr [Occ=Once], ts_a4Ws [Occ=Once]) ->
         System.IO.print
           @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
           $dShow_ae3q
           (gq_a3SR
              @ GHC.ParsedSource
              (SrcLoc.$fDataGenLocated
                 @ SrcLoc.SrcSpan
                 @ (HsSyn.HsModule RdrName.RdrName)
                 SrcLoc.$fDataSrcSpan
                 (HsSyn.$fDataHsModule
                    @ RdrName.RdrName
                    ((RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder)
                     `cast` ((<Data.Data.Data RdrName.RdrName>_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <UniqFM.UniqFM Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <BasicTypes.Fixity>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Types.Bool>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name.Name>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name.Name]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <TypeRep.Type>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <Coercion.Coercion>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName.RdrName>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[TypeRep.Type]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[ConLike.ConLike]>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data.Data.Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data.Data.Data RdrName.RdrName,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder,
                                 Data.Data.Data PlaceHolder.PlaceHolder)
                                ~R# (Data.Data.Data RdrName.RdrName,
                                     Data.Data.Data
                                       (PlaceHolder.PostRn
                                          RdrName.RdrName (UniqFM.UniqFM Name.Name)),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName BasicTypes.Fixity),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName GHC.Types.Bool),
                                     Data.Data.Data (PlaceHolder.PostRn RdrName.RdrName Name.Name),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName [Name.Name]),
                                     Data.Data.Data
                                       (PlaceHolder.PostRn RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TypeRep.Type),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName Coercion.Coercion),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName RdrName.RdrName),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [TypeRep.Type]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName [ConLike.ConLike]),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc RdrName.RdrName TcEvidence.HsWrapper),
                                     Data.Data.Data
                                       (PlaceHolder.PostTc
                                          RdrName.RdrName [FieldLabel.FieldLabel]))))))
              p_a4Wq,
            gq_a3SR
              @ (GHC.Base.Maybe GHC.RenamedSource)
              (Data.Data.$fDataMaybe
                 @ (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                    GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                    GHC.Base.Maybe HsDoc.LHsDocString)
                 (Data.Data.$fData(,,,)
                    @ (HsDecls.HsGroup Name.Name)
                    @ [HsImpExp.LImportDecl Name.Name]
                    @ (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                    @ (GHC.Base.Maybe HsDoc.LHsDocString)
                    (HsDecls.$fDataHsGroup
                       @ Name.Name
                       ((Name.$fDataName, UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName,
                         BasicTypes.$fDataFixity, Data.Data.$fDataBool, Name.$fDataName,
                         Data.Data.$fData[] @ Name.Name Name.$fDataName, Name.$fDataName,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder)
                        `cast` ((<Data.Data.Data Name.Name>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Name.Name,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Name.Name,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder,
                                    Data.Data.Data PlaceHolder.PlaceHolder)
                                   ~R# (Data.Data.Data Name.Name,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name BasicTypes.Fixity),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Name.Name GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Name.Name Name.Name),
                                        Data.Data.Data (PlaceHolder.PostTc Name.Name TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Name.Name Name.Name),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Name.Name [FieldLabel.FieldLabel])))))
                    (Data.Data.$fData[]
                       @ (SrcLoc.GenLocated
                            SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                       (SrcLoc.$fDataGenLocated
                          @ SrcLoc.SrcSpan
                          @ (HsImpExp.ImportDecl Name.Name)
                          SrcLoc.$fDataSrcSpan
                          (HsImpExp.$fDataImportDecl @ Name.Name Name.$fDataName)))
                    (Data.Data.$fDataMaybe
                       @ [HsImpExp.LIE Name.Name]
                       (Data.Data.$fData[]
                          @ (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                          (SrcLoc.$fDataGenLocated
                             @ SrcLoc.SrcSpan
                             @ (HsImpExp.IE Name.Name)
                             SrcLoc.$fDataSrcSpan
                             (HsImpExp.$fDataIE @ Name.Name Name.$fDataName))))
                    (Data.Data.$fDataMaybe
                       @ (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                       (SrcLoc.$fDataGenLocated
                          @ SrcLoc.SrcSpan
                          @ HsDoc.HsDocString
                          SrcLoc.$fDataSrcSpan
                          HsDoc.$fDataHsDocString))))
              r_a4Wr,
            let {
              $dData_adT2 :: Data.Data.Data [ConLike.ConLike]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT2 =
                Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
            let {
              $dData_adT1 :: Data.Data.Data [TypeRep.Type]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT1 =
                Data.Data.$fData[] @ TypeRep.Type TypeRep.$fDataType } in
            let {
              $dData_adSW :: Data.Data.Data [Name.Name]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adSW = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
            let {
              $dData_adT9 :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT9 =
                FieldLabel.$fDataFieldLbl @ Name.Name Name.$fDataName } in
            let {
              $dData_adT4 :: Data.Data.Data [FieldLabel.FieldLabel]
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adT4 =
                Data.Data.$fData[]
                  @ (FieldLabel.FieldLbl Name.Name) $dData_adT9 } in
            let {
              $dData_adSS :: Data.Data.Data (UniqFM.UniqFM Name.Name)
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=False, ConLike=False,
                       WorkFree=False, Expandable=True, Guidance=IF_ARGS [] 20 0}]
              $dData_adSS = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
            let {
              $d(%,,,,,,,,,,,,,%)_adSQ
                :: (Data.Data.Data Var.Var,
                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                    Data.Data.Data TcEvidence.HsWrapper,
                    Data.Data.Data [FieldLabel.FieldLabel])
              [LclId,
               Str=DmdType,
               Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                       WorkFree=True, Expandable=True, Guidance=IF_ARGS [] 10 150}]
              $d(%,,,,,,,,,,,,,%)_adSQ =
                (Var.$fDataVar, $dData_adSS, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData_adSW, Var.$fDataVar,
                 TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                 $dData_adT1, $dData_adT2, TcEvidence.$fDataHsWrapper,
                 $dData_adT4) } in
            gq_a3SR
              @ GHC.TypecheckedSource
              (Bag.$fDataBag
                 @ (SrcLoc.GenLocated
                      SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                 (SrcLoc.$fDataGenLocated
                    @ SrcLoc.SrcSpan
                    @ (HsBinds.HsBindLR Var.Id Var.Id)
                    SrcLoc.$fDataSrcSpan
                    (HsBinds.$fDataHsBindLR
                       @ Var.Var
                       @ Var.Var
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data.Data.Data Var.Var>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Var.Var,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                    Data.Data.Data TcEvidence.HsWrapper,
                                    Data.Data.Data [FieldLabel.FieldLabel])
                                   ~R# (Data.Data.Data Var.Var,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel]))))
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data.Data.Data Var.Var>_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <BasicTypes.Fixity>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Types.Bool>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <TypeRep.Type>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data.Data.Data
                                    (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[TypeRep.Type]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data.Data.Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data.Data.Data Var.Var,
                                    Data.Data.Data (UniqFM.UniqFM Name.Name),
                                    Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                                    Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                                    Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                                    Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                    Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                                    Data.Data.Data TcEvidence.HsWrapper,
                                    Data.Data.Data [FieldLabel.FieldLabel])
                                   ~R# (Data.Data.Data Var.Var,
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id (UniqFM.UniqFM Name.Name)),
                                        Data.Data.Data
                                          (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                        Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                        Data.Data.Data (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                        Data.Data.Data
                                          (PlaceHolder.PostTc Var.Id [FieldLabel.FieldLabel])))))))
              ts_a4Ws)
         })

Main.main :: GHC.Types.IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=NEVER}]
Main.main =
  GHC.Base.>>=
    @ GHC.Types.IO
    GHC.Base.$fMonadIO
    @ [GHC.Base.String]
    @ ()
    System.Environment.getArgs
    (\ (ds_dedZ [Occ=Once!] :: [GHC.Base.String]) ->
       let {
         fail_dee1 [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
         [LclId,
          Arity=1,
          Str=DmdType,
          Unf=Unf{Src=<vanilla>, TopLvl=False, Value=True, ConLike=True,
                  WorkFree=True, Expandable=True, Guidance=IF_ARGS [0] 220 0}]
         fail_dee1 =
           \ _ [Occ=Dead, OS=OneShot] ->
             GHC.Base.fail
               @ GHC.Types.IO
               GHC.Base.$fMonadIO
               @ ()
               (GHC.CString.unpackCString#
                  "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
       case ds_dedZ of _ [Occ=Dead] {
         [] -> fail_dee1 GHC.Prim.void#;
         : libdir_a3SO ds_dee0 [Occ=Once!] ->
           case ds_dee0 of _ [Occ=Dead] {
             [] ->
               GHC.Base.>>
                 @ GHC.Types.IO
                 GHC.Base.$fMonadIO
                 @ ()
                 @ ()
                 (Main.testOneFile
                    libdir_a3SO (GHC.CString.unpackCString# "MineFixity"#))
                 (GHC.Base.>>
                    @ GHC.Types.IO
                    GHC.Base.$fMonadIO
                    @ ()
                    @ ()
                    (Main.testOneFile
                       libdir_a3SO (GHC.CString.unpackCString# "MineKind"#))
                    (GHC.Base.>>
                       @ GHC.Types.IO
                       GHC.Base.$fMonadIO
                       @ ()
                       @ ()
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineNames"#))
                       (Main.testOneFile
                          libdir_a3SO (GHC.CString.unpackCString# "MineType"#))));
             : _ [Occ=Dead] _ [Occ=Dead] -> fail_dee1 GHC.Prim.void#
           }
       })

:Main.main :: GHC.Types.IO ()
[LclIdX,
 Str=DmdType,
 Unf=Unf{Src=<vanilla>, TopLvl=True, Value=False, ConLike=False,
         WorkFree=False, Expandable=False, Guidance=IF_ARGS [] 20 0}]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main




==================== Grand total simplifier statistics ====================
Total ticks:     59

24 PreInlineUnconditionally
  2 tpl_B1
  2 tpl_B2
  1 s_a41A
  1 $dData_accl
  1 $dData_accn
  1 $dData_adTj
  1 $dData_adTk
  1 $dData_adTl
  1 $dData_adTm
  1 $dData_adTn
  1 $d(%,,,,,,,,,,,,,%)_adTv
  1 $dData_adTx
  1 $dData_adTB
  1 $dData_adTK
  1 $dData_adTM
  1 $dData_adTN
  1 $dData_adTO
  1 $dData_adTP
  1 $dData_adTQ
  1 $dData_adU2
  1 $d(%,,,,,,,,,,,,,%)_adU6
  1 ds_dedL
5 PostInlineUnconditionally
  1 r_a4Ww
  1 br_a4Wx
  1 k_a4WN
  1 f_a4WO
  1 $dTypeable_a56w
4 UnfoldingDone
  2 GHC.Base.$
  1 worker_a3SS
  1 Main.mkQ
3 LetFloatFromLet 3
1 EtaExpansion 1 d_a56e
19 BetaReduction
  2 a_12
  2 b_13
  2 tpl_B1
  2 tpl_B2
  1 s_a41A
  1 r_a4Ww
  1 br_a4Wx
  1 k_a4WN
  1 f_a4WO
  1 a_a4Yh
  1 b_a4Yi
  1 r_a4Yj
  1 $dTypeable_a56v
  1 $dTypeable_a56w
  1 ds_dedL
3 FillInCaseDefault
  1 wild_Xa
  1 wild_Xi
  1 wild_Xk
3 SimplifierDone 3



==================== Tidy Core ====================
Result size of Tidy Core = {terms: 329, types: 509, coercions: 244}

-- RHS size: {terms: 2, types: 0, coercions: 0}
a_redQ :: TrName
[GblId, Caf=NoCafRefs, Str=DmdType]
a_redQ = TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
a1_reeE :: TrName
[GblId, Caf=NoCafRefs, Str=DmdType]
a1_reeE = TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId[ReflectionId], Caf=NoCafRefs, Str=DmdType]
Main.$trModule = Module a_redQ a1_reeE

-- RHS size: {terms: 18, types: 18, coercions: 0}
mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Typeable a_a3PP, Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[GblId, Arity=5, Str=DmdType]
mkQ =
  \ (@ a2_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_a56v :: Typeable a2_a4Yh)
    ($dTypeable1_a56w :: Typeable b_a4Yi)
    (r1_a4Ww :: r_a4Yj)
    (br_a4Wx :: b_a4Yi -> r_a4Yj)
    (a3_a4Wy :: a2_a4Yh) ->
    case cast
           @ a2_a4Yh @ b_a4Yi $dTypeable_a56v $dTypeable1_a56w a3_a4Wy
    of _ [Occ=Dead] {
      Nothing -> r1_a4Ww;
      Just b1_a4WM -> br_a4Wx b1_a4WM
    }

Rec {
-- RHS size: {terms: 23, types: 22, coercions: 0}
everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO) -> GenericQ r_a3PO -> GenericQ r_a3PO
[GblId, Arity=4, Str=DmdType]
everything =
  \ (@ r_a4XV)
    (dk_aecm :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk1_aecn :: GenericQ r_a4XV)
    (@ a2_a55z)
    ($dData_a55A :: Data a2_a55z)
    (x_a4WP :: a2_a55z) ->
    foldl
      @ []
      Data.Foldable.$fFoldable[]
      @ r_a4XV
      @ r_a4XV
      dk_aecm
      (dk1_aecn @ a2_a55z $dData_a55A x_a4WP)
      (gmapQ
         @ a2_a55z
         $dData_a55A
         @ r_a4XV
         (\ (@ d_a56e) ($dData1_a56f :: Data d_a56e) (eta_B1 :: d_a56e) ->
            everything @ r_a4XV dk_aecm dk1_aecn @ d_a56e $dData1_a56f eta_B1)
         x_a4WP)
end Rec }

-- RHS size: {terms: 4, types: 3, coercions: 0}
$dShow_reeF :: Show (Int, Int, Int)
[GblId, Str=DmdType]
$dShow_reeF =
  GHC.Show.$fShow(,,)
    @ Int
    @ Int
    @ Int
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt

-- RHS size: {terms: 222, types: 396, coercions: 244}
testOneFile :: FilePath -> String -> IO ()
[GblId, Arity=2, Str=DmdType]
testOneFile =
  \ (libdir_a3SP :: FilePath) (fileName_a3SQ :: String) ->
    let {
      gq_a3SR :: forall a2_a5bd. Data a2_a5bd => a2_a5bd -> Int
      [LclId, Arity=2, Str=DmdType]
      gq_a3SR =
        \ (@ a2_a5bd)
          ($dData_a6PB :: Data a2_a5bd)
          (ast_a3ST :: a2_a5bd) ->
          length
            @ []
            Data.Foldable.$fFoldable[]
            @ SrcSpan
            (everything
               @ [SrcSpan]
               (++ @ SrcSpan)
               (\ (@ a3_a5bk) ($dData1_a5bl :: Data a3_a5bk) ->
                  let {
                    $dTypeable_a56v :: Typeable a3_a5bk
                    [LclId, Str=DmdType]
                    $dTypeable_a56v = Data.Data.$p1Data @ a3_a5bk $dData1_a5bl } in
                  let {
                    ds_dedF :: TypeRep
                    [LclId, Str=DmdType]
                    ds_dedF =
                      mkPolyTyConApp SrcLoc.$tcSrcSpan ([] @ TypeRep) ([] @ TypeRep) } in
                  let {
                    a4_seeg :: Proxy# SrcSpan -> TypeRep
                    [LclId, Arity=1, Str=DmdType]
                    a4_seeg = \ _ [Occ=Dead] -> ds_dedF } in
                  \ (a5_a4Wy :: a3_a5bk) ->
                    case cast
                           @ a3_a5bk
                           @ SrcSpan
                           $dTypeable_a56v
                           (a4_seeg
                            `cast` (Sym (NTCo:Typeable[0] <*>_N <SrcSpan>_N)
                                    :: (Proxy# SrcSpan -> TypeRep) ~R# Typeable SrcSpan))
                           a5_a4Wy
                    of _ [Occ=Dead] {
                      Nothing -> [] @ SrcSpan;
                      Just b_a4WM ->
                        case b_a4WM of wild1_XT {
                          RealSrcSpan ds1_dedJ -> : @ SrcSpan wild1_XT ([] @ SrcSpan);
                          UnhelpfulSpan ipv_seee -> [] @ SrcSpan
                        }
                    })
               @ a2_a5bd
               $dData_a6PB
               ast_a3ST) } in
    >>=
      @ IO
      GHC.Base.$fMonadIO
      @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
      @ ()
      (runGhc
         @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
         (Just @ FilePath libdir_a3SP)
         (>>=
            @ Ghc
            GhcMonad.$fMonadGhc
            @ DynFlags
            @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
            (getSessionDynFlags @ Ghc GhcMonad.$fGhcMonadGhc)
            (\ (dflags_a4fE :: DynFlags) ->
               >>
                 @ Ghc
                 GhcMonad.$fMonadGhc
                 @ [UnitId]
                 @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                 (setSessionDynFlags @ Ghc GhcMonad.$fGhcMonadGhc dflags_a4fE)
                 (let {
                    mn_a4fF :: ModuleName
                    [LclId, Str=DmdType]
                    mn_a4fF = mkModuleName fileName_a3SQ } in
                  >>
                    @ Ghc
                    GhcMonad.$fMonadGhc
                    @ ()
                    @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                    (addTarget
                       @ Ghc
                       GhcMonad.$fGhcMonadGhc
                       (HscTypes.Target
                          (HscTypes.TargetModule mn_a4fF)
                          True
                          (Nothing
                             @ (StringBuffer.StringBuffer,
                                time-1.5.0.1:Data.Time.Clock.UTC.UTCTime))))
                    (>>
                       @ Ghc
                       GhcMonad.$fMonadGhc
                       @ SuccessFlag
                       @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                       (load @ Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets)
                       (>>=
                          @ Ghc
                          GhcMonad.$fMonadGhc
                          @ ModSummary
                          @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                          (getModSummary @ Ghc GhcMonad.$fGhcMonadGhc mn_a4fF)
                          (\ (modSum_a4Wj :: ModSummary) ->
                             >>=
                               @ Ghc
                               GhcMonad.$fMonadGhc
                               @ ParsedModule
                               @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                               (parseModule @ Ghc GhcMonad.$fGhcMonadGhc modSum_a4Wj)
                               (\ (p_a4Wk :: ParsedModule) ->
                                  >>=
                                    @ Ghc
                                    GhcMonad.$fMonadGhc
                                    @ TypecheckedModule
                                    @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                    (typecheckModule @ Ghc GhcMonad.$fGhcMonadGhc p_a4Wk)
                                    (\ (t_a4Wl :: TypecheckedModule) ->
                                       >>=
                                         @ Ghc
                                         GhcMonad.$fMonadGhc
                                         @ DesugaredModule
                                         @ (ParsedSource, Maybe RenamedSource, TypecheckedSource)
                                         (desugarModule @ Ghc GhcMonad.$fGhcMonadGhc t_a4Wl)
                                         (\ (d_a4Wm :: DesugaredModule) ->
                                            >>=
                                              @ Ghc
                                              GhcMonad.$fMonadGhc
                                              @ DesugaredModule
                                              @ (ParsedSource, Maybe RenamedSource,
                                                 TypecheckedSource)
                                              (loadModule
                                                 @ DesugaredModule
                                                 @ Ghc
                                                 GHC.$fTypecheckedModDesugaredModule
                                                 GhcMonad.$fGhcMonadGhc
                                                 d_a4Wm)
                                              (\ (l_a4Wn :: DesugaredModule) ->
                                                 return
                                                   @ Ghc
                                                   GhcMonad.$fMonadGhc
                                                   @ (ParsedSource, Maybe RenamedSource,
                                                      TypecheckedSource)
                                                   (pm_parsed_source p_a4Wk,
                                                    renamedSource
                                                      @ DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn,
                                                    typecheckedSource
                                                      @ DesugaredModule
                                                      GHC.$fTypecheckedModDesugaredModule
                                                      l_a4Wn))))))))))))
      (\ (ds_dedD
            :: (ParsedSource, Maybe RenamedSource, TypecheckedSource)) ->
         case ds_dedD of _ [Occ=Dead] { (p_a4Wq, r_a4Wr, ts_a4Ws) ->
         print
           @ (Int, Int, Int)
           $dShow_reeF
           (gq_a3SR
              @ ParsedSource
              (SrcLoc.$fDataGenLocated
                 @ SrcSpan
                 @ (HsModule RdrName)
                 SrcLoc.$fDataSrcSpan
                 (HsSyn.$fDataHsModule
                    @ RdrName
                    ((RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                      PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder)
                     `cast` ((<Data RdrName>_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                       <UniqFM.UniqFM Name>_N)))_N,
                              (Data
                                 (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <GHC.Fixity>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Bool>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <[Name]>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <RdrName>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <Type>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <Coercion.Coercion>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <RdrName>_N)))_N,
                              (Data (Sym (PlaceHolder.TFCo:R:PostTcRdrNamety[0] <[Type]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[ConLike.ConLike]>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <TcEvidence.HsWrapper>_N)))_N,
                              (Data
                                 (Sym
                                    (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                       <[FieldLabel.FieldLabel]>_N)))_N)_R
                             :: (Data RdrName, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                 Data PlaceHolder, Data PlaceHolder)
                                ~R# (Data RdrName, Data (PostRn RdrName (UniqFM.UniqFM Name)),
                                     Data (PostRn RdrName GHC.Fixity), Data (PostRn RdrName Bool),
                                     Data (PostRn RdrName Name), Data (PostRn RdrName [Name]),
                                     Data (PostRn RdrName RdrName), Data (PostTc RdrName Type),
                                     Data (PostTc RdrName Coercion.Coercion),
                                     Data (PostTc RdrName RdrName), Data (PostTc RdrName [Type]),
                                     Data (PostTc RdrName [ConLike.ConLike]),
                                     Data (PostTc RdrName TcEvidence.HsWrapper),
                                     Data (PostTc RdrName [FieldLabel.FieldLabel]))))))
              p_a4Wq,
            gq_a3SR
              @ (Maybe RenamedSource)
              (Data.Data.$fDataMaybe
                 @ (HsGroup Name, [LImportDecl Name], Maybe [LIE Name],
                    Maybe LHsDocString)
                 (Data.Data.$fData(,,,)
                    @ (HsGroup Name)
                    @ [LImportDecl Name]
                    @ (Maybe [LIE Name])
                    @ (Maybe LHsDocString)
                    (HsDecls.$fDataHsGroup
                       @ Name
                       ((Name.$fDataName, UniqFM.$fDataUniqFM @ Name Name.$fDataName,
                         BasicTypes.$fDataFixity, Data.Data.$fDataBool, Name.$fDataName,
                         Data.Data.$fData[] @ Name Name.$fDataName, Name.$fDataName,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                         PlaceHolder.$fDataPlaceHolder)
                        `cast` ((<Data Name>_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnNamety[0]
                                          <UniqFM.UniqFM Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <GHC.Fixity>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Bool>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <[Name]>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnNamety[0] <Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Type>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcNamety[0] <[Type]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcNamety[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data Name, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                    Data Bool, Data Name, Data [Name], Data Name, Data PlaceHolder,
                                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder,
                                    Data PlaceHolder, Data PlaceHolder, Data PlaceHolder)
                                   ~R# (Data Name, Data (PostRn Name (UniqFM.UniqFM Name)),
                                        Data (PostRn Name GHC.Fixity), Data (PostRn Name Bool),
                                        Data (PostRn Name Name), Data (PostRn Name [Name]),
                                        Data (PostRn Name Name), Data (PostTc Name Type),
                                        Data (PostTc Name Coercion.Coercion),
                                        Data (PostTc Name Name), Data (PostTc Name [Type]),
                                        Data (PostTc Name [ConLike.ConLike]),
                                        Data (PostTc Name TcEvidence.HsWrapper),
                                        Data (PostTc Name [FieldLabel.FieldLabel])))))
                    (Data.Data.$fData[]
                       @ (GenLocated SrcSpan (ImportDecl Name))
                       (SrcLoc.$fDataGenLocated
                          @ SrcSpan
                          @ (ImportDecl Name)
                          SrcLoc.$fDataSrcSpan
                          (HsImpExp.$fDataImportDecl @ Name Name.$fDataName)))
                    (Data.Data.$fDataMaybe
                       @ [LIE Name]
                       (Data.Data.$fData[]
                          @ (GenLocated SrcSpan (IE Name))
                          (SrcLoc.$fDataGenLocated
                             @ SrcSpan
                             @ (IE Name)
                             SrcLoc.$fDataSrcSpan
                             (HsImpExp.$fDataIE @ Name Name.$fDataName))))
                    (Data.Data.$fDataMaybe
                       @ (GenLocated SrcSpan HsDocString)
                       (SrcLoc.$fDataGenLocated
                          @ SrcSpan
                          @ HsDocString
                          SrcLoc.$fDataSrcSpan
                          HsDoc.$fDataHsDocString))))
              r_a4Wr,
            let {
              $dData_adT2 :: Data [ConLike.ConLike]
              [LclId, Str=DmdType]
              $dData_adT2 =
                Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
            let {
              $dData1_adT1 :: Data [Type]
              [LclId, Str=DmdType]
              $dData1_adT1 = Data.Data.$fData[] @ Type TypeRep.$fDataType } in
            let {
              $dData2_adSW :: Data [Name]
              [LclId, Str=DmdType]
              $dData2_adSW = Data.Data.$fData[] @ Name Name.$fDataName } in
            let {
              $dData3_adT9 :: Data (FieldLabel.FieldLbl Name)
              [LclId, Str=DmdType]
              $dData3_adT9 =
                FieldLabel.$fDataFieldLbl @ Name Name.$fDataName } in
            let {
              $dData4_adT4 :: Data [FieldLabel.FieldLabel]
              [LclId, Str=DmdType]
              $dData4_adT4 =
                Data.Data.$fData[] @ (FieldLabel.FieldLbl Name) $dData3_adT9 } in
            let {
              $dData5_adSS :: Data (UniqFM.UniqFM Name)
              [LclId, Str=DmdType]
              $dData5_adSS = UniqFM.$fDataUniqFM @ Name Name.$fDataName } in
            let {
              $d(%,,,,,,,,,,,,,%)_adSQ
                :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                    Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                    Data Coercion.Coercion, Data Var.Var, Data [Type],
                    Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                    Data [FieldLabel.FieldLabel])
              [LclId, Str=DmdType]
              $d(%,,,,,,,,,,,,,%)_adSQ =
                (Var.$fDataVar, $dData5_adSS, BasicTypes.$fDataFixity,
                 Data.Data.$fDataBool, Name.$fDataName, $dData2_adSW, Var.$fDataVar,
                 TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                 $dData1_adT1, $dData_adT2, TcEvidence.$fDataHsWrapper,
                 $dData4_adT4) } in
            gq_a3SR
              @ TypecheckedSource
              (Bag.$fDataBag
                 @ (GenLocated SrcSpan (HsBindLR Id Id))
                 (SrcLoc.$fDataGenLocated
                    @ SrcSpan
                    @ (HsBindLR Id Id)
                    SrcLoc.$fDataSrcSpan
                    (HsBinds.$fDataHsBindLR
                       @ Var.Var
                       @ Var.Var
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data Var.Var>_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                    Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                                    Data Coercion.Coercion, Data Var.Var, Data [Type],
                                    Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                                    Data [FieldLabel.FieldLabel])
                                   ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                        Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                        Data (PostRn Id Name), Data (PostRn Id [Name]),
                                        Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                        Data (PostTc Id Coercion.Coercion),
                                        Data (PostTc Id Var.Var), Data (PostTc Id [Type]),
                                        Data (PostTc Id [ConLike.ConLike]),
                                        Data (PostTc Id TcEvidence.HsWrapper),
                                        Data (PostTc Id [FieldLabel.FieldLabel]))))
                       ($d(%,,,,,,,,,,,,,%)_adSQ
                        `cast` ((<Data Var.Var>_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostRnVarty[0]
                                          <UniqFM.UniqFM Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <GHC.Fixity>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Bool>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name]>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Type>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <Coercion.Coercion>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                 (Data (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <[Type]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[ConLike.ConLike]>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <TcEvidence.HsWrapper>_N)))_N,
                                 (Data
                                    (Sym
                                       (PlaceHolder.TFCo:R:PostTcVarty[0]
                                          <[FieldLabel.FieldLabel]>_N)))_N)_R
                                :: (Data Var.Var, Data (UniqFM.UniqFM Name), Data GHC.Fixity,
                                    Data Bool, Data Name, Data [Name], Data Var.Var, Data Type,
                                    Data Coercion.Coercion, Data Var.Var, Data [Type],
                                    Data [ConLike.ConLike], Data TcEvidence.HsWrapper,
                                    Data [FieldLabel.FieldLabel])
                                   ~R# (Data Var.Var, Data (PostRn Id (UniqFM.UniqFM Name)),
                                        Data (PostRn Id GHC.Fixity), Data (PostRn Id Bool),
                                        Data (PostRn Id Name), Data (PostRn Id [Name]),
                                        Data (PostRn Id Var.Var), Data (PostTc Id Type),
                                        Data (PostTc Id Coercion.Coercion),
                                        Data (PostTc Id Var.Var), Data (PostTc Id [Type]),
                                        Data (PostTc Id [ConLike.ConLike]),
                                        Data (PostTc Id TcEvidence.HsWrapper),
                                        Data (PostTc Id [FieldLabel.FieldLabel])))))))
              ts_a4Ws)
         })

-- RHS size: {terms: 44, types: 31, coercions: 0}
main :: IO ()
[GblId, Str=DmdType]
main =
  >>=
    @ IO
    GHC.Base.$fMonadIO
    @ [String]
    @ ()
    getArgs
    (\ (ds_dedZ :: [String]) ->
       let {
         fail_dee1 :: Void# -> IO ()
         [LclId, Arity=1, Str=DmdType]
         fail_dee1 =
           \ _ [Occ=Dead, OS=OneShot] ->
             fail
               @ IO
               GHC.Base.$fMonadIO
               @ ()
               (unpackCString#
                  "Pattern match failure in do expression at landmines.hs:19:9-16"#) } in
       case ds_dedZ of _ [Occ=Dead] {
         [] -> fail_dee1 void#;
         : libdir_a3SO ds1_dee0 ->
           case ds1_dee0 of _ [Occ=Dead] {
             [] ->
               >>
                 @ IO
                 GHC.Base.$fMonadIO
                 @ ()
                 @ ()
                 (testOneFile libdir_a3SO (unpackCString# "MineFixity"#))
                 (>>
                    @ IO
                    GHC.Base.$fMonadIO
                    @ ()
                    @ ()
                    (testOneFile libdir_a3SO (unpackCString# "MineKind"#))
                    (>>
                       @ IO
                       GHC.Base.$fMonadIO
                       @ ()
                       @ ()
                       (testOneFile libdir_a3SO (unpackCString# "MineNames"#))
                       (testOneFile libdir_a3SO (unpackCString# "MineType"#))));
             : ipv_seen ipv1_seeo -> fail_dee1 void#
           }
       })

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: IO ()
[GblId, Str=DmdType]
:Main.main = runMainIO @ () main




==================== FINAL INTERFACE ====================
interface main@main:Main 71120151113
  interface hash: e42440f09f18217850972c976793dd78
  ABI hash: 5ea54b42d0512e8e33decaf1a7e2b07f
  export-list hash: 23a4ee515e936fac9997700d0830e4ed
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 2a73bb91a4bfcd9bfda40fbcaf90bb5b
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.everything
  Main.main
  Main.mkQ
  Main.testOneFile
  Main.GenericQ
module dependencies:
package dependencies: array-0.5.1.0@array-0.5.1.0 base-4.9.0.0
                      binary-0.7.5.0@binary-0.7.5.0
                      bytestring-0.10.6.0@bytestring-0.10.6.0
                      containers-0.5.6.2@containers-0.5.6.2
                      deepseq-1.4.2.0@deepseq-1.4.2.0 directory-1.2.5.0@directory-1.2.5.0
                      filepath-1.4.1.0@filepath-1.4.1.0 ghc-7.11.20151113
                      ghc-boot-0.0.0.0@ghc-boot-0.0.0.0 ghc-prim-0.5.0.0
                      hoopl-3.10.2.0@hoopl-3.10.2.0 hpc-0.6.0.2@hpc-0.6.0.2
                      integer-gmp-1.0.0.0 pretty-1.1.2.0@pretty-1.1.2.0
                      process-1.4.0.0@process-1.4.0.0 template-haskell-2.11.0.0
                      time-1.5.0.1@time-1.5.0.1 transformers-0.4.3.0@transformers-0.4.3.0
                      unix-2.7.1.0@unix-2.7.1.0
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
         binary-0.7.5.0@binary-0.7.5.0:Data.Binary.Generic
         ghc-7.11.20151113:BlockId ghc-7.11.20151113:DsMonad
         ghc-7.11.20151113:LoadIface ghc-7.11.20151113:PPC.Ppr
         ghc-7.11.20151113:PprCmm ghc-7.11.20151113:PprCmmDecl
         ghc-7.11.20151113:PprCmmExpr ghc-7.11.20151113:PprCore
         ghc-7.11.20151113:SPARC.Ppr ghc-7.11.20151113:TcEnv
         ghc-7.11.20151113:TcRnMonad ghc-7.11.20151113:Type
         ghc-7.11.20151113:X86.Ppr
         ghc-boot-0.0.0.0@ghc-boot-0.0.0.0:GHC.PackageDb
         time-1.5.0.1@time-1.5.0.1:Data.Time.Calendar.Gregorian
         time-1.5.0.1@time-1.5.0.1:Data.Time.Format.Parse
         time-1.5.0.1@time-1.5.0.1:Data.Time.LocalTime.LocalTime
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Complex base-4.9.0.0:Data.Either
                         base-4.9.0.0:Data.Functor.Identity base-4.9.0.0:Data.Monoid
                         base-4.9.0.0:Data.Type.Equality base-4.9.0.0:Data.Version
                         base-4.9.0.0:Data.Void base-4.9.0.0:GHC.Exts
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
                         containers-0.5.6.2@containers-0.5.6.2:Data.IntMap.Base
                         containers-0.5.6.2@containers-0.5.6.2:Data.IntSet.Base
                         containers-0.5.6.2@containers-0.5.6.2:Data.Map.Base
                         containers-0.5.6.2@containers-0.5.6.2:Data.Sequence
                         containers-0.5.6.2@containers-0.5.6.2:Data.Set.Base
                         ghc-7.11.20151113:PlaceHolder ghc-7.11.20151113:TrieMap
                         hoopl-3.10.2.0@hoopl-3.10.2.0:Compiler.Hoopl.Block
                         hoopl-3.10.2.0@hoopl-3.10.2.0:Compiler.Hoopl.Dataflow
                         hoopl-3.10.2.0@hoopl-3.10.2.0:Compiler.Hoopl.Fuel
                         hoopl-3.10.2.0@hoopl-3.10.2.0:Compiler.Hoopl.Label
                         hoopl-3.10.2.0@hoopl-3.10.2.0:Compiler.Hoopl.Unique
                         pretty-1.1.2.0@pretty-1.1.2.0:Text.PrettyPrint.HughesPJ
                         template-haskell-2.11.0.0:Language.Haskell.TH.Syntax
import  -/  base-4.9.0.0:Data.Data 2c5e217f74aac7610649c745f75a0d4d
import  -/  base-4.9.0.0:Data.Foldable 57157385e5a3fa57acbe841fd5e8d4a3
import  -/  base-4.9.0.0:Data.Typeable b35bd1d54bac1c64d10435d1f7094163
import  -/  base-4.9.0.0:Data.Typeable.Internal 4d57d20566bf824b910f3d68d6c6385d
import  -/  base-4.9.0.0:GHC.Base fcfb19a46aba24c6b0a18a2457bb3f51
import  -/  base-4.9.0.0:Prelude 0044b3b3ee910e4ce6a240580042175a
import  -/  base-4.9.0.0:System.Environment 847e988730ae36a2c401a8cfacbb1092
import  -/  base-4.9.0.0:System.IO 4c2035b735d5ae77329ee488d3290b81
import  -/  directory-1.2.5.0@directory-1.2.5.0:System.Directory c996912c31664621c53974682def7b43
import  -/  ghc-7.11.20151113:Bag 0f5fb312ee7562823b65219a334a635c
import  -/  ghc-7.11.20151113:GHC 8aee93436830b29b6f813d38d74fac51
import  -/  ghc-7.11.20151113:GhcMake 322a4613d52ab002762096f0253ca7ff
import  -/  ghc-7.11.20151113:GhcMonad 693265298a1b3f1dac10d6d86262dfe3
import  -/  ghc-7.11.20151113:HscTypes cdd4f6f20d1bb11e53a94a45e6c94846
import  -/  ghc-7.11.20151113:Module 3c6008725ec2e1f6722d8f735352640d
import  -/  ghc-7.11.20151113:MonadUtils 52a832d2945a9f6271e9554e5c222123
import  -/  ghc-7.11.20151113:Outputable e417e9841241f7621ea98cfc41f468fa
import  -/  ghc-7.11.20151113:SrcLoc 79e7aa7eab5fb59835cccb6f1ce973ac
import  -/  ghc-prim-0.5.0.0:GHC.Types 1d50b21f6250d14973dcd4ec2f198bfc
bf7f6fcaf029c1a431258a1eff55840c
  $trModule :: GHC.Types.Module
57f7aa1e52a78d2d36852888064f8cb1
  type GenericQ r = forall a. Data.Data.Data a => a -> r
769582ba4d41581daabac63857e582ff
  everything :: (r -> r -> r) -> Main.GenericQ r -> Main.GenericQ r
7b3284b9f6263c5c81a68dbc9dadcea4
  main :: GHC.Types.IO ()
a344363aeed84bf7aef821828b822c88
  mkQ ::
    (Data.Typeable.Internal.Typeable a,
     Data.Typeable.Internal.Typeable b) =>
    r -> (b -> r) -> a -> r
368d02233e7ec68b49eaffda3c36d885
  testOneFile ::
    GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False



==================== CorePrep ====================
Result size of CorePrep = {terms: 471, types: 746, coercions: 244}

-- RHS size: {terms: 2, types: 0, coercions: 0}
a_redQ :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
a_redQ = GHC.Types.TrNameS "main"#

-- RHS size: {terms: 2, types: 0, coercions: 0}
a1_reeE :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
a1_reeE = GHC.Types.TrNameS "Main"#

-- RHS size: {terms: 3, types: 0, coercions: 0}
Main.$trModule :: GHC.Types.Module
[GblId[ReflectionId], Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []]
Main.$trModule = GHC.Types.Module a_redQ a1_reeE

-- RHS size: {terms: 18, types: 18, coercions: 0}
Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []]
Main.mkQ =
  \ (@ a2_a4Yh)
    (@ b_a4Yi)
    (@ r_a4Yj)
    ($dTypeable_seeH [Occ=Once]
       :: Data.Typeable.Internal.Typeable a2_a4Yh)
    ($dTypeable1_seeI [Occ=Once]
       :: Data.Typeable.Internal.Typeable b_a4Yi)
    (r1_seeJ [Occ=Once] :: r_a4Yj)
    (br_seeK [Occ=Once!] :: b_a4Yi -> r_a4Yj)
    (a3_seeL [Occ=Once] :: a2_a4Yh) ->
    case Data.Typeable.cast
           @ a2_a4Yh @ b_a4Yi $dTypeable_seeH $dTypeable1_seeI a3_seeL
    of _ [Occ=Dead] {
      GHC.Base.Nothing -> r1_seeJ;
      GHC.Base.Just b1_seeN [Occ=Once] -> br_seeK b1_seeN
    }

Rec {
-- RHS size: {terms: 29, types: 30, coercions: 0}
Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[GblId, Arity=4, Str=DmdType, Unf=OtherCon []]
Main.everything =
  \ (@ r_a4XV)
    (dk_seeO :: r_a4XV -> r_a4XV -> r_a4XV)
    (dk1_seeP :: Main.GenericQ r_a4XV)
    (@ a2_a55z)
    ($dData_seeQ :: Data.Data.Data a2_a55z)
    (x_seeR :: a2_a55z) ->
    let {
      sat_seeW [Occ=Once] :: [r_a4XV]
      [LclId, Str=DmdType]
      sat_seeW =
        let {
          sat_seeV [Occ=Once]
            :: forall d_a567. Data.Data.Data d_a567 => d_a567 -> r_a4XV
          [LclId, Str=DmdType]
          sat_seeV =
            \ (@ d_a56e)
              ($dData1_seeT [Occ=Once] :: Data.Data.Data d_a56e)
              (eta_seeU [Occ=Once] :: d_a56e) ->
              Main.everything
                @ r_a4XV dk_seeO dk1_seeP @ d_a56e $dData1_seeT eta_seeU } in
        Data.Data.gmapQ @ a2_a55z $dData_seeQ @ r_a4XV sat_seeV x_seeR } in
    let {
      sat_seeS [Occ=Once] :: r_a4XV
      [LclId, Str=DmdType]
      sat_seeS = dk1_seeP @ a2_a55z $dData_seeQ x_seeR } in
    Data.Foldable.foldl
      @ []
      Data.Foldable.$fFoldable[]
      @ r_a4XV
      @ r_a4XV
      dk_seeO
      sat_seeS
      sat_seeW
end Rec }

-- RHS size: {terms: 4, types: 3, coercions: 0}
$dShow_reeF
  :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
[GblId, Str=DmdType]
$dShow_reeF =
  GHC.Show.$fShow(,,)
    @ GHC.Types.Int
    @ GHC.Types.Int
    @ GHC.Types.Int
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt
    GHC.Show.$fShowInt

-- RHS size: {terms: 334, types: 604, coercions: 244}
Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []]
Main.testOneFile =
  \ (libdir_seeX [Occ=Once] :: GHC.IO.FilePath)
    (fileName_seeY [Occ=OnceL] :: GHC.Base.String) ->
    let {
      gq_seeZ
        :: forall a2_a5bd.
           Data.Data.Data a2_a5bd =>
           a2_a5bd -> GHC.Types.Int
      [LclId, Arity=2, Str=DmdType, Unf=OtherCon []]
      gq_seeZ =
        \ (@ a2_a5bd)
          ($dData_sef0 [Occ=Once] :: Data.Data.Data a2_a5bd)
          (ast_sef1 [Occ=Once] :: a2_a5bd) ->
          let {
            sat_seff [Occ=Once] :: [SrcLoc.SrcSpan]
            [LclId, Str=DmdType]
            sat_seff =
              let {
                sat_sefe [Occ=Once] :: Main.GenericQ [SrcLoc.SrcSpan]
                [LclId, Str=DmdType]
                sat_sefe =
                  \ (@ a3_a5bk) ($dData1_sef2 :: Data.Data.Data a3_a5bk) ->
                    let {
                      $dTypeable_sef3 [Occ=OnceL]
                        :: Data.Typeable.Internal.Typeable a3_a5bk
                      [LclId, Str=DmdType]
                      $dTypeable_sef3 = Data.Data.$p1Data @ a3_a5bk $dData1_sef2 } in
                    let {
                      ds_sef4 [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                      [LclId, Str=DmdType]
                      ds_sef4 =
                        Data.Typeable.Internal.mkPolyTyConApp
                          SrcLoc.$tcSrcSpan
                          (GHC.Types.[] @ Data.Typeable.Internal.TypeRep)
                          (GHC.Types.[] @ Data.Typeable.Internal.TypeRep) } in
                    let {
                      a4_sef5 [Occ=OnceL]
                        :: GHC.Prim.Proxy# SrcLoc.SrcSpan -> Data.Typeable.Internal.TypeRep
                      [LclId, Arity=1, Str=DmdType, Unf=OtherCon []]
                      a4_sef5 = \ _ [Occ=Dead] -> ds_sef4 } in
                    let {
                      sat_sefd [Occ=Once] :: a3_a5bk -> [SrcLoc.SrcSpan]
                      [LclId, Str=DmdType]
                      sat_sefd =
                        \ (a5_sef7 [Occ=Once] :: a3_a5bk) ->
                          case Data.Typeable.cast
                                 @ a3_a5bk
                                 @ SrcLoc.SrcSpan
                                 $dTypeable_sef3
                                 (a4_sef5
                                  `cast` (Sym
                                            (Data.Typeable.Internal.NTCo:Typeable[0]
                                               <*>_N <SrcLoc.SrcSpan>_N)
                                          :: (GHC.Prim.Proxy# SrcLoc.SrcSpan
                                              -> Data.Typeable.Internal.TypeRep)
                                             ~R# Data.Typeable.Internal.Typeable SrcLoc.SrcSpan))
                                 a5_sef7
                          of _ [Occ=Dead] {
                            GHC.Base.Nothing -> GHC.Types.[] @ SrcLoc.SrcSpan;
                            GHC.Base.Just b_sef9 [Occ=Once!] ->
                              case b_sef9 of wild1_sefa {
                                SrcLoc.RealSrcSpan _ [Occ=Dead] ->
                                  GHC.Types.:
                                    @ SrcLoc.SrcSpan wild1_sefa (GHC.Types.[] @ SrcLoc.SrcSpan);
                                SrcLoc.UnhelpfulSpan _ [Occ=Dead] -> GHC.Types.[] @ SrcLoc.SrcSpan
                              }
                          } } in
                    sat_sefd } in
              Main.everything
                @ [SrcLoc.SrcSpan]
                (GHC.Base.++ @ SrcLoc.SrcSpan)
                sat_sefe
                @ a2_a5bd
                $dData_sef0
                ast_sef1 } in
          Data.Foldable.length
            @ [] Data.Foldable.$fFoldable[] @ SrcLoc.SrcSpan sat_seff } in
    let {
      sat_segp [Occ=Once]
        :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
            GHC.TypecheckedSource)
           -> GHC.Types.IO ()
      [LclId, Str=DmdType]
      sat_segp =
        \ (ds_sefO [Occ=Once!]
             :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                 GHC.TypecheckedSource)) ->
          case ds_sefO
          of _ [Occ=Dead]
          { (p_sefQ [Occ=Once], r_sefR [Occ=Once], ts_sefS [Occ=Once]) ->
          let {
            sat_segn [Occ=Once] :: GHC.Types.Int
            [LclId, Str=DmdType]
            sat_segn =
              let {
                $dData_segd :: Data.Data.Data [ConLike.ConLike]
                [LclId, Str=DmdType]
                $dData_segd =
                  Data.Data.$fData[] @ ConLike.ConLike ConLike.$fDataConLike } in
              let {
                $dData1_sege :: Data.Data.Data [TypeRep.Type]
                [LclId, Str=DmdType]
                $dData1_sege =
                  Data.Data.$fData[] @ TypeRep.Type TypeRep.$fDataType } in
              let {
                $dData2_segf :: Data.Data.Data [Name.Name]
                [LclId, Str=DmdType]
                $dData2_segf = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
              let {
                $dData3_segg :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
                [LclId, Str=DmdType]
                $dData3_segg =
                  FieldLabel.$fDataFieldLbl @ Name.Name Name.$fDataName } in
              let {
                $dData4_segh :: Data.Data.Data [FieldLabel.FieldLabel]
                [LclId, Str=DmdType]
                $dData4_segh =
                  Data.Data.$fData[]
                    @ (FieldLabel.FieldLbl Name.Name) $dData3_segg } in
              let {
                $dData5_segi :: Data.Data.Data (UniqFM.UniqFM Name.Name)
                [LclId, Str=DmdType]
                $dData5_segi = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
              let {
                $d(%,,,,,,,,,,,,,%)_segj
                  :: (Data.Data.Data Var.Var,
                      Data.Data.Data (UniqFM.UniqFM Name.Name),
                      Data.Data.Data BasicTypes.Fixity, Data.Data.Data GHC.Types.Bool,
                      Data.Data.Data Name.Name, Data.Data.Data [Name.Name],
                      Data.Data.Data Var.Var, Data.Data.Data TypeRep.Type,
                      Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                      Data.Data.Data [TypeRep.Type], Data.Data.Data [ConLike.ConLike],
                      Data.Data.Data TcEvidence.HsWrapper,
                      Data.Data.Data [FieldLabel.FieldLabel])
                [LclId, Str=DmdType, Unf=OtherCon []]
                $d(%,,,,,,,,,,,,,%)_segj =
                  (Var.$fDataVar, $dData5_segi, BasicTypes.$fDataFixity,
                   Data.Data.$fDataBool, Name.$fDataName, $dData2_segf, Var.$fDataVar,
                   TypeRep.$fDataType, Coercion.$fDataCoercion, Var.$fDataVar,
                   $dData1_sege, $dData_segd, TcEvidence.$fDataHsWrapper,
                   $dData4_segh) } in
              let {
                sat_segm [Occ=Once] :: Data.Data.Data GHC.TypecheckedSource
                [LclId, Str=DmdType]
                sat_segm =
                  let {
                    sat_segl [Occ=Once]
                      :: Data.Data.Data
                           (SrcLoc.GenLocated SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                    [LclId, Str=DmdType]
                    sat_segl =
                      let {
                        sat_segk [Occ=Once]
                          :: Data.Data.Data (HsBinds.HsBindLR Var.Id Var.Id)
                        [LclId, Str=DmdType]
                        sat_segk =
                          HsBinds.$fDataHsBindLR
                            @ Var.Var
                            @ Var.Var
                            ($d(%,,,,,,,,,,,,,%)_segj
                             `cast` ((<Data.Data.Data Var.Var>_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <UniqFM.UniqFM Name.Name>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <BasicTypes.Fixity>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <GHC.Types.Bool>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <TypeRep.Type>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <Coercion.Coercion>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[TypeRep.Type]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[ConLike.ConLike]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <TcEvidence.HsWrapper>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[FieldLabel.FieldLabel]>_N)))_N)_R
                                     :: (Data.Data.Data Var.Var,
                                         Data.Data.Data (UniqFM.UniqFM Name.Name),
                                         Data.Data.Data BasicTypes.Fixity,
                                         Data.Data.Data GHC.Types.Bool, Data.Data.Data Name.Name,
                                         Data.Data.Data [Name.Name], Data.Data.Data Var.Var,
                                         Data.Data.Data TypeRep.Type,
                                         Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                         Data.Data.Data [TypeRep.Type],
                                         Data.Data.Data [ConLike.ConLike],
                                         Data.Data.Data TcEvidence.HsWrapper,
                                         Data.Data.Data [FieldLabel.FieldLabel])
                                        ~R# (Data.Data.Data Var.Var,
                                             Data.Data.Data
                                               (PlaceHolder.PostRn
                                                  Var.Id (UniqFM.UniqFM Name.Name)),
                                             Data.Data.Data
                                               (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                             Data.Data.Data
                                               (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                             Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc
                                                  Var.Id [FieldLabel.FieldLabel]))))
                            ($d(%,,,,,,,,,,,,,%)_segj
                             `cast` ((<Data.Data.Data Var.Var>_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <UniqFM.UniqFM Name.Name>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <BasicTypes.Fixity>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0]
                                               <GHC.Types.Bool>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Name.Name>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostRnVarty[0] <[Name.Name]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostRnVarty[0] <Var.Var>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <TypeRep.Type>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <Coercion.Coercion>_N)))_N,
                                      (Data.Data.Data
                                         (Sym (PlaceHolder.TFCo:R:PostTcVarty[0] <Var.Var>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[TypeRep.Type]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[ConLike.ConLike]>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <TcEvidence.HsWrapper>_N)))_N,
                                      (Data.Data.Data
                                         (Sym
                                            (PlaceHolder.TFCo:R:PostTcVarty[0]
                                               <[FieldLabel.FieldLabel]>_N)))_N)_R
                                     :: (Data.Data.Data Var.Var,
                                         Data.Data.Data (UniqFM.UniqFM Name.Name),
                                         Data.Data.Data BasicTypes.Fixity,
                                         Data.Data.Data GHC.Types.Bool, Data.Data.Data Name.Name,
                                         Data.Data.Data [Name.Name], Data.Data.Data Var.Var,
                                         Data.Data.Data TypeRep.Type,
                                         Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                         Data.Data.Data [TypeRep.Type],
                                         Data.Data.Data [ConLike.ConLike],
                                         Data.Data.Data TcEvidence.HsWrapper,
                                         Data.Data.Data [FieldLabel.FieldLabel])
                                        ~R# (Data.Data.Data Var.Var,
                                             Data.Data.Data
                                               (PlaceHolder.PostRn
                                                  Var.Id (UniqFM.UniqFM Name.Name)),
                                             Data.Data.Data
                                               (PlaceHolder.PostRn Var.Id BasicTypes.Fixity),
                                             Data.Data.Data
                                               (PlaceHolder.PostRn Var.Id GHC.Types.Bool),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id Name.Name),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id [Name.Name]),
                                             Data.Data.Data (PlaceHolder.PostRn Var.Id Var.Var),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id TypeRep.Type),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id Coercion.Coercion),
                                             Data.Data.Data (PlaceHolder.PostTc Var.Id Var.Var),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id [TypeRep.Type]),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id [ConLike.ConLike]),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc Var.Id TcEvidence.HsWrapper),
                                             Data.Data.Data
                                               (PlaceHolder.PostTc
                                                  Var.Id [FieldLabel.FieldLabel])))) } in
                      SrcLoc.$fDataGenLocated
                        @ SrcLoc.SrcSpan
                        @ (HsBinds.HsBindLR Var.Id Var.Id)
                        SrcLoc.$fDataSrcSpan
                        sat_segk } in
                  Bag.$fDataBag
                    @ (SrcLoc.GenLocated
                         SrcLoc.SrcSpan (HsBinds.HsBindLR Var.Id Var.Id))
                    sat_segl } in
              gq_seeZ @ GHC.TypecheckedSource sat_segm ts_sefS } in
          let {
            sat_segc [Occ=Once] :: GHC.Types.Int
            [LclId, Str=DmdType]
            sat_segc =
              let {
                sat_segb [Occ=Once]
                  :: Data.Data.Data (GHC.Base.Maybe GHC.RenamedSource)
                [LclId, Str=DmdType]
                sat_segb =
                  let {
                    sat_sega [Occ=Once]
                      :: Data.Data.Data
                           (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                            GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                            GHC.Base.Maybe HsDoc.LHsDocString)
                    [LclId, Str=DmdType]
                    sat_sega =
                      let {
                        sat_seg9 [Occ=Once]
                          :: Data.Data.Data (GHC.Base.Maybe HsDoc.LHsDocString)
                        [LclId, Str=DmdType]
                        sat_seg9 =
                          let {
                            sat_seg8 [Occ=Once]
                              :: Data.Data.Data
                                   (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                            [LclId, Str=DmdType]
                            sat_seg8 =
                              SrcLoc.$fDataGenLocated
                                @ SrcLoc.SrcSpan
                                @ HsDoc.HsDocString
                                SrcLoc.$fDataSrcSpan
                                HsDoc.$fDataHsDocString } in
                          Data.Data.$fDataMaybe
                            @ (SrcLoc.GenLocated SrcLoc.SrcSpan HsDoc.HsDocString)
                            sat_seg8 } in
                      let {
                        sat_seg7 [Occ=Once]
                          :: Data.Data.Data (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                        [LclId, Str=DmdType]
                        sat_seg7 =
                          let {
                            sat_seg6 [Occ=Once] :: Data.Data.Data [HsImpExp.LIE Name.Name]
                            [LclId, Str=DmdType]
                            sat_seg6 =
                              let {
                                sat_seg5 [Occ=Once]
                                  :: Data.Data.Data
                                       (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                                [LclId, Str=DmdType]
                                sat_seg5 =
                                  let {
                                    sat_seg4 [Occ=Once] :: Data.Data.Data (HsImpExp.IE Name.Name)
                                    [LclId, Str=DmdType]
                                    sat_seg4 = HsImpExp.$fDataIE @ Name.Name Name.$fDataName } in
                                  SrcLoc.$fDataGenLocated
                                    @ SrcLoc.SrcSpan
                                    @ (HsImpExp.IE Name.Name)
                                    SrcLoc.$fDataSrcSpan
                                    sat_seg4 } in
                              Data.Data.$fData[]
                                @ (SrcLoc.GenLocated SrcLoc.SrcSpan (HsImpExp.IE Name.Name))
                                sat_seg5 } in
                          Data.Data.$fDataMaybe @ [HsImpExp.LIE Name.Name] sat_seg6 } in
                      let {
                        sat_seg3 [Occ=Once]
                          :: Data.Data.Data [HsImpExp.LImportDecl Name.Name]
                        [LclId, Str=DmdType]
                        sat_seg3 =
                          let {
                            sat_seg2 [Occ=Once]
                              :: Data.Data.Data
                                   (SrcLoc.GenLocated
                                      SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                            [LclId, Str=DmdType]
                            sat_seg2 =
                              let {
                                sat_seg1 [Occ=Once]
                                  :: Data.Data.Data (HsImpExp.ImportDecl Name.Name)
                                [LclId, Str=DmdType]
                                sat_seg1 =
                                  HsImpExp.$fDataImportDecl @ Name.Name Name.$fDataName } in
                              SrcLoc.$fDataGenLocated
                                @ SrcLoc.SrcSpan
                                @ (HsImpExp.ImportDecl Name.Name)
                                SrcLoc.$fDataSrcSpan
                                sat_seg1 } in
                          Data.Data.$fData[]
                            @ (SrcLoc.GenLocated
                                 SrcLoc.SrcSpan (HsImpExp.ImportDecl Name.Name))
                            sat_seg2 } in
                      let {
                        sat_seg0 [Occ=Once] :: Data.Data.Data (HsDecls.HsGroup Name.Name)
                        [LclId, Str=DmdType]
                        sat_seg0 =
                          let {
                            sat_sefY [Occ=Once] :: Data.Data.Data [Name.Name]
                            [LclId, Str=DmdType]
                            sat_sefY = Data.Data.$fData[] @ Name.Name Name.$fDataName } in
                          let {
                            sat_sefX [Occ=Once] :: Data.Data.Data (UniqFM.UniqFM Name.Name)
                            [LclId, Str=DmdType]
                            sat_sefX = UniqFM.$fDataUniqFM @ Name.Name Name.$fDataName } in
                          let {
                            sat_sefZ [Occ=Once] :: PlaceHolder.DataId Name.Name
                            [LclId, Str=DmdType]
                            sat_sefZ =
                              (Name.$fDataName, sat_sefX, BasicTypes.$fDataFixity,
                               Data.Data.$fDataBool, Name.$fDataName, sat_sefY, Name.$fDataName,
                               PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                               PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                               PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                               PlaceHolder.$fDataPlaceHolder)
                              `cast` ((<Data.Data.Data Name.Name>_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0]
                                                <UniqFM.UniqFM Name.Name>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0]
                                                <BasicTypes.Fixity>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0]
                                                <GHC.Types.Bool>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0]
                                                <[Name.Name]>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostRnNamety[0] <Name.Name>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <TypeRep.Type>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <Coercion.Coercion>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0] <Name.Name>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <[TypeRep.Type]>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <[ConLike.ConLike]>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <TcEvidence.HsWrapper>_N)))_N,
                                       (Data.Data.Data
                                          (Sym
                                             (PlaceHolder.TFCo:R:PostTcNamety[0]
                                                <[FieldLabel.FieldLabel]>_N)))_N)_R
                                      :: (Data.Data.Data Name.Name,
                                          Data.Data.Data (UniqFM.UniqFM Name.Name),
                                          Data.Data.Data BasicTypes.Fixity,
                                          Data.Data.Data GHC.Types.Bool, Data.Data.Data Name.Name,
                                          Data.Data.Data [Name.Name], Data.Data.Data Name.Name,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder,
                                          Data.Data.Data PlaceHolder.PlaceHolder)
                                         ~R# (Data.Data.Data Name.Name,
                                              Data.Data.Data
                                                (PlaceHolder.PostRn
                                                   Name.Name (UniqFM.UniqFM Name.Name)),
                                              Data.Data.Data
                                                (PlaceHolder.PostRn Name.Name BasicTypes.Fixity),
                                              Data.Data.Data
                                                (PlaceHolder.PostRn Name.Name GHC.Types.Bool),
                                              Data.Data.Data
                                                (PlaceHolder.PostRn Name.Name Name.Name),
                                              Data.Data.Data
                                                (PlaceHolder.PostRn Name.Name [Name.Name]),
                                              Data.Data.Data
                                                (PlaceHolder.PostRn Name.Name Name.Name),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name TypeRep.Type),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name Coercion.Coercion),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name Name.Name),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name [TypeRep.Type]),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name [ConLike.ConLike]),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc Name.Name TcEvidence.HsWrapper),
                                              Data.Data.Data
                                                (PlaceHolder.PostTc
                                                   Name.Name [FieldLabel.FieldLabel]))) } in
                          HsDecls.$fDataHsGroup @ Name.Name sat_sefZ } in
                      Data.Data.$fData(,,,)
                        @ (HsDecls.HsGroup Name.Name)
                        @ [HsImpExp.LImportDecl Name.Name]
                        @ (GHC.Base.Maybe [HsImpExp.LIE Name.Name])
                        @ (GHC.Base.Maybe HsDoc.LHsDocString)
                        sat_seg0
                        sat_seg3
                        sat_seg7
                        sat_seg9 } in
                  Data.Data.$fDataMaybe
                    @ (HsDecls.HsGroup Name.Name, [HsImpExp.LImportDecl Name.Name],
                       GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                       GHC.Base.Maybe HsDoc.LHsDocString)
                    sat_sega } in
              gq_seeZ @ (GHC.Base.Maybe GHC.RenamedSource) sat_segb r_sefR } in
          let {
            sat_sefW [Occ=Once] :: GHC.Types.Int
            [LclId, Str=DmdType]
            sat_sefW =
              let {
                sat_sefV [Occ=Once] :: Data.Data.Data GHC.ParsedSource
                [LclId, Str=DmdType]
                sat_sefV =
                  let {
                    sat_sefU [Occ=Once]
                      :: Data.Data.Data (HsSyn.HsModule RdrName.RdrName)
                    [LclId, Str=DmdType]
                    sat_sefU =
                      let {
                        sat_sefT [Occ=Once] :: PlaceHolder.DataId RdrName.RdrName
                        [LclId, Str=DmdType]
                        sat_sefT =
                          (RdrName.$fDataRdrName, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder,
                           PlaceHolder.$fDataPlaceHolder, PlaceHolder.$fDataPlaceHolder)
                          `cast` ((<Data.Data.Data RdrName.RdrName>_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                            <UniqFM.UniqFM Name.Name>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                            <BasicTypes.Fixity>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                            <GHC.Types.Bool>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0] <Name.Name>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                            <[Name.Name]>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostRnRdrNamety[0]
                                            <RdrName.RdrName>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <TypeRep.Type>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <Coercion.Coercion>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <RdrName.RdrName>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <[TypeRep.Type]>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <[ConLike.ConLike]>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <TcEvidence.HsWrapper>_N)))_N,
                                   (Data.Data.Data
                                      (Sym
                                         (PlaceHolder.TFCo:R:PostTcRdrNamety[0]
                                            <[FieldLabel.FieldLabel]>_N)))_N)_R
                                  :: (Data.Data.Data RdrName.RdrName,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder,
                                      Data.Data.Data PlaceHolder.PlaceHolder)
                                     ~R# (Data.Data.Data RdrName.RdrName,
                                          Data.Data.Data
                                            (PlaceHolder.PostRn
                                               RdrName.RdrName (UniqFM.UniqFM Name.Name)),
                                          Data.Data.Data
                                            (PlaceHolder.PostRn RdrName.RdrName BasicTypes.Fixity),
                                          Data.Data.Data
                                            (PlaceHolder.PostRn RdrName.RdrName GHC.Types.Bool),
                                          Data.Data.Data
                                            (PlaceHolder.PostRn RdrName.RdrName Name.Name),
                                          Data.Data.Data
                                            (PlaceHolder.PostRn RdrName.RdrName [Name.Name]),
                                          Data.Data.Data
                                            (PlaceHolder.PostRn RdrName.RdrName RdrName.RdrName),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc RdrName.RdrName TypeRep.Type),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc RdrName.RdrName Coercion.Coercion),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc RdrName.RdrName RdrName.RdrName),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc RdrName.RdrName [TypeRep.Type]),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc RdrName.RdrName [ConLike.ConLike]),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc
                                               RdrName.RdrName TcEvidence.HsWrapper),
                                          Data.Data.Data
                                            (PlaceHolder.PostTc
                                               RdrName.RdrName [FieldLabel.FieldLabel]))) } in
                      HsSyn.$fDataHsModule @ RdrName.RdrName sat_sefT } in
                  SrcLoc.$fDataGenLocated
                    @ SrcLoc.SrcSpan
                    @ (HsSyn.HsModule RdrName.RdrName)
                    SrcLoc.$fDataSrcSpan
                    sat_sefU } in
              gq_seeZ @ GHC.ParsedSource sat_sefV p_sefQ } in
          let {
            sat_sego [Occ=Once]
              :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
            [LclId, Str=DmdType]
            sat_sego = (sat_sefW, sat_segc, sat_segn) } in
          System.IO.print
            @ (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
            $dShow_reeF
            sat_sego
          } } in
    let {
      sat_sefN [Occ=Once]
        :: GHC.Types.IO
             (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
              GHC.TypecheckedSource)
      [LclId, Str=DmdType]
      sat_sefN =
        let {
          sat_sefM [Occ=Once]
            :: GhcMonad.Ghc
                 (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                  GHC.TypecheckedSource)
          [LclId, Str=DmdType]
          sat_sefM =
            let {
              sat_sefL [Occ=Once]
                :: DynFlags.DynFlags
                   -> GhcMonad.Ghc
                        (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                         GHC.TypecheckedSource)
              [LclId, Str=DmdType]
              sat_sefL =
                \ (dflags_sefi [Occ=Once] :: DynFlags.DynFlags) ->
                  let {
                    sat_sefK [Occ=Once]
                      :: GhcMonad.Ghc
                           (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                            GHC.TypecheckedSource)
                    [LclId, Str=DmdType]
                    sat_sefK =
                      let {
                        mn_sefk :: Module.ModuleName
                        [LclId, Str=DmdType]
                        mn_sefk = Module.mkModuleName fileName_seeY } in
                      let {
                        sat_sefJ [Occ=Once]
                          :: GhcMonad.Ghc
                               (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                GHC.TypecheckedSource)
                        [LclId, Str=DmdType]
                        sat_sefJ =
                          let {
                            sat_sefI [Occ=Once]
                              :: GhcMonad.Ghc
                                   (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                    GHC.TypecheckedSource)
                            [LclId, Str=DmdType]
                            sat_sefI =
                              let {
                                sat_sefH [Occ=Once]
                                  :: HscTypes.ModSummary
                                     -> GhcMonad.Ghc
                                          (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                           GHC.TypecheckedSource)
                                [LclId, Str=DmdType]
                                sat_sefH =
                                  \ (modSum_sefq [Occ=Once] :: HscTypes.ModSummary) ->
                                    let {
                                      sat_sefG [Occ=Once]
                                        :: GHC.ParsedModule
                                           -> GhcMonad.Ghc
                                                (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                 GHC.TypecheckedSource)
                                      [LclId, Str=DmdType]
                                      sat_sefG =
                                        \ (p_sefs :: GHC.ParsedModule) ->
                                          let {
                                            sat_sefF [Occ=Once]
                                              :: GHC.TypecheckedModule
                                                 -> GhcMonad.Ghc
                                                      (GHC.ParsedSource,
                                                       GHC.Base.Maybe GHC.RenamedSource,
                                                       GHC.TypecheckedSource)
                                            [LclId, Str=DmdType]
                                            sat_sefF =
                                              \ (t_sefu [Occ=Once] :: GHC.TypecheckedModule) ->
                                                let {
                                                  sat_sefE [Occ=Once]
                                                    :: GHC.DesugaredModule
                                                       -> GhcMonad.Ghc
                                                            (GHC.ParsedSource,
                                                             GHC.Base.Maybe GHC.RenamedSource,
                                                             GHC.TypecheckedSource)
                                                  [LclId, Str=DmdType]
                                                  sat_sefE =
                                                    \ (d_sefw [Occ=Once] :: GHC.DesugaredModule) ->
                                                      let {
                                                        sat_sefD [Occ=Once]
                                                          :: GHC.DesugaredModule
                                                             -> GhcMonad.Ghc
                                                                  (GHC.ParsedSource,
                                                                   GHC.Base.Maybe GHC.RenamedSource,
                                                                   GHC.TypecheckedSource)
                                                        [LclId, Str=DmdType]
                                                        sat_sefD =
                                                          \ (l_sefy :: GHC.DesugaredModule) ->
                                                            let {
                                                              sat_sefB [Occ=Once]
                                                                :: GHC.TypecheckedSource
                                                              [LclId, Str=DmdType]
                                                              sat_sefB =
                                                                GHC.typecheckedSource
                                                                  @ GHC.DesugaredModule
                                                                  GHC.$fTypecheckedModDesugaredModule
                                                                  l_sefy } in
                                                            let {
                                                              sat_sefA [Occ=Once]
                                                                :: GHC.Base.Maybe GHC.RenamedSource
                                                              [LclId, Str=DmdType]
                                                              sat_sefA =
                                                                GHC.renamedSource
                                                                  @ GHC.DesugaredModule
                                                                  GHC.$fTypecheckedModDesugaredModule
                                                                  l_sefy } in
                                                            let {
                                                              sat_sefz [Occ=Once]
                                                                :: GHC.ParsedSource
                                                              [LclId, Str=DmdType]
                                                              sat_sefz =
                                                                GHC.pm_parsed_source p_sefs } in
                                                            let {
                                                              sat_sefC [Occ=Once]
                                                                :: (GHC.ParsedSource,
                                                                    GHC.Base.Maybe
                                                                      GHC.RenamedSource,
                                                                    GHC.TypecheckedSource)
                                                              [LclId, Str=DmdType]
                                                              sat_sefC =
                                                                (sat_sefz, sat_sefA, sat_sefB) } in
                                                            GHC.Base.return
                                                              @ GhcMonad.Ghc
                                                              GhcMonad.$fMonadGhc
                                                              @ (GHC.ParsedSource,
                                                                 GHC.Base.Maybe GHC.RenamedSource,
                                                                 GHC.TypecheckedSource)
                                                              sat_sefC } in
                                                      let {
                                                        sat_sefx [Occ=Once]
                                                          :: GhcMonad.Ghc GHC.DesugaredModule
                                                        [LclId, Str=DmdType]
                                                        sat_sefx =
                                                          GHC.loadModule
                                                            @ GHC.DesugaredModule
                                                            @ GhcMonad.Ghc
                                                            GHC.$fTypecheckedModDesugaredModule
                                                            GhcMonad.$fGhcMonadGhc
                                                            d_sefw } in
                                                      GHC.Base.>>=
                                                        @ GhcMonad.Ghc
                                                        GhcMonad.$fMonadGhc
                                                        @ GHC.DesugaredModule
                                                        @ (GHC.ParsedSource,
                                                           GHC.Base.Maybe GHC.RenamedSource,
                                                           GHC.TypecheckedSource)
                                                        sat_sefx
                                                        sat_sefD } in
                                                let {
                                                  sat_sefv [Occ=Once]
                                                    :: GhcMonad.Ghc GHC.DesugaredModule
                                                  [LclId, Str=DmdType]
                                                  sat_sefv =
                                                    GHC.desugarModule
                                                      @ GhcMonad.Ghc
                                                      GhcMonad.$fGhcMonadGhc
                                                      t_sefu } in
                                                GHC.Base.>>=
                                                  @ GhcMonad.Ghc
                                                  GhcMonad.$fMonadGhc
                                                  @ GHC.DesugaredModule
                                                  @ (GHC.ParsedSource,
                                                     GHC.Base.Maybe GHC.RenamedSource,
                                                     GHC.TypecheckedSource)
                                                  sat_sefv
                                                  sat_sefE } in
                                          let {
                                            sat_seft [Occ=Once]
                                              :: GhcMonad.Ghc GHC.TypecheckedModule
                                            [LclId, Str=DmdType]
                                            sat_seft =
                                              GHC.typecheckModule
                                                @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc p_sefs } in
                                          GHC.Base.>>=
                                            @ GhcMonad.Ghc
                                            GhcMonad.$fMonadGhc
                                            @ GHC.TypecheckedModule
                                            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                               GHC.TypecheckedSource)
                                            sat_seft
                                            sat_sefF } in
                                    let {
                                      sat_sefr [Occ=Once] :: GhcMonad.Ghc GHC.ParsedModule
                                      [LclId, Str=DmdType]
                                      sat_sefr =
                                        GHC.parseModule
                                          @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc modSum_sefq } in
                                    GHC.Base.>>=
                                      @ GhcMonad.Ghc
                                      GhcMonad.$fMonadGhc
                                      @ GHC.ParsedModule
                                      @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                         GHC.TypecheckedSource)
                                      sat_sefr
                                      sat_sefG } in
                              let {
                                sat_sefp [Occ=Once] :: GhcMonad.Ghc HscTypes.ModSummary
                                [LclId, Str=DmdType]
                                sat_sefp =
                                  GHC.getModSummary
                                    @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc mn_sefk } in
                              GHC.Base.>>=
                                @ GhcMonad.Ghc
                                GhcMonad.$fMonadGhc
                                @ HscTypes.ModSummary
                                @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                   GHC.TypecheckedSource)
                                sat_sefp
                                sat_sefH } in
                          let {
                            sat_sefo [Occ=Once] :: GhcMonad.Ghc BasicTypes.SuccessFlag
                            [LclId, Str=DmdType]
                            sat_sefo =
                              GhcMake.load
                                @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc GhcMake.LoadAllTargets } in
                          GHC.Base.>>
                            @ GhcMonad.Ghc
                            GhcMonad.$fMonadGhc
                            @ BasicTypes.SuccessFlag
                            @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                               GHC.TypecheckedSource)
                            sat_sefo
                            sat_sefI } in
                      let {
                        sat_sefn [Occ=Once] :: GhcMonad.Ghc ()
                        [LclId, Str=DmdType]
                        sat_sefn =
                          let {
                            sat_sefl [Occ=Once] :: HscTypes.TargetId
                            [LclId, Str=DmdType]
                            sat_sefl = HscTypes.TargetModule mn_sefk } in
                          let {
                            sat_sefm [Occ=Once] :: HscTypes.Target
                            [LclId, Str=DmdType]
                            sat_sefm =
                              HscTypes.Target
                                sat_sefl
                                GHC.Types.True
                                (GHC.Base.Nothing
                                   @ (StringBuffer.StringBuffer, Data.Time.Clock.UTC.UTCTime)) } in
                          GHC.addTarget @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc sat_sefm } in
                      GHC.Base.>>
                        @ GhcMonad.Ghc
                        GhcMonad.$fMonadGhc
                        @ ()
                        @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                           GHC.TypecheckedSource)
                        sat_sefn
                        sat_sefJ } in
                  let {
                    sat_sefj [Occ=Once] :: GhcMonad.Ghc [Module.UnitId]
                    [LclId, Str=DmdType]
                    sat_sefj =
                      GHC.setSessionDynFlags
                        @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc dflags_sefi } in
                  GHC.Base.>>
                    @ GhcMonad.Ghc
                    GhcMonad.$fMonadGhc
                    @ [Module.UnitId]
                    @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                       GHC.TypecheckedSource)
                    sat_sefj
                    sat_sefK } in
            let {
              sat_sefh [Occ=Once] :: GhcMonad.Ghc DynFlags.DynFlags
              [LclId, Str=DmdType]
              sat_sefh =
                GhcMonad.getSessionDynFlags
                  @ GhcMonad.Ghc GhcMonad.$fGhcMonadGhc } in
            GHC.Base.>>=
              @ GhcMonad.Ghc
              GhcMonad.$fMonadGhc
              @ DynFlags.DynFlags
              @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                 GHC.TypecheckedSource)
              sat_sefh
              sat_sefL } in
        let {
          sat_sefg [Occ=Once] :: GHC.Base.Maybe GHC.IO.FilePath
          [LclId, Str=DmdType]
          sat_sefg = GHC.Base.Just @ GHC.IO.FilePath libdir_seeX } in
        GHC.runGhc
          @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
             GHC.TypecheckedSource)
          sat_sefg
          sat_sefM } in
    GHC.Base.>>=
      @ GHC.Types.IO
      GHC.Base.$fMonadIO
      @ (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
         GHC.TypecheckedSource)
      @ ()
      sat_sefN
      sat_segp

-- RHS size: {terms: 63, types: 44, coercions: 0}
sat_segK :: [GHC.Base.String] -> GHC.Types.IO ()
[LclId, Str=DmdType]
sat_segK =
  \ (ds_segq [Occ=Once!] :: [GHC.Base.String]) ->
    let {
      fail_segr [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
      [LclId, Arity=1, Str=DmdType, Unf=OtherCon []]
      fail_segr =
        \ _ [Occ=Dead, OS=OneShot] ->
          let {
            sat_segt [Occ=Once] :: GHC.Base.String
            [LclId, Str=DmdType]
            sat_segt =
              GHC.CString.unpackCString#
                "Pattern match failure in do expression at landmines.hs:19:9-16"# } in
          GHC.Base.fail @ GHC.Types.IO GHC.Base.$fMonadIO @ () sat_segt } in
    case ds_segq of _ [Occ=Dead] {
      [] -> fail_segr GHC.Prim.void#;
      : libdir_segv ds1_segw [Occ=Once!] ->
        case ds1_segw of _ [Occ=Dead] {
          [] ->
            let {
              sat_segH [Occ=Once] :: GHC.Types.IO ()
              [LclId, Str=DmdType]
              sat_segH =
                let {
                  sat_segG [Occ=Once] :: GHC.Types.IO ()
                  [LclId, Str=DmdType]
                  sat_segG =
                    let {
                      sat_segF [Occ=Once] :: GHC.Types.IO ()
                      [LclId, Str=DmdType]
                      sat_segF =
                        let {
                          sat_segE [Occ=Once] :: GHC.Base.String
                          [LclId, Str=DmdType]
                          sat_segE = GHC.CString.unpackCString# "MineType"# } in
                        Main.testOneFile libdir_segv sat_segE } in
                    let {
                      sat_segD [Occ=Once] :: GHC.Types.IO ()
                      [LclId, Str=DmdType]
                      sat_segD =
                        let {
                          sat_segC [Occ=Once] :: GHC.Base.String
                          [LclId, Str=DmdType]
                          sat_segC = GHC.CString.unpackCString# "MineNames"# } in
                        Main.testOneFile libdir_segv sat_segC } in
                    GHC.Base.>>
                      @ GHC.Types.IO GHC.Base.$fMonadIO @ () @ () sat_segD sat_segF } in
                let {
                  sat_segB [Occ=Once] :: GHC.Types.IO ()
                  [LclId, Str=DmdType]
                  sat_segB =
                    let {
                      sat_segA [Occ=Once] :: GHC.Base.String
                      [LclId, Str=DmdType]
                      sat_segA = GHC.CString.unpackCString# "MineKind"# } in
                    Main.testOneFile libdir_segv sat_segA } in
                GHC.Base.>>
                  @ GHC.Types.IO GHC.Base.$fMonadIO @ () @ () sat_segB sat_segG } in
            let {
              sat_segz [Occ=Once] :: GHC.Types.IO ()
              [LclId, Str=DmdType]
              sat_segz =
                let {
                  sat_segy [Occ=Once] :: GHC.Base.String
                  [LclId, Str=DmdType]
                  sat_segy = GHC.CString.unpackCString# "MineFixity"# } in
                Main.testOneFile libdir_segv sat_segy } in
            GHC.Base.>>
              @ GHC.Types.IO GHC.Base.$fMonadIO @ () @ () sat_segz sat_segH;
          : _ [Occ=Dead] _ [Occ=Dead] -> fail_segr GHC.Prim.void#
        }
    }

-- RHS size: {terms: 4, types: 4, coercions: 0}
Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType]
Main.main =
  GHC.Base.>>=
    @ GHC.Types.IO
    GHC.Base.$fMonadIO
    @ [GHC.Base.String]
    @ ()
    System.Environment.getArgs
    sat_segK

-- RHS size: {terms: 2, types: 1, coercions: 0}
:Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType]
:Main.main = GHC.TopHandler.runMainIO @ () Main.main




==================== STG syntax: ====================
a_redQ :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] =
    NO_CCS GHC.Types.TrNameS! ["main"#];

a1_reeE :: GHC.Types.TrName
[GblId, Caf=NoCafRefs, Str=DmdType, Unf=OtherCon []] =
    NO_CCS GHC.Types.TrNameS! ["Main"#];

Main.$trModule :: GHC.Types.Module
[GblId[ReflectionId],
 Caf=NoCafRefs,
 Str=DmdType,
 Unf=OtherCon []] =
    NO_CCS GHC.Types.Module! [a_redQ a1_reeE];

Main.mkQ
  :: forall a_a3PP b_a3PQ r_a3PR.
     (Data.Typeable.Internal.Typeable a_a3PP,
      Data.Typeable.Internal.Typeable b_a3PQ) =>
     r_a3PR -> (b_a3PQ -> r_a3PR) -> a_a3PP -> r_a3PR
[GblId, Arity=5, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[rrT :-> Data.Typeable.cast] [$dTypeable_seeH
                                             $dTypeable1_seeI
                                             r1_seeJ
                                             br_seeK
                                             a3_seeL]
        case
            Data.Typeable.cast $dTypeable_seeH $dTypeable1_seeI a3_seeL
        of
        _ [Occ=Dead]
        { GHC.Base.Nothing -> r1_seeJ;
          GHC.Base.Just b1_seeN [Occ=Once] -> br_seeK b1_seeN;
        };

Main.everything [Occ=LoopBreaker]
  :: forall r_a3PO.
     (r_a3PO -> r_a3PO -> r_a3PO)
     -> Main.GenericQ r_a3PO -> Main.GenericQ r_a3PO
[GblId, Arity=4, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[r1u0 :-> Data.Foldable.$fFoldable[],
                r3PK :-> Main.everything] [dk_seeO dk1_seeP $dData_seeQ x_seeR]
        let {
          sat_seeW [Occ=Once] :: [r_a4XV]
          [LclId, Str=DmdType] =
              \u srt:SRT:[r3PK :-> Main.everything] []
                  let {
                    sat_seeV [Occ=Once]
                      :: forall d_a567. Data.Data.Data d_a567 => d_a567 -> r_a4XV
                    [LclId, Str=DmdType] =
                        \r srt:SRT:[r3PK :-> Main.everything] [$dData1_seeT eta_seeU]
                            Main.everything dk_seeO dk1_seeP $dData1_seeT eta_seeU;
                  } in  Data.Data.gmapQ $dData_seeQ sat_seeV x_seeR; } in
        let {
          sat_seeS [Occ=Once] :: r_a4XV
          [LclId, Str=DmdType] =
              \u srt:SRT:[] [] dk1_seeP $dData_seeQ x_seeR;
        } in 
          Data.Foldable.foldl
              Data.Foldable.$fFoldable[] dk_seeO sat_seeS sat_seeW;

$dShow_reeF
  :: GHC.Show.Show (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
[GblId, Str=DmdType] =
    \u srt:SRT:[r3io :-> GHC.Show.$fShowInt,
                rdUI :-> GHC.Show.$fShow(,,)] []
        GHC.Show.$fShow(,,)
            GHC.Show.$fShowInt GHC.Show.$fShowInt GHC.Show.$fShowInt;

Main.testOneFile
  :: GHC.IO.FilePath -> GHC.Base.String -> GHC.Types.IO ()
[GblId, Arity=2, Str=DmdType, Unf=OtherCon []] =
    \r srt:SRT:[03 :-> GHC.Base.++, 0B :-> System.IO.print,
                088 :-> Data.Typeable.Internal.mkPolyTyConApp,
                r3K :-> Data.Data.$fData(,,,), ri7 :-> Data.Data.$fDataMaybe,
                rl9 :-> Data.Data.$fData[], rmD :-> Data.Data.$fDataBool,
                rrT :-> Data.Typeable.cast,
                rWH :-> GHC.$fTypecheckedModDesugaredModule,
                r1aO :-> GHC.pm_parsed_source, r1iV :-> Module.mkModuleName,
                r1pc :-> GhcMonad.getSessionDynFlags, r1pf :-> GhcMake.load,
                r1pj :-> GHC.typecheckModule, r1pm :-> GHC.setSessionDynFlags,
                r1pr :-> GHC.runGhc, r1pv :-> GHC.parseModule,
                r1pP :-> GHC.loadModule, r1q2 :-> GHC.getModSummary,
                r1qb :-> GHC.desugarModule, r1qh :-> GHC.addTarget,
                r1u0 :-> Data.Foldable.$fFoldable[], r1Oj :-> Bag.$fDataBag,
                r3wD :-> GHC.Base.$fMonadIO, r3PK :-> Main.everything,
                r41P :-> SrcLoc.$fDataSrcSpan, r41R :-> SrcLoc.$fDataGenLocated,
                r44A :-> SrcLoc.$tcSrcSpan, r4br :-> GhcMonad.$fGhcMonadGhc,
                r4c0 :-> GhcMonad.$fMonadGhc, r9Hn :-> BasicTypes.$fDataFixity,
                ral8 :-> HsDecls.$fDataHsGroup, raH7 :-> HsDoc.$fDataHsDocString,
                rbby :-> Name.$fDataName, rbiI :-> HsImpExp.$fDataImportDecl,
                rbjT :-> HsImpExp.$fDataIE, rbrp :-> UniqFM.$fDataUniqFM,
                rbwC :-> Var.$fDataVar, rbzZ :-> HsBinds.$fDataHsBindLR,
                rbA4 :-> PlaceHolder.$fDataPlaceHolder,
                rbDq :-> TcEvidence.$fDataHsWrapper, rbWw :-> HsSyn.$fDataHsModule,
                rbZp :-> RdrName.$fDataRdrName, rcfc :-> TypeRep.$fDataType,
                rcnh :-> Coercion.$fDataCoercion, rcxl :-> ConLike.$fDataConLike,
                rcRi :-> FieldLabel.$fDataFieldLbl,
                reeF :-> $dShow_reeF] [libdir_seeX fileName_seeY]
        let {
          gq_seeZ
            :: forall a2_a5bd.
               Data.Data.Data a2_a5bd =>
               a2_a5bd -> GHC.Types.Int
          [LclId, Arity=2, Str=DmdType, Unf=OtherCon []] =
              sat-only \r srt:SRT:[03 :-> GHC.Base.++,
                                   088 :-> Data.Typeable.Internal.mkPolyTyConApp,
                                   rrT :-> Data.Typeable.cast, r1u0 :-> Data.Foldable.$fFoldable[],
                                   r3PK :-> Main.everything,
                                   r44A :-> SrcLoc.$tcSrcSpan] [$dData_sef0 ast_sef1]
                  let {
                    sat_seff [Occ=Once] :: [SrcLoc.SrcSpan]
                    [LclId, Str=DmdType] =
                        \u srt:SRT:[03 :-> GHC.Base.++,
                                    088 :-> Data.Typeable.Internal.mkPolyTyConApp,
                                    rrT :-> Data.Typeable.cast, r3PK :-> Main.everything,
                                    r44A :-> SrcLoc.$tcSrcSpan] []
                            let {
                              sat_sefe [Occ=Once] :: Main.GenericQ [SrcLoc.SrcSpan]
                              [LclId, Str=DmdType] =
                                  \r srt:SRT:[088 :-> Data.Typeable.Internal.mkPolyTyConApp,
                                              rrT :-> Data.Typeable.cast,
                                              r44A :-> SrcLoc.$tcSrcSpan] [$dData1_sef2]
                                      let {
                                        $dTypeable_sef3 [Occ=OnceL]
                                          :: Data.Typeable.Internal.Typeable a3_a5bk
                                        [LclId, Str=DmdType] =
                                            \u srt:SRT:[] [] Data.Data.$p1Data $dData1_sef2; } in
                                      let {
                                        ds_sef4 [Occ=OnceL] :: Data.Typeable.Internal.TypeRep
                                        [LclId, Str=DmdType] =
                                            \u srt:SRT:[088 :-> Data.Typeable.Internal.mkPolyTyConApp,
                                                        r44A :-> SrcLoc.$tcSrcSpan] []
                                                Data.Typeable.Internal.mkPolyTyConApp
                                                    SrcLoc.$tcSrcSpan
                                                    GHC.Types.[]
                                                    GHC.Types.[]; } in
                                      let {
                                        a4_sef5 [Occ=OnceL]
                                          :: GHC.Prim.Proxy# SrcLoc.SrcSpan
                                             -> Data.Typeable.Internal.TypeRep
                                        [LclId, Arity=1, Str=DmdType, Unf=OtherCon []] =
                                            \r srt:SRT:[] [wild_sef6] ds_sef4; } in
                                      let {
                                        sat_sefd [Occ=Once] :: a3_a5bk -> [SrcLoc.SrcSpan]
                                        [LclId, Str=DmdType] =
                                            \r srt:SRT:[rrT :-> Data.Typeable.cast] [a5_sef7]
                                                case
                                                    Data.Typeable.cast
                                                        $dTypeable_sef3 a4_sef5 a5_sef7
                                                of
                                                _ [Occ=Dead]
                                                { GHC.Base.Nothing -> [] [];
                                                  GHC.Base.Just b_sef9 [Occ=Once!] ->
                                                      case b_sef9 of wild1_sefa {
                                                        SrcLoc.RealSrcSpan _ [Occ=Dead] ->
                                                            : [wild1_sefa GHC.Types.[]];
                                                        SrcLoc.UnhelpfulSpan _ [Occ=Dead] -> [] [];
                                                      };
                                                };
                                      } in  sat_sefd;
                            } in  Main.everything GHC.Base.++ sat_sefe $dData_sef0 ast_sef1;
                  } in 
                    Data.Foldable.length Data.Foldable.$fFoldable[] sat_seff; } in
        let {
          sat_segp [Occ=Once]
            :: (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                GHC.TypecheckedSource)
               -> GHC.Types.IO ()
          [LclId, Str=DmdType] =
              \r srt:SRT:[0B :-> System.IO.print, r3K :-> Data.Data.$fData(,,,),
                          ri7 :-> Data.Data.$fDataMaybe, rl9 :-> Data.Data.$fData[],
                          rmD :-> Data.Data.$fDataBool, r1Oj :-> Bag.$fDataBag,
                          r41P :-> SrcLoc.$fDataSrcSpan, r41R :-> SrcLoc.$fDataGenLocated,
                          r9Hn :-> BasicTypes.$fDataFixity, ral8 :-> HsDecls.$fDataHsGroup,
                          raH7 :-> HsDoc.$fDataHsDocString, rbby :-> Name.$fDataName,
                          rbiI :-> HsImpExp.$fDataImportDecl, rbjT :-> HsImpExp.$fDataIE,
                          rbrp :-> UniqFM.$fDataUniqFM, rbwC :-> Var.$fDataVar,
                          rbzZ :-> HsBinds.$fDataHsBindLR,
                          rbA4 :-> PlaceHolder.$fDataPlaceHolder,
                          rbDq :-> TcEvidence.$fDataHsWrapper, rbWw :-> HsSyn.$fDataHsModule,
                          rbZp :-> RdrName.$fDataRdrName, rcfc :-> TypeRep.$fDataType,
                          rcnh :-> Coercion.$fDataCoercion, rcxl :-> ConLike.$fDataConLike,
                          rcRi :-> FieldLabel.$fDataFieldLbl, reeF :-> $dShow_reeF] [ds_sefO]
                  case ds_sefO of _ [Occ=Dead] {
                    (,,) p_sefQ [Occ=Once] r_sefR [Occ=Once] ts_sefS [Occ=Once] ->
                        let {
                          sat_segn [Occ=Once] :: GHC.Types.Int
                          [LclId, Str=DmdType] =
                              \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                          rmD :-> Data.Data.$fDataBool, r1Oj :-> Bag.$fDataBag,
                                          r41P :-> SrcLoc.$fDataSrcSpan,
                                          r41R :-> SrcLoc.$fDataGenLocated,
                                          r9Hn :-> BasicTypes.$fDataFixity,
                                          rbby :-> Name.$fDataName, rbrp :-> UniqFM.$fDataUniqFM,
                                          rbwC :-> Var.$fDataVar, rbzZ :-> HsBinds.$fDataHsBindLR,
                                          rbDq :-> TcEvidence.$fDataHsWrapper,
                                          rcfc :-> TypeRep.$fDataType,
                                          rcnh :-> Coercion.$fDataCoercion,
                                          rcxl :-> ConLike.$fDataConLike,
                                          rcRi :-> FieldLabel.$fDataFieldLbl] []
                                  let {
                                    $dData_segd :: Data.Data.Data [ConLike.ConLike]
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                    rcxl :-> ConLike.$fDataConLike] []
                                            Data.Data.$fData[] ConLike.$fDataConLike; } in
                                  let {
                                    $dData1_sege :: Data.Data.Data [TypeRep.Type]
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                    rcfc :-> TypeRep.$fDataType] []
                                            Data.Data.$fData[] TypeRep.$fDataType; } in
                                  let {
                                    $dData2_segf :: Data.Data.Data [Name.Name]
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                    rbby :-> Name.$fDataName] []
                                            Data.Data.$fData[] Name.$fDataName; } in
                                  let {
                                    $dData3_segg :: Data.Data.Data (FieldLabel.FieldLbl Name.Name)
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rbby :-> Name.$fDataName,
                                                    rcRi :-> FieldLabel.$fDataFieldLbl] []
                                            FieldLabel.$fDataFieldLbl Name.$fDataName; } in
                                  let {
                                    $dData4_segh :: Data.Data.Data [FieldLabel.FieldLabel]
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rl9 :-> Data.Data.$fData[]] []
                                            Data.Data.$fData[] $dData3_segg; } in
                                  let {
                                    $dData5_segi :: Data.Data.Data (UniqFM.UniqFM Name.Name)
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[rbby :-> Name.$fDataName,
                                                    rbrp :-> UniqFM.$fDataUniqFM] []
                                            UniqFM.$fDataUniqFM Name.$fDataName; } in
                                  let {
                                    $d(%,,,,,,,,,,,,,%)_segj
                                      :: (Data.Data.Data Var.Var,
                                          Data.Data.Data (UniqFM.UniqFM Name.Name),
                                          Data.Data.Data BasicTypes.Fixity,
                                          Data.Data.Data GHC.Types.Bool, Data.Data.Data Name.Name,
                                          Data.Data.Data [Name.Name], Data.Data.Data Var.Var,
                                          Data.Data.Data TypeRep.Type,
                                          Data.Data.Data Coercion.Coercion, Data.Data.Data Var.Var,
                                          Data.Data.Data [TypeRep.Type],
                                          Data.Data.Data [ConLike.ConLike],
                                          Data.Data.Data TcEvidence.HsWrapper,
                                          Data.Data.Data [FieldLabel.FieldLabel])
                                    [LclId, Str=DmdType, Unf=OtherCon []] =
                                        NO_CCS GHC.Classes.D:(%,,,,,,,,,,,,,%)! [Var.$fDataVar
                                                                                 $dData5_segi
                                                                                 BasicTypes.$fDataFixity
                                                                                 Data.Data.$fDataBool
                                                                                 Name.$fDataName
                                                                                 $dData2_segf
                                                                                 Var.$fDataVar
                                                                                 TypeRep.$fDataType
                                                                                 Coercion.$fDataCoercion
                                                                                 Var.$fDataVar
                                                                                 $dData1_sege
                                                                                 $dData_segd
                                                                                 TcEvidence.$fDataHsWrapper
                                                                                 $dData4_segh]; } in
                                  let {
                                    sat_segm [Occ=Once] :: Data.Data.Data GHC.TypecheckedSource
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[r1Oj :-> Bag.$fDataBag,
                                                    r41P :-> SrcLoc.$fDataSrcSpan,
                                                    r41R :-> SrcLoc.$fDataGenLocated,
                                                    rbzZ :-> HsBinds.$fDataHsBindLR] []
                                            let {
                                              sat_segl [Occ=Once]
                                                :: Data.Data.Data
                                                     (SrcLoc.GenLocated
                                                        SrcLoc.SrcSpan
                                                        (HsBinds.HsBindLR Var.Id Var.Id))
                                              [LclId, Str=DmdType] =
                                                  \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                                              r41R :-> SrcLoc.$fDataGenLocated,
                                                              rbzZ :-> HsBinds.$fDataHsBindLR] []
                                                      let {
                                                        sat_segk [Occ=Once]
                                                          :: Data.Data.Data
                                                               (HsBinds.HsBindLR Var.Id Var.Id)
                                                        [LclId, Str=DmdType] =
                                                            \u srt:SRT:[rbzZ :-> HsBinds.$fDataHsBindLR] []
                                                                HsBinds.$fDataHsBindLR
                                                                    $d(%,,,,,,,,,,,,,%)_segj
                                                                    $d(%,,,,,,,,,,,,,%)_segj;
                                                      } in 
                                                        SrcLoc.$fDataGenLocated
                                                            SrcLoc.$fDataSrcSpan sat_segk;
                                            } in  Bag.$fDataBag sat_segl;
                                  } in  gq_seeZ sat_segm ts_sefS; } in
                        let {
                          sat_segc [Occ=Once] :: GHC.Types.Int
                          [LclId, Str=DmdType] =
                              \u srt:SRT:[r3K :-> Data.Data.$fData(,,,),
                                          ri7 :-> Data.Data.$fDataMaybe, rl9 :-> Data.Data.$fData[],
                                          rmD :-> Data.Data.$fDataBool,
                                          r41P :-> SrcLoc.$fDataSrcSpan,
                                          r41R :-> SrcLoc.$fDataGenLocated,
                                          r9Hn :-> BasicTypes.$fDataFixity,
                                          ral8 :-> HsDecls.$fDataHsGroup,
                                          raH7 :-> HsDoc.$fDataHsDocString,
                                          rbby :-> Name.$fDataName,
                                          rbiI :-> HsImpExp.$fDataImportDecl,
                                          rbjT :-> HsImpExp.$fDataIE, rbrp :-> UniqFM.$fDataUniqFM,
                                          rbA4 :-> PlaceHolder.$fDataPlaceHolder] []
                                  let {
                                    sat_segb [Occ=Once]
                                      :: Data.Data.Data (GHC.Base.Maybe GHC.RenamedSource)
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[r3K :-> Data.Data.$fData(,,,),
                                                    ri7 :-> Data.Data.$fDataMaybe,
                                                    rl9 :-> Data.Data.$fData[],
                                                    rmD :-> Data.Data.$fDataBool,
                                                    r41P :-> SrcLoc.$fDataSrcSpan,
                                                    r41R :-> SrcLoc.$fDataGenLocated,
                                                    r9Hn :-> BasicTypes.$fDataFixity,
                                                    ral8 :-> HsDecls.$fDataHsGroup,
                                                    raH7 :-> HsDoc.$fDataHsDocString,
                                                    rbby :-> Name.$fDataName,
                                                    rbiI :-> HsImpExp.$fDataImportDecl,
                                                    rbjT :-> HsImpExp.$fDataIE,
                                                    rbrp :-> UniqFM.$fDataUniqFM,
                                                    rbA4 :-> PlaceHolder.$fDataPlaceHolder] []
                                            let {
                                              sat_sega [Occ=Once]
                                                :: Data.Data.Data
                                                     (HsDecls.HsGroup Name.Name,
                                                      [HsImpExp.LImportDecl Name.Name],
                                                      GHC.Base.Maybe [HsImpExp.LIE Name.Name],
                                                      GHC.Base.Maybe HsDoc.LHsDocString)
                                              [LclId, Str=DmdType] =
                                                  \u srt:SRT:[r3K :-> Data.Data.$fData(,,,),
                                                              ri7 :-> Data.Data.$fDataMaybe,
                                                              rl9 :-> Data.Data.$fData[],
                                                              rmD :-> Data.Data.$fDataBool,
                                                              r41P :-> SrcLoc.$fDataSrcSpan,
                                                              r41R :-> SrcLoc.$fDataGenLocated,
                                                              r9Hn :-> BasicTypes.$fDataFixity,
                                                              ral8 :-> HsDecls.$fDataHsGroup,
                                                              raH7 :-> HsDoc.$fDataHsDocString,
                                                              rbby :-> Name.$fDataName,
                                                              rbiI :-> HsImpExp.$fDataImportDecl,
                                                              rbjT :-> HsImpExp.$fDataIE,
                                                              rbrp :-> UniqFM.$fDataUniqFM,
                                                              rbA4 :-> PlaceHolder.$fDataPlaceHolder] []
                                                      let {
                                                        sat_seg9 [Occ=Once]
                                                          :: Data.Data.Data
                                                               (GHC.Base.Maybe HsDoc.LHsDocString)
                                                        [LclId, Str=DmdType] =
                                                            \u srt:SRT:[ri7 :-> Data.Data.$fDataMaybe,
                                                                        r41P :-> SrcLoc.$fDataSrcSpan,
                                                                        r41R :-> SrcLoc.$fDataGenLocated,
                                                                        raH7 :-> HsDoc.$fDataHsDocString] []
                                                                let {
                                                                  sat_seg8 [Occ=Once]
                                                                    :: Data.Data.Data
                                                                         (SrcLoc.GenLocated
                                                                            SrcLoc.SrcSpan
                                                                            HsDoc.HsDocString)
                                                                  [LclId, Str=DmdType] =
                                                                      \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                                                                  r41R :-> SrcLoc.$fDataGenLocated,
                                                                                  raH7 :-> HsDoc.$fDataHsDocString] []
                                                                          SrcLoc.$fDataGenLocated
                                                                              SrcLoc.$fDataSrcSpan
                                                                              HsDoc.$fDataHsDocString;
                                                                } in 
                                                                  Data.Data.$fDataMaybe
                                                                      sat_seg8; } in
                                                      let {
                                                        sat_seg7 [Occ=Once]
                                                          :: Data.Data.Data
                                                               (GHC.Base.Maybe
                                                                  [HsImpExp.LIE Name.Name])
                                                        [LclId, Str=DmdType] =
                                                            \u srt:SRT:[ri7 :-> Data.Data.$fDataMaybe,
                                                                        rl9 :-> Data.Data.$fData[],
                                                                        r41P :-> SrcLoc.$fDataSrcSpan,
                                                                        r41R :-> SrcLoc.$fDataGenLocated,
                                                                        rbby :-> Name.$fDataName,
                                                                        rbjT :-> HsImpExp.$fDataIE] []
                                                                let {
                                                                  sat_seg6 [Occ=Once]
                                                                    :: Data.Data.Data
                                                                         [HsImpExp.LIE Name.Name]
                                                                  [LclId, Str=DmdType] =
                                                                      \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                                                  r41P :-> SrcLoc.$fDataSrcSpan,
                                                                                  r41R :-> SrcLoc.$fDataGenLocated,
                                                                                  rbby :-> Name.$fDataName,
                                                                                  rbjT :-> HsImpExp.$fDataIE] []
                                                                          let {
                                                                            sat_seg5 [Occ=Once]
                                                                              :: Data.Data.Data
                                                                                   (SrcLoc.GenLocated
                                                                                      SrcLoc.SrcSpan
                                                                                      (HsImpExp.IE
                                                                                         Name.Name))
                                                                            [LclId, Str=DmdType] =
                                                                                \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                                                                            r41R :-> SrcLoc.$fDataGenLocated,
                                                                                            rbby :-> Name.$fDataName,
                                                                                            rbjT :-> HsImpExp.$fDataIE] []
                                                                                    let {
                                                                                      sat_seg4 [Occ=Once]
                                                                                        :: Data.Data.Data
                                                                                             (HsImpExp.IE
                                                                                                Name.Name)
                                                                                      [LclId,
                                                                                       Str=DmdType] =
                                                                                          \u srt:SRT:[rbby :-> Name.$fDataName,
                                                                                                      rbjT :-> HsImpExp.$fDataIE] []
                                                                                              HsImpExp.$fDataIE
                                                                                                  Name.$fDataName;
                                                                                    } in 
                                                                                      SrcLoc.$fDataGenLocated
                                                                                          SrcLoc.$fDataSrcSpan
                                                                                          sat_seg4;
                                                                          } in 
                                                                            Data.Data.$fData[]
                                                                                sat_seg5;
                                                                } in 
                                                                  Data.Data.$fDataMaybe
                                                                      sat_seg6; } in
                                                      let {
                                                        sat_seg3 [Occ=Once]
                                                          :: Data.Data.Data
                                                               [HsImpExp.LImportDecl Name.Name]
                                                        [LclId, Str=DmdType] =
                                                            \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                                        r41P :-> SrcLoc.$fDataSrcSpan,
                                                                        r41R :-> SrcLoc.$fDataGenLocated,
                                                                        rbby :-> Name.$fDataName,
                                                                        rbiI :-> HsImpExp.$fDataImportDecl] []
                                                                let {
                                                                  sat_seg2 [Occ=Once]
                                                                    :: Data.Data.Data
                                                                         (SrcLoc.GenLocated
                                                                            SrcLoc.SrcSpan
                                                                            (HsImpExp.ImportDecl
                                                                               Name.Name))
                                                                  [LclId, Str=DmdType] =
                                                                      \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                                                                  r41R :-> SrcLoc.$fDataGenLocated,
                                                                                  rbby :-> Name.$fDataName,
                                                                                  rbiI :-> HsImpExp.$fDataImportDecl] []
                                                                          let {
                                                                            sat_seg1 [Occ=Once]
                                                                              :: Data.Data.Data
                                                                                   (HsImpExp.ImportDecl
                                                                                      Name.Name)
                                                                            [LclId, Str=DmdType] =
                                                                                \u srt:SRT:[rbby :-> Name.$fDataName,
                                                                                            rbiI :-> HsImpExp.$fDataImportDecl] []
                                                                                    HsImpExp.$fDataImportDecl
                                                                                        Name.$fDataName;
                                                                          } in 
                                                                            SrcLoc.$fDataGenLocated
                                                                                SrcLoc.$fDataSrcSpan
                                                                                sat_seg1;
                                                                } in 
                                                                  Data.Data.$fData[] sat_seg2; } in
                                                      let {
                                                        sat_seg0 [Occ=Once]
                                                          :: Data.Data.Data
                                                               (HsDecls.HsGroup Name.Name)
                                                        [LclId, Str=DmdType] =
                                                            \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                                        rmD :-> Data.Data.$fDataBool,
                                                                        r9Hn :-> BasicTypes.$fDataFixity,
                                                                        ral8 :-> HsDecls.$fDataHsGroup,
                                                                        rbby :-> Name.$fDataName,
                                                                        rbrp :-> UniqFM.$fDataUniqFM,
                                                                        rbA4 :-> PlaceHolder.$fDataPlaceHolder] []
                                                                let {
                                                                  sat_sefY [Occ=Once]
                                                                    :: Data.Data.Data [Name.Name]
                                                                  [LclId, Str=DmdType] =
                                                                      \u srt:SRT:[rl9 :-> Data.Data.$fData[],
                                                                                  rbby :-> Name.$fDataName] []
                                                                          Data.Data.$fData[]
                                                                              Name.$fDataName; } in
                                                                let {
                                                                  sat_sefX [Occ=Once]
                                                                    :: Data.Data.Data
                                                                         (UniqFM.UniqFM Name.Name)
                                                                  [LclId, Str=DmdType] =
                                                                      \u srt:SRT:[rbby :-> Name.$fDataName,
                                                                                  rbrp :-> UniqFM.$fDataUniqFM] []
                                                                          UniqFM.$fDataUniqFM
                                                                              Name.$fDataName; } in
                                                                let {
                                                                  sat_sefZ [Occ=Once]
                                                                    :: PlaceHolder.DataId Name.Name
                                                                  [LclId, Str=DmdType] =
                                                                      NO_CCS GHC.Classes.D:(%,,,,,,,,,,,,,%)! [Name.$fDataName
                                                                                                               sat_sefX
                                                                                                               BasicTypes.$fDataFixity
                                                                                                               Data.Data.$fDataBool
                                                                                                               Name.$fDataName
                                                                                                               sat_sefY
                                                                                                               Name.$fDataName
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder
                                                                                                               PlaceHolder.$fDataPlaceHolder];
                                                                } in 
                                                                  HsDecls.$fDataHsGroup sat_sefZ;
                                                      } in 
                                                        Data.Data.$fData(,,,)
                                                            sat_seg0 sat_seg3 sat_seg7 sat_seg9;
                                            } in  Data.Data.$fDataMaybe sat_sega;
                                  } in  gq_seeZ sat_segb r_sefR; } in
                        let {
                          sat_sefW [Occ=Once] :: GHC.Types.Int
                          [LclId, Str=DmdType] =
                              \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                          r41R :-> SrcLoc.$fDataGenLocated,
                                          rbA4 :-> PlaceHolder.$fDataPlaceHolder,
                                          rbWw :-> HsSyn.$fDataHsModule,
                                          rbZp :-> RdrName.$fDataRdrName] []
                                  let {
                                    sat_sefV [Occ=Once] :: Data.Data.Data GHC.ParsedSource
                                    [LclId, Str=DmdType] =
                                        \u srt:SRT:[r41P :-> SrcLoc.$fDataSrcSpan,
                                                    r41R :-> SrcLoc.$fDataGenLocated,
                                                    rbA4 :-> PlaceHolder.$fDataPlaceHolder,
                                                    rbWw :-> HsSyn.$fDataHsModule,
                                                    rbZp :-> RdrName.$fDataRdrName] []
                                            let {
                                              sat_sefU [Occ=Once]
                                                :: Data.Data.Data (HsSyn.HsModule RdrName.RdrName)
                                              [LclId, Str=DmdType] =
                                                  \u srt:SRT:[rbA4 :-> PlaceHolder.$fDataPlaceHolder,
                                                              rbWw :-> HsSyn.$fDataHsModule,
                                                              rbZp :-> RdrName.$fDataRdrName] []
                                                      let {
                                                        sat_sefT [Occ=Once]
                                                          :: PlaceHolder.DataId RdrName.RdrName
                                                        [LclId, Str=DmdType] =
                                                            NO_CCS GHC.Classes.D:(%,,,,,,,,,,,,,%)! [RdrName.$fDataRdrName
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder
                                                                                                     PlaceHolder.$fDataPlaceHolder];
                                                      } in  HsSyn.$fDataHsModule sat_sefT;
                                            } in 
                                              SrcLoc.$fDataGenLocated SrcLoc.$fDataSrcSpan sat_sefU;
                                  } in  gq_seeZ sat_sefV p_sefQ; } in
                        let {
                          sat_sego [Occ=Once]
                            :: (GHC.Types.Int, GHC.Types.Int, GHC.Types.Int)
                          [LclId, Str=DmdType] =
                              NO_CCS (,,)! [sat_sefW sat_segc sat_segn];
                        } in  System.IO.print $dShow_reeF sat_sego;
                  }; } in
        let {
          sat_sefN [Occ=Once]
            :: GHC.Types.IO
                 (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                  GHC.TypecheckedSource)
          [LclId, Str=DmdType] =
              \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                          r1aO :-> GHC.pm_parsed_source, r1iV :-> Module.mkModuleName,
                          r1pc :-> GhcMonad.getSessionDynFlags, r1pf :-> GhcMake.load,
                          r1pj :-> GHC.typecheckModule, r1pm :-> GHC.setSessionDynFlags,
                          r1pr :-> GHC.runGhc, r1pv :-> GHC.parseModule,
                          r1pP :-> GHC.loadModule, r1q2 :-> GHC.getModSummary,
                          r1qb :-> GHC.desugarModule, r1qh :-> GHC.addTarget,
                          r4br :-> GhcMonad.$fGhcMonadGhc, r4c0 :-> GhcMonad.$fMonadGhc] []
                  let {
                    sat_sefM [Occ=Once]
                      :: GhcMonad.Ghc
                           (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                            GHC.TypecheckedSource)
                    [LclId, Str=DmdType] =
                        \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                    r1aO :-> GHC.pm_parsed_source, r1iV :-> Module.mkModuleName,
                                    r1pc :-> GhcMonad.getSessionDynFlags, r1pf :-> GhcMake.load,
                                    r1pj :-> GHC.typecheckModule, r1pm :-> GHC.setSessionDynFlags,
                                    r1pv :-> GHC.parseModule, r1pP :-> GHC.loadModule,
                                    r1q2 :-> GHC.getModSummary, r1qb :-> GHC.desugarModule,
                                    r1qh :-> GHC.addTarget, r4br :-> GhcMonad.$fGhcMonadGhc,
                                    r4c0 :-> GhcMonad.$fMonadGhc] []
                            let {
                              sat_sefL [Occ=Once]
                                :: DynFlags.DynFlags
                                   -> GhcMonad.Ghc
                                        (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                         GHC.TypecheckedSource)
                              [LclId, Str=DmdType] =
                                  \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                              r1aO :-> GHC.pm_parsed_source,
                                              r1iV :-> Module.mkModuleName, r1pf :-> GhcMake.load,
                                              r1pj :-> GHC.typecheckModule,
                                              r1pm :-> GHC.setSessionDynFlags,
                                              r1pv :-> GHC.parseModule, r1pP :-> GHC.loadModule,
                                              r1q2 :-> GHC.getModSummary,
                                              r1qb :-> GHC.desugarModule, r1qh :-> GHC.addTarget,
                                              r4br :-> GhcMonad.$fGhcMonadGhc,
                                              r4c0 :-> GhcMonad.$fMonadGhc] [dflags_sefi]
                                      let {
                                        sat_sefK [Occ=Once]
                                          :: GhcMonad.Ghc
                                               (GHC.ParsedSource, GHC.Base.Maybe GHC.RenamedSource,
                                                GHC.TypecheckedSource)
                                        [LclId, Str=DmdType] =
                                            \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                        r1aO :-> GHC.pm_parsed_source,
                                                        r1iV :-> Module.mkModuleName,
                                                        r1pf :-> GhcMake.load,
                                                        r1pj :-> GHC.typecheckModule,
                                                        r1pv :-> GHC.parseModule,
                                                        r1pP :-> GHC.loadModule,
                                                        r1q2 :-> GHC.getModSummary,
                                                        r1qb :-> GHC.desugarModule,
                                                        r1qh :-> GHC.addTarget,
                                                        r4br :-> GhcMonad.$fGhcMonadGhc,
                                                        r4c0 :-> GhcMonad.$fMonadGhc] []
                                                let {
                                                  mn_sefk :: Module.ModuleName
                                                  [LclId, Str=DmdType] =
                                                      \u srt:SRT:[r1iV :-> Module.mkModuleName] []
                                                          Module.mkModuleName fileName_seeY; } in
                                                let {
                                                  sat_sefJ [Occ=Once]
                                                    :: GhcMonad.Ghc
                                                         (GHC.ParsedSource,
                                                          GHC.Base.Maybe GHC.RenamedSource,
                                                          GHC.TypecheckedSource)
                                                  [LclId, Str=DmdType] =
                                                      \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                  r1aO :-> GHC.pm_parsed_source,
                                                                  r1pf :-> GhcMake.load,
                                                                  r1pj :-> GHC.typecheckModule,
                                                                  r1pv :-> GHC.parseModule,
                                                                  r1pP :-> GHC.loadModule,
                                                                  r1q2 :-> GHC.getModSummary,
                                                                  r1qb :-> GHC.desugarModule,
                                                                  r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                  r4c0 :-> GhcMonad.$fMonadGhc] []
                                                          let {
                                                            sat_sefI [Occ=Once]
                                                              :: GhcMonad.Ghc
                                                                   (GHC.ParsedSource,
                                                                    GHC.Base.Maybe
                                                                      GHC.RenamedSource,
                                                                    GHC.TypecheckedSource)
                                                            [LclId, Str=DmdType] =
                                                                \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                            r1aO :-> GHC.pm_parsed_source,
                                                                            r1pj :-> GHC.typecheckModule,
                                                                            r1pv :-> GHC.parseModule,
                                                                            r1pP :-> GHC.loadModule,
                                                                            r1q2 :-> GHC.getModSummary,
                                                                            r1qb :-> GHC.desugarModule,
                                                                            r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                            r4c0 :-> GhcMonad.$fMonadGhc] []
                                                                    let {
                                                                      sat_sefH [Occ=Once]
                                                                        :: HscTypes.ModSummary
                                                                           -> GhcMonad.Ghc
                                                                                (GHC.ParsedSource,
                                                                                 GHC.Base.Maybe
                                                                                   GHC.RenamedSource,
                                                                                 GHC.TypecheckedSource)
                                                                      [LclId, Str=DmdType] =
                                                                          \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                      r1aO :-> GHC.pm_parsed_source,
                                                                                      r1pj :-> GHC.typecheckModule,
                                                                                      r1pv :-> GHC.parseModule,
                                                                                      r1pP :-> GHC.loadModule,
                                                                                      r1qb :-> GHC.desugarModule,
                                                                                      r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                                      r4c0 :-> GhcMonad.$fMonadGhc] [modSum_sefq]
                                                                              let {
                                                                                sat_sefG [Occ=Once]
                                                                                  :: GHC.ParsedModule
                                                                                     -> GhcMonad.Ghc
                                                                                          (GHC.ParsedSource,
                                                                                           GHC.Base.Maybe
                                                                                             GHC.RenamedSource,
                                                                                           GHC.TypecheckedSource)
                                                                                [LclId,
                                                                                 Str=DmdType] =
                                                                                    \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                                r1aO :-> GHC.pm_parsed_source,
                                                                                                r1pj :-> GHC.typecheckModule,
                                                                                                r1pP :-> GHC.loadModule,
                                                                                                r1qb :-> GHC.desugarModule,
                                                                                                r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                                                r4c0 :-> GhcMonad.$fMonadGhc] [p_sefs]
                                                                                        let {
                                                                                          sat_sefF [Occ=Once]
                                                                                            :: GHC.TypecheckedModule
                                                                                               -> GhcMonad.Ghc
                                                                                                    (GHC.ParsedSource,
                                                                                                     GHC.Base.Maybe
                                                                                                       GHC.RenamedSource,
                                                                                                     GHC.TypecheckedSource)
                                                                                          [LclId,
                                                                                           Str=DmdType] =
                                                                                              \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                                          r1aO :-> GHC.pm_parsed_source,
                                                                                                          r1pP :-> GHC.loadModule,
                                                                                                          r1qb :-> GHC.desugarModule,
                                                                                                          r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                                                          r4c0 :-> GhcMonad.$fMonadGhc] [t_sefu]
                                                                                                  let {
                                                                                                    sat_sefE [Occ=Once]
                                                                                                      :: GHC.DesugaredModule
                                                                                                         -> GhcMonad.Ghc
                                                                                                              (GHC.ParsedSource,
                                                                                                               GHC.Base.Maybe
                                                                                                                 GHC.RenamedSource,
                                                                                                               GHC.TypecheckedSource)
                                                                                                    [LclId,
                                                                                                     Str=DmdType] =
                                                                                                        \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                                                    r1aO :-> GHC.pm_parsed_source,
                                                                                                                    r1pP :-> GHC.loadModule,
                                                                                                                    r4br :-> GhcMonad.$fGhcMonadGhc,
                                                                                                                    r4c0 :-> GhcMonad.$fMonadGhc] [d_sefw]
                                                                                                            let {
                                                                                                              sat_sefD [Occ=Once]
                                                                                                                :: GHC.DesugaredModule
                                                                                                                   -> GhcMonad.Ghc
                                                                                                                        (GHC.ParsedSource,
                                                                                                                         GHC.Base.Maybe
                                                                                                                           GHC.RenamedSource,
                                                                                                                         GHC.TypecheckedSource)
                                                                                                              [LclId,
                                                                                                               Str=DmdType] =
                                                                                                                  \r srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                                                              r1aO :-> GHC.pm_parsed_source,
                                                                                                                              r4c0 :-> GhcMonad.$fMonadGhc] [l_sefy]
                                                                                                                      let {
                                                                                                                        sat_sefB [Occ=Once]
                                                                                                                          :: GHC.TypecheckedSource
                                                                                                                        [LclId,
                                                                                                                         Str=DmdType] =
                                                                                                                            \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule] []
                                                                                                                                GHC.typecheckedSource
                                                                                                                                    GHC.$fTypecheckedModDesugaredModule
                                                                                                                                    l_sefy; } in
                                                                                                                      let {
                                                                                                                        sat_sefA [Occ=Once]
                                                                                                                          :: GHC.Base.Maybe
                                                                                                                               GHC.RenamedSource
                                                                                                                        [LclId,
                                                                                                                         Str=DmdType] =
                                                                                                                            \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule] []
                                                                                                                                GHC.renamedSource
                                                                                                                                    GHC.$fTypecheckedModDesugaredModule
                                                                                                                                    l_sefy; } in
                                                                                                                      let {
                                                                                                                        sat_sefz [Occ=Once]
                                                                                                                          :: GHC.ParsedSource
                                                                                                                        [LclId,
                                                                                                                         Str=DmdType] =
                                                                                                                            \u srt:SRT:[r1aO :-> GHC.pm_parsed_source] []
                                                                                                                                GHC.pm_parsed_source
                                                                                                                                    p_sefs; } in
                                                                                                                      let {
                                                                                                                        sat_sefC [Occ=Once]
                                                                                                                          :: (GHC.ParsedSource,
                                                                                                                              GHC.Base.Maybe
                                                                                                                                GHC.RenamedSource,
                                                                                                                              GHC.TypecheckedSource)
                                                                                                                        [LclId,
                                                                                                                         Str=DmdType] =
                                                                                                                            NO_CCS (,,)! [sat_sefz
                                                                                                                                          sat_sefA
                                                                                                                                          sat_sefB];
                                                                                                                      } in 
                                                                                                                        GHC.Base.return
                                                                                                                            GhcMonad.$fMonadGhc
                                                                                                                            sat_sefC; } in
                                                                                                            let {
                                                                                                              sat_sefx [Occ=Once]
                                                                                                                :: GhcMonad.Ghc
                                                                                                                     GHC.DesugaredModule
                                                                                                              [LclId,
                                                                                                               Str=DmdType] =
                                                                                                                  \u srt:SRT:[rWH :-> GHC.$fTypecheckedModDesugaredModule,
                                                                                                                              r1pP :-> GHC.loadModule,
                                                                                                                              r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                                                                      GHC.loadModule
                                                                                                                          GHC.$fTypecheckedModDesugaredModule
                                                                                                                          GhcMonad.$fGhcMonadGhc
                                                                                                                          d_sefw;
                                                                                                            } in 
                                                                                                              GHC.Base.>>=
                                                                                                                  GhcMonad.$fMonadGhc
                                                                                                                  sat_sefx
                                                                                                                  sat_sefD; } in
                                                                                                  let {
                                                                                                    sat_sefv [Occ=Once]
                                                                                                      :: GhcMonad.Ghc
                                                                                                           GHC.DesugaredModule
                                                                                                    [LclId,
                                                                                                     Str=DmdType] =
                                                                                                        \u srt:SRT:[r1qb :-> GHC.desugarModule,
                                                                                                                    r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                                                            GHC.desugarModule
                                                                                                                GhcMonad.$fGhcMonadGhc
                                                                                                                t_sefu;
                                                                                                  } in 
                                                                                                    GHC.Base.>>=
                                                                                                        GhcMonad.$fMonadGhc
                                                                                                        sat_sefv
                                                                                                        sat_sefE; } in
                                                                                        let {
                                                                                          sat_seft [Occ=Once]
                                                                                            :: GhcMonad.Ghc
                                                                                                 GHC.TypecheckedModule
                                                                                          [LclId,
                                                                                           Str=DmdType] =
                                                                                              \u srt:SRT:[r1pj :-> GHC.typecheckModule,
                                                                                                          r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                                                  GHC.typecheckModule
                                                                                                      GhcMonad.$fGhcMonadGhc
                                                                                                      p_sefs;
                                                                                        } in 
                                                                                          GHC.Base.>>=
                                                                                              GhcMonad.$fMonadGhc
                                                                                              sat_seft
                                                                                              sat_sefF; } in
                                                                              let {
                                                                                sat_sefr [Occ=Once]
                                                                                  :: GhcMonad.Ghc
                                                                                       GHC.ParsedModule
                                                                                [LclId,
                                                                                 Str=DmdType] =
                                                                                    \u srt:SRT:[r1pv :-> GHC.parseModule,
                                                                                                r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                                        GHC.parseModule
                                                                                            GhcMonad.$fGhcMonadGhc
                                                                                            modSum_sefq;
                                                                              } in 
                                                                                GHC.Base.>>=
                                                                                    GhcMonad.$fMonadGhc
                                                                                    sat_sefr
                                                                                    sat_sefG; } in
                                                                    let {
                                                                      sat_sefp [Occ=Once]
                                                                        :: GhcMonad.Ghc
                                                                             HscTypes.ModSummary
                                                                      [LclId, Str=DmdType] =
                                                                          \u srt:SRT:[r1q2 :-> GHC.getModSummary,
                                                                                      r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                              GHC.getModSummary
                                                                                  GhcMonad.$fGhcMonadGhc
                                                                                  mn_sefk;
                                                                    } in 
                                                                      GHC.Base.>>=
                                                                          GhcMonad.$fMonadGhc
                                                                          sat_sefp
                                                                          sat_sefH; } in
                                                          let {
                                                            sat_sefo [Occ=Once]
                                                              :: GhcMonad.Ghc BasicTypes.SuccessFlag
                                                            [LclId, Str=DmdType] =
                                                                \u srt:SRT:[r1pf :-> GhcMake.load,
                                                                            r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                                    GhcMake.load
                                                                        GhcMonad.$fGhcMonadGhc
                                                                        GhcMake.LoadAllTargets;
                                                          } in 
                                                            GHC.Base.>>
                                                                GhcMonad.$fMonadGhc
                                                                sat_sefo
                                                                sat_sefI; } in
                                                let {
                                                  sat_sefn [Occ=Once] :: GhcMonad.Ghc ()
                                                  [LclId, Str=DmdType] =
                                                      \u srt:SRT:[r1qh :-> GHC.addTarget,
                                                                  r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                          let {
                                                            sat_sefl [Occ=Once] :: HscTypes.TargetId
                                                            [LclId, Str=DmdType] =
                                                                NO_CCS HscTypes.TargetModule! [mn_sefk]; } in
                                                          let {
                                                            sat_sefm [Occ=Once] :: HscTypes.Target
                                                            [LclId, Str=DmdType] =
                                                                NO_CCS HscTypes.Target! [sat_sefl
                                                                                         GHC.Types.True
                                                                                         GHC.Base.Nothing];
                                                          } in 
                                                            GHC.addTarget
                                                                GhcMonad.$fGhcMonadGhc sat_sefm;
                                                } in 
                                                  GHC.Base.>>
                                                      GhcMonad.$fMonadGhc sat_sefn sat_sefJ; } in
                                      let {
                                        sat_sefj [Occ=Once] :: GhcMonad.Ghc [Module.UnitId]
                                        [LclId, Str=DmdType] =
                                            \u srt:SRT:[r1pm :-> GHC.setSessionDynFlags,
                                                        r4br :-> GhcMonad.$fGhcMonadGhc] []
                                                GHC.setSessionDynFlags
                                                    GhcMonad.$fGhcMonadGhc dflags_sefi;
                                      } in  GHC.Base.>> GhcMonad.$fMonadGhc sat_sefj sat_sefK; } in
                            let {
                              sat_sefh [Occ=Once] :: GhcMonad.Ghc DynFlags.DynFlags
                              [LclId, Str=DmdType] =
                                  \u srt:SRT:[r1pc :-> GhcMonad.getSessionDynFlags,
                                              r4br :-> GhcMonad.$fGhcMonadGhc] []
                                      GhcMonad.getSessionDynFlags GhcMonad.$fGhcMonadGhc;
                            } in  GHC.Base.>>= GhcMonad.$fMonadGhc sat_sefh sat_sefL; } in
                  let {
                    sat_sefg [Occ=Once] :: GHC.Base.Maybe GHC.IO.FilePath
                    [LclId, Str=DmdType] =
                        NO_CCS GHC.Base.Just! [libdir_seeX];
                  } in  GHC.runGhc sat_sefg sat_sefM;
        } in  GHC.Base.>>= GHC.Base.$fMonadIO sat_sefN sat_segp;

sat_segK :: [GHC.Base.String] -> GHC.Types.IO ()
[LclId, Str=DmdType] =
    \r srt:SRT:[0k :-> GHC.CString.unpackCString#,
                r3wD :-> GHC.Base.$fMonadIO, r3PI :-> Main.testOneFile] [ds_segq]
        let-no-escape {
          fail_segr [Occ=Once*!] :: GHC.Prim.Void# -> GHC.Types.IO ()
          [LclId, Arity=1, Str=DmdType, Unf=OtherCon []] =
              sat-only \r srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                   r3wD :-> GHC.Base.$fMonadIO] [ds1_segs]
                  let {
                    sat_segt [Occ=Once] :: GHC.Base.String
                    [LclId, Str=DmdType] =
                        \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                            GHC.CString.unpackCString#
                                "Pattern match failure in do expression at landmines.hs:19:9-16"#;
                  } in  GHC.Base.fail GHC.Base.$fMonadIO sat_segt;
        } in 
          case ds_segq of _ [Occ=Dead] {
            [] -> fail_segr GHC.Prim.void#;
            : libdir_segv ds1_segw [Occ=Once!] ->
                case ds1_segw of _ [Occ=Dead] {
                  [] ->
                      let {
                        sat_segH [Occ=Once] :: GHC.Types.IO ()
                        [LclId, Str=DmdType] =
                            \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                        r3wD :-> GHC.Base.$fMonadIO, r3PI :-> Main.testOneFile] []
                                let {
                                  sat_segG [Occ=Once] :: GHC.Types.IO ()
                                  [LclId, Str=DmdType] =
                                      \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                                  r3wD :-> GHC.Base.$fMonadIO,
                                                  r3PI :-> Main.testOneFile] []
                                          let {
                                            sat_segF [Occ=Once] :: GHC.Types.IO ()
                                            [LclId, Str=DmdType] =
                                                \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                                            r3PI :-> Main.testOneFile] []
                                                    let {
                                                      sat_segE [Occ=Once] :: GHC.Base.String
                                                      [LclId, Str=DmdType] =
                                                          \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                                              GHC.CString.unpackCString#
                                                                  "MineType"#;
                                                    } in 
                                                      Main.testOneFile libdir_segv sat_segE; } in
                                          let {
                                            sat_segD [Occ=Once] :: GHC.Types.IO ()
                                            [LclId, Str=DmdType] =
                                                \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                                            r3PI :-> Main.testOneFile] []
                                                    let {
                                                      sat_segC [Occ=Once] :: GHC.Base.String
                                                      [LclId, Str=DmdType] =
                                                          \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                                              GHC.CString.unpackCString#
                                                                  "MineNames"#;
                                                    } in  Main.testOneFile libdir_segv sat_segC;
                                          } in 
                                            GHC.Base.>> GHC.Base.$fMonadIO sat_segD sat_segF; } in
                                let {
                                  sat_segB [Occ=Once] :: GHC.Types.IO ()
                                  [LclId, Str=DmdType] =
                                      \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                                  r3PI :-> Main.testOneFile] []
                                          let {
                                            sat_segA [Occ=Once] :: GHC.Base.String
                                            [LclId, Str=DmdType] =
                                                \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                                    GHC.CString.unpackCString# "MineKind"#;
                                          } in  Main.testOneFile libdir_segv sat_segA;
                                } in  GHC.Base.>> GHC.Base.$fMonadIO sat_segB sat_segG; } in
                      let {
                        sat_segz [Occ=Once] :: GHC.Types.IO ()
                        [LclId, Str=DmdType] =
                            \u srt:SRT:[0k :-> GHC.CString.unpackCString#,
                                        r3PI :-> Main.testOneFile] []
                                let {
                                  sat_segy [Occ=Once] :: GHC.Base.String
                                  [LclId, Str=DmdType] =
                                      \u srt:SRT:[0k :-> GHC.CString.unpackCString#] []
                                          GHC.CString.unpackCString# "MineFixity"#;
                                } in  Main.testOneFile libdir_segv sat_segy;
                      } in  GHC.Base.>> GHC.Base.$fMonadIO sat_segz sat_segH;
                  : _ [Occ=Dead] _ [Occ=Dead] -> fail_segr GHC.Prim.void#;
                };
          };

Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType] =
    \u srt:SRT:[r25k :-> System.Environment.getArgs,
                r3wD :-> GHC.Base.$fMonadIO, segK :-> sat_segK] []
        GHC.Base.>>=
            GHC.Base.$fMonadIO System.Environment.getArgs sat_segK;

:Main.main :: GHC.Types.IO ()
[GblId, Str=DmdType] =
    \u srt:SRT:[01E :-> GHC.TopHandler.runMainIO,
                r3PH :-> Main.main] []
        GHC.TopHandler.runMainIO Main.main;



==================== Foreign export header file ====================



==================== Foreign export stubs ====================



==================== Cmm produced by new codegen ====================
[section ""data" . __stginit_main@main:Main" {
     __stginit_main@main:Main:
 }]



==================== Post CPS Cmm ====================
[section ""data" . __stginit_main@main:Main" {
     __stginit_main@main:Main:
 }]



==================== Output Cmm ====================
[section ""data" . __stginit_main@main:Main" {
     __stginit_main@main:Main:
 }]



==================== Raw Cmm ====================
[section ""data" . __stginit_main@main:Main" {
     __stginit_main@main:Main:
 }]



==================== Optimised Cmm ====================
section ""data" . __stginit_main@main:Main" {
    __stginit_main@main:Main:
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl __stginit_main@main:Main
.type __stginit_main@main:Main, @object
__stginit_main@main:Main:



==================== Liveness annotations added ====================
section ""data" . __stginit_main@main:Main" {
    (1, __stginit_main@main:Main:)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl __stginit_main@main:Main
.type __stginit_main@main:Main, @object
__stginit_main@main:Main:



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl __stginit_main@main:Main
.type __stginit_main@main:Main, @object
__stginit_main@main:Main:



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl __stginit_main@main:Main
.type __stginit_main@main:Main, @object
__stginit_main@main:Main:



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""readonly" . cehz_str" {
     cehz_str:
         I8[] [109,97,105,110]
 },
 section ""data" . a_redQ_closure" {
     a_redQ_closure:
         const GHC.Types.TrNameS_static_info;
         const cehz_str;
 }]



==================== Post CPS Cmm ====================
[section ""readonly" . cehz_str" {
     cehz_str:
         I8[] [109,97,105,110]
 },
 section ""data" . a_redQ_closure" {
     a_redQ_closure:
         const GHC.Types.TrNameS_static_info;
         const cehz_str;
 }]



==================== Output Cmm ====================
[section ""readonly" . cehz_str" {
     cehz_str:
         I8[] [109,97,105,110]
 },
 section ""data" . a_redQ_closure" {
     a_redQ_closure:
         const GHC.Types.TrNameS_static_info;
         const cehz_str;
 }]



==================== Raw Cmm ====================
[section ""readonly" . cehz_str" {
     cehz_str:
         I8[] [109,97,105,110]
 },
 section ""data" . a_redQ_closure" {
     a_redQ_closure:
         const GHC.Types.TrNameS_static_info;
         const cehz_str;
 }]



==================== Optimised Cmm ====================
section ""readonly" . cehz_str" {
    cehz_str:
        I8[] [109,97,105,110]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cehz_str:
	.byte	109
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cehz_str" {
    (1,
     cehz_str:
         I8[] [109,97,105,110])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cehz_str:
	.byte	109
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cehz_str:
	.byte	109
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cehz_str:
	.byte	109
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Optimised Cmm ====================
section ""data" . a_redQ_closure" {
    a_redQ_closure:
        const GHC.Types.TrNameS_static_info;
        const cehz_str;
}



==================== Native code ====================
.section .data
.align 8
.align 1
a_redQ_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehz_str



==================== Liveness annotations added ====================
section ""data" . a_redQ_closure" {
    (1,
     a_redQ_closure:
         const GHC.Types.TrNameS_static_info;
         const cehz_str;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
a_redQ_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehz_str



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
a_redQ_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehz_str



==================== Asm code ====================
.section .data
.align 8
.align 1
a_redQ_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehz_str



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""readonly" . cehC_str" {
     cehC_str:
         I8[] [77,97,105,110]
 },
 section ""data" . a1_reeE_closure" {
     a1_reeE_closure:
         const GHC.Types.TrNameS_static_info;
         const cehC_str;
 }]



==================== Post CPS Cmm ====================
[section ""readonly" . cehC_str" {
     cehC_str:
         I8[] [77,97,105,110]
 },
 section ""data" . a1_reeE_closure" {
     a1_reeE_closure:
         const GHC.Types.TrNameS_static_info;
         const cehC_str;
 }]



==================== Output Cmm ====================
[section ""readonly" . cehC_str" {
     cehC_str:
         I8[] [77,97,105,110]
 },
 section ""data" . a1_reeE_closure" {
     a1_reeE_closure:
         const GHC.Types.TrNameS_static_info;
         const cehC_str;
 }]



==================== Raw Cmm ====================
[section ""readonly" . cehC_str" {
     cehC_str:
         I8[] [77,97,105,110]
 },
 section ""data" . a1_reeE_closure" {
     a1_reeE_closure:
         const GHC.Types.TrNameS_static_info;
         const cehC_str;
 }]



==================== Optimised Cmm ====================
section ""readonly" . cehC_str" {
    cehC_str:
        I8[] [77,97,105,110]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cehC_str:
	.byte	77
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cehC_str" {
    (1,
     cehC_str:
         I8[] [77,97,105,110])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cehC_str:
	.byte	77
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cehC_str:
	.byte	77
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cehC_str:
	.byte	77
	.byte	97
	.byte	105
	.byte	110
	.byte	0



==================== Optimised Cmm ====================
section ""data" . a1_reeE_closure" {
    a1_reeE_closure:
        const GHC.Types.TrNameS_static_info;
        const cehC_str;
}



==================== Native code ====================
.section .data
.align 8
.align 1
a1_reeE_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehC_str



==================== Liveness annotations added ====================
section ""data" . a1_reeE_closure" {
    (1,
     a1_reeE_closure:
         const GHC.Types.TrNameS_static_info;
         const cehC_str;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
a1_reeE_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehC_str



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
a1_reeE_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehC_str



==================== Asm code ====================
.section .data
.align 8
.align 1
a1_reeE_closure:
	.quad	GHC.Types.TrNameS_static_info
	.quad	cehC_str



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . Main.$trModule_closure" {
     Main.$trModule_closure:
         const GHC.Types.Module_static_info;
         const a_redQ_closure+1;
         const a1_reeE_closure+1;
         const 3;
 }]



==================== Post CPS Cmm ====================
[section ""data" . Main.$trModule_closure" {
     Main.$trModule_closure:
         const GHC.Types.Module_static_info;
         const a_redQ_closure+1;
         const a1_reeE_closure+1;
         const 3;
 }]



==================== Output Cmm ====================
[section ""data" . Main.$trModule_closure" {
     Main.$trModule_closure:
         const GHC.Types.Module_static_info;
         const a_redQ_closure+1;
         const a1_reeE_closure+1;
         const 3;
 }]



==================== Raw Cmm ====================
[section ""data" . Main.$trModule_closure" {
     Main.$trModule_closure:
         const GHC.Types.Module_static_info;
         const a_redQ_closure+1;
         const a1_reeE_closure+1;
         const 3;
 }]



==================== Optimised Cmm ====================
section ""data" . Main.$trModule_closure" {
    Main.$trModule_closure:
        const GHC.Types.Module_static_info;
        const a_redQ_closure+1;
        const a1_reeE_closure+1;
        const 3;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl Main.$trModule_closure
.type Main.$trModule_closure, @object
Main.$trModule_closure:
	.quad	GHC.Types.Module_static_info
	.quad	a_redQ_closure+1
	.quad	a1_reeE_closure+1
	.quad	3



==================== Liveness annotations added ====================
section ""data" . Main.$trModule_closure" {
    (1,
     Main.$trModule_closure:
         const GHC.Types.Module_static_info;
         const a_redQ_closure+1;
         const a1_reeE_closure+1;
         const 3;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl Main.$trModule_closure
.type Main.$trModule_closure, @object
Main.$trModule_closure:
	.quad	GHC.Types.Module_static_info
	.quad	a_redQ_closure+1
	.quad	a1_reeE_closure+1
	.quad	3



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl Main.$trModule_closure
.type Main.$trModule_closure, @object
Main.$trModule_closure:
	.quad	GHC.Types.Module_static_info
	.quad	a_redQ_closure+1
	.quad	a1_reeE_closure+1
	.quad	3



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl Main.$trModule_closure
.type Main.$trModule_closure, @object
Main.$trModule_closure:
	.quad	GHC.Types.Module_static_info
	.quad	a_redQ_closure+1
	.quad	a1_reeE_closure+1
	.quad	3



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . Main.mkQ_closure" {
     Main.mkQ_closure:
         const Main.mkQ_info;
         const 0;
 },
 Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cehQ,
                       label: Main.mkQ_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cehQ:
           _seeL::P64 = R6;   // CmmAssign
           _seeK::P64 = R5;   // CmmAssign
           _seeJ::P64 = R4;   // CmmAssign
           _seeI::P64 = R3;   // CmmAssign
           _seeH::P64 = R2;   // CmmAssign
           goto cehI;   // CmmBranch
       cehI:
           if ((old + 0) - <highSp> < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
       cehR:
           R6 = _seeL::P64;   // CmmAssign
           R5 = _seeK::P64;   // CmmAssign
           R4 = _seeJ::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Main.mkQ_closure;   // CmmAssign
           call (stg_gc_fun)(R6,
                             R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehS:
           goto cehH;   // CmmBranch
       cehH:
           I64[(young<cehK> + 8)] = cehK;   // CmmStore
           R4 = _seeL::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
       cehK:
           _seeM::P64 = R1;   // CmmAssign
           _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
           switch [1 .. 2] _cehP::P64 {
               case 1 : goto cehN;
               case 2 : goto cehO;
           }   // CmmSwitch
       cehO:
           _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
           R2 = _seeN::P64;   // CmmAssign
           R1 = _seeK::P64;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehN:
           R1 = _seeJ::P64;   // CmmAssign
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cehQ:
      _seeL::P64 = R6;   // CmmAssign
      _seeK::P64 = R5;   // CmmAssign
      _seeJ::P64 = R4;   // CmmAssign
      _seeI::P64 = R3;   // CmmAssign
      _seeH::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
  cehR:
      R6 = _seeL::P64;   // CmmAssign
      R5 = _seeK::P64;   // CmmAssign
      R4 = _seeJ::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Main.mkQ_closure;   // CmmAssign
      call (stg_gc_fun)(R6,
                        R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehS:
      I64[(young<cehK> + 8)] = cehK;   // CmmStore
      R4 = _seeL::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
  cehK:
      _seeM::P64 = R1;   // CmmAssign
      _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
      switch [1 .. 2] _cehP::P64 {
          case 1 : goto cehN;
          case 2 : goto cehO;
      }   // CmmSwitch
  cehO:
      _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
      R2 = _seeN::P64;   // CmmAssign
      R1 = _seeK::P64;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehN:
      R1 = _seeJ::P64;   // CmmAssign
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cehQ:
      _seeL::P64 = R6;   // CmmAssign
      _seeK::P64 = R5;   // CmmAssign
      _seeJ::P64 = R4;   // CmmAssign
      _seeI::P64 = R3;   // CmmAssign
      _seeH::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
  cehR:
      R6 = _seeL::P64;   // CmmAssign
      R5 = _seeK::P64;   // CmmAssign
      R4 = _seeJ::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Main.mkQ_closure;   // CmmAssign
      call (stg_gc_fun)(R6,
                        R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehS:
      I64[(young<cehK> + 8)] = cehK;   // CmmStore
      R4 = _seeL::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
  cehK:
      _seeM::P64 = R1;   // CmmAssign
      _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
      if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
  cehO:
      _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
      R2 = _seeN::P64;   // CmmAssign
      R1 = _seeK::P64;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehN:
      R1 = _seeJ::P64;   // CmmAssign
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cehQ:
      _seeL::P64 = R6;   // CmmAssign
      _seeK::P64 = R5;   // CmmAssign
      _seeJ::P64 = R4;   // CmmAssign
      _seeI::P64 = R3;   // CmmAssign
      _seeH::P64 = R2;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
  cehR:
      R6 = _seeL::P64;   // CmmAssign
      R5 = _seeK::P64;   // CmmAssign
      R4 = _seeJ::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Main.mkQ_closure;   // CmmAssign
      call (stg_gc_fun)(R6,
                        R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehS:
      I64[Sp - 24] = cehK;   // CmmStore
      R4 = _seeL::P64;   // CmmAssign
      R3 = _seeI::P64;   // CmmAssign
      R2 = _seeH::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      P64[Sp - 16] = _seeJ::P64;   // CmmStore
      P64[Sp - 8] = _seeK::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
  cehK:
      _seeJ::P64 = P64[Sp + 8];   // CmmAssign
      _seeK::P64 = P64[Sp + 16];   // CmmAssign
      _seeM::P64 = R1;   // CmmAssign
      _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
      if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
  cehO:
      _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
      R2 = _seeN::P64;   // CmmAssign
      R1 = _seeK::P64;   // CmmAssign
      Sp = Sp + 24;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cehN:
      R1 = _seeJ::P64;   // CmmAssign
      Sp = Sp + 24;   // CmmAssign
      call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cehK, {}), (cehN, {}), (cehO, {}),
 (cehQ, {Data.Typeable.cast_closure, Main.mkQ_closure}),
 (cehR, {Main.mkQ_closure}), (cehS, {Data.Typeable.cast_closure})]



==================== after setInfoTableStackMap ====================
Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cehK,
                      label: block_cehK_info
                      rep:StackRep [False, False]),
                     (cehQ,
                      label: Main.mkQ_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cehQ:
          _seeL::P64 = R6;   // CmmAssign
          _seeK::P64 = R5;   // CmmAssign
          _seeJ::P64 = R4;   // CmmAssign
          _seeI::P64 = R3;   // CmmAssign
          _seeH::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
      cehR:
          R6 = _seeL::P64;   // CmmAssign
          R5 = _seeK::P64;   // CmmAssign
          R4 = _seeJ::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Main.mkQ_closure;   // CmmAssign
          call (stg_gc_fun)(R6,
                            R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehS:
          I64[Sp - 24] = cehK;   // CmmStore
          R4 = _seeL::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          P64[Sp - 16] = _seeJ::P64;   // CmmStore
          P64[Sp - 8] = _seeK::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
      cehK:
          _seeJ::P64 = P64[Sp + 8];   // CmmAssign
          _seeK::P64 = P64[Sp + 16];   // CmmAssign
          _seeM::P64 = R1;   // CmmAssign
          _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
          if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
      cehO:
          _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
          R2 = _seeN::P64;   // CmmAssign
          R1 = _seeK::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehN:
          R1 = _seeJ::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
        { info_tbl: [(cehK,
                      label: block_cehK_info
                      rep:StackRep [False, False]),
                     (cehQ,
                      label: Main.mkQ_info
                      rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cehQ:
          _seeL::P64 = R6;   // CmmAssign
          _seeK::P64 = R5;   // CmmAssign
          _seeJ::P64 = R4;   // CmmAssign
          _seeI::P64 = R3;   // CmmAssign
          _seeH::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
      cehR:
          R6 = _seeL::P64;   // CmmAssign
          R5 = _seeK::P64;   // CmmAssign
          R4 = _seeJ::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Main.mkQ_closure;   // CmmAssign
          call (stg_gc_fun)(R6,
                            R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehS:
          I64[Sp - 24] = cehK;   // CmmStore
          R4 = _seeL::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          P64[Sp - 16] = _seeJ::P64;   // CmmStore
          P64[Sp - 8] = _seeK::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
      cehK:
          _seeJ::P64 = P64[Sp + 8];   // CmmAssign
          _seeK::P64 = P64[Sp + 16];   // CmmAssign
          _seeM::P64 = R1;   // CmmAssign
          _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
          if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
      cehO:
          _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
          R2 = _seeN::P64;   // CmmAssign
          R1 = _seeK::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehN:
          R1 = _seeJ::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . Main.mkQ_closure" {
     Main.mkQ_closure:
         const Main.mkQ_info;
         const 0;
 },
 Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cehK,
                       label: block_cehK_info
                       rep:StackRep [False, False]),
                      (cehQ,
                       label: Main.mkQ_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cehQ:
           _seeL::P64 = R6;   // CmmAssign
           _seeK::P64 = R5;   // CmmAssign
           _seeJ::P64 = R4;   // CmmAssign
           _seeI::P64 = R3;   // CmmAssign
           _seeH::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
       cehR:
           R6 = _seeL::P64;   // CmmAssign
           R5 = _seeK::P64;   // CmmAssign
           R4 = _seeJ::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Main.mkQ_closure;   // CmmAssign
           call (stg_gc_fun)(R6,
                             R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehS:
           I64[Sp - 24] = cehK;   // CmmStore
           R4 = _seeL::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           P64[Sp - 16] = _seeJ::P64;   // CmmStore
           P64[Sp - 8] = _seeK::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
       cehK:
           _seeJ::P64 = P64[Sp + 8];   // CmmAssign
           _seeK::P64 = P64[Sp + 16];   // CmmAssign
           _seeM::P64 = R1;   // CmmAssign
           _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
           if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
       cehO:
           _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
           R2 = _seeN::P64;   // CmmAssign
           R1 = _seeK::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehN:
           R1 = _seeJ::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . Main.mkQ_closure" {
     Main.mkQ_closure:
         const Main.mkQ_info;
         const 0;
 },
 Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
         { info_tbl: [(cehK,
                       label: block_cehK_info
                       rep:StackRep [False, False]),
                      (cehQ,
                       label: Main.mkQ_info
                       rep:HeapRep static { Fun {arity: 5 fun_type: ArgSpec 25} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cehQ:
           _seeL::P64 = R6;   // CmmAssign
           _seeK::P64 = R5;   // CmmAssign
           _seeJ::P64 = R4;   // CmmAssign
           _seeI::P64 = R3;   // CmmAssign
           _seeH::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
       cehR:
           R6 = _seeL::P64;   // CmmAssign
           R5 = _seeK::P64;   // CmmAssign
           R4 = _seeJ::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Main.mkQ_closure;   // CmmAssign
           call (stg_gc_fun)(R6,
                             R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehS:
           I64[Sp - 24] = cehK;   // CmmStore
           R4 = _seeL::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           P64[Sp - 16] = _seeJ::P64;   // CmmStore
           P64[Sp - 8] = _seeK::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
       cehK:
           _seeJ::P64 = P64[Sp + 8];   // CmmAssign
           _seeK::P64 = P64[Sp + 16];   // CmmAssign
           _seeM::P64 = R1;   // CmmAssign
           _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
           if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
       cehO:
           _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
           R2 = _seeN::P64;   // CmmAssign
           R1 = _seeK::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehN:
           R1 = _seeJ::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . Main.mkQ_closure" {
     Main.mkQ_closure:
         const Main.mkQ_info;
         const 0;
 },
 Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
         { [(cehK,
             block_cehK_info:
                 const 2;
                 const 32;),
            (cehQ,
             Main.mkQ_info:
                 const SehZ_srt-Main.mkQ_info;
                 const 21474836505;
                 const 0;
                 const 12884901903;)]
         }
     {offset
       cehQ:
           _seeL::P64 = R6;   // CmmAssign
           _seeK::P64 = R5;   // CmmAssign
           _seeJ::P64 = R4;   // CmmAssign
           _seeI::P64 = R3;   // CmmAssign
           _seeH::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
       cehR:
           R6 = _seeL::P64;   // CmmAssign
           R5 = _seeK::P64;   // CmmAssign
           R4 = _seeJ::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Main.mkQ_closure;   // CmmAssign
           call (stg_gc_fun)(R6,
                             R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehS:
           I64[Sp - 24] = cehK;   // CmmStore
           R4 = _seeL::P64;   // CmmAssign
           R3 = _seeI::P64;   // CmmAssign
           R2 = _seeH::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           P64[Sp - 16] = _seeJ::P64;   // CmmStore
           P64[Sp - 8] = _seeK::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
       cehK:
           _seeJ::P64 = P64[Sp + 8];   // CmmAssign
           _seeK::P64 = P64[Sp + 16];   // CmmAssign
           _seeM::P64 = R1;   // CmmAssign
           _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
           if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
       cehO:
           _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
           R2 = _seeN::P64;   // CmmAssign
           R1 = _seeK::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cehN:
           R1 = _seeJ::P64;   // CmmAssign
           Sp = Sp + 24;   // CmmAssign
           call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . Main.mkQ_closure" {
    Main.mkQ_closure:
        const Main.mkQ_info;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl Main.mkQ_closure
.type Main.mkQ_closure, @object
Main.mkQ_closure:
	.quad	Main.mkQ_info
	.quad	0



==================== Liveness annotations added ====================
section ""data" . Main.mkQ_closure" {
    (1,
     Main.mkQ_closure:
         const Main.mkQ_info;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl Main.mkQ_closure
.type Main.mkQ_closure, @object
Main.mkQ_closure:
	.quad	Main.mkQ_info
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl Main.mkQ_closure
.type Main.mkQ_closure, @object
Main.mkQ_closure:
	.quad	Main.mkQ_info
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl Main.mkQ_closure
.type Main.mkQ_closure, @object
Main.mkQ_closure:
	.quad	Main.mkQ_info
	.quad	0



==================== Optimised Cmm ====================
Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
        { [(cehK,
            block_cehK_info:
                const 2;
                const 32;),
           (cehQ,
            Main.mkQ_info:
                const SehZ_srt-Main.mkQ_info;
                const 21474836505;
                const 0;
                const 12884901903;)]
        }
    {offset
      cehQ:
          _seeL::P64 = R6;   // CmmAssign
          _seeK::P64 = R5;   // CmmAssign
          _seeJ::P64 = R4;   // CmmAssign
          _seeI::P64 = R3;   // CmmAssign
          _seeH::P64 = R2;   // CmmAssign
          if ((Sp + -24) < SpLim) goto cehR; else goto cehS;   // CmmCondBranch
      cehR:
          R6 = _seeL::P64;   // CmmAssign
          R5 = _seeK::P64;   // CmmAssign
          R4 = _seeJ::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Main.mkQ_closure;   // CmmAssign
          call (I64[BaseReg - 8])(R6,
                                  R5,
                                  R4,
                                  R3,
                                  R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehS:
          I64[Sp - 24] = block_cehK_info;   // CmmStore
          R4 = _seeL::P64;   // CmmAssign
          R3 = _seeI::P64;   // CmmAssign
          R2 = _seeH::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          P64[Sp - 16] = _seeJ::P64;   // CmmStore
          P64[Sp - 8] = _seeK::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cehK, args: 8, res: 8, upd: 8;   // CmmCall
      cehK:
          _seeJ::P64 = P64[Sp + 8];   // CmmAssign
          _seeK::P64 = P64[Sp + 16];   // CmmAssign
          _seeM::P64 = R1;   // CmmAssign
          _cehP::P64 = _seeM::P64 & 7;   // CmmAssign
          if (_cehP::P64 != 1) goto cehO; else goto cehN;   // CmmCondBranch
      cehO:
          _seeN::P64 = P64[_seeM::P64 + 6];   // CmmAssign
          R2 = _seeN::P64;   // CmmAssign
          R1 = _seeK::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cehN:
          R1 = _seeJ::P64;   // CmmAssign
          Sp = Sp + 24;   // CmmAssign
          call stg_ap_0_fast(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.mkQ_info)+0
	.long	0
	.quad	21474836505
	.quad	0
	.quad	12884901903
.globl Main.mkQ_info
.type Main.mkQ_info, @object
Main.mkQ_info:
_cehQ:
	movq %r9,%vI_seeL
	movq %r8,%vI_seeK
	movq %rdi,%vI_seeJ
	movq %rsi,%vI_seeI
	movq %r14,%vI_seeH
	leaq -24(%rbp),%vI_nei2
	cmpq %r15,%vI_nei2
	jb _cehR
	jmp _cehS
	.quad	2
	.quad	32
block_cehK_info:
_cehK:
	movq 8(%rbp),%vI_seeJ
	movq 16(%rbp),%vI_seeK
	movq %rbx,%vI_seeM
	movq %vI_seeM,%vI_cehP
	andl $7,%vI_cehP
	cmpq $1,%vI_cehP
	jne _cehO
	jmp _cehN
_cehN:
	movq %vI_seeJ,%rbx
	addq $24,%rbp
	jmp stg_ap_0_fast
_cehO:
	movq 6(%vI_seeM),%vI_seeN
	movq %vI_seeN,%r14
	movq %vI_seeK,%rbx
	addq $24,%rbp
	jmp stg_ap_p_fast
_cehR:
	movq %vI_seeL,%r9
	movq %vI_seeK,%r8
	movq %vI_seeJ,%rdi
	movq %vI_seeI,%rsi
	movq %vI_seeH,%r14
	movl $Main.mkQ_closure,%ebx
	jmp *-8(%r13)
_cehS:
	movq $block_cehK_info,-24(%rbp)
	movq %vI_seeL,%rdi
	movq %vI_seeI,%rsi
	movq %vI_seeH,%r14
	movl $Data.Typeable.cast_closure,%ebx
	movq %vI_seeJ,-16(%rbp)
	movq %vI_seeK,-8(%rbp)
	addq $-24,%rbp
	jmp stg_ap_ppp_fast
	.size Main.mkQ_info, .-Main.mkQ_info



==================== Liveness annotations added ====================
Main.mkQ_entry() //  [R6, R5, R4, R3, R2]
        { [(cehK,
            block_cehK_info:
                const 2;
                const 32;),
           (cehQ,
            Main.mkQ_info:
                const SehZ_srt-Main.mkQ_info;
                const 21474836505;
                const 0;
                const 12884901903;)]
          # entryIds         = [cehQ, cehK]
          # liveVRegsOnEntry = Just [(cehK, [R1 :-> %r1]),
                                     (cehN, [seeJ :-> %vI_seeJ]),
                                     (cehO, [seeK :-> %vI_seeK, seeM :-> %vI_seeM]),
                                     (cehQ,
                                      [R4 :-> %r4, R5 :-> %r5, R8 :-> %r8, R9 :-> %r9,
                                       Re :-> %r14]),
                                     (cehR,
                                      [seeH :-> %vI_seeH, seeI :-> %vI_seeI, seeJ :-> %vI_seeJ,
                                       seeK :-> %vI_seeK, seeL :-> %vI_seeL]),
                                     (cehS,
                                      [seeH :-> %vI_seeH, seeI :-> %vI_seeI, seeJ :-> %vI_seeJ,
                                       seeK :-> %vI_seeK, seeL :-> %vI_seeL])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cehQ:
            	movq %r9,%vI_seeL
                    # born:    %vI_seeL
                    # r_dying: %r9
                     
            	movq %r8,%vI_seeK
                    # born:    %vI_seeK
                    # r_dying: %r8
                     
            	movq %rdi,%vI_seeJ
                    # born:    %vI_seeJ
                    # r_dying: %r5
                     
            	movq %rsi,%vI_seeI
                    # born:    %vI_seeI
                    # r_dying: %r4
                     
            	movq %r14,%vI_seeH
                    # born:    %vI_seeH
                    # r_dying: %r14
                     
            	leaq -24(%rbp),%vI_nei2
                    # born:    %vI_nei2
                     
            	cmpq %r15,%vI_nei2
                    # r_dying: %vI_nei2
                     
            	jb _cehR
                     
            	jmp _cehS
                    # r_dying: %vI_seeH %vI_seeI %vI_seeJ %vI_seeK %vI_seeL
                     ,
     NONREC
        cehK:
            	movq 8(%rbp),%vI_seeJ
                    # born:    %vI_seeJ
                     
            	movq 16(%rbp),%vI_seeK
                    # born:    %vI_seeK
                     
            	movq %rbx,%vI_seeM
                    # born:    %vI_seeM
                    # r_dying: %r1
                     
            	movq %vI_seeM,%vI_cehP
                    # born:    %vI_cehP
                     
            	andl $7,%vI_cehP
                     
            	cmpq $1,%vI_cehP
                    # r_dying: %vI_cehP
                     
            	jne _cehO
                    # r_dying: %vI_seeK %vI_seeM
                     
            	jmp _cehN
                    # r_dying: %vI_seeJ
                     ,
     NONREC
        cehN:
            	movq %vI_seeJ,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeJ
                     
            	addq $24,%rbp
                     
            	jmp stg_ap_0_fast
                    # r_dying: %r1
                     ,
     NONREC
        cehO:
            	movq 6(%vI_seeM),%vI_seeN
                    # born:    %vI_seeN
                    # r_dying: %vI_seeM
                     
            	movq %vI_seeN,%r14
                    # born:    %r14
                    # r_dying: %vI_seeN
                     
            	movq %vI_seeK,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeK
                     
            	addq $24,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cehR:
            	movq %vI_seeL,%r9
                    # born:    %r9
                    # r_dying: %vI_seeL
                     
            	movq %vI_seeK,%r8
                    # born:    %r8
                    # r_dying: %vI_seeK
                     
            	movq %vI_seeJ,%rdi
                    # born:    %r5
                    # r_dying: %vI_seeJ
                     
            	movq %vI_seeI,%rsi
                    # born:    %r4
                    # r_dying: %vI_seeI
                     
            	movq %vI_seeH,%r14
                    # born:    %r14
                    # r_dying: %vI_seeH
                     
            	movl $Main.mkQ_closure,%ebx
                    # born:    %r1
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r4 %r5 %r8 %r9 %r14
                     ,
     NONREC
        cehS:
            	movq $block_cehK_info,-24(%rbp)
                     
            	movq %vI_seeL,%rdi
                    # born:    %r5
                    # r_dying: %vI_seeL
                     
            	movq %vI_seeI,%rsi
                    # born:    %r4
                    # r_dying: %vI_seeI
                     
            	movq %vI_seeH,%r14
                    # born:    %r14
                    # r_dying: %vI_seeH
                     
            	movl $Data.Typeable.cast_closure,%ebx
                    # born:    %r1
                     
            	movq %vI_seeJ,-16(%rbp)
                    # r_dying: %vI_seeJ
                     
            	movq %vI_seeK,-8(%rbp)
                    # r_dying: %vI_seeK
                     
            	addq $-24,%rbp
                     
            	jmp stg_ap_ppp_fast
                    # r_dying: %r1 %r4 %r5 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.mkQ_info)+0
	.long	0
	.quad	21474836505
	.quad	0
	.quad	12884901903
.globl Main.mkQ_info
.type Main.mkQ_info, @object
Main.mkQ_info:
_cehQ:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cehR
	jmp _cehS
	.quad	2
	.quad	32
block_cehK_info:
_cehK:
	movq 8(%rbp),%rax
	movq 16(%rbp),%rcx
	movq %rbx,%rdx
	andl $7,%edx
	cmpq $1,%rdx
	jne _cehO
	jmp _cehN
_cehN:
	movq %rax,%rbx
	addq $24,%rbp
	jmp stg_ap_0_fast
_cehO:
	movq 6(%rbx),%rax
	movq %rax,%r14
	movq %rcx,%rbx
	addq $24,%rbp
	jmp stg_ap_p_fast
_cehR:
	movl $Main.mkQ_closure,%ebx
	jmp *-8(%r13)
_cehS:
	movq $block_cehK_info,-24(%rbp)
	movq %rdi,%rax
	movq %r9,%rdi
	movl $Data.Typeable.cast_closure,%ebx
	movq %rax,-16(%rbp)
	movq %r8,-8(%rbp)
	addq $-24,%rbp
	jmp stg_ap_ppp_fast
	.size Main.mkQ_info, .-Main.mkQ_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.mkQ_info)+0
	.long	0
	.quad	21474836505
	.quad	0
	.quad	12884901903
.globl Main.mkQ_info
.type Main.mkQ_info, @object
Main.mkQ_info:
_cehQ:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cehR
_cehS:
	movq $block_cehK_info,-24(%rbp)
	movq %rdi,%rax
	movq %r9,%rdi
	movl $Data.Typeable.cast_closure,%ebx
	movq %rax,-16(%rbp)
	movq %r8,-8(%rbp)
	addq $-24,%rbp
	jmp stg_ap_ppp_fast
	.quad	2
	.quad	32
block_cehK_info:
_cehK:
	movq 8(%rbp),%rax
	movq 16(%rbp),%rcx
	movq %rbx,%rdx
	andl $7,%edx
	cmpq $1,%rdx
	jne _cehO
_cehN:
	movq %rax,%rbx
	addq $24,%rbp
	jmp stg_ap_0_fast
_cehO:
	movq 6(%rbx),%rax
	movq %rax,%r14
	movq %rcx,%rbx
	addq $24,%rbp
	jmp stg_ap_p_fast
_cehR:
	movl $Main.mkQ_closure,%ebx
	jmp *-8(%r13)
	.size Main.mkQ_info, .-Main.mkQ_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.mkQ_info)+0
	.long	0
	.quad	21474836505
	.quad	0
	.quad	12884901903
.globl Main.mkQ_info
.type Main.mkQ_info, @object
Main.mkQ_info:
_cehQ:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cehR
_cehS:
	movq $block_cehK_info,-24(%rbp)
	movq %rdi,%rax
	movq %r9,%rdi
	movl $Data.Typeable.cast_closure,%ebx
	movq %rax,-16(%rbp)
	movq %r8,-8(%rbp)
	addq $-24,%rbp
	jmp stg_ap_ppp_fast
	.quad	2
	.quad	32
block_cehK_info:
_cehK:
	movq 8(%rbp),%rax
	movq 16(%rbp),%rcx
	movq %rbx,%rdx
	andl $7,%edx
	cmpq $1,%rdx
	jne _cehO
_cehN:
	movq %rax,%rbx
	addq $24,%rbp
	jmp stg_ap_0_fast
_cehO:
	movq 6(%rbx),%rax
	movq %rax,%r14
	movq %rcx,%rbx
	addq $24,%rbp
	jmp stg_ap_p_fast
_cehR:
	movl $Main.mkQ_closure,%ebx
	jmp *-8(%r13)
	.size Main.mkQ_info, .-Main.mkQ_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . Main.everything_closure" {
     Main.everything_closure:
         const Main.everything_info;
         const 0;
 },
 sat_seeV_entry() //  [R3, R2, R1]
         { info_tbl: [(ceii,
                       label: sat_seeV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceii:
           _seeU::P64 = R3;   // CmmAssign
           _seeT::P64 = R2;   // CmmAssign
           _seeV::P64 = R1;   // CmmAssign
           goto ceig;   // CmmBranch
       ceig:
           if ((old + 0) - <highSp> < SpLim) goto ceij; else goto ceik;   // CmmCondBranch
       ceij:
           R3 = _seeU::P64;   // CmmAssign
           R2 = _seeT::P64;   // CmmAssign
           R1 = _seeV::P64;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceik:
           goto ceif;   // CmmBranch
       ceif:
           _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
           _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
           R5 = _seeU::P64;   // CmmAssign
           R4 = _seeT::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seeW_entry() //  [R1]
         { info_tbl: [(ceil,
                       label: sat_seeW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceil:
           _seeW::P64 = R1;   // CmmAssign
           goto ceib;   // CmmBranch
       ceib:
           if ((old + 0) - <highSp> < SpLim) goto ceim; else goto cein;   // CmmCondBranch
       cein:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
       ceip:
           HpAlloc = 24;   // CmmAssign
           goto ceim;   // CmmBranch
       ceim:
           R1 = _seeW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceio:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seeW::P64;   // CmmStore
           _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
           _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
           _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
           _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seeV_info;   // CmmStore
           P64[Hp - 8] = _seeO::P64;   // CmmStore
           P64[Hp] = _seeP::P64;   // CmmStore
           _ceid::P64 = Hp - 14;   // CmmAssign
           R2 = _seeQ::P64;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _ceid::P64;   // CmmStore
           P64[(old + 32)] = _seeR::P64;   // CmmStore
           call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 Main.everything_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(ceir,
                       label: Main.everything_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceir:
           _seeR::P64 = R5;   // CmmAssign
           _seeQ::P64 = R4;   // CmmAssign
           _seeP::P64 = R3;   // CmmAssign
           _seeO::P64 = R2;   // CmmAssign
           goto cei7;   // CmmBranch
       cei7:
           if ((old + 0) - <highSp> < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
       ceit:
           goto cei6;   // CmmBranch
       cei6:
           Hp = Hp + 88;   // CmmAssign
           if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
       ceiv:
           HpAlloc = 88;   // CmmAssign
           goto ceis;   // CmmBranch
       ceis:
           R5 = _seeR::P64;   // CmmAssign
           R4 = _seeQ::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           R1 = Main.everything_closure;   // CmmAssign
           call (stg_gc_fun)(R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiu:
           // calling allocDynClosure
           I64[Hp - 80] = sat_seeW_info;   // CmmStore
           P64[Hp - 64] = _seeO::P64;   // CmmStore
           P64[Hp - 56] = _seeP::P64;   // CmmStore
           P64[Hp - 48] = _seeQ::P64;   // CmmStore
           P64[Hp - 40] = _seeR::P64;   // CmmStore
           _cei9::P64 = Hp - 80;   // CmmAssign
           I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
           P64[Hp - 16] = _seeP::P64;   // CmmStore
           P64[Hp - 8] = _seeQ::P64;   // CmmStore
           P64[Hp] = _seeR::P64;   // CmmStore
           _ceiq::P64 = Hp - 32;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[(old + 40)] = stg_ap_ppp_info;   // CmmStore
           P64[(old + 32)] = _seeO::P64;   // CmmStore
           P64[(old + 24)] = _ceiq::P64;   // CmmStore
           P64[(old + 16)] = _cei9::P64;   // CmmStore
           call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  ceii:
      _seeU::P64 = R3;   // CmmAssign
      _seeT::P64 = R2;   // CmmAssign
      _seeV::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceij; else goto ceik;   // CmmCondBranch
  ceij:
      R3 = _seeU::P64;   // CmmAssign
      R2 = _seeT::P64;   // CmmAssign
      R1 = _seeV::P64;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceik:
      _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
      _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
      R5 = _seeU::P64;   // CmmAssign
      R4 = _seeT::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceii:
      _seeU::P64 = R3;   // CmmAssign
      _seeT::P64 = R2;   // CmmAssign
      _seeV::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceij; else goto ceik;   // CmmCondBranch
  ceij:
      R3 = _seeU::P64;   // CmmAssign
      R2 = _seeT::P64;   // CmmAssign
      R1 = _seeV::P64;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceik:
      _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
      _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
      R5 = _seeU::P64;   // CmmAssign
      R4 = _seeT::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceii:
      _seeU::P64 = R3;   // CmmAssign
      _seeT::P64 = R2;   // CmmAssign
      _seeV::P64 = R1;   // CmmAssign
      goto ceik;   // CmmBranch
  ceik:
      _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
      _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
      R5 = _seeU::P64;   // CmmAssign
      R4 = _seeT::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceii, {Main.everything_closure}),
 (ceik, {Main.everything_closure})]



==================== after setInfoTableStackMap ====================
sat_seeV_entry() //  [R3, R2, R1]
        { info_tbl: [(ceii,
                      label: sat_seeV_info
                      rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceii:
          _seeU::P64 = R3;   // CmmAssign
          _seeT::P64 = R2;   // CmmAssign
          _seeV::P64 = R1;   // CmmAssign
          goto ceik;   // CmmBranch
      ceik:
          _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
          _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
          R5 = _seeU::P64;   // CmmAssign
          R4 = _seeT::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seeV_entry() //  [R3, R2, R1]
        { info_tbl: [(ceii,
                      label: sat_seeV_info
                      rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceii:
          _seeU::P64 = R3;   // CmmAssign
          _seeT::P64 = R2;   // CmmAssign
          _seeV::P64 = R1;   // CmmAssign
          goto ceik;   // CmmBranch
      ceik:
          _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
          _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
          R5 = _seeU::P64;   // CmmAssign
          R4 = _seeT::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceil:
      _seeW::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceim; else goto cein;   // CmmCondBranch
  cein:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
  ceip:
      HpAlloc = 24;   // CmmAssign
      goto ceim;   // CmmBranch
  ceim:
      R1 = _seeW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceio:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seeW::P64;   // CmmStore
      _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
      _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
      _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
      _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seeV_info;   // CmmStore
      P64[Hp - 8] = _seeO::P64;   // CmmStore
      P64[Hp] = _seeP::P64;   // CmmStore
      _ceid::P64 = Hp - 14;   // CmmAssign
      R2 = _seeQ::P64;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceid::P64;   // CmmStore
      P64[(old + 32)] = _seeR::P64;   // CmmStore
      call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceil:
      _seeW::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceim; else goto cein;   // CmmCondBranch
  cein:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
  ceip:
      HpAlloc = 24;   // CmmAssign
      goto ceim;   // CmmBranch
  ceim:
      R1 = _seeW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceio:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seeW::P64;   // CmmStore
      _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
      _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
      _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
      _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seeV_info;   // CmmStore
      P64[Hp - 8] = _seeO::P64;   // CmmStore
      P64[Hp] = _seeP::P64;   // CmmStore
      _ceid::P64 = Hp - 14;   // CmmAssign
      R2 = _seeQ::P64;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceid::P64;   // CmmStore
      P64[(old + 32)] = _seeR::P64;   // CmmStore
      call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceil:
      _seeW::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
  cein:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
  ceip:
      HpAlloc = 24;   // CmmAssign
      goto ceim;   // CmmBranch
  ceim:
      R1 = _seeW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceio:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seeW::P64;   // CmmStore
      _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
      _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
      _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
      _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seeV_info;   // CmmStore
      P64[Hp - 8] = _seeO::P64;   // CmmStore
      P64[Hp] = _seeP::P64;   // CmmStore
      _ceid::P64 = Hp - 14;   // CmmAssign
      R2 = _seeQ::P64;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _ceid::P64;   // CmmStore
      P64[Sp - 24] = _seeR::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceil, {sat_seeV_closure}), (ceim, {}),
 (cein, {sat_seeV_closure}), (ceio, {sat_seeV_closure}), (ceip, {})]



==================== after setInfoTableStackMap ====================
sat_seeW_entry() //  [R1]
        { info_tbl: [(ceil,
                      label: sat_seeW_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceil:
          _seeW::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
      cein:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
      ceip:
          HpAlloc = 24;   // CmmAssign
          goto ceim;   // CmmBranch
      ceim:
          R1 = _seeW::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceio:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seeW::P64;   // CmmStore
          _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
          _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
          _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
          _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seeV_info;   // CmmStore
          P64[Hp - 8] = _seeO::P64;   // CmmStore
          P64[Hp] = _seeP::P64;   // CmmStore
          _ceid::P64 = Hp - 14;   // CmmAssign
          R2 = _seeQ::P64;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceid::P64;   // CmmStore
          P64[Sp - 24] = _seeR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seeW_entry() //  [R1]
        { info_tbl: [(ceil,
                      label: sat_seeW_info
                      rep:HeapRep 4 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceil:
          _seeW::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
      cein:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
      ceip:
          HpAlloc = 24;   // CmmAssign
          goto ceim;   // CmmBranch
      ceim:
          R1 = _seeW::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceio:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seeW::P64;   // CmmStore
          _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
          _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
          _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
          _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seeV_info;   // CmmStore
          P64[Hp - 8] = _seeO::P64;   // CmmStore
          P64[Hp] = _seeP::P64;   // CmmStore
          _ceid::P64 = Hp - 14;   // CmmAssign
          R2 = _seeQ::P64;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceid::P64;   // CmmStore
          P64[Sp - 24] = _seeR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceir:
      _seeR::P64 = R5;   // CmmAssign
      _seeQ::P64 = R4;   // CmmAssign
      _seeP::P64 = R3;   // CmmAssign
      _seeO::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
  ceit:
      Hp = Hp + 88;   // CmmAssign
      if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
  ceiv:
      HpAlloc = 88;   // CmmAssign
      goto ceis;   // CmmBranch
  ceis:
      R5 = _seeR::P64;   // CmmAssign
      R4 = _seeQ::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      R1 = Main.everything_closure;   // CmmAssign
      call (stg_gc_fun)(R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiu:
      // calling allocDynClosure
      I64[Hp - 80] = sat_seeW_info;   // CmmStore
      P64[Hp - 64] = _seeO::P64;   // CmmStore
      P64[Hp - 56] = _seeP::P64;   // CmmStore
      P64[Hp - 48] = _seeQ::P64;   // CmmStore
      P64[Hp - 40] = _seeR::P64;   // CmmStore
      _cei9::P64 = Hp - 80;   // CmmAssign
      I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
      P64[Hp - 16] = _seeP::P64;   // CmmStore
      P64[Hp - 8] = _seeQ::P64;   // CmmStore
      P64[Hp] = _seeR::P64;   // CmmStore
      _ceiq::P64 = Hp - 32;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_ppp_info;   // CmmStore
      P64[(old + 32)] = _seeO::P64;   // CmmStore
      P64[(old + 24)] = _ceiq::P64;   // CmmStore
      P64[(old + 16)] = _cei9::P64;   // CmmStore
      call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceir:
      _seeR::P64 = R5;   // CmmAssign
      _seeQ::P64 = R4;   // CmmAssign
      _seeP::P64 = R3;   // CmmAssign
      _seeO::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
  ceit:
      Hp = Hp + 88;   // CmmAssign
      if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
  ceiv:
      HpAlloc = 88;   // CmmAssign
      goto ceis;   // CmmBranch
  ceis:
      R5 = _seeR::P64;   // CmmAssign
      R4 = _seeQ::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      R1 = Main.everything_closure;   // CmmAssign
      call (stg_gc_fun)(R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiu:
      // calling allocDynClosure
      I64[Hp - 80] = sat_seeW_info;   // CmmStore
      P64[Hp - 64] = _seeO::P64;   // CmmStore
      P64[Hp - 56] = _seeP::P64;   // CmmStore
      P64[Hp - 48] = _seeQ::P64;   // CmmStore
      P64[Hp - 40] = _seeR::P64;   // CmmStore
      _cei9::P64 = Hp - 80;   // CmmAssign
      I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
      P64[Hp - 16] = _seeP::P64;   // CmmStore
      P64[Hp - 8] = _seeQ::P64;   // CmmStore
      P64[Hp] = _seeR::P64;   // CmmStore
      _ceiq::P64 = Hp - 32;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_ppp_info;   // CmmStore
      P64[(old + 32)] = _seeO::P64;   // CmmStore
      P64[(old + 24)] = _ceiq::P64;   // CmmStore
      P64[(old + 16)] = _cei9::P64;   // CmmStore
      call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceir:
      _seeR::P64 = R5;   // CmmAssign
      _seeQ::P64 = R4;   // CmmAssign
      _seeP::P64 = R3;   // CmmAssign
      _seeO::P64 = R2;   // CmmAssign
      if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
  ceit:
      Hp = Hp + 88;   // CmmAssign
      if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
  ceiv:
      HpAlloc = 88;   // CmmAssign
      goto ceis;   // CmmBranch
  ceis:
      R5 = _seeR::P64;   // CmmAssign
      R4 = _seeQ::P64;   // CmmAssign
      R3 = _seeP::P64;   // CmmAssign
      R2 = _seeO::P64;   // CmmAssign
      R1 = Main.everything_closure;   // CmmAssign
      call (stg_gc_fun)(R5,
                        R4,
                        R3,
                        R2,
                        R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiu:
      // calling allocDynClosure
      I64[Hp - 80] = sat_seeW_info;   // CmmStore
      P64[Hp - 64] = _seeO::P64;   // CmmStore
      P64[Hp - 56] = _seeP::P64;   // CmmStore
      P64[Hp - 48] = _seeQ::P64;   // CmmStore
      P64[Hp - 40] = _seeR::P64;   // CmmStore
      _cei9::P64 = Hp - 80;   // CmmAssign
      I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
      P64[Hp - 16] = _seeP::P64;   // CmmStore
      P64[Hp - 8] = _seeQ::P64;   // CmmStore
      P64[Hp] = _seeR::P64;   // CmmStore
      _ceiq::P64 = Hp - 32;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
      P64[Sp - 24] = _seeO::P64;   // CmmStore
      P64[Sp - 16] = _ceiq::P64;   // CmmStore
      P64[Sp - 8] = _cei9::P64;   // CmmStore
      Sp = Sp - 32;   // CmmAssign
      call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceir,
  {Data.Foldable.$fFoldable[]_closure, Main.everything_closure,
   sat_seeW_closure}),
 (ceis, {Main.everything_closure}),
 (ceit,
  {Data.Foldable.$fFoldable[]_closure, Main.everything_closure,
   sat_seeW_closure}),
 (ceiu, {Data.Foldable.$fFoldable[]_closure, sat_seeW_closure}),
 (ceiv, {Main.everything_closure})]



==================== after setInfoTableStackMap ====================
Main.everything_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(ceir,
                      label: Main.everything_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceir:
          _seeR::P64 = R5;   // CmmAssign
          _seeQ::P64 = R4;   // CmmAssign
          _seeP::P64 = R3;   // CmmAssign
          _seeO::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
      ceit:
          Hp = Hp + 88;   // CmmAssign
          if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
      ceiv:
          HpAlloc = 88;   // CmmAssign
          goto ceis;   // CmmBranch
      ceis:
          R5 = _seeR::P64;   // CmmAssign
          R4 = _seeQ::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          R1 = Main.everything_closure;   // CmmAssign
          call (stg_gc_fun)(R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiu:
          // calling allocDynClosure
          I64[Hp - 80] = sat_seeW_info;   // CmmStore
          P64[Hp - 64] = _seeO::P64;   // CmmStore
          P64[Hp - 56] = _seeP::P64;   // CmmStore
          P64[Hp - 48] = _seeQ::P64;   // CmmStore
          P64[Hp - 40] = _seeR::P64;   // CmmStore
          _cei9::P64 = Hp - 80;   // CmmAssign
          I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
          P64[Hp - 16] = _seeP::P64;   // CmmStore
          P64[Hp - 8] = _seeQ::P64;   // CmmStore
          P64[Hp] = _seeR::P64;   // CmmStore
          _ceiq::P64 = Hp - 32;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
          P64[Sp - 24] = _seeO::P64;   // CmmStore
          P64[Sp - 16] = _ceiq::P64;   // CmmStore
          P64[Sp - 8] = _cei9::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
Main.everything_entry() //  [R5, R4, R3, R2]
        { info_tbl: [(ceir,
                      label: Main.everything_info
                      rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceir:
          _seeR::P64 = R5;   // CmmAssign
          _seeQ::P64 = R4;   // CmmAssign
          _seeP::P64 = R3;   // CmmAssign
          _seeO::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
      ceit:
          Hp = Hp + 88;   // CmmAssign
          if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
      ceiv:
          HpAlloc = 88;   // CmmAssign
          goto ceis;   // CmmBranch
      ceis:
          R5 = _seeR::P64;   // CmmAssign
          R4 = _seeQ::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          R1 = Main.everything_closure;   // CmmAssign
          call (stg_gc_fun)(R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiu:
          // calling allocDynClosure
          I64[Hp - 80] = sat_seeW_info;   // CmmStore
          P64[Hp - 64] = _seeO::P64;   // CmmStore
          P64[Hp - 56] = _seeP::P64;   // CmmStore
          P64[Hp - 48] = _seeQ::P64;   // CmmStore
          P64[Hp - 40] = _seeR::P64;   // CmmStore
          _cei9::P64 = Hp - 80;   // CmmAssign
          I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
          P64[Hp - 16] = _seeP::P64;   // CmmStore
          P64[Hp - 8] = _seeQ::P64;   // CmmStore
          P64[Hp] = _seeR::P64;   // CmmStore
          _ceiq::P64 = Hp - 32;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
          P64[Sp - 24] = _seeO::P64;   // CmmStore
          P64[Sp - 16] = _ceiq::P64;   // CmmStore
          P64[Sp - 8] = _cei9::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . Main.everything_closure" {
     Main.everything_closure:
         const Main.everything_info;
         const 0;
 },
 sat_seeV_entry() //  [R3, R2, R1]
         { info_tbl: [(ceii,
                       label: sat_seeV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceii:
           _seeU::P64 = R3;   // CmmAssign
           _seeT::P64 = R2;   // CmmAssign
           _seeV::P64 = R1;   // CmmAssign
           goto ceik;   // CmmBranch
       ceik:
           _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
           _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
           R5 = _seeU::P64;   // CmmAssign
           R4 = _seeT::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seeW_entry() //  [R1]
         { info_tbl: [(ceil,
                       label: sat_seeW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceil:
           _seeW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
       cein:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
       ceip:
           HpAlloc = 24;   // CmmAssign
           goto ceim;   // CmmBranch
       ceim:
           R1 = _seeW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceio:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seeW::P64;   // CmmStore
           _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
           _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
           _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
           _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seeV_info;   // CmmStore
           P64[Hp - 8] = _seeO::P64;   // CmmStore
           P64[Hp] = _seeP::P64;   // CmmStore
           _ceid::P64 = Hp - 14;   // CmmAssign
           R2 = _seeQ::P64;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceid::P64;   // CmmStore
           P64[Sp - 24] = _seeR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 Main.everything_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(ceir,
                       label: Main.everything_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceir:
           _seeR::P64 = R5;   // CmmAssign
           _seeQ::P64 = R4;   // CmmAssign
           _seeP::P64 = R3;   // CmmAssign
           _seeO::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
       ceit:
           Hp = Hp + 88;   // CmmAssign
           if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
       ceiv:
           HpAlloc = 88;   // CmmAssign
           goto ceis;   // CmmBranch
       ceis:
           R5 = _seeR::P64;   // CmmAssign
           R4 = _seeQ::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           R1 = Main.everything_closure;   // CmmAssign
           call (stg_gc_fun)(R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiu:
           // calling allocDynClosure
           I64[Hp - 80] = sat_seeW_info;   // CmmStore
           P64[Hp - 64] = _seeO::P64;   // CmmStore
           P64[Hp - 56] = _seeP::P64;   // CmmStore
           P64[Hp - 48] = _seeQ::P64;   // CmmStore
           P64[Hp - 40] = _seeR::P64;   // CmmStore
           _cei9::P64 = Hp - 80;   // CmmAssign
           I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
           P64[Hp - 16] = _seeP::P64;   // CmmStore
           P64[Hp - 8] = _seeQ::P64;   // CmmStore
           P64[Hp] = _seeR::P64;   // CmmStore
           _ceiq::P64 = Hp - 32;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
           P64[Sp - 24] = _seeO::P64;   // CmmStore
           P64[Sp - 16] = _ceiq::P64;   // CmmStore
           P64[Sp - 8] = _cei9::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . Main.everything_closure" {
     Main.everything_closure:
         const Main.everything_info;
         const 0;
 },
 sat_seeV_entry() //  [R3, R2, R1]
         { info_tbl: [(ceii,
                       label: sat_seeV_info
                       rep:HeapRep 2 ptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceii:
           _seeU::P64 = R3;   // CmmAssign
           _seeT::P64 = R2;   // CmmAssign
           _seeV::P64 = R1;   // CmmAssign
           goto ceik;   // CmmBranch
       ceik:
           _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
           _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
           R5 = _seeU::P64;   // CmmAssign
           R4 = _seeT::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seeW_entry() //  [R1]
         { info_tbl: [(ceil,
                       label: sat_seeW_info
                       rep:HeapRep 4 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceil:
           _seeW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
       cein:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
       ceip:
           HpAlloc = 24;   // CmmAssign
           goto ceim;   // CmmBranch
       ceim:
           R1 = _seeW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceio:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seeW::P64;   // CmmStore
           _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
           _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
           _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
           _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seeV_info;   // CmmStore
           P64[Hp - 8] = _seeO::P64;   // CmmStore
           P64[Hp] = _seeP::P64;   // CmmStore
           _ceid::P64 = Hp - 14;   // CmmAssign
           R2 = _seeQ::P64;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceid::P64;   // CmmStore
           P64[Sp - 24] = _seeR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 Main.everything_entry() //  [R5, R4, R3, R2]
         { info_tbl: [(ceir,
                       label: Main.everything_info
                       rep:HeapRep static { Fun {arity: 4 fun_type: ArgSpec 24} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceir:
           _seeR::P64 = R5;   // CmmAssign
           _seeQ::P64 = R4;   // CmmAssign
           _seeP::P64 = R3;   // CmmAssign
           _seeO::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
       ceit:
           Hp = Hp + 88;   // CmmAssign
           if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
       ceiv:
           HpAlloc = 88;   // CmmAssign
           goto ceis;   // CmmBranch
       ceis:
           R5 = _seeR::P64;   // CmmAssign
           R4 = _seeQ::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           R1 = Main.everything_closure;   // CmmAssign
           call (stg_gc_fun)(R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiu:
           // calling allocDynClosure
           I64[Hp - 80] = sat_seeW_info;   // CmmStore
           P64[Hp - 64] = _seeO::P64;   // CmmStore
           P64[Hp - 56] = _seeP::P64;   // CmmStore
           P64[Hp - 48] = _seeQ::P64;   // CmmStore
           P64[Hp - 40] = _seeR::P64;   // CmmStore
           _cei9::P64 = Hp - 80;   // CmmAssign
           I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
           P64[Hp - 16] = _seeP::P64;   // CmmStore
           P64[Hp - 8] = _seeQ::P64;   // CmmStore
           P64[Hp] = _seeR::P64;   // CmmStore
           _ceiq::P64 = Hp - 32;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
           P64[Sp - 24] = _seeO::P64;   // CmmStore
           P64[Sp - 16] = _ceiq::P64;   // CmmStore
           P64[Sp - 8] = _cei9::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . Main.everything_closure" {
     Main.everything_closure:
         const Main.everything_info;
         const 0;
 },
 sat_seeV_entry() //  [R3, R2, R1]
         { [(ceii,
             sat_seeV_info:
                 const SehZ_srt-sat_seeV_info+16;
                 const 8589934607;
                 const 2;
                 const 4294967308;)]
         }
     {offset
       ceii:
           _seeU::P64 = R3;   // CmmAssign
           _seeT::P64 = R2;   // CmmAssign
           _seeV::P64 = R1;   // CmmAssign
           goto ceik;   // CmmBranch
       ceik:
           _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
           _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
           R5 = _seeU::P64;   // CmmAssign
           R4 = _seeT::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seeW_entry() //  [R1]
         { [(ceil,
             sat_seeW_info:
                 const SehZ_srt-sat_seeW_info+16;
                 const 4;
                 const 4294967312;)]
         }
     {offset
       ceil:
           _seeW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceim; else goto cein;   // CmmCondBranch
       cein:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto ceip; else goto ceio;   // CmmCondBranch
       ceip:
           HpAlloc = 24;   // CmmAssign
           goto ceim;   // CmmBranch
       ceim:
           R1 = _seeW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceio:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seeW::P64;   // CmmStore
           _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
           _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
           _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
           _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seeV_info;   // CmmStore
           P64[Hp - 8] = _seeO::P64;   // CmmStore
           P64[Hp] = _seeP::P64;   // CmmStore
           _ceid::P64 = Hp - 14;   // CmmAssign
           R2 = _seeQ::P64;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceid::P64;   // CmmStore
           P64[Sp - 24] = _seeR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 Main.everything_entry() //  [R5, R4, R3, R2]
         { [(ceir,
             Main.everything_info:
                 const SehZ_srt-Main.everything_info+16;
                 const 17179869208;
                 const 0;
                 const 12884901903;)]
         }
     {offset
       ceir:
           _seeR::P64 = R5;   // CmmAssign
           _seeQ::P64 = R4;   // CmmAssign
           _seeP::P64 = R3;   // CmmAssign
           _seeO::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
       ceit:
           Hp = Hp + 88;   // CmmAssign
           if (Hp > HpLim) goto ceiv; else goto ceiu;   // CmmCondBranch
       ceiv:
           HpAlloc = 88;   // CmmAssign
           goto ceis;   // CmmBranch
       ceis:
           R5 = _seeR::P64;   // CmmAssign
           R4 = _seeQ::P64;   // CmmAssign
           R3 = _seeP::P64;   // CmmAssign
           R2 = _seeO::P64;   // CmmAssign
           R1 = Main.everything_closure;   // CmmAssign
           call (stg_gc_fun)(R5,
                             R4,
                             R3,
                             R2,
                             R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiu:
           // calling allocDynClosure
           I64[Hp - 80] = sat_seeW_info;   // CmmStore
           P64[Hp - 64] = _seeO::P64;   // CmmStore
           P64[Hp - 56] = _seeP::P64;   // CmmStore
           P64[Hp - 48] = _seeQ::P64;   // CmmStore
           P64[Hp - 40] = _seeR::P64;   // CmmStore
           _cei9::P64 = Hp - 80;   // CmmAssign
           I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
           P64[Hp - 16] = _seeP::P64;   // CmmStore
           P64[Hp - 8] = _seeQ::P64;   // CmmStore
           P64[Hp] = _seeR::P64;   // CmmStore
           _ceiq::P64 = Hp - 32;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
           P64[Sp - 24] = _seeO::P64;   // CmmStore
           P64[Sp - 16] = _ceiq::P64;   // CmmStore
           P64[Sp - 8] = _cei9::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . Main.everything_closure" {
    Main.everything_closure:
        const Main.everything_info;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl Main.everything_closure
.type Main.everything_closure, @object
Main.everything_closure:
	.quad	Main.everything_info
	.quad	0



==================== Liveness annotations added ====================
section ""data" . Main.everything_closure" {
    (1,
     Main.everything_closure:
         const Main.everything_info;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl Main.everything_closure
.type Main.everything_closure, @object
Main.everything_closure:
	.quad	Main.everything_info
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl Main.everything_closure
.type Main.everything_closure, @object
Main.everything_closure:
	.quad	Main.everything_info
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl Main.everything_closure
.type Main.everything_closure, @object
Main.everything_closure:
	.quad	Main.everything_info
	.quad	0



==================== Optimised Cmm ====================
sat_seeV_entry() //  [R3, R2, R1]
        { [(ceii,
            sat_seeV_info:
                const SehZ_srt-sat_seeV_info+16;
                const 8589934607;
                const 2;
                const 4294967308;)]
        }
    {offset
      ceii:
          _seeU::P64 = R3;   // CmmAssign
          _seeT::P64 = R2;   // CmmAssign
          _seeV::P64 = R1;   // CmmAssign
          goto ceik;   // CmmBranch
      ceik:
          _seeO::P64 = P64[_seeV::P64 + 6];   // CmmAssign
          _seeP::P64 = P64[_seeV::P64 + 14];   // CmmAssign
          R5 = _seeU::P64;   // CmmAssign
          R4 = _seeT::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeV_info)+16
	.long	0
	.quad	8589934607
	.quad	2
	.quad	4294967308
sat_seeV_info:
_ceii:
	movq %rsi,%vI_seeU
	movq %r14,%vI_seeT
	movq %rbx,%vI_seeV
	jmp _ceik
_ceik:
	movq 6(%vI_seeV),%vI_seeO
	movq 14(%vI_seeV),%vI_seeP
	movq %vI_seeU,%r8
	movq %vI_seeT,%rdi
	movq %vI_seeP,%rsi
	movq %vI_seeO,%r14
	jmp Main.everything_info
	.size sat_seeV_info, .-sat_seeV_info



==================== Liveness annotations added ====================
sat_seeV_entry() //  [R3, R2, R1]
        { [(ceii,
            sat_seeV_info:
                const SehZ_srt-sat_seeV_info+16;
                const 8589934607;
                const 2;
                const 4294967308;)]
          # entryIds         = [ceii]
          # liveVRegsOnEntry = Just [(ceii,
                                      [R1 :-> %r1, R4 :-> %r4, Re :-> %r14]),
                                     (ceik,
                                      [seeT :-> %vI_seeT, seeU :-> %vI_seeU, seeV :-> %vI_seeV])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceii:
            	movq %rsi,%vI_seeU
                    # born:    %vI_seeU
                    # r_dying: %r4
                     
            	movq %r14,%vI_seeT
                    # born:    %vI_seeT
                    # r_dying: %r14
                     
            	movq %rbx,%vI_seeV
                    # born:    %vI_seeV
                    # r_dying: %r1
                     
            	jmp _ceik
                    # r_dying: %vI_seeT %vI_seeU %vI_seeV
                     ,
     NONREC
        ceik:
            	movq 6(%vI_seeV),%vI_seeO
                    # born:    %vI_seeO
                     
            	movq 14(%vI_seeV),%vI_seeP
                    # born:    %vI_seeP
                    # r_dying: %vI_seeV
                     
            	movq %vI_seeU,%r8
                    # born:    %r8
                    # r_dying: %vI_seeU
                     
            	movq %vI_seeT,%rdi
                    # born:    %r5
                    # r_dying: %vI_seeT
                     
            	movq %vI_seeP,%rsi
                    # born:    %r4
                    # r_dying: %vI_seeP
                     
            	movq %vI_seeO,%r14
                    # born:    %r14
                    # r_dying: %vI_seeO
                     
            	jmp Main.everything_info
                    # r_dying: %r4 %r5 %r8 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeV_info)+16
	.long	0
	.quad	8589934607
	.quad	2
	.quad	4294967308
sat_seeV_info:
_ceii:
	jmp _ceik
_ceik:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq %rsi,%r8
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	jmp Main.everything_info
	.size sat_seeV_info, .-sat_seeV_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeV_info)+16
	.long	0
	.quad	8589934607
	.quad	2
	.quad	4294967308
sat_seeV_info:
_ceii:
_ceik:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq %rsi,%r8
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	jmp Main.everything_info
	.size sat_seeV_info, .-sat_seeV_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeV_info)+16
	.long	0
	.quad	8589934607
	.quad	2
	.quad	4294967308
sat_seeV_info:
_ceii:
_ceik:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq %rsi,%r8
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	jmp Main.everything_info
	.size sat_seeV_info, .-sat_seeV_info



==================== Optimised Cmm ====================
sat_seeW_entry() //  [R1]
        { [(ceil,
            sat_seeW_info:
                const SehZ_srt-sat_seeW_info+16;
                const 4;
                const 4294967312;)]
        }
    {offset
      ceil:
          _seeW::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto ceim; else goto cein;   // CmmCondBranch
      cein:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceip; else goto ceio;   // CmmCondBranch
      ceip:
          I64[BaseReg + 904] = 24;   // CmmStore
          goto ceim;   // CmmBranch
      ceim:
          R1 = _seeW::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceio:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seeW::P64;   // CmmStore
          _seeO::P64 = P64[_seeW::P64 + 16];   // CmmAssign
          _seeP::P64 = P64[_seeW::P64 + 24];   // CmmAssign
          _seeQ::P64 = P64[_seeW::P64 + 32];   // CmmAssign
          _seeR::P64 = P64[_seeW::P64 + 40];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seeV_info;   // CmmStore
          P64[Hp - 8] = _seeO::P64;   // CmmStore
          P64[Hp] = _seeP::P64;   // CmmStore
          _ceid::P64 = Hp - 14;   // CmmAssign
          R2 = _seeQ::P64;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceid::P64;   // CmmStore
          P64[Sp - 24] = _seeR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call Data.Data.gmapQ_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeW_info)+16
	.long	0
	.quad	4
	.quad	4294967312
sat_seeW_info:
_ceil:
	movq %rbx,%vI_seeW
	leaq -40(%rbp),%vI_neiA
	cmpq %r15,%vI_neiA
	jb _ceim
	jmp _cein
_ceim:
	movq %vI_seeW,%rbx
	jmp *-16(%r13)
_cein:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _ceip
	jmp _ceio
_ceio:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seeW,-8(%rbp)
	movq 16(%vI_seeW),%vI_seeO
	movq 24(%vI_seeW),%vI_seeP
	movq 32(%vI_seeW),%vI_seeQ
	movq 40(%vI_seeW),%vI_seeR
	movq $sat_seeV_info,-16(%r12)
	movq %vI_seeO,-8(%r12)
	movq %vI_seeP,(%r12)
	leaq -14(%r12),%vI_ceid
	movq %vI_seeQ,%r14
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_ceid,-32(%rbp)
	movq %vI_seeR,-24(%rbp)
	addq $-40,%rbp
	jmp Data.Data.gmapQ_info
_ceip:
	movq $24,904(%r13)
	jmp _ceim
	.size sat_seeW_info, .-sat_seeW_info



==================== Liveness annotations added ====================
sat_seeW_entry() //  [R1]
        { [(ceil,
            sat_seeW_info:
                const SehZ_srt-sat_seeW_info+16;
                const 4;
                const 4294967312;)]
          # entryIds         = [ceil]
          # liveVRegsOnEntry = Just [(ceil, [R1 :-> %r1]),
                                     (ceim, [seeW :-> %vI_seeW]), (cein, [seeW :-> %vI_seeW]),
                                     (ceio, [seeW :-> %vI_seeW]), (ceip, [seeW :-> %vI_seeW])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceil:
            	movq %rbx,%vI_seeW
                    # born:    %vI_seeW
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_neiA
                    # born:    %vI_neiA
                     
            	cmpq %r15,%vI_neiA
                    # r_dying: %vI_neiA
                     
            	jb _ceim
                     
            	jmp _cein
                    # r_dying: %vI_seeW
                     ,
     NONREC
        cein:
            	addq $24,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceip
                     
            	jmp _ceio
                    # r_dying: %vI_seeW
                     ,
     NONREC
        ceip:
            	movq $24,904(%r13)
                     
            	jmp _ceim
                    # r_dying: %vI_seeW
                     ,
     NONREC
        ceim:
            	movq %vI_seeW,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeW
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceio:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seeW,-8(%rbp)
                     
            	movq 16(%vI_seeW),%vI_seeO
                    # born:    %vI_seeO
                     
            	movq 24(%vI_seeW),%vI_seeP
                    # born:    %vI_seeP
                     
            	movq 32(%vI_seeW),%vI_seeQ
                    # born:    %vI_seeQ
                     
            	movq 40(%vI_seeW),%vI_seeR
                    # born:    %vI_seeR
                    # r_dying: %vI_seeW
                     
            	movq $sat_seeV_info,-16(%r12)
                     
            	movq %vI_seeO,-8(%r12)
                    # r_dying: %vI_seeO
                     
            	movq %vI_seeP,(%r12)
                    # r_dying: %vI_seeP
                     
            	leaq -14(%r12),%vI_ceid
                    # born:    %vI_ceid
                     
            	movq %vI_seeQ,%r14
                    # born:    %r14
                    # r_dying: %vI_seeQ
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_ceid,-32(%rbp)
                    # r_dying: %vI_ceid
                     
            	movq %vI_seeR,-24(%rbp)
                    # r_dying: %vI_seeR
                     
            	addq $-40,%rbp
                     
            	jmp Data.Data.gmapQ_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeW_info)+16
	.long	0
	.quad	4
	.quad	4294967312
sat_seeW_info:
_ceil:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceim
	jmp _cein
_cein:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _ceip
	jmp _ceio
_ceip:
	movq $24,904(%r13)
	jmp _ceim
_ceim:
	jmp *-16(%r13)
_ceio:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rcx
	movq 32(%rbx),%rdx
	movq 40(%rbx),%rbx
	movq $sat_seeV_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rcx,(%r12)
	leaq -14(%r12),%rax
	movq %rdx,%r14
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp Data.Data.gmapQ_info
	.size sat_seeW_info, .-sat_seeW_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeW_info)+16
	.long	0
	.quad	4
	.quad	4294967312
sat_seeW_info:
_ceil:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceim
_cein:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _ceip
_ceio:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rcx
	movq 32(%rbx),%rdx
	movq 40(%rbx),%rbx
	movq $sat_seeV_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rcx,(%r12)
	leaq -14(%r12),%rax
	movq %rdx,%r14
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp Data.Data.gmapQ_info
_ceip:
	movq $24,904(%r13)
_ceim:
	jmp *-16(%r13)
	.size sat_seeW_info, .-sat_seeW_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seeW_info)+16
	.long	0
	.quad	4
	.quad	4294967312
sat_seeW_info:
_ceil:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceim
_cein:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _ceip
_ceio:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rcx
	movq 32(%rbx),%rdx
	movq 40(%rbx),%rbx
	movq $sat_seeV_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rcx,(%r12)
	leaq -14(%r12),%rax
	movq %rdx,%r14
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp Data.Data.gmapQ_info
_ceip:
	movq $24,904(%r13)
_ceim:
	jmp *-16(%r13)
	.size sat_seeW_info, .-sat_seeW_info



==================== Optimised Cmm ====================
Main.everything_entry() //  [R5, R4, R3, R2]
        { [(ceir,
            Main.everything_info:
                const SehZ_srt-Main.everything_info+16;
                const 17179869208;
                const 0;
                const 12884901903;)]
        }
    {offset
      ceir:
          _seeR::P64 = R5;   // CmmAssign
          _seeQ::P64 = R4;   // CmmAssign
          _seeP::P64 = R3;   // CmmAssign
          _seeO::P64 = R2;   // CmmAssign
          if ((Sp + -32) < SpLim) goto ceis; else goto ceit;   // CmmCondBranch
      ceit:
          Hp = Hp + 88;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceiv; else goto ceiu;   // CmmCondBranch
      ceiv:
          I64[BaseReg + 904] = 88;   // CmmStore
          goto ceis;   // CmmBranch
      ceis:
          R5 = _seeR::P64;   // CmmAssign
          R4 = _seeQ::P64;   // CmmAssign
          R3 = _seeP::P64;   // CmmAssign
          R2 = _seeO::P64;   // CmmAssign
          R1 = Main.everything_closure;   // CmmAssign
          call (I64[BaseReg - 8])(R5,
                                  R4,
                                  R3,
                                  R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiu:
          // calling allocDynClosure
          I64[Hp - 80] = sat_seeW_info;   // CmmStore
          P64[Hp - 64] = _seeO::P64;   // CmmStore
          P64[Hp - 56] = _seeP::P64;   // CmmStore
          P64[Hp - 48] = _seeQ::P64;   // CmmStore
          P64[Hp - 40] = _seeR::P64;   // CmmStore
          _cei9::P64 = Hp - 80;   // CmmAssign
          I64[Hp - 32] = stg_ap_3_upd_info;   // CmmStore
          P64[Hp - 16] = _seeP::P64;   // CmmStore
          P64[Hp - 8] = _seeQ::P64;   // CmmStore
          P64[Hp] = _seeR::P64;   // CmmStore
          _ceiq::P64 = Hp - 32;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_ppp_info;   // CmmStore
          P64[Sp - 24] = _seeO::P64;   // CmmStore
          P64[Sp - 16] = _ceiq::P64;   // CmmStore
          P64[Sp - 8] = _cei9::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call Data.Foldable.foldl_info(R2) args: 40, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.everything_info)+16
	.long	0
	.quad	17179869208
	.quad	0
	.quad	12884901903
.globl Main.everything_info
.type Main.everything_info, @object
Main.everything_info:
_ceir:
	movq %r8,%vI_seeR
	movq %rdi,%vI_seeQ
	movq %rsi,%vI_seeP
	movq %r14,%vI_seeO
	leaq -32(%rbp),%vI_neiD
	cmpq %r15,%vI_neiD
	jb _ceis
	jmp _ceit
_ceis:
	movq %vI_seeR,%r8
	movq %vI_seeQ,%rdi
	movq %vI_seeP,%rsi
	movq %vI_seeO,%r14
	movl $Main.everything_closure,%ebx
	jmp *-8(%r13)
_ceit:
	addq $88,%r12
	cmpq 856(%r13),%r12
	ja _ceiv
	jmp _ceiu
_ceiu:
	movq $sat_seeW_info,-80(%r12)
	movq %vI_seeO,-64(%r12)
	movq %vI_seeP,-56(%r12)
	movq %vI_seeQ,-48(%r12)
	movq %vI_seeR,-40(%r12)
	leaq -80(%r12),%vI_cei9
	movq $stg_ap_3_upd_info,-32(%r12)
	movq %vI_seeP,-16(%r12)
	movq %vI_seeQ,-8(%r12)
	movq %vI_seeR,(%r12)
	leaq -32(%r12),%vI_ceiq
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_ppp_info,-32(%rbp)
	movq %vI_seeO,-24(%rbp)
	movq %vI_ceiq,-16(%rbp)
	movq %vI_cei9,-8(%rbp)
	addq $-32,%rbp
	jmp Data.Foldable.foldl_info
_ceiv:
	movq $88,904(%r13)
	jmp _ceis
	.size Main.everything_info, .-Main.everything_info



==================== Liveness annotations added ====================
Main.everything_entry() //  [R5, R4, R3, R2]
        { [(ceir,
            Main.everything_info:
                const SehZ_srt-Main.everything_info+16;
                const 17179869208;
                const 0;
                const 12884901903;)]
          # entryIds         = [ceir]
          # liveVRegsOnEntry = Just [(ceir,
                                      [R4 :-> %r4, R5 :-> %r5, R8 :-> %r8, Re :-> %r14]),
                                     (ceis,
                                      [seeO :-> %vI_seeO, seeP :-> %vI_seeP, seeQ :-> %vI_seeQ,
                                       seeR :-> %vI_seeR]),
                                     (ceit,
                                      [seeO :-> %vI_seeO, seeP :-> %vI_seeP, seeQ :-> %vI_seeQ,
                                       seeR :-> %vI_seeR]),
                                     (ceiu,
                                      [seeO :-> %vI_seeO, seeP :-> %vI_seeP, seeQ :-> %vI_seeQ,
                                       seeR :-> %vI_seeR]),
                                     (ceiv,
                                      [seeO :-> %vI_seeO, seeP :-> %vI_seeP, seeQ :-> %vI_seeQ,
                                       seeR :-> %vI_seeR])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceir:
            	movq %r8,%vI_seeR
                    # born:    %vI_seeR
                    # r_dying: %r8
                     
            	movq %rdi,%vI_seeQ
                    # born:    %vI_seeQ
                    # r_dying: %r5
                     
            	movq %rsi,%vI_seeP
                    # born:    %vI_seeP
                    # r_dying: %r4
                     
            	movq %r14,%vI_seeO
                    # born:    %vI_seeO
                    # r_dying: %r14
                     
            	leaq -32(%rbp),%vI_neiD
                    # born:    %vI_neiD
                     
            	cmpq %r15,%vI_neiD
                    # r_dying: %vI_neiD
                     
            	jb _ceis
                     
            	jmp _ceit
                    # r_dying: %vI_seeO %vI_seeP %vI_seeQ %vI_seeR
                     ,
     NONREC
        ceit:
            	addq $88,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceiv
                     
            	jmp _ceiu
                    # r_dying: %vI_seeO %vI_seeP %vI_seeQ %vI_seeR
                     ,
     NONREC
        ceiv:
            	movq $88,904(%r13)
                     
            	jmp _ceis
                    # r_dying: %vI_seeO %vI_seeP %vI_seeQ %vI_seeR
                     ,
     NONREC
        ceis:
            	movq %vI_seeR,%r8
                    # born:    %r8
                    # r_dying: %vI_seeR
                     
            	movq %vI_seeQ,%rdi
                    # born:    %r5
                    # r_dying: %vI_seeQ
                     
            	movq %vI_seeP,%rsi
                    # born:    %r4
                    # r_dying: %vI_seeP
                     
            	movq %vI_seeO,%r14
                    # born:    %r14
                    # r_dying: %vI_seeO
                     
            	movl $Main.everything_closure,%ebx
                    # born:    %r1
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r4 %r5 %r8 %r14
                     ,
     NONREC
        ceiu:
            	movq $sat_seeW_info,-80(%r12)
                     
            	movq %vI_seeO,-64(%r12)
                     
            	movq %vI_seeP,-56(%r12)
                     
            	movq %vI_seeQ,-48(%r12)
                     
            	movq %vI_seeR,-40(%r12)
                     
            	leaq -80(%r12),%vI_cei9
                    # born:    %vI_cei9
                     
            	movq $stg_ap_3_upd_info,-32(%r12)
                     
            	movq %vI_seeP,-16(%r12)
                    # r_dying: %vI_seeP
                     
            	movq %vI_seeQ,-8(%r12)
                    # r_dying: %vI_seeQ
                     
            	movq %vI_seeR,(%r12)
                    # r_dying: %vI_seeR
                     
            	leaq -32(%r12),%vI_ceiq
                    # born:    %vI_ceiq
                     
            	movl $Data.Foldable.$fFoldable[]_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_ppp_info,-32(%rbp)
                     
            	movq %vI_seeO,-24(%rbp)
                    # r_dying: %vI_seeO
                     
            	movq %vI_ceiq,-16(%rbp)
                    # r_dying: %vI_ceiq
                     
            	movq %vI_cei9,-8(%rbp)
                    # r_dying: %vI_cei9
                     
            	addq $-32,%rbp
                     
            	jmp Data.Foldable.foldl_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.everything_info)+16
	.long	0
	.quad	17179869208
	.quad	0
	.quad	12884901903
.globl Main.everything_info
.type Main.everything_info, @object
Main.everything_info:
_ceir:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceis
	jmp _ceit
_ceit:
	addq $88,%r12
	cmpq 856(%r13),%r12
	ja _ceiv
	jmp _ceiu
_ceiv:
	movq $88,904(%r13)
	jmp _ceis
_ceis:
	movl $Main.everything_closure,%ebx
	jmp *-8(%r13)
_ceiu:
	movq $sat_seeW_info,-80(%r12)
	movq %r14,-64(%r12)
	movq %rsi,-56(%r12)
	movq %rdi,-48(%r12)
	movq %r8,-40(%r12)
	leaq -80(%r12),%rax
	movq $stg_ap_3_upd_info,-32(%r12)
	movq %rsi,-16(%r12)
	movq %rdi,-8(%r12)
	movq %r8,(%r12)
	leaq -32(%r12),%rbx
	movq %r14,%rcx
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_ppp_info,-32(%rbp)
	movq %rcx,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-32,%rbp
	jmp Data.Foldable.foldl_info
	.size Main.everything_info, .-Main.everything_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.everything_info)+16
	.long	0
	.quad	17179869208
	.quad	0
	.quad	12884901903
.globl Main.everything_info
.type Main.everything_info, @object
Main.everything_info:
_ceir:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceis
_ceit:
	addq $88,%r12
	cmpq 856(%r13),%r12
	ja _ceiv
_ceiu:
	movq $sat_seeW_info,-80(%r12)
	movq %r14,-64(%r12)
	movq %rsi,-56(%r12)
	movq %rdi,-48(%r12)
	movq %r8,-40(%r12)
	leaq -80(%r12),%rax
	movq $stg_ap_3_upd_info,-32(%r12)
	movq %rsi,-16(%r12)
	movq %rdi,-8(%r12)
	movq %r8,(%r12)
	leaq -32(%r12),%rbx
	movq %r14,%rcx
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_ppp_info,-32(%rbp)
	movq %rcx,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-32,%rbp
	jmp Data.Foldable.foldl_info
_ceiv:
	movq $88,904(%r13)
_ceis:
	movl $Main.everything_closure,%ebx
	jmp *-8(%r13)
	.size Main.everything_info, .-Main.everything_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.everything_info)+16
	.long	0
	.quad	17179869208
	.quad	0
	.quad	12884901903
.globl Main.everything_info
.type Main.everything_info, @object
Main.everything_info:
_ceir:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceis
_ceit:
	addq $88,%r12
	cmpq 856(%r13),%r12
	ja _ceiv
_ceiu:
	movq $sat_seeW_info,-80(%r12)
	movq %r14,-64(%r12)
	movq %rsi,-56(%r12)
	movq %rdi,-48(%r12)
	movq %r8,-40(%r12)
	leaq -80(%r12),%rax
	movq $stg_ap_3_upd_info,-32(%r12)
	movq %rsi,-16(%r12)
	movq %rdi,-8(%r12)
	movq %r8,(%r12)
	leaq -32(%r12),%rbx
	movq %r14,%rcx
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_ppp_info,-32(%rbp)
	movq %rcx,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-32,%rbp
	jmp Data.Foldable.foldl_info
_ceiv:
	movq $88,904(%r13)
_ceis:
	movl $Main.everything_closure,%ebx
	jmp *-8(%r13)
	.size Main.everything_info, .-Main.everything_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . $dShow_reeF_closure" {
     $dShow_reeF_closure:
         const $dShow_reeF_info;
         const 0;
         const 0;
         const 0;
 },
 $dShow_reeF_entry() //  [R1]
         { info_tbl: [(ceiL,
                       label: $dShow_reeF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceiL:
           _reeF::P64 = R1;   // CmmAssign
           goto ceiG;   // CmmBranch
       ceiG:
           if ((old + 0) - <highSp> < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
       ceiM:
           R1 = _reeF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiN:
           (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
           if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
       ceiK:
           call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       ceiJ:
           I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
           I64[(old + 16)] = _ceiI::I64;   // CmmStore
           R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  ceiL:
      _reeF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
  ceiM:
      R1 = _reeF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiN:
      (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
      if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
  ceiK:
      call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  ceiJ:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _ceiI::I64;   // CmmStore
      R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceiL:
      _reeF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
  ceiM:
      R1 = _reeF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiN:
      (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
      if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
  ceiK:
      call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  ceiJ:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _ceiI::I64;   // CmmStore
      R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceiL:
      _reeF::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
  ceiM:
      R1 = _reeF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceiN:
      (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
      if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
  ceiK:
      call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  ceiJ:
      I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
      I64[Sp - 8] = _ceiI::I64;   // CmmStore
      R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
      R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceiJ, {GHC.Show.$fShowInt_closure, GHC.Show.$fShow(,,)_closure}),
 (ceiK, {}),
 (ceiL, {GHC.Show.$fShowInt_closure, GHC.Show.$fShow(,,)_closure}),
 (ceiM, {}),
 (ceiN, {GHC.Show.$fShowInt_closure, GHC.Show.$fShow(,,)_closure})]



==================== after setInfoTableStackMap ====================
$dShow_reeF_entry() //  [R1]
        { info_tbl: [(ceiL,
                      label: $dShow_reeF_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceiL:
          _reeF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
      ceiM:
          R1 = _reeF::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiN:
          (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
          if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
      ceiK:
          call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      ceiJ:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _ceiI::I64;   // CmmStore
          R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dShow_reeF_entry() //  [R1]
        { info_tbl: [(ceiL,
                      label: $dShow_reeF_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceiL:
          _reeF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
      ceiM:
          R1 = _reeF::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiN:
          (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
          if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
      ceiK:
          call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      ceiJ:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _ceiI::I64;   // CmmStore
          R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . $dShow_reeF_closure" {
     $dShow_reeF_closure:
         const $dShow_reeF_info;
         const 0;
         const 0;
         const 0;
 },
 $dShow_reeF_entry() //  [R1]
         { info_tbl: [(ceiL,
                       label: $dShow_reeF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceiL:
           _reeF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
       ceiM:
           R1 = _reeF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiN:
           (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
           if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
       ceiK:
           call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       ceiJ:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _ceiI::I64;   // CmmStore
           R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . $dShow_reeF_closure" {
     $dShow_reeF_closure:
         const $dShow_reeF_info;
         const 0;
         const 0;
         const 0;
 },
 $dShow_reeF_entry() //  [R1]
         { info_tbl: [(ceiL,
                       label: $dShow_reeF_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceiL:
           _reeF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
       ceiM:
           R1 = _reeF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiN:
           (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
           if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
       ceiK:
           call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       ceiJ:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _ceiI::I64;   // CmmStore
           R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . $dShow_reeF_closure" {
     $dShow_reeF_closure:
         const $dShow_reeF_info;
         const 0;
         const 0;
         const 0;
 },
 $dShow_reeF_entry() //  [R1]
         { [(ceiL,
             $dShow_reeF_info:
                 const SehZ_srt-$dShow_reeF_info+32;
                 const 0;
                 const 12884901910;)]
         }
     {offset
       ceiL:
           _reeF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
       ceiM:
           R1 = _reeF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceiN:
           (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
           if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
       ceiK:
           call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       ceiJ:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _ceiI::I64;   // CmmStore
           R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
           R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . $dShow_reeF_closure" {
    $dShow_reeF_closure:
        const $dShow_reeF_info;
        const 0;
        const 0;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
$dShow_reeF_closure:
	.quad	$dShow_reeF_info
	.quad	0
	.quad	0
	.quad	0



==================== Liveness annotations added ====================
section ""data" . $dShow_reeF_closure" {
    (1,
     $dShow_reeF_closure:
         const $dShow_reeF_info;
         const 0;
         const 0;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
$dShow_reeF_closure:
	.quad	$dShow_reeF_info
	.quad	0
	.quad	0
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
$dShow_reeF_closure:
	.quad	$dShow_reeF_info
	.quad	0
	.quad	0
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
$dShow_reeF_closure:
	.quad	$dShow_reeF_info
	.quad	0
	.quad	0
	.quad	0



==================== Optimised Cmm ====================
$dShow_reeF_entry() //  [R1]
        { [(ceiL,
            $dShow_reeF_info:
                const SehZ_srt-$dShow_reeF_info+32;
                const 0;
                const 12884901910;)]
        }
    {offset
      ceiL:
          _reeF::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceiM; else goto ceiN;   // CmmCondBranch
      ceiM:
          R1 = _reeF::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceiN:
          (_ceiI::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _reeF::P64);   // CmmUnsafeForeignCall
          if (_ceiI::I64 == 0) goto ceiK; else goto ceiJ;   // CmmCondBranch
      ceiK:
          call (I64[_reeF::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      ceiJ:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _ceiI::I64;   // CmmStore
          R4 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R3 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R2 = GHC.Show.$fShowInt_closure;   // CmmAssign
          R1 = GHC.Show.$fShow(,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dShow_reeF_info)+32
	.long	0
	.quad	0
	.quad	12884901910
$dShow_reeF_info:
_ceiL:
	movq %rbx,%vI_reeF
	leaq -16(%rbp),%vI_neiQ
	cmpq %r15,%vI_neiQ
	jb _ceiM
	jmp _ceiN
_ceiJ:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %vI_ceiI,-8(%rbp)
	movl $GHC.Show.$fShowInt_closure,%edi
	movl $GHC.Show.$fShowInt_closure,%esi
	movl $GHC.Show.$fShowInt_closure,%r14d
	movl $GHC.Show.$fShow(,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_ceiK:
	jmp *(%vI_reeF)
_ceiM:
	movq %vI_reeF,%rbx
	jmp *-16(%r13)
_ceiN:
	movq %r13,%rdi
	movq %vI_reeF,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	movq %rax,%vI_ceiI
	testq %vI_ceiI,%vI_ceiI
	je _ceiK
	jmp _ceiJ
	.size $dShow_reeF_info, .-$dShow_reeF_info



==================== Liveness annotations added ====================
$dShow_reeF_entry() //  [R1]
        { [(ceiL,
            $dShow_reeF_info:
                const SehZ_srt-$dShow_reeF_info+32;
                const 0;
                const 12884901910;)]
          # entryIds         = [ceiL]
          # liveVRegsOnEntry = Just [(ceiJ, [ceiI :-> %vI_ceiI]),
                                     (ceiK, [reeF :-> %vI_reeF]), (ceiL, [R1 :-> %r1]),
                                     (ceiM, [reeF :-> %vI_reeF]), (ceiN, [reeF :-> %vI_reeF])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceiL:
            	movq %rbx,%vI_reeF
                    # born:    %vI_reeF
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neiQ
                    # born:    %vI_neiQ
                     
            	cmpq %r15,%vI_neiQ
                    # r_dying: %vI_neiQ
                     
            	jb _ceiM
                     
            	jmp _ceiN
                    # r_dying: %vI_reeF
                     ,
     NONREC
        ceiN:
            	movq %r13,%rdi
                    # born:    %r5
                     
            	movq %vI_reeF,%rsi
                    # born:    %r4
                     
            	subq $8,%rsp
                     
            	xorl %eax,%eax
                    # born:    %r0
                     
            	call newCAF
                    # born:    %r2 %r3 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                    # w_dying: %r2 %r3 %r4 %r5 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                     
            	addq $8,%rsp
                     
            	movq %rax,%vI_ceiI
                    # born:    %vI_ceiI
                    # r_dying: %r0
                     
            	testq %vI_ceiI,%vI_ceiI
                     
            	je _ceiK
                    # r_dying: %vI_reeF
                     
            	jmp _ceiJ
                    # r_dying: %vI_ceiI
                     ,
     NONREC
        ceiJ:
            	movq $stg_bh_upd_frame_info,-16(%rbp)
                     
            	movq %vI_ceiI,-8(%rbp)
                    # r_dying: %vI_ceiI
                     
            	movl $GHC.Show.$fShowInt_closure,%edi
                    # born:    %r5
                     
            	movl $GHC.Show.$fShowInt_closure,%esi
                    # born:    %r4
                     
            	movl $GHC.Show.$fShowInt_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.Show.$fShow(,,)_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_ppp_fast
                    # r_dying: %r1 %r4 %r5 %r14
                     ,
     NONREC
        ceiK:
            	jmp *(%vI_reeF)
                    # r_dying: %vI_reeF
                     ,
     NONREC
        ceiM:
            	movq %vI_reeF,%rbx
                    # born:    %r1
                    # r_dying: %vI_reeF
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dShow_reeF_info)+32
	.long	0
	.quad	0
	.quad	12884901910
$dShow_reeF_info:
_ceiL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceiM
	jmp _ceiN
_ceiN:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _ceiK
	jmp _ceiJ
_ceiJ:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Show.$fShowInt_closure,%edi
	movl $GHC.Show.$fShowInt_closure,%esi
	movl $GHC.Show.$fShowInt_closure,%r14d
	movl $GHC.Show.$fShow(,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_ceiK:
	jmp *(%rbx)
_ceiM:
	jmp *-16(%r13)
	.size $dShow_reeF_info, .-$dShow_reeF_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dShow_reeF_info)+32
	.long	0
	.quad	0
	.quad	12884901910
$dShow_reeF_info:
_ceiL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceiM
_ceiN:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _ceiK
_ceiJ:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Show.$fShowInt_closure,%edi
	movl $GHC.Show.$fShowInt_closure,%esi
	movl $GHC.Show.$fShowInt_closure,%r14d
	movl $GHC.Show.$fShow(,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_ceiK:
	jmp *(%rbx)
_ceiM:
	jmp *-16(%r13)
	.size $dShow_reeF_info, .-$dShow_reeF_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dShow_reeF_info)+32
	.long	0
	.quad	0
	.quad	12884901910
$dShow_reeF_info:
_ceiL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceiM
_ceiN:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _ceiK
_ceiJ:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Show.$fShowInt_closure,%edi
	movl $GHC.Show.$fShowInt_closure,%esi
	movl $GHC.Show.$fShowInt_closure,%r14d
	movl $GHC.Show.$fShow(,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_ceiK:
	jmp *(%rbx)
_ceiM:
	jmp *-16(%r13)
	.size $dShow_reeF_info, .-$dShow_reeF_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . Main.testOneFile_closure" {
     Main.testOneFile_closure:
         const Main.testOneFile_info;
         const 0;
 },
 $dTypeable_sef3_entry() //  [R1]
         { info_tbl: [(ceje,
                       label: $dTypeable_sef3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceje:
           _sef3::P64 = R1;   // CmmAssign
           goto cejc;   // CmmBranch
       cejc:
           if ((old + 0) - <highSp> < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
       cejf:
           R1 = _sef3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejg:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sef3::P64;   // CmmStore
           _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
           R2 = _sef2::P64;   // CmmAssign
           call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 ds_sef4_entry() //  [R1]
         { info_tbl: [(cejl,
                       label: ds_sef4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejl:
           _sef4::P64 = R1;   // CmmAssign
           goto cejj;   // CmmBranch
       cejj:
           if ((old + 0) - <highSp> < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
       cejm:
           R1 = _sef4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejn:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sef4::P64;   // CmmStore
           R4 = GHC.Types.[]_closure+1;   // CmmAssign
           R3 = GHC.Types.[]_closure+1;   // CmmAssign
           R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
           R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 a4_sef5_entry() //  [R1]
         { info_tbl: [(cejt,
                       label: a4_sef5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejt:
           _sef5::P64 = R1;   // CmmAssign
           goto cejr;   // CmmBranch
       cejr:
           if ((old + 0) - <highSp> < SpLim) goto ceju; else goto cejv;   // CmmCondBranch
       ceju:
           R1 = _sef5::P64;   // CmmAssign
           call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejv:
           goto cejq;   // CmmBranch
       cejq:
           _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
           R1 = _sef4::P64 & (-8);   // CmmAssign
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefd_entry() //  [R2, R1]
         { info_tbl: [(cejH,
                       label: sat_sefd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejH:
           _sef7::P64 = R2;   // CmmAssign
           _sefd::P64 = R1;   // CmmAssign
           goto cejz;   // CmmBranch
       cejz:
           if ((old + 0) - <highSp> < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
       cejI:
           R2 = _sef7::P64;   // CmmAssign
           R1 = _sefd::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejJ:
           goto cejy;   // CmmBranch
       cejy:
           _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
           _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
           I64[(young<cejB> + 8)] = cejB;   // CmmStore
           R4 = _sef7::P64;   // CmmAssign
           R3 = _sef5::P64;   // CmmAssign
           R2 = _sef3::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
       cejB:
           _sef8::P64 = R1;   // CmmAssign
           _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
           switch [1 .. 2] _cejG::P64 {
               case 1 : goto cejE;
               case 2 : goto cejF;
           }   // CmmSwitch
       cejF:
           _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
           I64[(young<cejP> + 8)] = cejP;   // CmmStore
           R1 = _sef9::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
       cejR:
           call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejP:
           _sefa::P64 = R1;   // CmmAssign
           _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
           switch [1 .. 2] _cek5::P64 {
               case 1 : goto cejX;
               case 2 : goto cek4;
           }   // CmmSwitch
       cek4:
           _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
           R1 = []_closure+1;   // CmmAssign
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejX:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
       cek0:
           HpAlloc = 24;   // CmmAssign
           goto cejY;   // CmmBranch
       cejY:
           R1 = _sefa::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejZ:
           _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
           I64[Hp - 16] = :_con_info;   // CmmStore
           P64[Hp - 8] = _sefa::P64;   // CmmStore
           P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
           _cejV::P64 = Hp - 14;   // CmmAssign
           R1 = _cejV::P64;   // CmmAssign
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejE:
           R1 = []_closure+1;   // CmmAssign
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefe_entry() //  [R2, R1]
         { info_tbl: [(cek6,
                       label: sat_sefe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cek6:
           _sef2::P64 = R2;   // CmmAssign
           _sefe::P64 = R1;   // CmmAssign
           goto cej8;   // CmmBranch
       cej8:
           if ((old + 0) - <highSp> < SpLim) goto cek7; else goto cek8;   // CmmCondBranch
       cek8:
           goto cej7;   // CmmBranch
       cej7:
           Hp = Hp + 80;   // CmmAssign
           if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
       ceka:
           HpAlloc = 80;   // CmmAssign
           goto cek7;   // CmmBranch
       cek7:
           R2 = _sef2::P64;   // CmmAssign
           R1 = _sefe::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cek9:
           // calling allocDynClosure
           I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
           P64[Hp - 56] = _sef2::P64;   // CmmStore
           _ceja::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = ds_sef4_info;   // CmmStore
           _cejh::P64 = Hp - 48;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = a4_sef5_info;   // CmmStore
           P64[Hp - 24] = _cejh::P64;   // CmmStore
           _cejo::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefd_info;   // CmmStore
           P64[Hp - 8] = _ceja::P64;   // CmmStore
           P64[Hp] = _cejo::P64;   // CmmStore
           _cejw::P64 = Hp - 15;   // CmmAssign
           R1 = _cejw::P64;   // CmmAssign
           call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seff_entry() //  [R1]
         { info_tbl: [(cekb,
                       label: sat_seff_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekb:
           _seff::P64 = R1;   // CmmAssign
           goto cej3;   // CmmBranch
       cej3:
           if ((old + 0) - <highSp> < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
       cekd:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
       cekf:
           HpAlloc = 16;   // CmmAssign
           goto cekc;   // CmmBranch
       cekc:
           R1 = _seff::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceke:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seff::P64;   // CmmStore
           _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
           _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefe_info;   // CmmStore
           _cej5::P64 = Hp - 7;   // CmmAssign
           R5 = _sef1::P64;   // CmmAssign
           R4 = _sef0::P64;   // CmmAssign
           R3 = _cej5::P64;   // CmmAssign
           R2 = GHC.Base.++_closure;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 gq_seeZ_entry() //  [R3, R2, R1]
         { info_tbl: [(cekg,
                       label: gq_seeZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekg:
           _sef1::P64 = R3;   // CmmAssign
           _sef0::P64 = R2;   // CmmAssign
           _seeZ::P64 = R1;   // CmmAssign
           goto ceiZ;   // CmmBranch
       ceiZ:
           if ((old + 0) - <highSp> < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
       ceki:
           goto ceiY;   // CmmBranch
       ceiY:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
       cekk:
           HpAlloc = 32;   // CmmAssign
           goto cekh;   // CmmBranch
       cekh:
           R3 = _sef1::P64;   // CmmAssign
           R2 = _sef0::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekj:
           // calling allocDynClosure
           I64[Hp - 24] = sat_seff_info;   // CmmStore
           P64[Hp - 8] = _sef0::P64;   // CmmStore
           P64[Hp] = _sef1::P64;   // CmmStore
           _cej1::P64 = Hp - 24;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[(old + 24)] = stg_ap_p_info;   // CmmStore
           P64[(old + 16)] = _cej1::P64;   // CmmStore
           call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 $dData_segd_entry() //  [R1]
         { info_tbl: [(cekD,
                       label: $dData_segd_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekD:
           _segd::P64 = R1;   // CmmAssign
           goto cekB;   // CmmBranch
       cekB:
           if ((old + 0) - <highSp> < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
       cekE:
           R1 = _segd::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekF:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segd::P64;   // CmmStore
           R2 = ConLike.$fDataConLike_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData1_sege_entry() //  [R1]
         { info_tbl: [(cekK,
                       label: $dData1_sege_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekK:
           _sege::P64 = R1;   // CmmAssign
           goto cekI;   // CmmBranch
       cekI:
           if ((old + 0) - <highSp> < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
       cekL:
           R1 = _sege::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekM:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sege::P64;   // CmmStore
           R2 = TypeRep.$fDataType_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData2_segf_entry() //  [R1]
         { info_tbl: [(cekR,
                       label: $dData2_segf_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekR:
           _segf::P64 = R1;   // CmmAssign
           goto cekP;   // CmmBranch
       cekP:
           if ((old + 0) - <highSp> < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
       cekS:
           R1 = _segf::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekT:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segf::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData3_segg_entry() //  [R1]
         { info_tbl: [(cekY,
                       label: $dData3_segg_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekY:
           _segg::P64 = R1;   // CmmAssign
           goto cekW;   // CmmBranch
       cekW:
           if ((old + 0) - <highSp> < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
       cekZ:
           R1 = _segg::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel0:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segg::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData4_segh_entry() //  [R1]
         { info_tbl: [(cel5,
                       label: $dData4_segh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cel5:
           _segh::P64 = R1;   // CmmAssign
           goto cel3;   // CmmBranch
       cel3:
           if ((old + 0) - <highSp> < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
       cel6:
           R1 = _segh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel7:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segh::P64;   // CmmStore
           _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
           R2 = _segg::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData5_segi_entry() //  [R1]
         { info_tbl: [(celc,
                       label: $dData5_segi_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celc:
           _segi::P64 = R1;   // CmmAssign
           goto cela;   // CmmBranch
       cela:
           if ((old + 0) - <highSp> < SpLim) goto celd; else goto cele;   // CmmCondBranch
       celd:
           R1 = _segi::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cele:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segi::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segk_entry() //  [R1]
         { info_tbl: [(cels,
                       label: sat_segk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cels:
           _segk::P64 = R1;   // CmmAssign
           goto celq;   // CmmBranch
       celq:
           if ((old + 0) - <highSp> < SpLim) goto celt; else goto celu;   // CmmCondBranch
       celt:
           R1 = _segk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celu:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segk::P64;   // CmmStore
           _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
           R3 = _segj::P64;   // CmmAssign
           R2 = _segj::P64;   // CmmAssign
           R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segl_entry() //  [R1]
         { info_tbl: [(celv,
                       label: sat_segl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celv:
           _segl::P64 = R1;   // CmmAssign
           goto celm;   // CmmBranch
       celm:
           if ((old + 0) - <highSp> < SpLim) goto celw; else goto celx;   // CmmCondBranch
       celx:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
       celz:
           HpAlloc = 24;   // CmmAssign
           goto celw;   // CmmBranch
       celw:
           R1 = _segl::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cely:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segl::P64;   // CmmStore
           _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segk_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celo::P64 = Hp - 16;   // CmmAssign
           R3 = _celo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segm_entry() //  [R1]
         { info_tbl: [(celA,
                       label: sat_segm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celA:
           _segm::P64 = R1;   // CmmAssign
           goto celi;   // CmmBranch
       celi:
           if ((old + 0) - <highSp> < SpLim) goto celB; else goto celC;   // CmmCondBranch
       celC:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
       celE:
           HpAlloc = 24;   // CmmAssign
           goto celB;   // CmmBranch
       celB:
           R1 = _segm::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celD:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segm::P64;   // CmmStore
           _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segl_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celk::P64 = Hp - 16;   // CmmAssign
           R2 = _celk::P64;   // CmmAssign
           R1 = Bag.$fDataBag_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segn_entry() //  [R1]
         { info_tbl: [(celF,
                       label: sat_segn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celF:
           _segn::P64 = R1;   // CmmAssign
           goto cekx;   // CmmBranch
       cekx:
           if ((old + 0) - <highSp> < SpLim) goto celG; else goto celH;   // CmmCondBranch
       celH:
           Hp = Hp + 248;   // CmmAssign
           if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
       celJ:
           HpAlloc = 248;   // CmmAssign
           goto celG;   // CmmBranch
       celG:
           R1 = _segn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celI:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segn::P64;   // CmmStore
           _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
           _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 240] = $dData_segd_info;   // CmmStore
           _cekz::P64 = Hp - 240;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 224] = $dData1_sege_info;   // CmmStore
           _cekG::P64 = Hp - 224;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 208] = $dData2_segf_info;   // CmmStore
           _cekN::P64 = Hp - 208;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 192] = $dData3_segg_info;   // CmmStore
           _cekU::P64 = Hp - 192;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 176] = $dData4_segh_info;   // CmmStore
           P64[Hp - 160] = _cekU::P64;   // CmmStore
           _cel1::P64 = Hp - 176;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 152] = $dData5_segi_info;   // CmmStore
           _cel8::P64 = Hp - 152;   // CmmAssign
           I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 120] = _cel8::P64;   // CmmStore
           P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 88] = _cekN::P64;   // CmmStore
           P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
           P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
           P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 48] = _cekG::P64;   // CmmStore
           P64[Hp - 40] = _cekz::P64;   // CmmStore
           P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
           P64[Hp - 24] = _cel1::P64;   // CmmStore
           _celf::P64 = Hp - 135;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segm_info;   // CmmStore
           P64[Hp] = _celf::P64;   // CmmStore
           _celg::P64 = Hp - 16;   // CmmAssign
           R3 = _sefS::P64;   // CmmAssign
           R2 = _celg::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg8_entry() //  [R1]
         { info_tbl: [(cem4,
                       label: sat_seg8_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem4:
           _seg8::P64 = R1;   // CmmAssign
           goto cem2;   // CmmBranch
       cem2:
           if ((old + 0) - <highSp> < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
       cem5:
           R1 = _seg8::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cem6:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg8::P64;   // CmmStore
           R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg9_entry() //  [R1]
         { info_tbl: [(cem7,
                       label: sat_seg9_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem7:
           _seg9::P64 = R1;   // CmmAssign
           goto celY;   // CmmBranch
       celY:
           if ((old + 0) - <highSp> < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
       cem9:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
       cemb:
           HpAlloc = 16;   // CmmAssign
           goto cem8;   // CmmBranch
       cem8:
           R1 = _seg9::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cema:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg9::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg8_info;   // CmmStore
           _cem0::P64 = Hp - 8;   // CmmAssign
           R2 = _cem0::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg4_entry() //  [R1]
         { info_tbl: [(cems,
                       label: sat_seg4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cems:
           _seg4::P64 = R1;   // CmmAssign
           goto cemq;   // CmmBranch
       cemq:
           if ((old + 0) - <highSp> < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
       cemt:
           R1 = _seg4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemu:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg4::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg5_entry() //  [R1]
         { info_tbl: [(cemv,
                       label: sat_seg5_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemv:
           _seg5::P64 = R1;   // CmmAssign
           goto cemm;   // CmmBranch
       cemm:
           if ((old + 0) - <highSp> < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
       cemx:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
       cemz:
           HpAlloc = 16;   // CmmAssign
           goto cemw;   // CmmBranch
       cemw:
           R1 = _seg5::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemy:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg5::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg4_info;   // CmmStore
           _cemo::P64 = Hp - 8;   // CmmAssign
           R3 = _cemo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg6_entry() //  [R1]
         { info_tbl: [(cemA,
                       label: sat_seg6_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemA:
           _seg6::P64 = R1;   // CmmAssign
           goto cemi;   // CmmBranch
       cemi:
           if ((old + 0) - <highSp> < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
       cemC:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
       cemE:
           HpAlloc = 16;   // CmmAssign
           goto cemB;   // CmmBranch
       cemB:
           R1 = _seg6::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemD:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg6::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg5_info;   // CmmStore
           _cemk::P64 = Hp - 8;   // CmmAssign
           R2 = _cemk::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg7_entry() //  [R1]
         { info_tbl: [(cemF,
                       label: sat_seg7_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemF:
           _seg7::P64 = R1;   // CmmAssign
           goto ceme;   // CmmBranch
       ceme:
           if ((old + 0) - <highSp> < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
       cemH:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
       cemJ:
           HpAlloc = 16;   // CmmAssign
           goto cemG;   // CmmBranch
       cemG:
           R1 = _seg7::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemI:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg7::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg6_info;   // CmmStore
           _cemg::P64 = Hp - 8;   // CmmAssign
           R2 = _cemg::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg1_entry() //  [R1]
         { info_tbl: [(cemW,
                       label: sat_seg1_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemW:
           _seg1::P64 = R1;   // CmmAssign
           goto cemU;   // CmmBranch
       cemU:
           if ((old + 0) - <highSp> < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
       cemX:
           R1 = _seg1::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemY:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg1::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg2_entry() //  [R1]
         { info_tbl: [(cemZ,
                       label: sat_seg2_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemZ:
           _seg2::P64 = R1;   // CmmAssign
           goto cemQ;   // CmmBranch
       cemQ:
           if ((old + 0) - <highSp> < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
       cen1:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
       cen3:
           HpAlloc = 16;   // CmmAssign
           goto cen0;   // CmmBranch
       cen0:
           R1 = _seg2::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen2:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg2::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg1_info;   // CmmStore
           _cemS::P64 = Hp - 8;   // CmmAssign
           R3 = _cemS::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg3_entry() //  [R1]
         { info_tbl: [(cen4,
                       label: sat_seg3_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cen4:
           _seg3::P64 = R1;   // CmmAssign
           goto cemM;   // CmmBranch
       cemM:
           if ((old + 0) - <highSp> < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
       cen6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
       cen8:
           HpAlloc = 16;   // CmmAssign
           goto cen5;   // CmmBranch
       cen5:
           R1 = _seg3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen7:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg3::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg2_info;   // CmmStore
           _cemO::P64 = Hp - 8;   // CmmAssign
           R2 = _cemO::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefY_entry() //  [R1]
         { info_tbl: [(cenh,
                       label: sat_sefY_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenh:
           _sefY::P64 = R1;   // CmmAssign
           goto cenf;   // CmmBranch
       cenf:
           if ((old + 0) - <highSp> < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
       ceni:
           R1 = _sefY::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenj:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefY::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefX_entry() //  [R1]
         { info_tbl: [(ceno,
                       label: sat_sefX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceno:
           _sefX::P64 = R1;   // CmmAssign
           goto cenm;   // CmmBranch
       cenm:
           if ((old + 0) - <highSp> < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
       cenp:
           R1 = _sefX::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenq:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefX::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg0_entry() //  [R1]
         { info_tbl: [(cens,
                       label: sat_seg0_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cens:
           _seg0::P64 = R1;   // CmmAssign
           goto cenb;   // CmmBranch
       cenb:
           if ((old + 0) - <highSp> < SpLim) goto cent; else goto cenu;   // CmmCondBranch
       cenu:
           Hp = Hp + 152;   // CmmAssign
           if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
       cenw:
           HpAlloc = 152;   // CmmAssign
           goto cent;   // CmmBranch
       cent:
           R1 = _seg0::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenv:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seg0::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 144] = sat_sefY_info;   // CmmStore
           _cend::P64 = Hp - 144;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 128] = sat_sefX_info;   // CmmStore
           _cenk::P64 = Hp - 128;   // CmmAssign
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 96] = _cenk::P64;   // CmmStore
           P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 64] = _cend::P64;   // CmmStore
           P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenr::P64 = Hp - 111;   // CmmAssign
           R2 = _cenr::P64;   // CmmAssign
           R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sega_entry() //  [R1]
         { info_tbl: [(cenx,
                       label: sat_sega_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenx:
           _sega::P64 = R1;   // CmmAssign
           goto celU;   // CmmBranch
       celU:
           if ((old + 0) - <highSp> < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
       cenz:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
       cenB:
           HpAlloc = 64;   // CmmAssign
           goto ceny;   // CmmBranch
       ceny:
           R1 = _sega::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenA:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sega::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 56] = sat_seg9_info;   // CmmStore
           _celW::P64 = Hp - 56;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_seg7_info;   // CmmStore
           _cemc::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_seg3_info;   // CmmStore
           _cemK::P64 = Hp - 24;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg0_info;   // CmmStore
           _cen9::P64 = Hp - 8;   // CmmAssign
           R5 = _celW::P64;   // CmmAssign
           R4 = _cemc::P64;   // CmmAssign
           R3 = _cemK::P64;   // CmmAssign
           R2 = _cen9::P64;   // CmmAssign
           R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
           call stg_ap_pppp_fast(R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segb_entry() //  [R1]
         { info_tbl: [(cenC,
                       label: sat_segb_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenC:
           _segb::P64 = R1;   // CmmAssign
           goto celQ;   // CmmBranch
       celQ:
           if ((old + 0) - <highSp> < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
       cenE:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
       cenG:
           HpAlloc = 16;   // CmmAssign
           goto cenD;   // CmmBranch
       cenD:
           R1 = _segb::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenF:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segb::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sega_info;   // CmmStore
           _celS::P64 = Hp - 8;   // CmmAssign
           R2 = _celS::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segc_entry() //  [R1]
         { info_tbl: [(cenH,
                       label: sat_segc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenH:
           _segc::P64 = R1;   // CmmAssign
           goto celM;   // CmmBranch
       celM:
           if ((old + 0) - <highSp> < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
       cenJ:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
       cenL:
           HpAlloc = 16;   // CmmAssign
           goto cenI;   // CmmBranch
       cenI:
           R1 = _segc::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenK:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segc::P64;   // CmmStore
           _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
           _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segb_info;   // CmmStore
           _celO::P64 = Hp - 8;   // CmmAssign
           R3 = _sefR::P64;   // CmmAssign
           R2 = _celO::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefU_entry() //  [R1]
         { info_tbl: [(cenZ,
                       label: sat_sefU_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenZ:
           _sefU::P64 = R1;   // CmmAssign
           goto cenW;   // CmmBranch
       cenW:
           if ((old + 0) - <highSp> < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
       ceo1:
           Hp = Hp + 120;   // CmmAssign
           if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
       ceo3:
           HpAlloc = 120;   // CmmAssign
           goto ceo0;   // CmmBranch
       ceo0:
           R1 = _sefU::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo2:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefU::P64;   // CmmStore
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
           P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenY::P64 = Hp - 111;   // CmmAssign
           R2 = _cenY::P64;   // CmmAssign
           R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefV_entry() //  [R1]
         { info_tbl: [(ceo4,
                       label: sat_sefV_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo4:
           _sefV::P64 = R1;   // CmmAssign
           goto cenS;   // CmmBranch
       cenS:
           if ((old + 0) - <highSp> < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
       ceo6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
       ceo8:
           HpAlloc = 16;   // CmmAssign
           goto ceo5;   // CmmBranch
       ceo5:
           R1 = _sefV::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo7:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefV::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefU_info;   // CmmStore
           _cenU::P64 = Hp - 8;   // CmmAssign
           R3 = _cenU::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefW_entry() //  [R1]
         { info_tbl: [(ceo9,
                       label: sat_sefW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo9:
           _sefW::P64 = R1;   // CmmAssign
           goto cenO;   // CmmBranch
       cenO:
           if ((old + 0) - <highSp> < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
       ceob:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
       ceod:
           HpAlloc = 16;   // CmmAssign
           goto ceoa;   // CmmBranch
       ceoa:
           R1 = _sefW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoc:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefW::P64;   // CmmStore
           _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
           _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefV_info;   // CmmStore
           _cenQ::P64 = Hp - 8;   // CmmAssign
           R3 = _sefQ::P64;   // CmmAssign
           R2 = _cenQ::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segp_entry() //  [R2, R1]
         { info_tbl: [(ceoe,
                       label: sat_segp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoe:
           _sefO::P64 = R2;   // CmmAssign
           _segp::P64 = R1;   // CmmAssign
           goto ceko;   // CmmBranch
       ceko:
           if ((old + 0) - <highSp> < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
       ceog:
           R2 = _sefO::P64;   // CmmAssign
           R1 = _segp::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoh:
           goto cekn;   // CmmBranch
       cekn:
           _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
           I64[(young<cekq> + 8)] = cekq;   // CmmStore
           R1 = _sefO::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
       cekr:
           call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       cekq:
           _sefP::P64 = R1;   // CmmAssign
           Hp = Hp + 128;   // CmmAssign
           if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
       ceok:
           HpAlloc = 128;   // CmmAssign
           goto ceoi;   // CmmBranch
       ceoi:
           R1 = _sefP::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       ceoj:
           _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
           _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
           _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 120] = sat_segn_info;   // CmmStore
           P64[Hp - 104] = _seeZ::P64;   // CmmStore
           P64[Hp - 96] = _sefS::P64;   // CmmStore
           _cekv::P64 = Hp - 120;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 88] = sat_segc_info;   // CmmStore
           P64[Hp - 72] = _seeZ::P64;   // CmmStore
           P64[Hp - 64] = _sefR::P64;   // CmmStore
           _celK::P64 = Hp - 88;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 56] = sat_sefW_info;   // CmmStore
           P64[Hp - 40] = _seeZ::P64;   // CmmStore
           P64[Hp - 32] = _sefQ::P64;   // CmmStore
           _cenM::P64 = Hp - 56;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cenM::P64;   // CmmStore
           P64[Hp - 8] = _celK::P64;   // CmmStore
           P64[Hp] = _cekv::P64;   // CmmStore
           _ceof::P64 = Hp - 23;   // CmmAssign
           R3 = _ceof::P64;   // CmmAssign
           R2 = $dShow_reeF_closure;   // CmmAssign
           R1 = System.IO.print_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 mn_sefk_entry() //  [R1]
         { info_tbl: [(ceoG,
                       label: mn_sefk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoG:
           _sefk::P64 = R1;   // CmmAssign
           goto ceoE;   // CmmBranch
       ceoE:
           if ((old + 0) - <highSp> < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
       ceoH:
           R1 = _sefk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoI:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefk::P64;   // CmmStore
           _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
           R2 = _seeY::P64;   // CmmAssign
           R1 = Module.mkModuleName_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefB_entry() //  [R1]
         { info_tbl: [(cepk,
                       label: sat_sefB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepk:
           _sefB::P64 = R1;   // CmmAssign
           goto cepi;   // CmmBranch
       cepi:
           if ((old + 0) - <highSp> < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
       cepl:
           R1 = _sefB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepm:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefB::P64;   // CmmStore
           _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[(old + 40)] = stg_ap_p_info;   // CmmStore
           P64[(old + 32)] = _sefy::P64;   // CmmStore
           call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefA_entry() //  [R1]
         { info_tbl: [(cepr,
                       label: sat_sefA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepr:
           _sefA::P64 = R1;   // CmmAssign
           goto cepp;   // CmmBranch
       cepp:
           if ((old + 0) - <highSp> < SpLim) goto ceps; else goto cept;   // CmmCondBranch
       ceps:
           R1 = _sefA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cept:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefA::P64;   // CmmStore
           _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[(old + 40)] = stg_ap_p_info;   // CmmStore
           P64[(old + 32)] = _sefy::P64;   // CmmStore
           call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefz_entry() //  [R1]
         { info_tbl: [(cepy,
                       label: sat_sefz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepy:
           _sefz::P64 = R1;   // CmmAssign
           goto cepw;   // CmmBranch
       cepw:
           if ((old + 0) - <highSp> < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
       cepz:
           R1 = _sefz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepA:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefz::P64;   // CmmStore
           _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
           R2 = _sefs::P64;   // CmmAssign
           R1 = GHC.pm_parsed_source_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefD_entry() //  [R2, R1]
         { info_tbl: [(cepC,
                       label: sat_sefD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepC:
           _sefy::P64 = R2;   // CmmAssign
           _sefD::P64 = R1;   // CmmAssign
           goto cepe;   // CmmBranch
       cepe:
           if ((old + 0) - <highSp> < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
       cepE:
           goto cepd;   // CmmBranch
       cepd:
           Hp = Hp + 104;   // CmmAssign
           if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
       cepG:
           HpAlloc = 104;   // CmmAssign
           goto cepD;   // CmmBranch
       cepD:
           R2 = _sefy::P64;   // CmmAssign
           R1 = _sefD::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepF:
           _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 96] = sat_sefB_info;   // CmmStore
           P64[Hp - 80] = _sefy::P64;   // CmmStore
           _cepg::P64 = Hp - 96;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 72] = sat_sefA_info;   // CmmStore
           P64[Hp - 56] = _sefy::P64;   // CmmStore
           _cepn::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = sat_sefz_info;   // CmmStore
           P64[Hp - 32] = _sefs::P64;   // CmmStore
           _cepu::P64 = Hp - 48;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cepu::P64;   // CmmStore
           P64[Hp - 8] = _cepn::P64;   // CmmStore
           P64[Hp] = _cepg::P64;   // CmmStore
           _cepB::P64 = Hp - 23;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 24)] = stg_ap_p_info;   // CmmStore
           P64[(old + 16)] = _cepB::P64;   // CmmStore
           call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefx_entry() //  [R1]
         { info_tbl: [(cepL,
                       label: sat_sefx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepL:
           _sefx::P64 = R1;   // CmmAssign
           goto cepJ;   // CmmBranch
       cepJ:
           if ((old + 0) - <highSp> < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
       cepM:
           R1 = _sefx::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepN:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefx::P64;   // CmmStore
           _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
           R4 = _sefw::P64;   // CmmAssign
           R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           R1 = GHC.loadModule_closure;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefE_entry() //  [R2, R1]
         { info_tbl: [(cepO,
                       label: sat_sefE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepO:
           _sefw::P64 = R2;   // CmmAssign
           _sefE::P64 = R1;   // CmmAssign
           goto cep9;   // CmmBranch
       cep9:
           if ((old + 0) - <highSp> < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
       cepQ:
           goto cep8;   // CmmBranch
       cep8:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
       cepS:
           HpAlloc = 40;   // CmmAssign
           goto cepP;   // CmmBranch
       cepP:
           R2 = _sefw::P64;   // CmmAssign
           R1 = _sefE::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepR:
           _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefD_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cepb::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefx_info;   // CmmStore
           P64[Hp] = _sefw::P64;   // CmmStore
           _cepH::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _cepH::P64;   // CmmStore
           P64[(old + 16)] = _cepb::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefv_entry() //  [R1]
         { info_tbl: [(cepX,
                       label: sat_sefv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepX:
           _sefv::P64 = R1;   // CmmAssign
           goto cepV;   // CmmBranch
       cepV:
           if ((old + 0) - <highSp> < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
       cepY:
           R1 = _sefv::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepZ:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefv::P64;   // CmmStore
           _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
           R3 = _sefu::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.desugarModule_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefF_entry() //  [R2, R1]
         { info_tbl: [(ceq0,
                       label: sat_sefF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq0:
           _sefu::P64 = R2;   // CmmAssign
           _sefF::P64 = R1;   // CmmAssign
           goto cep4;   // CmmBranch
       cep4:
           if ((old + 0) - <highSp> < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
       ceq2:
           goto cep3;   // CmmBranch
       cep3:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
       ceq4:
           HpAlloc = 40;   // CmmAssign
           goto ceq1;   // CmmBranch
       ceq1:
           R2 = _sefu::P64;   // CmmAssign
           R1 = _sefF::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceq3:
           _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefE_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep6::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefv_info;   // CmmStore
           P64[Hp] = _sefu::P64;   // CmmStore
           _cepT::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _cepT::P64;   // CmmStore
           P64[(old + 16)] = _cep6::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seft_entry() //  [R1]
         { info_tbl: [(ceq9,
                       label: sat_seft_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq9:
           _seft::P64 = R1;   // CmmAssign
           goto ceq7;   // CmmBranch
       ceq7:
           if ((old + 0) - <highSp> < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
       ceqa:
           R1 = _seft::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqb:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _seft::P64;   // CmmStore
           _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
           R3 = _sefs::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.typecheckModule_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefG_entry() //  [R2, R1]
         { info_tbl: [(ceqc,
                       label: sat_sefG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqc:
           _sefs::P64 = R2;   // CmmAssign
           _sefG::P64 = R1;   // CmmAssign
           goto ceoZ;   // CmmBranch
       ceoZ:
           if ((old + 0) - <highSp> < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
       ceqe:
           goto ceoY;   // CmmBranch
       ceoY:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
       ceqg:
           HpAlloc = 40;   // CmmAssign
           goto ceqd;   // CmmBranch
       ceqd:
           R2 = _sefs::P64;   // CmmAssign
           R1 = _sefG::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqf:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefF_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep1::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seft_info;   // CmmStore
           P64[Hp] = _sefs::P64;   // CmmStore
           _ceq5::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _ceq5::P64;   // CmmStore
           P64[(old + 16)] = _cep1::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefr_entry() //  [R1]
         { info_tbl: [(ceql,
                       label: sat_sefr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceql:
           _sefr::P64 = R1;   // CmmAssign
           goto ceqj;   // CmmBranch
       ceqj:
           if ((old + 0) - <highSp> < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
       ceqm:
           R1 = _sefr::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqn:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefr::P64;   // CmmStore
           _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
           R3 = _sefq::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.parseModule_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefH_entry() //  [R2, R1]
         { info_tbl: [(ceqo,
                       label: sat_sefH_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqo:
           _sefq::P64 = R2;   // CmmAssign
           _sefH::P64 = R1;   // CmmAssign
           goto ceoU;   // CmmBranch
       ceoU:
           if ((old + 0) - <highSp> < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
       ceqq:
           goto ceoT;   // CmmBranch
       ceoT:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
       ceqs:
           HpAlloc = 40;   // CmmAssign
           goto ceqp;   // CmmBranch
       ceqp:
           R2 = _sefq::P64;   // CmmAssign
           R1 = _sefH::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqr:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefG_info;   // CmmStore
           _ceoW::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefr_info;   // CmmStore
           P64[Hp] = _sefq::P64;   // CmmStore
           _ceqh::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _ceqh::P64;   // CmmStore
           P64[(old + 16)] = _ceoW::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefp_entry() //  [R1]
         { info_tbl: [(ceqx,
                       label: sat_sefp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqx:
           _sefp::P64 = R1;   // CmmAssign
           goto ceqv;   // CmmBranch
       ceqv:
           if ((old + 0) - <highSp> < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
       ceqy:
           R1 = _sefp::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqz:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefp::P64;   // CmmStore
           _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
           R3 = _sefk::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.getModSummary_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefI_entry() //  [R1]
         { info_tbl: [(ceqA,
                       label: sat_sefI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqA:
           _sefI::P64 = R1;   // CmmAssign
           goto ceoP;   // CmmBranch
       ceoP:
           if ((old + 0) - <highSp> < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
       ceqC:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
       ceqE:
           HpAlloc = 40;   // CmmAssign
           goto ceqB;   // CmmBranch
       ceqB:
           R1 = _sefI::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqD:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefI::P64;   // CmmStore
           _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefH_info;   // CmmStore
           _ceoR::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefp_info;   // CmmStore
           P64[Hp] = _sefk::P64;   // CmmStore
           _ceqt::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _ceqt::P64;   // CmmStore
           P64[(old + 32)] = _ceoR::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefo_entry() //  [R1]
         { info_tbl: [(ceqJ,
                       label: sat_sefo_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqJ:
           _sefo::P64 = R1;   // CmmAssign
           goto ceqH;   // CmmBranch
       ceqH:
           if ((old + 0) - <highSp> < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
       ceqK:
           R1 = _sefo::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqL:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefo::P64;   // CmmStore
           R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMake.load_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefJ_entry() //  [R1]
         { info_tbl: [(ceqM,
                       label: sat_sefJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqM:
           _sefJ::P64 = R1;   // CmmAssign
           goto ceoL;   // CmmBranch
       ceoL:
           if ((old + 0) - <highSp> < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
       ceqO:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
       ceqQ:
           HpAlloc = 40;   // CmmAssign
           goto ceqN;   // CmmBranch
       ceqN:
           R1 = _sefJ::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqP:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefJ::P64;   // CmmStore
           _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefI_info;   // CmmStore
           P64[Hp - 16] = _sefk::P64;   // CmmStore
           _ceoN::P64 = Hp - 32;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefo_info;   // CmmStore
           _ceqF::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _ceqF::P64;   // CmmStore
           P64[(old + 32)] = _ceoN::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefn_entry() //  [R1]
         { info_tbl: [(ceqX,
                       label: sat_sefn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqX:
           _sefn::P64 = R1;   // CmmAssign
           goto ceqT;   // CmmBranch
       ceqT:
           if ((old + 0) - <highSp> < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
       ceqZ:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
       cer1:
           HpAlloc = 48;   // CmmAssign
           goto ceqY;   // CmmBranch
       ceqY:
           R1 = _sefn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer0:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefn::P64;   // CmmStore
           _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
           I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
           P64[Hp - 32] = _sefk::P64;   // CmmStore
           _ceqV::P64 = Hp - 39;   // CmmAssign
           I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
           P64[Hp - 16] = _ceqV::P64;   // CmmStore
           P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
           P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
           _ceqW::P64 = Hp - 23;   // CmmAssign
           R3 = _ceqW::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.addTarget_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefK_entry() //  [R1]
         { info_tbl: [(cer2,
                       label: sat_sefK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cer2:
           _sefK::P64 = R1;   // CmmAssign
           goto ceoA;   // CmmBranch
       ceoA:
           if ((old + 0) - <highSp> < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
       cer4:
           Hp = Hp + 72;   // CmmAssign
           if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
       cer6:
           HpAlloc = 72;   // CmmAssign
           goto cer3;   // CmmBranch
       cer3:
           R1 = _sefK::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer5:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefK::P64;   // CmmStore
           _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 64] = mn_sefk_info;   // CmmStore
           P64[Hp - 48] = _seeY::P64;   // CmmStore
           _ceoC::P64 = Hp - 64;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefJ_info;   // CmmStore
           P64[Hp - 24] = _ceoC::P64;   // CmmStore
           _ceoJ::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefn_info;   // CmmStore
           P64[Hp] = _ceoC::P64;   // CmmStore
           _ceqR::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _ceqR::P64;   // CmmStore
           P64[(old + 32)] = _ceoJ::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefj_entry() //  [R1]
         { info_tbl: [(cerb,
                       label: sat_sefj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerb:
           _sefj::P64 = R1;   // CmmAssign
           goto cer9;   // CmmBranch
       cer9:
           if ((old + 0) - <highSp> < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
       cerc:
           R1 = _sefj::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerd:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefj::P64;   // CmmStore
           _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
           R3 = _sefi::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefL_entry() //  [R2, R1]
         { info_tbl: [(cere,
                       label: sat_sefL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cere:
           _sefi::P64 = R2;   // CmmAssign
           _sefL::P64 = R1;   // CmmAssign
           goto ceow;   // CmmBranch
       ceow:
           if ((old + 0) - <highSp> < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
       cerg:
           goto ceov;   // CmmBranch
       ceov:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
       ceri:
           HpAlloc = 48;   // CmmAssign
           goto cerf;   // CmmBranch
       cerf:
           R2 = _sefi::P64;   // CmmAssign
           R1 = _sefL::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerh:
           _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefK_info;   // CmmStore
           P64[Hp - 24] = _seeY::P64;   // CmmStore
           _ceoy::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefj_info;   // CmmStore
           P64[Hp] = _sefi::P64;   // CmmStore
           _cer7::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _cer7::P64;   // CmmStore
           P64[(old + 16)] = _ceoy::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefh_entry() //  [R1]
         { info_tbl: [(cern,
                       label: sat_sefh_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cern:
           _sefh::P64 = R1;   // CmmAssign
           goto cerl;   // CmmBranch
       cerl:
           if ((old + 0) - <highSp> < SpLim) goto cero; else goto cerp;   // CmmCondBranch
       cero:
           R1 = _sefh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerp:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefh::P64;   // CmmStore
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefM_entry() //  [R1]
         { info_tbl: [(cerq,
                       label: sat_sefM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerq:
           _sefM::P64 = R1;   // CmmAssign
           goto ceor;   // CmmBranch
       ceor:
           if ((old + 0) - <highSp> < SpLim) goto cerr; else goto cers;   // CmmCondBranch
       cers:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
       ceru:
           HpAlloc = 32;   // CmmAssign
           goto cerr;   // CmmBranch
       cerr:
           R1 = _sefM::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cert:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefM::P64;   // CmmStore
           _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefL_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceot::P64 = Hp - 23;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefh_info;   // CmmStore
           _cerj::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _cerj::P64;   // CmmStore
           P64[(old + 32)] = _ceot::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefN_entry() //  [R1]
         { info_tbl: [(cerw,
                       label: sat_sefN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerw:
           _sefN::P64 = R1;   // CmmAssign
           goto ceon;   // CmmBranch
       ceon:
           if ((old + 0) - <highSp> < SpLim) goto cerx; else goto cery;   // CmmCondBranch
       cery:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
       cerA:
           HpAlloc = 40;   // CmmAssign
           goto cerx;   // CmmBranch
       cerx:
           R1 = _sefN::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerz:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _sefN::P64;   // CmmStore
           _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
           _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefM_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceop::P64 = Hp - 32;   // CmmAssign
           I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
           P64[Hp] = _seeX::P64;   // CmmStore
           _cerv::P64 = Hp - 6;   // CmmAssign
           R3 = _ceop::P64;   // CmmAssign
           R2 = _cerv::P64;   // CmmAssign
           R1 = GHC.runGhc_closure;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 Main.testOneFile_entry() //  [R3, R2]
         { info_tbl: [(cerB,
                       label: Main.testOneFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerB:
           _seeY::P64 = R3;   // CmmAssign
           _seeX::P64 = R2;   // CmmAssign
           goto ceiU;   // CmmBranch
       ceiU:
           if ((old + 0) - <highSp> < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
       cerD:
           goto ceiT;   // CmmBranch
       ceiT:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
       cerF:
           HpAlloc = 64;   // CmmAssign
           goto cerC;   // CmmBranch
       cerC:
           R3 = _seeY::P64;   // CmmAssign
           R2 = _seeX::P64;   // CmmAssign
           R1 = Main.testOneFile_closure;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerE:
           // calling allocDynClosure
           I64[Hp - 56] = gq_seeZ_info;   // CmmStore
           _ceiW::P64 = Hp - 54;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segp_info;   // CmmStore
           P64[Hp - 32] = _ceiW::P64;   // CmmStore
           _cekl::P64 = Hp - 39;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefN_info;   // CmmStore
           P64[Hp - 8] = _seeX::P64;   // CmmStore
           P64[Hp] = _seeY::P64;   // CmmStore
           _ceol::P64 = Hp - 24;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _ceol::P64;   // CmmStore
           P64[(old + 16)] = _cekl::P64;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  ceje:
      _sef3::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
  cejf:
      R1 = _sef3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejg:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sef3::P64;   // CmmStore
      _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
      R2 = _sef2::P64;   // CmmAssign
      call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceje:
      _sef3::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
  cejf:
      R1 = _sef3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejg:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sef3::P64;   // CmmStore
      _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
      R2 = _sef2::P64;   // CmmAssign
      call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceje:
      _sef3::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
  cejf:
      R1 = _sef3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejg:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sef3::P64;   // CmmStore
      _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
      R2 = _sef2::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceje, {}), (cejf, {}), (cejg, {})]



==================== after setInfoTableStackMap ====================
$dTypeable_sef3_entry() //  [R1]
        { info_tbl: [(ceje,
                      label: $dTypeable_sef3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceje:
          _sef3::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
      cejf:
          R1 = _sef3::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejg:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef3::P64;   // CmmStore
          _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
          R2 = _sef2::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dTypeable_sef3_entry() //  [R1]
        { info_tbl: [(ceje,
                      label: $dTypeable_sef3_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceje:
          _sef3::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
      cejf:
          R1 = _sef3::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejg:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef3::P64;   // CmmStore
          _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
          R2 = _sef2::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cejl:
      _sef4::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
  cejm:
      R1 = _sef4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejn:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sef4::P64;   // CmmStore
      R4 = GHC.Types.[]_closure+1;   // CmmAssign
      R3 = GHC.Types.[]_closure+1;   // CmmAssign
      R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
      R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cejl:
      _sef4::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
  cejm:
      R1 = _sef4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejn:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sef4::P64;   // CmmStore
      R4 = GHC.Types.[]_closure+1;   // CmmAssign
      R3 = GHC.Types.[]_closure+1;   // CmmAssign
      R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
      R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cejl:
      _sef4::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
  cejm:
      R1 = _sef4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejn:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sef4::P64;   // CmmStore
      R4 = GHC.Types.[]_closure+1;   // CmmAssign
      R3 = GHC.Types.[]_closure+1;   // CmmAssign
      R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
      R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cejl,
  {Data.Typeable.Internal.mkPolyTyConApp_closure,
   SrcLoc.$tcSrcSpan_closure}),
 (cejm, {}),
 (cejn,
  {Data.Typeable.Internal.mkPolyTyConApp_closure,
   SrcLoc.$tcSrcSpan_closure})]



==================== after setInfoTableStackMap ====================
ds_sef4_entry() //  [R1]
        { info_tbl: [(cejl,
                      label: ds_sef4_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejl:
          _sef4::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
      cejm:
          R1 = _sef4::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef4::P64;   // CmmStore
          R4 = GHC.Types.[]_closure+1;   // CmmAssign
          R3 = GHC.Types.[]_closure+1;   // CmmAssign
          R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
          R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
ds_sef4_entry() //  [R1]
        { info_tbl: [(cejl,
                      label: ds_sef4_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejl:
          _sef4::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
      cejm:
          R1 = _sef4::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef4::P64;   // CmmStore
          R4 = GHC.Types.[]_closure+1;   // CmmAssign
          R3 = GHC.Types.[]_closure+1;   // CmmAssign
          R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
          R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cejt:
      _sef5::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceju; else goto cejv;   // CmmCondBranch
  ceju:
      R1 = _sef5::P64;   // CmmAssign
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejv:
      _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
      R1 = _sef4::P64 & (-8);   // CmmAssign
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cejt:
      _sef5::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceju; else goto cejv;   // CmmCondBranch
  ceju:
      R1 = _sef5::P64;   // CmmAssign
      call (stg_gc_fun)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejv:
      _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
      R1 = _sef4::P64 & (-8);   // CmmAssign
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cejt:
      _sef5::P64 = R1;   // CmmAssign
      goto cejv;   // CmmBranch
  cejv:
      _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
      R1 = _sef4::P64 & (-8);   // CmmAssign
      call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cejt, {}), (cejv, {})]



==================== after setInfoTableStackMap ====================
a4_sef5_entry() //  [R1]
        { info_tbl: [(cejt,
                      label: a4_sef5_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejt:
          _sef5::P64 = R1;   // CmmAssign
          goto cejv;   // CmmBranch
      cejv:
          _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
          R1 = _sef4::P64 & (-8);   // CmmAssign
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
a4_sef5_entry() //  [R1]
        { info_tbl: [(cejt,
                      label: a4_sef5_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejt:
          _sef5::P64 = R1;   // CmmAssign
          goto cejv;   // CmmBranch
      cejv:
          _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
          R1 = _sef4::P64 & (-8);   // CmmAssign
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cejH:
      _sef7::P64 = R2;   // CmmAssign
      _sefd::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
  cejI:
      R2 = _sef7::P64;   // CmmAssign
      R1 = _sefd::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejJ:
      _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
      _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
      I64[(young<cejB> + 8)] = cejB;   // CmmStore
      R4 = _sef7::P64;   // CmmAssign
      R3 = _sef5::P64;   // CmmAssign
      R2 = _sef3::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
  cejB:
      _sef8::P64 = R1;   // CmmAssign
      _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
      switch [1 .. 2] _cejG::P64 {
          case 1 : goto cejE;
          case 2 : goto cejF;
      }   // CmmSwitch
  cejF:
      _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
      I64[(young<cejP> + 8)] = cejP;   // CmmStore
      R1 = _sef9::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
  cejR:
      call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejP:
      _sefa::P64 = R1;   // CmmAssign
      _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
      switch [1 .. 2] _cek5::P64 {
          case 1 : goto cejX;
          case 2 : goto cek4;
      }   // CmmSwitch
  cek4:
      _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
      R1 = []_closure+1;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejX:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
  cek0:
      HpAlloc = 24;   // CmmAssign
      R1 = _sefa::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejZ:
      _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
      I64[Hp - 16] = :_con_info;   // CmmStore
      P64[Hp - 8] = _sefa::P64;   // CmmStore
      P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
      _cejV::P64 = Hp - 14;   // CmmAssign
      R1 = _cejV::P64;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejE:
      R1 = []_closure+1;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cejH:
      _sef7::P64 = R2;   // CmmAssign
      _sefd::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
  cejI:
      R2 = _sef7::P64;   // CmmAssign
      R1 = _sefd::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejJ:
      _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
      _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
      I64[(young<cejB> + 8)] = cejB;   // CmmStore
      R4 = _sef7::P64;   // CmmAssign
      R3 = _sef5::P64;   // CmmAssign
      R2 = _sef3::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
  cejB:
      _sef8::P64 = R1;   // CmmAssign
      _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
      if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
  cejF:
      _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
      I64[(young<cejP> + 8)] = cejP;   // CmmStore
      R1 = _sef9::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
  cejR:
      call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejP:
      _sefa::P64 = R1;   // CmmAssign
      _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
      if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
  cek4:
      _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
      R1 = []_closure+1;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejX:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
  cek0:
      HpAlloc = 24;   // CmmAssign
      R1 = _sefa::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejZ:
      _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
      I64[Hp - 16] = :_con_info;   // CmmStore
      P64[Hp - 8] = _sefa::P64;   // CmmStore
      P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
      _cejV::P64 = Hp - 14;   // CmmAssign
      R1 = _cejV::P64;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejE:
      R1 = []_closure+1;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cejH:
      _sef7::P64 = R2;   // CmmAssign
      _sefd::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
  cejI:
      R2 = _sef7::P64;   // CmmAssign
      R1 = _sefd::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejJ:
      _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
      _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
      I64[Sp - 8] = cejB;   // CmmStore
      R4 = _sef7::P64;   // CmmAssign
      R3 = _sef5::P64;   // CmmAssign
      R2 = _sef3::P64;   // CmmAssign
      R1 = Data.Typeable.cast_closure;   // CmmAssign
      Sp = Sp - 8;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
  cejB:
      _sef8::P64 = R1;   // CmmAssign
      _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
      if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
  cejF:
      _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
      I64[Sp] = cejP;   // CmmStore
      R1 = _sef9::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
  cejR:
      call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejP:
      _sefa::P64 = R1;   // CmmAssign
      _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
      if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
  cek4:
      _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
      R1 = []_closure+1;   // CmmAssign
      Sp = Sp + 8;   // CmmAssign
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejX:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
  cek0:
      HpAlloc = 24;   // CmmAssign
      R1 = _sefa::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
  cejZ:
      _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
      I64[Hp - 16] = :_con_info;   // CmmStore
      P64[Hp - 8] = _sefa::P64;   // CmmStore
      P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
      _cejV::P64 = Hp - 14;   // CmmAssign
      R1 = _cejV::P64;   // CmmAssign
      Sp = Sp + 8;   // CmmAssign
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cejE:
      R1 = []_closure+1;   // CmmAssign
      Sp = Sp + 8;   // CmmAssign
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cejB, {}), (cejE, {}), (cejF, {}),
 (cejH, {Data.Typeable.cast_closure}), (cejI, {}),
 (cejJ, {Data.Typeable.cast_closure}), (cejP, {}), (cejR, {}),
 (cejX, {}), (cejZ, {}), (cek0, {}), (cek4, {})]



==================== after setInfoTableStackMap ====================
sat_sefd_entry() //  [R2, R1]
        { info_tbl: [(cejB,
                      label: block_cejB_info
                      rep:StackRep []),
                     (cejH,
                      label: sat_sefd_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} }),
                     (cejP,
                      label: block_cejP_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejH:
          _sef7::P64 = R2;   // CmmAssign
          _sefd::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
      cejI:
          R2 = _sef7::P64;   // CmmAssign
          R1 = _sefd::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejJ:
          _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
          _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
          I64[Sp - 8] = cejB;   // CmmStore
          R4 = _sef7::P64;   // CmmAssign
          R3 = _sef5::P64;   // CmmAssign
          R2 = _sef3::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
      cejB:
          _sef8::P64 = R1;   // CmmAssign
          _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
          if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
      cejF:
          _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
          I64[Sp] = cejP;   // CmmStore
          R1 = _sef9::P64;   // CmmAssign
          if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
      cejR:
          call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejP:
          _sefa::P64 = R1;   // CmmAssign
          _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
          if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
      cek4:
          _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejX:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
      cek0:
          HpAlloc = 24;   // CmmAssign
          R1 = _sefa::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejZ:
          _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
          I64[Hp - 16] = :_con_info;   // CmmStore
          P64[Hp - 8] = _sefa::P64;   // CmmStore
          P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
          _cejV::P64 = Hp - 14;   // CmmAssign
          R1 = _cejV::P64;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejE:
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefd_entry() //  [R2, R1]
        { info_tbl: [(cejB,
                      label: block_cejB_info
                      rep:StackRep []),
                     (cejH,
                      label: sat_sefd_info
                      rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} }),
                     (cejP,
                      label: block_cejP_info
                      rep:StackRep [])]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cejH:
          _sef7::P64 = R2;   // CmmAssign
          _sefd::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
      cejI:
          R2 = _sef7::P64;   // CmmAssign
          R1 = _sefd::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejJ:
          _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
          _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
          I64[Sp - 8] = cejB;   // CmmStore
          R4 = _sef7::P64;   // CmmAssign
          R3 = _sef5::P64;   // CmmAssign
          R2 = _sef3::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
      cejB:
          _sef8::P64 = R1;   // CmmAssign
          _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
          if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
      cejF:
          _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
          I64[Sp] = cejP;   // CmmStore
          R1 = _sef9::P64;   // CmmAssign
          if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
      cejR:
          call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejP:
          _sefa::P64 = R1;   // CmmAssign
          _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
          if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
      cek4:
          _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejX:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
      cek0:
          HpAlloc = 24;   // CmmAssign
          R1 = _sefa::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejZ:
          _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
          I64[Hp - 16] = :_con_info;   // CmmStore
          P64[Hp - 8] = _sefa::P64;   // CmmStore
          P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
          _cejV::P64 = Hp - 14;   // CmmAssign
          R1 = _cejV::P64;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejE:
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cek6:
      _sef2::P64 = R2;   // CmmAssign
      _sefe::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cek7; else goto cek8;   // CmmCondBranch
  cek8:
      Hp = Hp + 80;   // CmmAssign
      if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
  ceka:
      HpAlloc = 80;   // CmmAssign
      goto cek7;   // CmmBranch
  cek7:
      R2 = _sef2::P64;   // CmmAssign
      R1 = _sefe::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cek9:
      // calling allocDynClosure
      I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
      P64[Hp - 56] = _sef2::P64;   // CmmStore
      _ceja::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = ds_sef4_info;   // CmmStore
      _cejh::P64 = Hp - 48;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = a4_sef5_info;   // CmmStore
      P64[Hp - 24] = _cejh::P64;   // CmmStore
      _cejo::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefd_info;   // CmmStore
      P64[Hp - 8] = _ceja::P64;   // CmmStore
      P64[Hp] = _cejo::P64;   // CmmStore
      _cejw::P64 = Hp - 15;   // CmmAssign
      R1 = _cejw::P64;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cek6:
      _sef2::P64 = R2;   // CmmAssign
      _sefe::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cek7; else goto cek8;   // CmmCondBranch
  cek8:
      Hp = Hp + 80;   // CmmAssign
      if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
  ceka:
      HpAlloc = 80;   // CmmAssign
      goto cek7;   // CmmBranch
  cek7:
      R2 = _sef2::P64;   // CmmAssign
      R1 = _sefe::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cek9:
      // calling allocDynClosure
      I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
      P64[Hp - 56] = _sef2::P64;   // CmmStore
      _ceja::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = ds_sef4_info;   // CmmStore
      _cejh::P64 = Hp - 48;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = a4_sef5_info;   // CmmStore
      P64[Hp - 24] = _cejh::P64;   // CmmStore
      _cejo::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefd_info;   // CmmStore
      P64[Hp - 8] = _ceja::P64;   // CmmStore
      P64[Hp] = _cejo::P64;   // CmmStore
      _cejw::P64 = Hp - 15;   // CmmAssign
      R1 = _cejw::P64;   // CmmAssign
      call (P64[(old + 8)])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cek6:
      _sef2::P64 = R2;   // CmmAssign
      _sefe::P64 = R1;   // CmmAssign
      goto cek8;   // CmmBranch
  cek8:
      Hp = Hp + 80;   // CmmAssign
      if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
  ceka:
      HpAlloc = 80;   // CmmAssign
      goto cek7;   // CmmBranch
  cek7:
      R2 = _sef2::P64;   // CmmAssign
      R1 = _sefe::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cek9:
      // calling allocDynClosure
      I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
      P64[Hp - 56] = _sef2::P64;   // CmmStore
      _ceja::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = ds_sef4_info;   // CmmStore
      _cejh::P64 = Hp - 48;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = a4_sef5_info;   // CmmStore
      P64[Hp - 24] = _cejh::P64;   // CmmStore
      _cejo::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefd_info;   // CmmStore
      P64[Hp - 8] = _ceja::P64;   // CmmStore
      P64[Hp] = _cejo::P64;   // CmmStore
      _cejw::P64 = Hp - 15;   // CmmAssign
      R1 = _cejw::P64;   // CmmAssign
      call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cek6,
  {$dTypeable_sef3_closure, ds_sef4_closure, a4_sef5_closure,
   sat_sefd_closure}),
 (cek7, {}),
 (cek8,
  {$dTypeable_sef3_closure, ds_sef4_closure, a4_sef5_closure,
   sat_sefd_closure}),
 (cek9,
  {$dTypeable_sef3_closure, ds_sef4_closure, a4_sef5_closure,
   sat_sefd_closure}),
 (ceka, {})]



==================== after setInfoTableStackMap ====================
sat_sefe_entry() //  [R2, R1]
        { info_tbl: [(cek6,
                      label: sat_sefe_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cek6:
          _sef2::P64 = R2;   // CmmAssign
          _sefe::P64 = R1;   // CmmAssign
          goto cek8;   // CmmBranch
      cek8:
          Hp = Hp + 80;   // CmmAssign
          if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
      ceka:
          HpAlloc = 80;   // CmmAssign
          goto cek7;   // CmmBranch
      cek7:
          R2 = _sef2::P64;   // CmmAssign
          R1 = _sefe::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cek9:
          // calling allocDynClosure
          I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
          P64[Hp - 56] = _sef2::P64;   // CmmStore
          _ceja::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = ds_sef4_info;   // CmmStore
          _cejh::P64 = Hp - 48;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = a4_sef5_info;   // CmmStore
          P64[Hp - 24] = _cejh::P64;   // CmmStore
          _cejo::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefd_info;   // CmmStore
          P64[Hp - 8] = _ceja::P64;   // CmmStore
          P64[Hp] = _cejo::P64;   // CmmStore
          _cejw::P64 = Hp - 15;   // CmmAssign
          R1 = _cejw::P64;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefe_entry() //  [R2, R1]
        { info_tbl: [(cek6,
                      label: sat_sefe_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cek6:
          _sef2::P64 = R2;   // CmmAssign
          _sefe::P64 = R1;   // CmmAssign
          goto cek8;   // CmmBranch
      cek8:
          Hp = Hp + 80;   // CmmAssign
          if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
      ceka:
          HpAlloc = 80;   // CmmAssign
          goto cek7;   // CmmBranch
      cek7:
          R2 = _sef2::P64;   // CmmAssign
          R1 = _sefe::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cek9:
          // calling allocDynClosure
          I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
          P64[Hp - 56] = _sef2::P64;   // CmmStore
          _ceja::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = ds_sef4_info;   // CmmStore
          _cejh::P64 = Hp - 48;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = a4_sef5_info;   // CmmStore
          P64[Hp - 24] = _cejh::P64;   // CmmStore
          _cejo::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefd_info;   // CmmStore
          P64[Hp - 8] = _ceja::P64;   // CmmStore
          P64[Hp] = _cejo::P64;   // CmmStore
          _cejw::P64 = Hp - 15;   // CmmAssign
          R1 = _cejw::P64;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekb:
      _seff::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
  cekd:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
  cekf:
      HpAlloc = 16;   // CmmAssign
      goto cekc;   // CmmBranch
  cekc:
      R1 = _seff::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceke:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seff::P64;   // CmmStore
      _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
      _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefe_info;   // CmmStore
      _cej5::P64 = Hp - 7;   // CmmAssign
      R5 = _sef1::P64;   // CmmAssign
      R4 = _sef0::P64;   // CmmAssign
      R3 = _cej5::P64;   // CmmAssign
      R2 = GHC.Base.++_closure;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekb:
      _seff::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
  cekd:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
  cekf:
      HpAlloc = 16;   // CmmAssign
      goto cekc;   // CmmBranch
  cekc:
      R1 = _seff::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceke:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seff::P64;   // CmmStore
      _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
      _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefe_info;   // CmmStore
      _cej5::P64 = Hp - 7;   // CmmAssign
      R5 = _sef1::P64;   // CmmAssign
      R4 = _sef0::P64;   // CmmAssign
      R3 = _cej5::P64;   // CmmAssign
      R2 = GHC.Base.++_closure;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekb:
      _seff::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
  cekd:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
  cekf:
      HpAlloc = 16;   // CmmAssign
      goto cekc;   // CmmBranch
  cekc:
      R1 = _seff::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceke:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seff::P64;   // CmmStore
      _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
      _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefe_info;   // CmmStore
      _cej5::P64 = Hp - 7;   // CmmAssign
      R5 = _sef1::P64;   // CmmAssign
      R4 = _sef0::P64;   // CmmAssign
      R3 = _cej5::P64;   // CmmAssign
      R2 = GHC.Base.++_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Main.everything_info(R5,
                                R4,
                                R3,
                                R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cekb,
  {GHC.Base.++_closure, Main.everything_closure, sat_sefe_closure}),
 (cekc, {}),
 (cekd,
  {GHC.Base.++_closure, Main.everything_closure, sat_sefe_closure}),
 (ceke,
  {GHC.Base.++_closure, Main.everything_closure, sat_sefe_closure}),
 (cekf, {})]



==================== after setInfoTableStackMap ====================
sat_seff_entry() //  [R1]
        { info_tbl: [(cekb,
                      label: sat_seff_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekb:
          _seff::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
      cekd:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
      cekf:
          HpAlloc = 16;   // CmmAssign
          goto cekc;   // CmmBranch
      cekc:
          R1 = _seff::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceke:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seff::P64;   // CmmStore
          _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
          _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefe_info;   // CmmStore
          _cej5::P64 = Hp - 7;   // CmmAssign
          R5 = _sef1::P64;   // CmmAssign
          R4 = _sef0::P64;   // CmmAssign
          R3 = _cej5::P64;   // CmmAssign
          R2 = GHC.Base.++_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seff_entry() //  [R1]
        { info_tbl: [(cekb,
                      label: sat_seff_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekb:
          _seff::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
      cekd:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
      cekf:
          HpAlloc = 16;   // CmmAssign
          goto cekc;   // CmmBranch
      cekc:
          R1 = _seff::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceke:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seff::P64;   // CmmStore
          _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
          _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefe_info;   // CmmStore
          _cej5::P64 = Hp - 7;   // CmmAssign
          R5 = _sef1::P64;   // CmmAssign
          R4 = _sef0::P64;   // CmmAssign
          R3 = _cej5::P64;   // CmmAssign
          R2 = GHC.Base.++_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekg:
      _sef1::P64 = R3;   // CmmAssign
      _sef0::P64 = R2;   // CmmAssign
      _seeZ::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
  ceki:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
  cekk:
      HpAlloc = 32;   // CmmAssign
      goto cekh;   // CmmBranch
  cekh:
      R3 = _sef1::P64;   // CmmAssign
      R2 = _sef0::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekj:
      // calling allocDynClosure
      I64[Hp - 24] = sat_seff_info;   // CmmStore
      P64[Hp - 8] = _sef0::P64;   // CmmStore
      P64[Hp] = _sef1::P64;   // CmmStore
      _cej1::P64 = Hp - 24;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _cej1::P64;   // CmmStore
      call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekg:
      _sef1::P64 = R3;   // CmmAssign
      _sef0::P64 = R2;   // CmmAssign
      _seeZ::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
  ceki:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
  cekk:
      HpAlloc = 32;   // CmmAssign
      goto cekh;   // CmmBranch
  cekh:
      R3 = _sef1::P64;   // CmmAssign
      R2 = _sef0::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekj:
      // calling allocDynClosure
      I64[Hp - 24] = sat_seff_info;   // CmmStore
      P64[Hp - 8] = _sef0::P64;   // CmmStore
      P64[Hp] = _sef1::P64;   // CmmStore
      _cej1::P64 = Hp - 24;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _cej1::P64;   // CmmStore
      call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekg:
      _sef1::P64 = R3;   // CmmAssign
      _sef0::P64 = R2;   // CmmAssign
      _seeZ::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
  ceki:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
  cekk:
      HpAlloc = 32;   // CmmAssign
      goto cekh;   // CmmBranch
  cekh:
      R3 = _sef1::P64;   // CmmAssign
      R2 = _sef0::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekj:
      // calling allocDynClosure
      I64[Hp - 24] = sat_seff_info;   // CmmStore
      P64[Hp - 8] = _sef0::P64;   // CmmStore
      P64[Hp] = _sef1::P64;   // CmmStore
      _cej1::P64 = Hp - 24;   // CmmAssign
      R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
      I64[Sp - 16] = stg_ap_p_info;   // CmmStore
      P64[Sp - 8] = _cej1::P64;   // CmmStore
      Sp = Sp - 16;   // CmmAssign
      call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cekg, {Data.Foldable.$fFoldable[]_closure, sat_seff_closure}),
 (cekh, {}),
 (ceki, {Data.Foldable.$fFoldable[]_closure, sat_seff_closure}),
 (cekj, {Data.Foldable.$fFoldable[]_closure, sat_seff_closure}),
 (cekk, {})]



==================== after setInfoTableStackMap ====================
gq_seeZ_entry() //  [R3, R2, R1]
        { info_tbl: [(cekg,
                      label: gq_seeZ_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekg:
          _sef1::P64 = R3;   // CmmAssign
          _sef0::P64 = R2;   // CmmAssign
          _seeZ::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
      ceki:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
      cekk:
          HpAlloc = 32;   // CmmAssign
          goto cekh;   // CmmBranch
      cekh:
          R3 = _sef1::P64;   // CmmAssign
          R2 = _sef0::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekj:
          // calling allocDynClosure
          I64[Hp - 24] = sat_seff_info;   // CmmStore
          P64[Hp - 8] = _sef0::P64;   // CmmStore
          P64[Hp] = _sef1::P64;   // CmmStore
          _cej1::P64 = Hp - 24;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cej1::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
gq_seeZ_entry() //  [R3, R2, R1]
        { info_tbl: [(cekg,
                      label: gq_seeZ_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekg:
          _sef1::P64 = R3;   // CmmAssign
          _sef0::P64 = R2;   // CmmAssign
          _seeZ::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
      ceki:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
      cekk:
          HpAlloc = 32;   // CmmAssign
          goto cekh;   // CmmBranch
      cekh:
          R3 = _sef1::P64;   // CmmAssign
          R2 = _sef0::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekj:
          // calling allocDynClosure
          I64[Hp - 24] = sat_seff_info;   // CmmStore
          P64[Hp - 8] = _sef0::P64;   // CmmStore
          P64[Hp] = _sef1::P64;   // CmmStore
          _cej1::P64 = Hp - 24;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cej1::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekD:
      _segd::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
  cekE:
      R1 = _segd::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekF:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segd::P64;   // CmmStore
      R2 = ConLike.$fDataConLike_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekD:
      _segd::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
  cekE:
      R1 = _segd::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekF:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segd::P64;   // CmmStore
      R2 = ConLike.$fDataConLike_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekD:
      _segd::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
  cekE:
      R1 = _segd::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekF:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segd::P64;   // CmmStore
      R2 = ConLike.$fDataConLike_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cekD,
  {Data.Data.$fData[]_closure, ConLike.$fDataConLike_closure}),
 (cekE, {}),
 (cekF,
  {Data.Data.$fData[]_closure, ConLike.$fDataConLike_closure})]



==================== after setInfoTableStackMap ====================
$dData_segd_entry() //  [R1]
        { info_tbl: [(cekD,
                      label: $dData_segd_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekD:
          _segd::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
      cekE:
          R1 = _segd::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segd::P64;   // CmmStore
          R2 = ConLike.$fDataConLike_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData_segd_entry() //  [R1]
        { info_tbl: [(cekD,
                      label: $dData_segd_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekD:
          _segd::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
      cekE:
          R1 = _segd::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segd::P64;   // CmmStore
          R2 = ConLike.$fDataConLike_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekK:
      _sege::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
  cekL:
      R1 = _sege::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekM:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sege::P64;   // CmmStore
      R2 = TypeRep.$fDataType_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekK:
      _sege::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
  cekL:
      R1 = _sege::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekM:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sege::P64;   // CmmStore
      R2 = TypeRep.$fDataType_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekK:
      _sege::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
  cekL:
      R1 = _sege::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekM:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sege::P64;   // CmmStore
      R2 = TypeRep.$fDataType_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cekK, {Data.Data.$fData[]_closure, TypeRep.$fDataType_closure}),
 (cekL, {}),
 (cekM, {Data.Data.$fData[]_closure, TypeRep.$fDataType_closure})]



==================== after setInfoTableStackMap ====================
$dData1_sege_entry() //  [R1]
        { info_tbl: [(cekK,
                      label: $dData1_sege_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekK:
          _sege::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
      cekL:
          R1 = _sege::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekM:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sege::P64;   // CmmStore
          R2 = TypeRep.$fDataType_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData1_sege_entry() //  [R1]
        { info_tbl: [(cekK,
                      label: $dData1_sege_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekK:
          _sege::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
      cekL:
          R1 = _sege::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekM:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sege::P64;   // CmmStore
          R2 = TypeRep.$fDataType_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekR:
      _segf::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
  cekS:
      R1 = _segf::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekT:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segf::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekR:
      _segf::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
  cekS:
      R1 = _segf::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekT:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segf::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekR:
      _segf::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
  cekS:
      R1 = _segf::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cekT:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segf::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cekR, {Data.Data.$fData[]_closure, Name.$fDataName_closure}),
 (cekS, {}),
 (cekT, {Data.Data.$fData[]_closure, Name.$fDataName_closure})]



==================== after setInfoTableStackMap ====================
$dData2_segf_entry() //  [R1]
        { info_tbl: [(cekR,
                      label: $dData2_segf_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekR:
          _segf::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
      cekS:
          R1 = _segf::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segf::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData2_segf_entry() //  [R1]
        { info_tbl: [(cekR,
                      label: $dData2_segf_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekR:
          _segf::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
      cekS:
          R1 = _segf::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segf::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cekY:
      _segg::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
  cekZ:
      R1 = _segg::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel0:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segg::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cekY:
      _segg::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
  cekZ:
      R1 = _segg::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel0:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segg::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cekY:
      _segg::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
  cekZ:
      R1 = _segg::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel0:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segg::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cekY,
  {Name.$fDataName_closure, FieldLabel.$fDataFieldLbl_closure}),
 (cekZ, {}),
 (cel0,
  {Name.$fDataName_closure, FieldLabel.$fDataFieldLbl_closure})]



==================== after setInfoTableStackMap ====================
$dData3_segg_entry() //  [R1]
        { info_tbl: [(cekY,
                      label: $dData3_segg_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekY:
          _segg::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
      cekZ:
          R1 = _segg::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segg::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData3_segg_entry() //  [R1]
        { info_tbl: [(cekY,
                      label: $dData3_segg_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cekY:
          _segg::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
      cekZ:
          R1 = _segg::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segg::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cel5:
      _segh::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
  cel6:
      R1 = _segh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segh::P64;   // CmmStore
      _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
      R2 = _segg::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cel5:
      _segh::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
  cel6:
      R1 = _segh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segh::P64;   // CmmStore
      _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
      R2 = _segg::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cel5:
      _segh::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
  cel6:
      R1 = _segh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cel7:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segh::P64;   // CmmStore
      _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
      R2 = _segg::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cel5, {Data.Data.$fData[]_closure}), (cel6, {}),
 (cel7, {Data.Data.$fData[]_closure})]



==================== after setInfoTableStackMap ====================
$dData4_segh_entry() //  [R1]
        { info_tbl: [(cel5,
                      label: $dData4_segh_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cel5:
          _segh::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
      cel6:
          R1 = _segh::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segh::P64;   // CmmStore
          _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
          R2 = _segg::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData4_segh_entry() //  [R1]
        { info_tbl: [(cel5,
                      label: $dData4_segh_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cel5:
          _segh::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
      cel6:
          R1 = _segh::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segh::P64;   // CmmStore
          _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
          R2 = _segg::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  celc:
      _segi::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celd; else goto cele;   // CmmCondBranch
  celd:
      R1 = _segi::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cele:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segi::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  celc:
      _segi::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celd; else goto cele;   // CmmCondBranch
  celd:
      R1 = _segi::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cele:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segi::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  celc:
      _segi::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
  celd:
      R1 = _segi::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cele:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segi::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(celc, {Name.$fDataName_closure, UniqFM.$fDataUniqFM_closure}),
 (celd, {}),
 (cele, {Name.$fDataName_closure, UniqFM.$fDataUniqFM_closure})]



==================== after setInfoTableStackMap ====================
$dData5_segi_entry() //  [R1]
        { info_tbl: [(celc,
                      label: $dData5_segi_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celc:
          _segi::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
      celd:
          R1 = _segi::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cele:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segi::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
$dData5_segi_entry() //  [R1]
        { info_tbl: [(celc,
                      label: $dData5_segi_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celc:
          _segi::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
      celd:
          R1 = _segi::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cele:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segi::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cels:
      _segk::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celt; else goto celu;   // CmmCondBranch
  celt:
      R1 = _segk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celu:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segk::P64;   // CmmStore
      _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
      R3 = _segj::P64;   // CmmAssign
      R2 = _segj::P64;   // CmmAssign
      R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cels:
      _segk::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celt; else goto celu;   // CmmCondBranch
  celt:
      R1 = _segk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celu:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segk::P64;   // CmmStore
      _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
      R3 = _segj::P64;   // CmmAssign
      R2 = _segj::P64;   // CmmAssign
      R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cels:
      _segk::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
  celt:
      R1 = _segk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celu:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segk::P64;   // CmmStore
      _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
      R3 = _segj::P64;   // CmmAssign
      R2 = _segj::P64;   // CmmAssign
      R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cels, {HsBinds.$fDataHsBindLR_closure}), (celt, {}),
 (celu, {HsBinds.$fDataHsBindLR_closure})]



==================== after setInfoTableStackMap ====================
sat_segk_entry() //  [R1]
        { info_tbl: [(cels,
                      label: sat_segk_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cels:
          _segk::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
      celt:
          R1 = _segk::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segk::P64;   // CmmStore
          _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
          R3 = _segj::P64;   // CmmAssign
          R2 = _segj::P64;   // CmmAssign
          R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segk_entry() //  [R1]
        { info_tbl: [(cels,
                      label: sat_segk_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cels:
          _segk::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
      celt:
          R1 = _segk::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segk::P64;   // CmmStore
          _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
          R3 = _segj::P64;   // CmmAssign
          R2 = _segj::P64;   // CmmAssign
          R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  celv:
      _segl::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celw; else goto celx;   // CmmCondBranch
  celx:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
  celz:
      HpAlloc = 24;   // CmmAssign
      goto celw;   // CmmBranch
  celw:
      R1 = _segl::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cely:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segl::P64;   // CmmStore
      _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segk_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celo::P64 = Hp - 16;   // CmmAssign
      R3 = _celo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  celv:
      _segl::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celw; else goto celx;   // CmmCondBranch
  celx:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
  celz:
      HpAlloc = 24;   // CmmAssign
      goto celw;   // CmmBranch
  celw:
      R1 = _segl::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cely:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segl::P64;   // CmmStore
      _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segk_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celo::P64 = Hp - 16;   // CmmAssign
      R3 = _celo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  celv:
      _segl::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
  celx:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
  celz:
      HpAlloc = 24;   // CmmAssign
      goto celw;   // CmmBranch
  celw:
      R1 = _segl::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cely:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segl::P64;   // CmmStore
      _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segk_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celo::P64 = Hp - 16;   // CmmAssign
      R3 = _celo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(celv,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_segk_closure}),
 (celw, {}),
 (celx,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_segk_closure}),
 (cely,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_segk_closure}),
 (celz, {})]



==================== after setInfoTableStackMap ====================
sat_segl_entry() //  [R1]
        { info_tbl: [(celv,
                      label: sat_segl_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celv:
          _segl::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
      celx:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
      celz:
          HpAlloc = 24;   // CmmAssign
          goto celw;   // CmmBranch
      celw:
          R1 = _segl::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cely:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segl::P64;   // CmmStore
          _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segk_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celo::P64 = Hp - 16;   // CmmAssign
          R3 = _celo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segl_entry() //  [R1]
        { info_tbl: [(celv,
                      label: sat_segl_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celv:
          _segl::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
      celx:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
      celz:
          HpAlloc = 24;   // CmmAssign
          goto celw;   // CmmBranch
      celw:
          R1 = _segl::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cely:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segl::P64;   // CmmStore
          _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segk_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celo::P64 = Hp - 16;   // CmmAssign
          R3 = _celo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  celA:
      _segm::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celB; else goto celC;   // CmmCondBranch
  celC:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
  celE:
      HpAlloc = 24;   // CmmAssign
      goto celB;   // CmmBranch
  celB:
      R1 = _segm::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segm::P64;   // CmmStore
      _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segl_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celk::P64 = Hp - 16;   // CmmAssign
      R2 = _celk::P64;   // CmmAssign
      R1 = Bag.$fDataBag_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  celA:
      _segm::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celB; else goto celC;   // CmmCondBranch
  celC:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
  celE:
      HpAlloc = 24;   // CmmAssign
      goto celB;   // CmmBranch
  celB:
      R1 = _segm::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segm::P64;   // CmmStore
      _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segl_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celk::P64 = Hp - 16;   // CmmAssign
      R2 = _celk::P64;   // CmmAssign
      R1 = Bag.$fDataBag_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  celA:
      _segm::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
  celC:
      Hp = Hp + 24;   // CmmAssign
      if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
  celE:
      HpAlloc = 24;   // CmmAssign
      goto celB;   // CmmBranch
  celB:
      R1 = _segm::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celD:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segm::P64;   // CmmStore
      _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segl_info;   // CmmStore
      P64[Hp] = _segj::P64;   // CmmStore
      _celk::P64 = Hp - 16;   // CmmAssign
      R2 = _celk::P64;   // CmmAssign
      R1 = Bag.$fDataBag_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(celA, {Bag.$fDataBag_closure, sat_segl_closure}), (celB, {}),
 (celC, {Bag.$fDataBag_closure, sat_segl_closure}),
 (celD, {Bag.$fDataBag_closure, sat_segl_closure}), (celE, {})]



==================== after setInfoTableStackMap ====================
sat_segm_entry() //  [R1]
        { info_tbl: [(celA,
                      label: sat_segm_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celA:
          _segm::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
      celC:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
      celE:
          HpAlloc = 24;   // CmmAssign
          goto celB;   // CmmBranch
      celB:
          R1 = _segm::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segm::P64;   // CmmStore
          _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segl_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celk::P64 = Hp - 16;   // CmmAssign
          R2 = _celk::P64;   // CmmAssign
          R1 = Bag.$fDataBag_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segm_entry() //  [R1]
        { info_tbl: [(celA,
                      label: sat_segm_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celA:
          _segm::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
      celC:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
      celE:
          HpAlloc = 24;   // CmmAssign
          goto celB;   // CmmBranch
      celB:
          R1 = _segm::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segm::P64;   // CmmStore
          _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segl_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celk::P64 = Hp - 16;   // CmmAssign
          R2 = _celk::P64;   // CmmAssign
          R1 = Bag.$fDataBag_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  celF:
      _segn::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celG; else goto celH;   // CmmCondBranch
  celH:
      Hp = Hp + 248;   // CmmAssign
      if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
  celJ:
      HpAlloc = 248;   // CmmAssign
      goto celG;   // CmmBranch
  celG:
      R1 = _segn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segn::P64;   // CmmStore
      _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
      _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 240] = $dData_segd_info;   // CmmStore
      _cekz::P64 = Hp - 240;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 224] = $dData1_sege_info;   // CmmStore
      _cekG::P64 = Hp - 224;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 208] = $dData2_segf_info;   // CmmStore
      _cekN::P64 = Hp - 208;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 192] = $dData3_segg_info;   // CmmStore
      _cekU::P64 = Hp - 192;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 176] = $dData4_segh_info;   // CmmStore
      P64[Hp - 160] = _cekU::P64;   // CmmStore
      _cel1::P64 = Hp - 176;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 152] = $dData5_segi_info;   // CmmStore
      _cel8::P64 = Hp - 152;   // CmmAssign
      I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 120] = _cel8::P64;   // CmmStore
      P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 88] = _cekN::P64;   // CmmStore
      P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
      P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
      P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 48] = _cekG::P64;   // CmmStore
      P64[Hp - 40] = _cekz::P64;   // CmmStore
      P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
      P64[Hp - 24] = _cel1::P64;   // CmmStore
      _celf::P64 = Hp - 135;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segm_info;   // CmmStore
      P64[Hp] = _celf::P64;   // CmmStore
      _celg::P64 = Hp - 16;   // CmmAssign
      R3 = _sefS::P64;   // CmmAssign
      R2 = _celg::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  celF:
      _segn::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto celG; else goto celH;   // CmmCondBranch
  celH:
      Hp = Hp + 248;   // CmmAssign
      if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
  celJ:
      HpAlloc = 248;   // CmmAssign
      goto celG;   // CmmBranch
  celG:
      R1 = _segn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segn::P64;   // CmmStore
      _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
      _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 240] = $dData_segd_info;   // CmmStore
      _cekz::P64 = Hp - 240;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 224] = $dData1_sege_info;   // CmmStore
      _cekG::P64 = Hp - 224;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 208] = $dData2_segf_info;   // CmmStore
      _cekN::P64 = Hp - 208;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 192] = $dData3_segg_info;   // CmmStore
      _cekU::P64 = Hp - 192;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 176] = $dData4_segh_info;   // CmmStore
      P64[Hp - 160] = _cekU::P64;   // CmmStore
      _cel1::P64 = Hp - 176;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 152] = $dData5_segi_info;   // CmmStore
      _cel8::P64 = Hp - 152;   // CmmAssign
      I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 120] = _cel8::P64;   // CmmStore
      P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 88] = _cekN::P64;   // CmmStore
      P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
      P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
      P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 48] = _cekG::P64;   // CmmStore
      P64[Hp - 40] = _cekz::P64;   // CmmStore
      P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
      P64[Hp - 24] = _cel1::P64;   // CmmStore
      _celf::P64 = Hp - 135;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segm_info;   // CmmStore
      P64[Hp] = _celf::P64;   // CmmStore
      _celg::P64 = Hp - 16;   // CmmAssign
      R3 = _sefS::P64;   // CmmAssign
      R2 = _celg::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  celF:
      _segn::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
  celH:
      Hp = Hp + 248;   // CmmAssign
      if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
  celJ:
      HpAlloc = 248;   // CmmAssign
      goto celG;   // CmmBranch
  celG:
      R1 = _segn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  celI:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segn::P64;   // CmmStore
      _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
      _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 240] = $dData_segd_info;   // CmmStore
      _cekz::P64 = Hp - 240;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 224] = $dData1_sege_info;   // CmmStore
      _cekG::P64 = Hp - 224;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 208] = $dData2_segf_info;   // CmmStore
      _cekN::P64 = Hp - 208;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 192] = $dData3_segg_info;   // CmmStore
      _cekU::P64 = Hp - 192;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 176] = $dData4_segh_info;   // CmmStore
      P64[Hp - 160] = _cekU::P64;   // CmmStore
      _cel1::P64 = Hp - 176;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 152] = $dData5_segi_info;   // CmmStore
      _cel8::P64 = Hp - 152;   // CmmAssign
      I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 120] = _cel8::P64;   // CmmStore
      P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 88] = _cekN::P64;   // CmmStore
      P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
      P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
      P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
      P64[Hp - 48] = _cekG::P64;   // CmmStore
      P64[Hp - 40] = _cekz::P64;   // CmmStore
      P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
      P64[Hp - 24] = _cel1::P64;   // CmmStore
      _celf::P64 = Hp - 135;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segm_info;   // CmmStore
      P64[Hp] = _celf::P64;   // CmmStore
      _celg::P64 = Hp - 16;   // CmmAssign
      R3 = _sefS::P64;   // CmmAssign
      R2 = _celg::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(celF,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   Name.$fDataName_closure, Var.$fDataVar_closure,
   TcEvidence.$fDataHsWrapper_closure, TypeRep.$fDataType_closure,
   Coercion.$fDataCoercion_closure, gq_seeZ_closure,
   $dData_segd_closure, $dData1_sege_closure, $dData2_segf_closure,
   $dData3_segg_closure, $dData4_segh_closure, $dData5_segi_closure,
   sat_segm_closure}),
 (celG, {}),
 (celH,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   Name.$fDataName_closure, Var.$fDataVar_closure,
   TcEvidence.$fDataHsWrapper_closure, TypeRep.$fDataType_closure,
   Coercion.$fDataCoercion_closure, gq_seeZ_closure,
   $dData_segd_closure, $dData1_sege_closure, $dData2_segf_closure,
   $dData3_segg_closure, $dData4_segh_closure, $dData5_segi_closure,
   sat_segm_closure}),
 (celI,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   Name.$fDataName_closure, Var.$fDataVar_closure,
   TcEvidence.$fDataHsWrapper_closure, TypeRep.$fDataType_closure,
   Coercion.$fDataCoercion_closure, gq_seeZ_closure,
   $dData_segd_closure, $dData1_sege_closure, $dData2_segf_closure,
   $dData3_segg_closure, $dData4_segh_closure, $dData5_segi_closure,
   sat_segm_closure}),
 (celJ, {})]



==================== after setInfoTableStackMap ====================
sat_segn_entry() //  [R1]
        { info_tbl: [(celF,
                      label: sat_segn_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celF:
          _segn::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
      celH:
          Hp = Hp + 248;   // CmmAssign
          if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
      celJ:
          HpAlloc = 248;   // CmmAssign
          goto celG;   // CmmBranch
      celG:
          R1 = _segn::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segn::P64;   // CmmStore
          _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
          _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 240] = $dData_segd_info;   // CmmStore
          _cekz::P64 = Hp - 240;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 224] = $dData1_sege_info;   // CmmStore
          _cekG::P64 = Hp - 224;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 208] = $dData2_segf_info;   // CmmStore
          _cekN::P64 = Hp - 208;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 192] = $dData3_segg_info;   // CmmStore
          _cekU::P64 = Hp - 192;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 176] = $dData4_segh_info;   // CmmStore
          P64[Hp - 160] = _cekU::P64;   // CmmStore
          _cel1::P64 = Hp - 176;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 152] = $dData5_segi_info;   // CmmStore
          _cel8::P64 = Hp - 152;   // CmmAssign
          I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 120] = _cel8::P64;   // CmmStore
          P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 88] = _cekN::P64;   // CmmStore
          P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
          P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
          P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 48] = _cekG::P64;   // CmmStore
          P64[Hp - 40] = _cekz::P64;   // CmmStore
          P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
          P64[Hp - 24] = _cel1::P64;   // CmmStore
          _celf::P64 = Hp - 135;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segm_info;   // CmmStore
          P64[Hp] = _celf::P64;   // CmmStore
          _celg::P64 = Hp - 16;   // CmmAssign
          R3 = _sefS::P64;   // CmmAssign
          R2 = _celg::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segn_entry() //  [R1]
        { info_tbl: [(celF,
                      label: sat_segn_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      celF:
          _segn::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
      celH:
          Hp = Hp + 248;   // CmmAssign
          if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
      celJ:
          HpAlloc = 248;   // CmmAssign
          goto celG;   // CmmBranch
      celG:
          R1 = _segn::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segn::P64;   // CmmStore
          _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
          _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 240] = $dData_segd_info;   // CmmStore
          _cekz::P64 = Hp - 240;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 224] = $dData1_sege_info;   // CmmStore
          _cekG::P64 = Hp - 224;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 208] = $dData2_segf_info;   // CmmStore
          _cekN::P64 = Hp - 208;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 192] = $dData3_segg_info;   // CmmStore
          _cekU::P64 = Hp - 192;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 176] = $dData4_segh_info;   // CmmStore
          P64[Hp - 160] = _cekU::P64;   // CmmStore
          _cel1::P64 = Hp - 176;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 152] = $dData5_segi_info;   // CmmStore
          _cel8::P64 = Hp - 152;   // CmmAssign
          I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 120] = _cel8::P64;   // CmmStore
          P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 88] = _cekN::P64;   // CmmStore
          P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
          P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
          P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 48] = _cekG::P64;   // CmmStore
          P64[Hp - 40] = _cekz::P64;   // CmmStore
          P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
          P64[Hp - 24] = _cel1::P64;   // CmmStore
          _celf::P64 = Hp - 135;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segm_info;   // CmmStore
          P64[Hp] = _celf::P64;   // CmmStore
          _celg::P64 = Hp - 16;   // CmmAssign
          R3 = _sefS::P64;   // CmmAssign
          R2 = _celg::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cem4:
      _seg8::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
  cem5:
      R1 = _seg8::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cem6:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg8::P64;   // CmmStore
      R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cem4:
      _seg8::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
  cem5:
      R1 = _seg8::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cem6:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg8::P64;   // CmmStore
      R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cem4:
      _seg8::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
  cem5:
      R1 = _seg8::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cem6:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg8::P64;   // CmmStore
      R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cem4,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   HsDoc.$fDataHsDocString_closure}),
 (cem5, {}),
 (cem6,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   HsDoc.$fDataHsDocString_closure})]



==================== after setInfoTableStackMap ====================
sat_seg8_entry() //  [R1]
        { info_tbl: [(cem4,
                      label: sat_seg8_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cem4:
          _seg8::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
      cem5:
          R1 = _seg8::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cem6:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg8::P64;   // CmmStore
          R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg8_entry() //  [R1]
        { info_tbl: [(cem4,
                      label: sat_seg8_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cem4:
          _seg8::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
      cem5:
          R1 = _seg8::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cem6:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg8::P64;   // CmmStore
          R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cem7:
      _seg9::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
  cem9:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
  cemb:
      HpAlloc = 16;   // CmmAssign
      goto cem8;   // CmmBranch
  cem8:
      R1 = _seg9::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cema:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg9::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg8_info;   // CmmStore
      _cem0::P64 = Hp - 8;   // CmmAssign
      R2 = _cem0::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cem7:
      _seg9::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
  cem9:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
  cemb:
      HpAlloc = 16;   // CmmAssign
      goto cem8;   // CmmBranch
  cem8:
      R1 = _seg9::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cema:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg9::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg8_info;   // CmmStore
      _cem0::P64 = Hp - 8;   // CmmAssign
      R2 = _cem0::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cem7:
      _seg9::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
  cem9:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
  cemb:
      HpAlloc = 16;   // CmmAssign
      goto cem8;   // CmmBranch
  cem8:
      R1 = _seg9::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cema:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg9::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg8_info;   // CmmStore
      _cem0::P64 = Hp - 8;   // CmmAssign
      R2 = _cem0::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cem7, {Data.Data.$fDataMaybe_closure, sat_seg8_closure}),
 (cem8, {}),
 (cem9, {Data.Data.$fDataMaybe_closure, sat_seg8_closure}),
 (cema, {Data.Data.$fDataMaybe_closure, sat_seg8_closure}),
 (cemb, {})]



==================== after setInfoTableStackMap ====================
sat_seg9_entry() //  [R1]
        { info_tbl: [(cem7,
                      label: sat_seg9_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cem7:
          _seg9::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
      cem9:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
      cemb:
          HpAlloc = 16;   // CmmAssign
          goto cem8;   // CmmBranch
      cem8:
          R1 = _seg9::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cema:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg9::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg8_info;   // CmmStore
          _cem0::P64 = Hp - 8;   // CmmAssign
          R2 = _cem0::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg9_entry() //  [R1]
        { info_tbl: [(cem7,
                      label: sat_seg9_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cem7:
          _seg9::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
      cem9:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
      cemb:
          HpAlloc = 16;   // CmmAssign
          goto cem8;   // CmmBranch
      cem8:
          R1 = _seg9::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cema:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg9::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg8_info;   // CmmStore
          _cem0::P64 = Hp - 8;   // CmmAssign
          R2 = _cem0::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cems:
      _seg4::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
  cemt:
      R1 = _seg4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemu:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg4::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cems:
      _seg4::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
  cemt:
      R1 = _seg4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemu:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg4::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cems:
      _seg4::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
  cemt:
      R1 = _seg4::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemu:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg4::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cems, {Name.$fDataName_closure, HsImpExp.$fDataIE_closure}),
 (cemt, {}),
 (cemu, {Name.$fDataName_closure, HsImpExp.$fDataIE_closure})]



==================== after setInfoTableStackMap ====================
sat_seg4_entry() //  [R1]
        { info_tbl: [(cems,
                      label: sat_seg4_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cems:
          _seg4::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
      cemt:
          R1 = _seg4::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg4::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg4_entry() //  [R1]
        { info_tbl: [(cems,
                      label: sat_seg4_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cems:
          _seg4::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
      cemt:
          R1 = _seg4::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg4::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cemv:
      _seg5::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
  cemx:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
  cemz:
      HpAlloc = 16;   // CmmAssign
      goto cemw;   // CmmBranch
  cemw:
      R1 = _seg5::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemy:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg5::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg4_info;   // CmmStore
      _cemo::P64 = Hp - 8;   // CmmAssign
      R3 = _cemo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cemv:
      _seg5::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
  cemx:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
  cemz:
      HpAlloc = 16;   // CmmAssign
      goto cemw;   // CmmBranch
  cemw:
      R1 = _seg5::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemy:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg5::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg4_info;   // CmmStore
      _cemo::P64 = Hp - 8;   // CmmAssign
      R3 = _cemo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cemv:
      _seg5::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
  cemx:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
  cemz:
      HpAlloc = 16;   // CmmAssign
      goto cemw;   // CmmBranch
  cemw:
      R1 = _seg5::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemy:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg5::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg4_info;   // CmmStore
      _cemo::P64 = Hp - 8;   // CmmAssign
      R3 = _cemo::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cemv,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg4_closure}),
 (cemw, {}),
 (cemx,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg4_closure}),
 (cemy,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg4_closure}),
 (cemz, {})]



==================== after setInfoTableStackMap ====================
sat_seg5_entry() //  [R1]
        { info_tbl: [(cemv,
                      label: sat_seg5_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemv:
          _seg5::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
      cemx:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
      cemz:
          HpAlloc = 16;   // CmmAssign
          goto cemw;   // CmmBranch
      cemw:
          R1 = _seg5::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg5::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg4_info;   // CmmStore
          _cemo::P64 = Hp - 8;   // CmmAssign
          R3 = _cemo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg5_entry() //  [R1]
        { info_tbl: [(cemv,
                      label: sat_seg5_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemv:
          _seg5::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
      cemx:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
      cemz:
          HpAlloc = 16;   // CmmAssign
          goto cemw;   // CmmBranch
      cemw:
          R1 = _seg5::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg5::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg4_info;   // CmmStore
          _cemo::P64 = Hp - 8;   // CmmAssign
          R3 = _cemo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cemA:
      _seg6::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
  cemC:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
  cemE:
      HpAlloc = 16;   // CmmAssign
      goto cemB;   // CmmBranch
  cemB:
      R1 = _seg6::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg6::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg5_info;   // CmmStore
      _cemk::P64 = Hp - 8;   // CmmAssign
      R2 = _cemk::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cemA:
      _seg6::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
  cemC:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
  cemE:
      HpAlloc = 16;   // CmmAssign
      goto cemB;   // CmmBranch
  cemB:
      R1 = _seg6::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg6::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg5_info;   // CmmStore
      _cemk::P64 = Hp - 8;   // CmmAssign
      R2 = _cemk::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cemA:
      _seg6::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
  cemC:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
  cemE:
      HpAlloc = 16;   // CmmAssign
      goto cemB;   // CmmBranch
  cemB:
      R1 = _seg6::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemD:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg6::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg5_info;   // CmmStore
      _cemk::P64 = Hp - 8;   // CmmAssign
      R2 = _cemk::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cemA, {Data.Data.$fData[]_closure, sat_seg5_closure}),
 (cemB, {}), (cemC, {Data.Data.$fData[]_closure, sat_seg5_closure}),
 (cemD, {Data.Data.$fData[]_closure, sat_seg5_closure}), (cemE, {})]



==================== after setInfoTableStackMap ====================
sat_seg6_entry() //  [R1]
        { info_tbl: [(cemA,
                      label: sat_seg6_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemA:
          _seg6::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
      cemC:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
      cemE:
          HpAlloc = 16;   // CmmAssign
          goto cemB;   // CmmBranch
      cemB:
          R1 = _seg6::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg6::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg5_info;   // CmmStore
          _cemk::P64 = Hp - 8;   // CmmAssign
          R2 = _cemk::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg6_entry() //  [R1]
        { info_tbl: [(cemA,
                      label: sat_seg6_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemA:
          _seg6::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
      cemC:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
      cemE:
          HpAlloc = 16;   // CmmAssign
          goto cemB;   // CmmBranch
      cemB:
          R1 = _seg6::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg6::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg5_info;   // CmmStore
          _cemk::P64 = Hp - 8;   // CmmAssign
          R2 = _cemk::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cemF:
      _seg7::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
  cemH:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
  cemJ:
      HpAlloc = 16;   // CmmAssign
      goto cemG;   // CmmBranch
  cemG:
      R1 = _seg7::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg7::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg6_info;   // CmmStore
      _cemg::P64 = Hp - 8;   // CmmAssign
      R2 = _cemg::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cemF:
      _seg7::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
  cemH:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
  cemJ:
      HpAlloc = 16;   // CmmAssign
      goto cemG;   // CmmBranch
  cemG:
      R1 = _seg7::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg7::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg6_info;   // CmmStore
      _cemg::P64 = Hp - 8;   // CmmAssign
      R2 = _cemg::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cemF:
      _seg7::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
  cemH:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
  cemJ:
      HpAlloc = 16;   // CmmAssign
      goto cemG;   // CmmBranch
  cemG:
      R1 = _seg7::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemI:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg7::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg6_info;   // CmmStore
      _cemg::P64 = Hp - 8;   // CmmAssign
      R2 = _cemg::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cemF, {Data.Data.$fDataMaybe_closure, sat_seg6_closure}),
 (cemG, {}),
 (cemH, {Data.Data.$fDataMaybe_closure, sat_seg6_closure}),
 (cemI, {Data.Data.$fDataMaybe_closure, sat_seg6_closure}),
 (cemJ, {})]



==================== after setInfoTableStackMap ====================
sat_seg7_entry() //  [R1]
        { info_tbl: [(cemF,
                      label: sat_seg7_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemF:
          _seg7::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
      cemH:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
      cemJ:
          HpAlloc = 16;   // CmmAssign
          goto cemG;   // CmmBranch
      cemG:
          R1 = _seg7::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg7::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg6_info;   // CmmStore
          _cemg::P64 = Hp - 8;   // CmmAssign
          R2 = _cemg::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg7_entry() //  [R1]
        { info_tbl: [(cemF,
                      label: sat_seg7_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemF:
          _seg7::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
      cemH:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
      cemJ:
          HpAlloc = 16;   // CmmAssign
          goto cemG;   // CmmBranch
      cemG:
          R1 = _seg7::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg7::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg6_info;   // CmmStore
          _cemg::P64 = Hp - 8;   // CmmAssign
          R2 = _cemg::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cemW:
      _seg1::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
  cemX:
      R1 = _seg1::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemY:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg1::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cemW:
      _seg1::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
  cemX:
      R1 = _seg1::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemY:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg1::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cemW:
      _seg1::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
  cemX:
      R1 = _seg1::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cemY:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg1::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cemW,
  {Name.$fDataName_closure, HsImpExp.$fDataImportDecl_closure}),
 (cemX, {}),
 (cemY,
  {Name.$fDataName_closure, HsImpExp.$fDataImportDecl_closure})]



==================== after setInfoTableStackMap ====================
sat_seg1_entry() //  [R1]
        { info_tbl: [(cemW,
                      label: sat_seg1_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemW:
          _seg1::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
      cemX:
          R1 = _seg1::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg1::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg1_entry() //  [R1]
        { info_tbl: [(cemW,
                      label: sat_seg1_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemW:
          _seg1::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
      cemX:
          R1 = _seg1::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg1::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cemZ:
      _seg2::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
  cen1:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
  cen3:
      HpAlloc = 16;   // CmmAssign
      goto cen0;   // CmmBranch
  cen0:
      R1 = _seg2::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen2:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg2::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg1_info;   // CmmStore
      _cemS::P64 = Hp - 8;   // CmmAssign
      R3 = _cemS::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cemZ:
      _seg2::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
  cen1:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
  cen3:
      HpAlloc = 16;   // CmmAssign
      goto cen0;   // CmmBranch
  cen0:
      R1 = _seg2::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen2:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg2::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg1_info;   // CmmStore
      _cemS::P64 = Hp - 8;   // CmmAssign
      R3 = _cemS::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cemZ:
      _seg2::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
  cen1:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
  cen3:
      HpAlloc = 16;   // CmmAssign
      goto cen0;   // CmmBranch
  cen0:
      R1 = _seg2::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen2:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg2::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg1_info;   // CmmStore
      _cemS::P64 = Hp - 8;   // CmmAssign
      R3 = _cemS::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cemZ,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg1_closure}),
 (cen0, {}),
 (cen1,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg1_closure}),
 (cen2,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_seg1_closure}),
 (cen3, {})]



==================== after setInfoTableStackMap ====================
sat_seg2_entry() //  [R1]
        { info_tbl: [(cemZ,
                      label: sat_seg2_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemZ:
          _seg2::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
      cen1:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
      cen3:
          HpAlloc = 16;   // CmmAssign
          goto cen0;   // CmmBranch
      cen0:
          R1 = _seg2::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg2::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg1_info;   // CmmStore
          _cemS::P64 = Hp - 8;   // CmmAssign
          R3 = _cemS::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg2_entry() //  [R1]
        { info_tbl: [(cemZ,
                      label: sat_seg2_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cemZ:
          _seg2::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
      cen1:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
      cen3:
          HpAlloc = 16;   // CmmAssign
          goto cen0;   // CmmBranch
      cen0:
          R1 = _seg2::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg2::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg1_info;   // CmmStore
          _cemS::P64 = Hp - 8;   // CmmAssign
          R3 = _cemS::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cen4:
      _seg3::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
  cen6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
  cen8:
      HpAlloc = 16;   // CmmAssign
      goto cen5;   // CmmBranch
  cen5:
      R1 = _seg3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg3::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg2_info;   // CmmStore
      _cemO::P64 = Hp - 8;   // CmmAssign
      R2 = _cemO::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cen4:
      _seg3::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
  cen6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
  cen8:
      HpAlloc = 16;   // CmmAssign
      goto cen5;   // CmmBranch
  cen5:
      R1 = _seg3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg3::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg2_info;   // CmmStore
      _cemO::P64 = Hp - 8;   // CmmAssign
      R2 = _cemO::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cen4:
      _seg3::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
  cen6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
  cen8:
      HpAlloc = 16;   // CmmAssign
      goto cen5;   // CmmBranch
  cen5:
      R1 = _seg3::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cen7:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg3::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg2_info;   // CmmStore
      _cemO::P64 = Hp - 8;   // CmmAssign
      R2 = _cemO::P64;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cen4, {Data.Data.$fData[]_closure, sat_seg2_closure}),
 (cen5, {}), (cen6, {Data.Data.$fData[]_closure, sat_seg2_closure}),
 (cen7, {Data.Data.$fData[]_closure, sat_seg2_closure}), (cen8, {})]



==================== after setInfoTableStackMap ====================
sat_seg3_entry() //  [R1]
        { info_tbl: [(cen4,
                      label: sat_seg3_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cen4:
          _seg3::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
      cen6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
      cen8:
          HpAlloc = 16;   // CmmAssign
          goto cen5;   // CmmBranch
      cen5:
          R1 = _seg3::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg3::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg2_info;   // CmmStore
          _cemO::P64 = Hp - 8;   // CmmAssign
          R2 = _cemO::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg3_entry() //  [R1]
        { info_tbl: [(cen4,
                      label: sat_seg3_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cen4:
          _seg3::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
      cen6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
      cen8:
          HpAlloc = 16;   // CmmAssign
          goto cen5;   // CmmBranch
      cen5:
          R1 = _seg3::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg3::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg2_info;   // CmmStore
          _cemO::P64 = Hp - 8;   // CmmAssign
          R2 = _cemO::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cenh:
      _sefY::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
  ceni:
      R1 = _sefY::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenj:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefY::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cenh:
      _sefY::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
  ceni:
      R1 = _sefY::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenj:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefY::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cenh:
      _sefY::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
  ceni:
      R1 = _sefY::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenj:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefY::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = Data.Data.$fData[]_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cenh, {Data.Data.$fData[]_closure, Name.$fDataName_closure}),
 (ceni, {}),
 (cenj, {Data.Data.$fData[]_closure, Name.$fDataName_closure})]



==================== after setInfoTableStackMap ====================
sat_sefY_entry() //  [R1]
        { info_tbl: [(cenh,
                      label: sat_sefY_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenh:
          _sefY::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
      ceni:
          R1 = _sefY::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenj:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefY::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefY_entry() //  [R1]
        { info_tbl: [(cenh,
                      label: sat_sefY_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenh:
          _sefY::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
      ceni:
          R1 = _sefY::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenj:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefY::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceno:
      _sefX::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
  cenp:
      R1 = _sefX::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenq:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefX::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceno:
      _sefX::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
  cenp:
      R1 = _sefX::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenq:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefX::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceno:
      _sefX::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
  cenp:
      R1 = _sefX::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenq:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefX::P64;   // CmmStore
      R2 = Name.$fDataName_closure;   // CmmAssign
      R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceno, {Name.$fDataName_closure, UniqFM.$fDataUniqFM_closure}),
 (cenp, {}),
 (cenq, {Name.$fDataName_closure, UniqFM.$fDataUniqFM_closure})]



==================== after setInfoTableStackMap ====================
sat_sefX_entry() //  [R1]
        { info_tbl: [(ceno,
                      label: sat_sefX_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceno:
          _sefX::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
      cenp:
          R1 = _sefX::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenq:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefX::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefX_entry() //  [R1]
        { info_tbl: [(ceno,
                      label: sat_sefX_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceno:
          _sefX::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
      cenp:
          R1 = _sefX::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenq:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefX::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cens:
      _seg0::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cent; else goto cenu;   // CmmCondBranch
  cenu:
      Hp = Hp + 152;   // CmmAssign
      if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
  cenw:
      HpAlloc = 152;   // CmmAssign
      goto cent;   // CmmBranch
  cent:
      R1 = _seg0::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenv:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg0::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 144] = sat_sefY_info;   // CmmStore
      _cend::P64 = Hp - 144;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 128] = sat_sefX_info;   // CmmStore
      _cenk::P64 = Hp - 128;   // CmmAssign
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 96] = _cenk::P64;   // CmmStore
      P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 64] = _cend::P64;   // CmmStore
      P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenr::P64 = Hp - 111;   // CmmAssign
      R2 = _cenr::P64;   // CmmAssign
      R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cens:
      _seg0::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cent; else goto cenu;   // CmmCondBranch
  cenu:
      Hp = Hp + 152;   // CmmAssign
      if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
  cenw:
      HpAlloc = 152;   // CmmAssign
      goto cent;   // CmmBranch
  cent:
      R1 = _seg0::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenv:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seg0::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 144] = sat_sefY_info;   // CmmStore
      _cend::P64 = Hp - 144;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 128] = sat_sefX_info;   // CmmStore
      _cenk::P64 = Hp - 128;   // CmmAssign
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 96] = _cenk::P64;   // CmmStore
      P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 64] = _cend::P64;   // CmmStore
      P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenr::P64 = Hp - 111;   // CmmAssign
      R2 = _cenr::P64;   // CmmAssign
      R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cens:
      _seg0::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
  cenu:
      Hp = Hp + 152;   // CmmAssign
      if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
  cenw:
      HpAlloc = 152;   // CmmAssign
      goto cent;   // CmmBranch
  cent:
      R1 = _seg0::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenv:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seg0::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 144] = sat_sefY_info;   // CmmStore
      _cend::P64 = Hp - 144;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 128] = sat_sefX_info;   // CmmStore
      _cenk::P64 = Hp - 128;   // CmmAssign
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 96] = _cenk::P64;   // CmmStore
      P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
      P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
      P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 64] = _cend::P64;   // CmmStore
      P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenr::P64 = Hp - 111;   // CmmAssign
      R2 = _cenr::P64;   // CmmAssign
      R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cens,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   HsDecls.$fDataHsGroup_closure, Name.$fDataName_closure,
   PlaceHolder.$fDataPlaceHolder_closure, sat_sefX_closure,
   sat_sefY_closure}),
 (cent, {}),
 (cenu,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   HsDecls.$fDataHsGroup_closure, Name.$fDataName_closure,
   PlaceHolder.$fDataPlaceHolder_closure, sat_sefX_closure,
   sat_sefY_closure}),
 (cenv,
  {Data.Data.$fDataBool_closure, BasicTypes.$fDataFixity_closure,
   HsDecls.$fDataHsGroup_closure, Name.$fDataName_closure,
   PlaceHolder.$fDataPlaceHolder_closure, sat_sefX_closure,
   sat_sefY_closure}),
 (cenw, {})]



==================== after setInfoTableStackMap ====================
sat_seg0_entry() //  [R1]
        { info_tbl: [(cens,
                      label: sat_seg0_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cens:
          _seg0::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
      cenu:
          Hp = Hp + 152;   // CmmAssign
          if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
      cenw:
          HpAlloc = 152;   // CmmAssign
          goto cent;   // CmmBranch
      cent:
          R1 = _seg0::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenv:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg0::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 144] = sat_sefY_info;   // CmmStore
          _cend::P64 = Hp - 144;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 128] = sat_sefX_info;   // CmmStore
          _cenk::P64 = Hp - 128;   // CmmAssign
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 96] = _cenk::P64;   // CmmStore
          P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 64] = _cend::P64;   // CmmStore
          P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenr::P64 = Hp - 111;   // CmmAssign
          R2 = _cenr::P64;   // CmmAssign
          R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seg0_entry() //  [R1]
        { info_tbl: [(cens,
                      label: sat_seg0_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cens:
          _seg0::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
      cenu:
          Hp = Hp + 152;   // CmmAssign
          if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
      cenw:
          HpAlloc = 152;   // CmmAssign
          goto cent;   // CmmBranch
      cent:
          R1 = _seg0::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenv:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg0::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 144] = sat_sefY_info;   // CmmStore
          _cend::P64 = Hp - 144;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 128] = sat_sefX_info;   // CmmStore
          _cenk::P64 = Hp - 128;   // CmmAssign
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 96] = _cenk::P64;   // CmmStore
          P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 64] = _cend::P64;   // CmmStore
          P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenr::P64 = Hp - 111;   // CmmAssign
          R2 = _cenr::P64;   // CmmAssign
          R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cenx:
      _sega::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
  cenz:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
  cenB:
      HpAlloc = 64;   // CmmAssign
      goto ceny;   // CmmBranch
  ceny:
      R1 = _sega::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenA:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sega::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 56] = sat_seg9_info;   // CmmStore
      _celW::P64 = Hp - 56;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_seg7_info;   // CmmStore
      _cemc::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_seg3_info;   // CmmStore
      _cemK::P64 = Hp - 24;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg0_info;   // CmmStore
      _cen9::P64 = Hp - 8;   // CmmAssign
      R5 = _celW::P64;   // CmmAssign
      R4 = _cemc::P64;   // CmmAssign
      R3 = _cemK::P64;   // CmmAssign
      R2 = _cen9::P64;   // CmmAssign
      R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
      call stg_ap_pppp_fast(R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cenx:
      _sega::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
  cenz:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
  cenB:
      HpAlloc = 64;   // CmmAssign
      goto ceny;   // CmmBranch
  ceny:
      R1 = _sega::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenA:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sega::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 56] = sat_seg9_info;   // CmmStore
      _celW::P64 = Hp - 56;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_seg7_info;   // CmmStore
      _cemc::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_seg3_info;   // CmmStore
      _cemK::P64 = Hp - 24;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg0_info;   // CmmStore
      _cen9::P64 = Hp - 8;   // CmmAssign
      R5 = _celW::P64;   // CmmAssign
      R4 = _cemc::P64;   // CmmAssign
      R3 = _cemK::P64;   // CmmAssign
      R2 = _cen9::P64;   // CmmAssign
      R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
      call stg_ap_pppp_fast(R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cenx:
      _sega::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
  cenz:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
  cenB:
      HpAlloc = 64;   // CmmAssign
      goto ceny;   // CmmBranch
  ceny:
      R1 = _sega::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenA:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sega::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 56] = sat_seg9_info;   // CmmStore
      _celW::P64 = Hp - 56;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_seg7_info;   // CmmStore
      _cemc::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_seg3_info;   // CmmStore
      _cemK::P64 = Hp - 24;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_seg0_info;   // CmmStore
      _cen9::P64 = Hp - 8;   // CmmAssign
      R5 = _celW::P64;   // CmmAssign
      R4 = _cemc::P64;   // CmmAssign
      R3 = _cemK::P64;   // CmmAssign
      R2 = _cen9::P64;   // CmmAssign
      R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pppp_fast(R5,
                            R4,
                            R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cenx,
  {Data.Data.$fData(,,,)_closure, sat_seg0_closure, sat_seg3_closure,
   sat_seg7_closure, sat_seg9_closure}),
 (ceny, {}),
 (cenz,
  {Data.Data.$fData(,,,)_closure, sat_seg0_closure, sat_seg3_closure,
   sat_seg7_closure, sat_seg9_closure}),
 (cenA,
  {Data.Data.$fData(,,,)_closure, sat_seg0_closure, sat_seg3_closure,
   sat_seg7_closure, sat_seg9_closure}),
 (cenB, {})]



==================== after setInfoTableStackMap ====================
sat_sega_entry() //  [R1]
        { info_tbl: [(cenx,
                      label: sat_sega_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenx:
          _sega::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
      cenz:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
      cenB:
          HpAlloc = 64;   // CmmAssign
          goto ceny;   // CmmBranch
      ceny:
          R1 = _sega::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sega::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 56] = sat_seg9_info;   // CmmStore
          _celW::P64 = Hp - 56;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_seg7_info;   // CmmStore
          _cemc::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_seg3_info;   // CmmStore
          _cemK::P64 = Hp - 24;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg0_info;   // CmmStore
          _cen9::P64 = Hp - 8;   // CmmAssign
          R5 = _celW::P64;   // CmmAssign
          R4 = _cemc::P64;   // CmmAssign
          R3 = _cemK::P64;   // CmmAssign
          R2 = _cen9::P64;   // CmmAssign
          R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pppp_fast(R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sega_entry() //  [R1]
        { info_tbl: [(cenx,
                      label: sat_sega_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenx:
          _sega::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
      cenz:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
      cenB:
          HpAlloc = 64;   // CmmAssign
          goto ceny;   // CmmBranch
      ceny:
          R1 = _sega::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sega::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 56] = sat_seg9_info;   // CmmStore
          _celW::P64 = Hp - 56;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_seg7_info;   // CmmStore
          _cemc::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_seg3_info;   // CmmStore
          _cemK::P64 = Hp - 24;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg0_info;   // CmmStore
          _cen9::P64 = Hp - 8;   // CmmAssign
          R5 = _celW::P64;   // CmmAssign
          R4 = _cemc::P64;   // CmmAssign
          R3 = _cemK::P64;   // CmmAssign
          R2 = _cen9::P64;   // CmmAssign
          R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pppp_fast(R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cenC:
      _segb::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
  cenE:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
  cenG:
      HpAlloc = 16;   // CmmAssign
      goto cenD;   // CmmBranch
  cenD:
      R1 = _segb::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenF:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segb::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sega_info;   // CmmStore
      _celS::P64 = Hp - 8;   // CmmAssign
      R2 = _celS::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cenC:
      _segb::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
  cenE:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
  cenG:
      HpAlloc = 16;   // CmmAssign
      goto cenD;   // CmmBranch
  cenD:
      R1 = _segb::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenF:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segb::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sega_info;   // CmmStore
      _celS::P64 = Hp - 8;   // CmmAssign
      R2 = _celS::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cenC:
      _segb::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
  cenE:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
  cenG:
      HpAlloc = 16;   // CmmAssign
      goto cenD;   // CmmBranch
  cenD:
      R1 = _segb::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenF:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segb::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sega_info;   // CmmStore
      _celS::P64 = Hp - 8;   // CmmAssign
      R2 = _celS::P64;   // CmmAssign
      R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cenC, {Data.Data.$fDataMaybe_closure, sat_sega_closure}),
 (cenD, {}),
 (cenE, {Data.Data.$fDataMaybe_closure, sat_sega_closure}),
 (cenF, {Data.Data.$fDataMaybe_closure, sat_sega_closure}),
 (cenG, {})]



==================== after setInfoTableStackMap ====================
sat_segb_entry() //  [R1]
        { info_tbl: [(cenC,
                      label: sat_segb_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenC:
          _segb::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
      cenE:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
      cenG:
          HpAlloc = 16;   // CmmAssign
          goto cenD;   // CmmBranch
      cenD:
          R1 = _segb::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segb::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sega_info;   // CmmStore
          _celS::P64 = Hp - 8;   // CmmAssign
          R2 = _celS::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segb_entry() //  [R1]
        { info_tbl: [(cenC,
                      label: sat_segb_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenC:
          _segb::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
      cenE:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
      cenG:
          HpAlloc = 16;   // CmmAssign
          goto cenD;   // CmmBranch
      cenD:
          R1 = _segb::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segb::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sega_info;   // CmmStore
          _celS::P64 = Hp - 8;   // CmmAssign
          R2 = _celS::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cenH:
      _segc::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
  cenJ:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
  cenL:
      HpAlloc = 16;   // CmmAssign
      goto cenI;   // CmmBranch
  cenI:
      R1 = _segc::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenK:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segc::P64;   // CmmStore
      _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
      _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segb_info;   // CmmStore
      _celO::P64 = Hp - 8;   // CmmAssign
      R3 = _sefR::P64;   // CmmAssign
      R2 = _celO::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cenH:
      _segc::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
  cenJ:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
  cenL:
      HpAlloc = 16;   // CmmAssign
      goto cenI;   // CmmBranch
  cenI:
      R1 = _segc::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenK:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segc::P64;   // CmmStore
      _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
      _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segb_info;   // CmmStore
      _celO::P64 = Hp - 8;   // CmmAssign
      R3 = _sefR::P64;   // CmmAssign
      R2 = _celO::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cenH:
      _segc::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
  cenJ:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
  cenL:
      HpAlloc = 16;   // CmmAssign
      goto cenI;   // CmmBranch
  cenI:
      R1 = _segc::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cenK:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segc::P64;   // CmmStore
      _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
      _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segb_info;   // CmmStore
      _celO::P64 = Hp - 8;   // CmmAssign
      R3 = _sefR::P64;   // CmmAssign
      R2 = _celO::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cenH, {gq_seeZ_closure, sat_segb_closure}), (cenI, {}),
 (cenJ, {gq_seeZ_closure, sat_segb_closure}),
 (cenK, {gq_seeZ_closure, sat_segb_closure}), (cenL, {})]



==================== after setInfoTableStackMap ====================
sat_segc_entry() //  [R1]
        { info_tbl: [(cenH,
                      label: sat_segc_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenH:
          _segc::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
      cenJ:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
      cenL:
          HpAlloc = 16;   // CmmAssign
          goto cenI;   // CmmBranch
      cenI:
          R1 = _segc::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenK:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segc::P64;   // CmmStore
          _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
          _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segb_info;   // CmmStore
          _celO::P64 = Hp - 8;   // CmmAssign
          R3 = _sefR::P64;   // CmmAssign
          R2 = _celO::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segc_entry() //  [R1]
        { info_tbl: [(cenH,
                      label: sat_segc_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenH:
          _segc::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
      cenJ:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
      cenL:
          HpAlloc = 16;   // CmmAssign
          goto cenI;   // CmmBranch
      cenI:
          R1 = _segc::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenK:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segc::P64;   // CmmStore
          _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
          _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segb_info;   // CmmStore
          _celO::P64 = Hp - 8;   // CmmAssign
          R3 = _sefR::P64;   // CmmAssign
          R2 = _celO::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cenZ:
      _sefU::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
  ceo1:
      Hp = Hp + 120;   // CmmAssign
      if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
  ceo3:
      HpAlloc = 120;   // CmmAssign
      goto ceo0;   // CmmBranch
  ceo0:
      R1 = _sefU::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo2:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefU::P64;   // CmmStore
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
      P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenY::P64 = Hp - 111;   // CmmAssign
      R2 = _cenY::P64;   // CmmAssign
      R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cenZ:
      _sefU::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
  ceo1:
      Hp = Hp + 120;   // CmmAssign
      if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
  ceo3:
      HpAlloc = 120;   // CmmAssign
      goto ceo0;   // CmmBranch
  ceo0:
      R1 = _sefU::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo2:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefU::P64;   // CmmStore
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
      P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenY::P64 = Hp - 111;   // CmmAssign
      R2 = _cenY::P64;   // CmmAssign
      R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cenZ:
      _sefU::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
  ceo1:
      Hp = Hp + 120;   // CmmAssign
      if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
  ceo3:
      HpAlloc = 120;   // CmmAssign
      goto ceo0;   // CmmBranch
  ceo0:
      R1 = _sefU::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo2:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefU::P64;   // CmmStore
      I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
      P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
      P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
      _cenY::P64 = Hp - 111;   // CmmAssign
      R2 = _cenY::P64;   // CmmAssign
      R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cenZ,
  {PlaceHolder.$fDataPlaceHolder_closure,
   HsSyn.$fDataHsModule_closure, RdrName.$fDataRdrName_closure}),
 (ceo0, {}),
 (ceo1,
  {PlaceHolder.$fDataPlaceHolder_closure,
   HsSyn.$fDataHsModule_closure, RdrName.$fDataRdrName_closure}),
 (ceo2,
  {PlaceHolder.$fDataPlaceHolder_closure,
   HsSyn.$fDataHsModule_closure, RdrName.$fDataRdrName_closure}),
 (ceo3, {})]



==================== after setInfoTableStackMap ====================
sat_sefU_entry() //  [R1]
        { info_tbl: [(cenZ,
                      label: sat_sefU_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenZ:
          _sefU::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
      ceo1:
          Hp = Hp + 120;   // CmmAssign
          if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
      ceo3:
          HpAlloc = 120;   // CmmAssign
          goto ceo0;   // CmmBranch
      ceo0:
          R1 = _sefU::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefU::P64;   // CmmStore
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
          P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenY::P64 = Hp - 111;   // CmmAssign
          R2 = _cenY::P64;   // CmmAssign
          R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefU_entry() //  [R1]
        { info_tbl: [(cenZ,
                      label: sat_sefU_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cenZ:
          _sefU::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
      ceo1:
          Hp = Hp + 120;   // CmmAssign
          if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
      ceo3:
          HpAlloc = 120;   // CmmAssign
          goto ceo0;   // CmmBranch
      ceo0:
          R1 = _sefU::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefU::P64;   // CmmStore
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
          P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenY::P64 = Hp - 111;   // CmmAssign
          R2 = _cenY::P64;   // CmmAssign
          R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceo4:
      _sefV::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
  ceo6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
  ceo8:
      HpAlloc = 16;   // CmmAssign
      goto ceo5;   // CmmBranch
  ceo5:
      R1 = _sefV::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefV::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefU_info;   // CmmStore
      _cenU::P64 = Hp - 8;   // CmmAssign
      R3 = _cenU::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceo4:
      _sefV::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
  ceo6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
  ceo8:
      HpAlloc = 16;   // CmmAssign
      goto ceo5;   // CmmBranch
  ceo5:
      R1 = _sefV::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo7:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefV::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefU_info;   // CmmStore
      _cenU::P64 = Hp - 8;   // CmmAssign
      R3 = _cenU::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceo4:
      _sefV::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
  ceo6:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
  ceo8:
      HpAlloc = 16;   // CmmAssign
      goto ceo5;   // CmmBranch
  ceo5:
      R1 = _sefV::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceo7:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefV::P64;   // CmmStore
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefU_info;   // CmmStore
      _cenU::P64 = Hp - 8;   // CmmAssign
      R3 = _cenU::P64;   // CmmAssign
      R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
      R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceo4,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_sefU_closure}),
 (ceo5, {}),
 (ceo6,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_sefU_closure}),
 (ceo7,
  {SrcLoc.$fDataSrcSpan_closure, SrcLoc.$fDataGenLocated_closure,
   sat_sefU_closure}),
 (ceo8, {})]



==================== after setInfoTableStackMap ====================
sat_sefV_entry() //  [R1]
        { info_tbl: [(ceo4,
                      label: sat_sefV_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceo4:
          _sefV::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
      ceo6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
      ceo8:
          HpAlloc = 16;   // CmmAssign
          goto ceo5;   // CmmBranch
      ceo5:
          R1 = _sefV::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefV::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefU_info;   // CmmStore
          _cenU::P64 = Hp - 8;   // CmmAssign
          R3 = _cenU::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefV_entry() //  [R1]
        { info_tbl: [(ceo4,
                      label: sat_sefV_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceo4:
          _sefV::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
      ceo6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
      ceo8:
          HpAlloc = 16;   // CmmAssign
          goto ceo5;   // CmmBranch
      ceo5:
          R1 = _sefV::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefV::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefU_info;   // CmmStore
          _cenU::P64 = Hp - 8;   // CmmAssign
          R3 = _cenU::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceo9:
      _sefW::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
  ceob:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
  ceod:
      HpAlloc = 16;   // CmmAssign
      goto ceoa;   // CmmBranch
  ceoa:
      R1 = _sefW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoc:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefW::P64;   // CmmStore
      _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
      _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefV_info;   // CmmStore
      _cenQ::P64 = Hp - 8;   // CmmAssign
      R3 = _sefQ::P64;   // CmmAssign
      R2 = _cenQ::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceo9:
      _sefW::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
  ceob:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
  ceod:
      HpAlloc = 16;   // CmmAssign
      goto ceoa;   // CmmBranch
  ceoa:
      R1 = _sefW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoc:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefW::P64;   // CmmStore
      _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
      _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefV_info;   // CmmStore
      _cenQ::P64 = Hp - 8;   // CmmAssign
      R3 = _sefQ::P64;   // CmmAssign
      R2 = _cenQ::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceo9:
      _sefW::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
  ceob:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
  ceod:
      HpAlloc = 16;   // CmmAssign
      goto ceoa;   // CmmBranch
  ceoa:
      R1 = _sefW::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoc:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefW::P64;   // CmmStore
      _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
      _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefV_info;   // CmmStore
      _cenQ::P64 = Hp - 8;   // CmmAssign
      R3 = _sefQ::P64;   // CmmAssign
      R2 = _cenQ::P64;   // CmmAssign
      R1 = _seeZ::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call gq_seeZ_info(R3,
                        R2,
                        R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceo9, {gq_seeZ_closure, sat_sefV_closure}), (ceoa, {}),
 (ceob, {gq_seeZ_closure, sat_sefV_closure}),
 (ceoc, {gq_seeZ_closure, sat_sefV_closure}), (ceod, {})]



==================== after setInfoTableStackMap ====================
sat_sefW_entry() //  [R1]
        { info_tbl: [(ceo9,
                      label: sat_sefW_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceo9:
          _sefW::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
      ceob:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
      ceod:
          HpAlloc = 16;   // CmmAssign
          goto ceoa;   // CmmBranch
      ceoa:
          R1 = _sefW::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoc:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefW::P64;   // CmmStore
          _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
          _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefV_info;   // CmmStore
          _cenQ::P64 = Hp - 8;   // CmmAssign
          R3 = _sefQ::P64;   // CmmAssign
          R2 = _cenQ::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefW_entry() //  [R1]
        { info_tbl: [(ceo9,
                      label: sat_sefW_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceo9:
          _sefW::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
      ceob:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
      ceod:
          HpAlloc = 16;   // CmmAssign
          goto ceoa;   // CmmBranch
      ceoa:
          R1 = _sefW::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoc:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefW::P64;   // CmmStore
          _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
          _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefV_info;   // CmmStore
          _cenQ::P64 = Hp - 8;   // CmmAssign
          R3 = _sefQ::P64;   // CmmAssign
          R2 = _cenQ::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceoe:
      _sefO::P64 = R2;   // CmmAssign
      _segp::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
  ceog:
      R2 = _sefO::P64;   // CmmAssign
      R1 = _segp::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoh:
      _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
      I64[(young<cekq> + 8)] = cekq;   // CmmStore
      R1 = _sefO::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
  cekr:
      call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  cekq:
      _sefP::P64 = R1;   // CmmAssign
      Hp = Hp + 128;   // CmmAssign
      if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
  ceok:
      HpAlloc = 128;   // CmmAssign
      R1 = _sefP::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  ceoj:
      _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
      _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
      _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 120] = sat_segn_info;   // CmmStore
      P64[Hp - 104] = _seeZ::P64;   // CmmStore
      P64[Hp - 96] = _sefS::P64;   // CmmStore
      _cekv::P64 = Hp - 120;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 88] = sat_segc_info;   // CmmStore
      P64[Hp - 72] = _seeZ::P64;   // CmmStore
      P64[Hp - 64] = _sefR::P64;   // CmmStore
      _celK::P64 = Hp - 88;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 56] = sat_sefW_info;   // CmmStore
      P64[Hp - 40] = _seeZ::P64;   // CmmStore
      P64[Hp - 32] = _sefQ::P64;   // CmmStore
      _cenM::P64 = Hp - 56;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cenM::P64;   // CmmStore
      P64[Hp - 8] = _celK::P64;   // CmmStore
      P64[Hp] = _cekv::P64;   // CmmStore
      _ceof::P64 = Hp - 23;   // CmmAssign
      R3 = _ceof::P64;   // CmmAssign
      R2 = $dShow_reeF_closure;   // CmmAssign
      R1 = System.IO.print_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceoe:
      _sefO::P64 = R2;   // CmmAssign
      _segp::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
  ceog:
      R2 = _sefO::P64;   // CmmAssign
      R1 = _segp::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoh:
      _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
      I64[(young<cekq> + 8)] = cekq;   // CmmStore
      R1 = _sefO::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
  cekr:
      call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  cekq:
      _sefP::P64 = R1;   // CmmAssign
      Hp = Hp + 128;   // CmmAssign
      if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
  ceok:
      HpAlloc = 128;   // CmmAssign
      R1 = _sefP::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  ceoj:
      _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
      _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
      _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 120] = sat_segn_info;   // CmmStore
      P64[Hp - 104] = _seeZ::P64;   // CmmStore
      P64[Hp - 96] = _sefS::P64;   // CmmStore
      _cekv::P64 = Hp - 120;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 88] = sat_segc_info;   // CmmStore
      P64[Hp - 72] = _seeZ::P64;   // CmmStore
      P64[Hp - 64] = _sefR::P64;   // CmmStore
      _celK::P64 = Hp - 88;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 56] = sat_sefW_info;   // CmmStore
      P64[Hp - 40] = _seeZ::P64;   // CmmStore
      P64[Hp - 32] = _sefQ::P64;   // CmmStore
      _cenM::P64 = Hp - 56;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cenM::P64;   // CmmStore
      P64[Hp - 8] = _celK::P64;   // CmmStore
      P64[Hp] = _cekv::P64;   // CmmStore
      _ceof::P64 = Hp - 23;   // CmmAssign
      R3 = _ceof::P64;   // CmmAssign
      R2 = $dShow_reeF_closure;   // CmmAssign
      R1 = System.IO.print_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceoe:
      _sefO::P64 = R2;   // CmmAssign
      _segp::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
  ceog:
      R2 = _sefO::P64;   // CmmAssign
      R1 = _segp::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoh:
      _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
      I64[Sp - 16] = cekq;   // CmmStore
      R1 = _sefO::P64;   // CmmAssign
      P64[Sp - 8] = _seeZ::P64;   // CmmStore
      Sp = Sp - 16;   // CmmAssign
      if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
  cekr:
      call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  cekq:
      _seeZ::P64 = P64[Sp + 8];   // CmmAssign
      _sefP::P64 = R1;   // CmmAssign
      Hp = Hp + 128;   // CmmAssign
      if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
  ceok:
      HpAlloc = 128;   // CmmAssign
      R1 = _sefP::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
  ceoj:
      _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
      _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
      _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 120] = sat_segn_info;   // CmmStore
      P64[Hp - 104] = _seeZ::P64;   // CmmStore
      P64[Hp - 96] = _sefS::P64;   // CmmStore
      _cekv::P64 = Hp - 120;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 88] = sat_segc_info;   // CmmStore
      P64[Hp - 72] = _seeZ::P64;   // CmmStore
      P64[Hp - 64] = _sefR::P64;   // CmmStore
      _celK::P64 = Hp - 88;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 56] = sat_sefW_info;   // CmmStore
      P64[Hp - 40] = _seeZ::P64;   // CmmStore
      P64[Hp - 32] = _sefQ::P64;   // CmmStore
      _cenM::P64 = Hp - 56;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cenM::P64;   // CmmStore
      P64[Hp - 8] = _celK::P64;   // CmmStore
      P64[Hp] = _cekv::P64;   // CmmStore
      _ceof::P64 = Hp - 23;   // CmmAssign
      R3 = _ceof::P64;   // CmmAssign
      R2 = $dShow_reeF_closure;   // CmmAssign
      R1 = System.IO.print_closure;   // CmmAssign
      Sp = Sp + 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 8, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cekq,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure}),
 (cekr,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure}),
 (ceoe,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure}),
 (ceog, {}),
 (ceoh,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure}),
 (ceoj,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure}),
 (ceok,
  {System.IO.print_closure, $dShow_reeF_closure, sat_sefW_closure,
   sat_segc_closure, sat_segn_closure})]



==================== after setInfoTableStackMap ====================
sat_segp_entry() //  [R2, R1]
        { info_tbl: [(cekq,
                      label: block_cekq_info
                      rep:StackRep [False]),
                     (ceoe,
                      label: sat_segp_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceoe:
          _sefO::P64 = R2;   // CmmAssign
          _segp::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
      ceog:
          R2 = _sefO::P64;   // CmmAssign
          R1 = _segp::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoh:
          _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
          I64[Sp - 16] = cekq;   // CmmStore
          R1 = _sefO::P64;   // CmmAssign
          P64[Sp - 8] = _seeZ::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
      cekr:
          call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      cekq:
          _seeZ::P64 = P64[Sp + 8];   // CmmAssign
          _sefP::P64 = R1;   // CmmAssign
          Hp = Hp + 128;   // CmmAssign
          if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
      ceok:
          HpAlloc = 128;   // CmmAssign
          R1 = _sefP::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      ceoj:
          _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
          _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
          _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 120] = sat_segn_info;   // CmmStore
          P64[Hp - 104] = _seeZ::P64;   // CmmStore
          P64[Hp - 96] = _sefS::P64;   // CmmStore
          _cekv::P64 = Hp - 120;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 88] = sat_segc_info;   // CmmStore
          P64[Hp - 72] = _seeZ::P64;   // CmmStore
          P64[Hp - 64] = _sefR::P64;   // CmmStore
          _celK::P64 = Hp - 88;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 56] = sat_sefW_info;   // CmmStore
          P64[Hp - 40] = _seeZ::P64;   // CmmStore
          P64[Hp - 32] = _sefQ::P64;   // CmmStore
          _cenM::P64 = Hp - 56;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cenM::P64;   // CmmStore
          P64[Hp - 8] = _celK::P64;   // CmmStore
          P64[Hp] = _cekv::P64;   // CmmStore
          _ceof::P64 = Hp - 23;   // CmmAssign
          R3 = _ceof::P64;   // CmmAssign
          R2 = $dShow_reeF_closure;   // CmmAssign
          R1 = System.IO.print_closure;   // CmmAssign
          Sp = Sp + 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segp_entry() //  [R2, R1]
        { info_tbl: [(cekq,
                      label: block_cekq_info
                      rep:StackRep [False]),
                     (ceoe,
                      label: sat_segp_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceoe:
          _sefO::P64 = R2;   // CmmAssign
          _segp::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
      ceog:
          R2 = _sefO::P64;   // CmmAssign
          R1 = _segp::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoh:
          _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
          I64[Sp - 16] = cekq;   // CmmStore
          R1 = _sefO::P64;   // CmmAssign
          P64[Sp - 8] = _seeZ::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
      cekr:
          call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      cekq:
          _seeZ::P64 = P64[Sp + 8];   // CmmAssign
          _sefP::P64 = R1;   // CmmAssign
          Hp = Hp + 128;   // CmmAssign
          if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
      ceok:
          HpAlloc = 128;   // CmmAssign
          R1 = _sefP::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      ceoj:
          _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
          _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
          _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 120] = sat_segn_info;   // CmmStore
          P64[Hp - 104] = _seeZ::P64;   // CmmStore
          P64[Hp - 96] = _sefS::P64;   // CmmStore
          _cekv::P64 = Hp - 120;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 88] = sat_segc_info;   // CmmStore
          P64[Hp - 72] = _seeZ::P64;   // CmmStore
          P64[Hp - 64] = _sefR::P64;   // CmmStore
          _celK::P64 = Hp - 88;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 56] = sat_sefW_info;   // CmmStore
          P64[Hp - 40] = _seeZ::P64;   // CmmStore
          P64[Hp - 32] = _sefQ::P64;   // CmmStore
          _cenM::P64 = Hp - 56;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cenM::P64;   // CmmStore
          P64[Hp - 8] = _celK::P64;   // CmmStore
          P64[Hp] = _cekv::P64;   // CmmStore
          _ceof::P64 = Hp - 23;   // CmmAssign
          R3 = _ceof::P64;   // CmmAssign
          R2 = $dShow_reeF_closure;   // CmmAssign
          R1 = System.IO.print_closure;   // CmmAssign
          Sp = Sp + 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceoG:
      _sefk::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
  ceoH:
      R1 = _sefk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefk::P64;   // CmmStore
      _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
      R2 = _seeY::P64;   // CmmAssign
      R1 = Module.mkModuleName_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceoG:
      _sefk::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
  ceoH:
      R1 = _sefk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoI:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefk::P64;   // CmmStore
      _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
      R2 = _seeY::P64;   // CmmAssign
      R1 = Module.mkModuleName_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceoG:
      _sefk::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
  ceoH:
      R1 = _sefk::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceoI:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefk::P64;   // CmmStore
      _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
      R2 = _seeY::P64;   // CmmAssign
      R1 = Module.mkModuleName_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceoG, {Module.mkModuleName_closure}), (ceoH, {}),
 (ceoI, {Module.mkModuleName_closure})]



==================== after setInfoTableStackMap ====================
mn_sefk_entry() //  [R1]
        { info_tbl: [(ceoG,
                      label: mn_sefk_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceoG:
          _sefk::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
      ceoH:
          R1 = _sefk::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefk::P64;   // CmmStore
          _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
          R2 = _seeY::P64;   // CmmAssign
          R1 = Module.mkModuleName_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
mn_sefk_entry() //  [R1]
        { info_tbl: [(ceoG,
                      label: mn_sefk_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceoG:
          _sefk::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
      ceoH:
          R1 = _sefk::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefk::P64;   // CmmStore
          _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
          R2 = _seeY::P64;   // CmmAssign
          R1 = Module.mkModuleName_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepk:
      _sefB::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
  cepl:
      R1 = _sefB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepm:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefB::P64;   // CmmStore
      _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_p_info;   // CmmStore
      P64[(old + 32)] = _sefy::P64;   // CmmStore
      call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepk:
      _sefB::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
  cepl:
      R1 = _sefB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepm:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefB::P64;   // CmmStore
      _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_p_info;   // CmmStore
      P64[(old + 32)] = _sefy::P64;   // CmmStore
      call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepk:
      _sefB::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
  cepl:
      R1 = _sefB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepm:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefB::P64;   // CmmStore
      _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[Sp - 32] = stg_ap_p_info;   // CmmStore
      P64[Sp - 24] = _sefy::P64;   // CmmStore
      Sp = Sp - 32;   // CmmAssign
      call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cepk, {GHC.$fTypecheckedModDesugaredModule_closure}), (cepl, {}),
 (cepm, {GHC.$fTypecheckedModDesugaredModule_closure})]



==================== after setInfoTableStackMap ====================
sat_sefB_entry() //  [R1]
        { info_tbl: [(cepk,
                      label: sat_sefB_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepk:
          _sefB::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
      cepl:
          R1 = _sefB::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepm:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefB::P64;   // CmmStore
          _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefB_entry() //  [R1]
        { info_tbl: [(cepk,
                      label: sat_sefB_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepk:
          _sefB::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
      cepl:
          R1 = _sefB::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepm:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefB::P64;   // CmmStore
          _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepr:
      _sefA::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceps; else goto cept;   // CmmCondBranch
  ceps:
      R1 = _sefA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cept:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefA::P64;   // CmmStore
      _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_p_info;   // CmmStore
      P64[(old + 32)] = _sefy::P64;   // CmmStore
      call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepr:
      _sefA::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceps; else goto cept;   // CmmCondBranch
  ceps:
      R1 = _sefA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cept:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefA::P64;   // CmmStore
      _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[(old + 40)] = stg_ap_p_info;   // CmmStore
      P64[(old + 32)] = _sefy::P64;   // CmmStore
      call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepr:
      _sefA::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
  ceps:
      R1 = _sefA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cept:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefA::P64;   // CmmStore
      _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      I64[Sp - 32] = stg_ap_p_info;   // CmmStore
      P64[Sp - 24] = _sefy::P64;   // CmmStore
      Sp = Sp - 32;   // CmmAssign
      call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cepr, {GHC.$fTypecheckedModDesugaredModule_closure}), (ceps, {}),
 (cept, {GHC.$fTypecheckedModDesugaredModule_closure})]



==================== after setInfoTableStackMap ====================
sat_sefA_entry() //  [R1]
        { info_tbl: [(cepr,
                      label: sat_sefA_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepr:
          _sefA::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
      ceps:
          R1 = _sefA::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cept:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefA::P64;   // CmmStore
          _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefA_entry() //  [R1]
        { info_tbl: [(cepr,
                      label: sat_sefA_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepr:
          _sefA::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
      ceps:
          R1 = _sefA::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cept:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefA::P64;   // CmmStore
          _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepy:
      _sefz::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
  cepz:
      R1 = _sefz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepA:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefz::P64;   // CmmStore
      _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
      R2 = _sefs::P64;   // CmmAssign
      R1 = GHC.pm_parsed_source_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepy:
      _sefz::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
  cepz:
      R1 = _sefz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepA:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefz::P64;   // CmmStore
      _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
      R2 = _sefs::P64;   // CmmAssign
      R1 = GHC.pm_parsed_source_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepy:
      _sefz::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
  cepz:
      R1 = _sefz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepA:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefz::P64;   // CmmStore
      _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
      R2 = _sefs::P64;   // CmmAssign
      R1 = GHC.pm_parsed_source_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cepy, {GHC.pm_parsed_source_closure}), (cepz, {}),
 (cepA, {GHC.pm_parsed_source_closure})]



==================== after setInfoTableStackMap ====================
sat_sefz_entry() //  [R1]
        { info_tbl: [(cepy,
                      label: sat_sefz_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepy:
          _sefz::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
      cepz:
          R1 = _sefz::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefz::P64;   // CmmStore
          _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
          R2 = _sefs::P64;   // CmmAssign
          R1 = GHC.pm_parsed_source_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefz_entry() //  [R1]
        { info_tbl: [(cepy,
                      label: sat_sefz_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepy:
          _sefz::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
      cepz:
          R1 = _sefz::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefz::P64;   // CmmStore
          _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
          R2 = _sefs::P64;   // CmmAssign
          R1 = GHC.pm_parsed_source_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepC:
      _sefy::P64 = R2;   // CmmAssign
      _sefD::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
  cepE:
      Hp = Hp + 104;   // CmmAssign
      if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
  cepG:
      HpAlloc = 104;   // CmmAssign
      goto cepD;   // CmmBranch
  cepD:
      R2 = _sefy::P64;   // CmmAssign
      R1 = _sefD::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepF:
      _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 96] = sat_sefB_info;   // CmmStore
      P64[Hp - 80] = _sefy::P64;   // CmmStore
      _cepg::P64 = Hp - 96;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 72] = sat_sefA_info;   // CmmStore
      P64[Hp - 56] = _sefy::P64;   // CmmStore
      _cepn::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = sat_sefz_info;   // CmmStore
      P64[Hp - 32] = _sefs::P64;   // CmmStore
      _cepu::P64 = Hp - 48;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cepu::P64;   // CmmStore
      P64[Hp - 8] = _cepn::P64;   // CmmStore
      P64[Hp] = _cepg::P64;   // CmmStore
      _cepB::P64 = Hp - 23;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _cepB::P64;   // CmmStore
      call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepC:
      _sefy::P64 = R2;   // CmmAssign
      _sefD::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
  cepE:
      Hp = Hp + 104;   // CmmAssign
      if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
  cepG:
      HpAlloc = 104;   // CmmAssign
      goto cepD;   // CmmBranch
  cepD:
      R2 = _sefy::P64;   // CmmAssign
      R1 = _sefD::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepF:
      _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 96] = sat_sefB_info;   // CmmStore
      P64[Hp - 80] = _sefy::P64;   // CmmStore
      _cepg::P64 = Hp - 96;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 72] = sat_sefA_info;   // CmmStore
      P64[Hp - 56] = _sefy::P64;   // CmmStore
      _cepn::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = sat_sefz_info;   // CmmStore
      P64[Hp - 32] = _sefs::P64;   // CmmStore
      _cepu::P64 = Hp - 48;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cepu::P64;   // CmmStore
      P64[Hp - 8] = _cepn::P64;   // CmmStore
      P64[Hp] = _cepg::P64;   // CmmStore
      _cepB::P64 = Hp - 23;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _cepB::P64;   // CmmStore
      call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepC:
      _sefy::P64 = R2;   // CmmAssign
      _sefD::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
  cepE:
      Hp = Hp + 104;   // CmmAssign
      if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
  cepG:
      HpAlloc = 104;   // CmmAssign
      goto cepD;   // CmmBranch
  cepD:
      R2 = _sefy::P64;   // CmmAssign
      R1 = _sefD::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepF:
      _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 96] = sat_sefB_info;   // CmmStore
      P64[Hp - 80] = _sefy::P64;   // CmmStore
      _cepg::P64 = Hp - 96;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 72] = sat_sefA_info;   // CmmStore
      P64[Hp - 56] = _sefy::P64;   // CmmStore
      _cepn::P64 = Hp - 72;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 48] = sat_sefz_info;   // CmmStore
      P64[Hp - 32] = _sefs::P64;   // CmmStore
      _cepu::P64 = Hp - 48;   // CmmAssign
      I64[Hp - 24] = (,,)_con_info;   // CmmStore
      P64[Hp - 16] = _cepu::P64;   // CmmStore
      P64[Hp - 8] = _cepn::P64;   // CmmStore
      P64[Hp] = _cepg::P64;   // CmmStore
      _cepB::P64 = Hp - 23;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 16] = stg_ap_p_info;   // CmmStore
      P64[Sp - 8] = _cepB::P64;   // CmmStore
      Sp = Sp - 16;   // CmmAssign
      call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cepC,
  {GhcMonad.$fMonadGhc_closure, sat_sefz_closure, sat_sefA_closure,
   sat_sefB_closure}),
 (cepD, {}),
 (cepE,
  {GhcMonad.$fMonadGhc_closure, sat_sefz_closure, sat_sefA_closure,
   sat_sefB_closure}),
 (cepF,
  {GhcMonad.$fMonadGhc_closure, sat_sefz_closure, sat_sefA_closure,
   sat_sefB_closure}),
 (cepG, {})]



==================== after setInfoTableStackMap ====================
sat_sefD_entry() //  [R2, R1]
        { info_tbl: [(cepC,
                      label: sat_sefD_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepC:
          _sefy::P64 = R2;   // CmmAssign
          _sefD::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
      cepE:
          Hp = Hp + 104;   // CmmAssign
          if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
      cepG:
          HpAlloc = 104;   // CmmAssign
          goto cepD;   // CmmBranch
      cepD:
          R2 = _sefy::P64;   // CmmAssign
          R1 = _sefD::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepF:
          _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 96] = sat_sefB_info;   // CmmStore
          P64[Hp - 80] = _sefy::P64;   // CmmStore
          _cepg::P64 = Hp - 96;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 72] = sat_sefA_info;   // CmmStore
          P64[Hp - 56] = _sefy::P64;   // CmmStore
          _cepn::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = sat_sefz_info;   // CmmStore
          P64[Hp - 32] = _sefs::P64;   // CmmStore
          _cepu::P64 = Hp - 48;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cepu::P64;   // CmmStore
          P64[Hp - 8] = _cepn::P64;   // CmmStore
          P64[Hp] = _cepg::P64;   // CmmStore
          _cepB::P64 = Hp - 23;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cepB::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefD_entry() //  [R2, R1]
        { info_tbl: [(cepC,
                      label: sat_sefD_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepC:
          _sefy::P64 = R2;   // CmmAssign
          _sefD::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
      cepE:
          Hp = Hp + 104;   // CmmAssign
          if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
      cepG:
          HpAlloc = 104;   // CmmAssign
          goto cepD;   // CmmBranch
      cepD:
          R2 = _sefy::P64;   // CmmAssign
          R1 = _sefD::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepF:
          _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 96] = sat_sefB_info;   // CmmStore
          P64[Hp - 80] = _sefy::P64;   // CmmStore
          _cepg::P64 = Hp - 96;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 72] = sat_sefA_info;   // CmmStore
          P64[Hp - 56] = _sefy::P64;   // CmmStore
          _cepn::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = sat_sefz_info;   // CmmStore
          P64[Hp - 32] = _sefs::P64;   // CmmStore
          _cepu::P64 = Hp - 48;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cepu::P64;   // CmmStore
          P64[Hp - 8] = _cepn::P64;   // CmmStore
          P64[Hp] = _cepg::P64;   // CmmStore
          _cepB::P64 = Hp - 23;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cepB::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepL:
      _sefx::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
  cepM:
      R1 = _sefx::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepN:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefx::P64;   // CmmStore
      _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
      R4 = _sefw::P64;   // CmmAssign
      R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      R1 = GHC.loadModule_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepL:
      _sefx::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
  cepM:
      R1 = _sefx::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepN:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefx::P64;   // CmmStore
      _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
      R4 = _sefw::P64;   // CmmAssign
      R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      R1 = GHC.loadModule_closure;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepL:
      _sefx::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
  cepM:
      R1 = _sefx::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepN:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefx::P64;   // CmmStore
      _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
      R4 = _sefw::P64;   // CmmAssign
      R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
      R1 = GHC.loadModule_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_ppp_fast(R4,
                           R3,
                           R2,
                           R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cepL,
  {GHC.$fTypecheckedModDesugaredModule_closure,
   GHC.loadModule_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (cepM, {}),
 (cepN,
  {GHC.$fTypecheckedModDesugaredModule_closure,
   GHC.loadModule_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefx_entry() //  [R1]
        { info_tbl: [(cepL,
                      label: sat_sefx_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepL:
          _sefx::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
      cepM:
          R1 = _sefx::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepN:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefx::P64;   // CmmStore
          _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
          R4 = _sefw::P64;   // CmmAssign
          R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          R1 = GHC.loadModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefx_entry() //  [R1]
        { info_tbl: [(cepL,
                      label: sat_sefx_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepL:
          _sefx::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
      cepM:
          R1 = _sefx::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepN:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefx::P64;   // CmmStore
          _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
          R4 = _sefw::P64;   // CmmAssign
          R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          R1 = GHC.loadModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepO:
      _sefw::P64 = R2;   // CmmAssign
      _sefE::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
  cepQ:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
  cepS:
      HpAlloc = 40;   // CmmAssign
      goto cepP;   // CmmBranch
  cepP:
      R2 = _sefw::P64;   // CmmAssign
      R1 = _sefE::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepR:
      _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefD_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cepb::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefx_info;   // CmmStore
      P64[Hp] = _sefw::P64;   // CmmStore
      _cepH::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cepH::P64;   // CmmStore
      P64[(old + 16)] = _cepb::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepO:
      _sefw::P64 = R2;   // CmmAssign
      _sefE::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
  cepQ:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
  cepS:
      HpAlloc = 40;   // CmmAssign
      goto cepP;   // CmmBranch
  cepP:
      R2 = _sefw::P64;   // CmmAssign
      R1 = _sefE::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepR:
      _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefD_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cepb::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefx_info;   // CmmStore
      P64[Hp] = _sefw::P64;   // CmmStore
      _cepH::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cepH::P64;   // CmmStore
      P64[(old + 16)] = _cepb::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepO:
      _sefw::P64 = R2;   // CmmAssign
      _sefE::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
  cepQ:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
  cepS:
      HpAlloc = 40;   // CmmAssign
      goto cepP;   // CmmBranch
  cepP:
      R2 = _sefw::P64;   // CmmAssign
      R1 = _sefE::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepR:
      _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefD_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cepb::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefx_info;   // CmmStore
      P64[Hp] = _sefw::P64;   // CmmStore
      _cepH::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _cepH::P64;   // CmmStore
      P64[Sp - 8] = _cepb::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cepO,
  {GhcMonad.$fMonadGhc_closure, sat_sefx_closure, sat_sefD_closure}),
 (cepP, {}),
 (cepQ,
  {GhcMonad.$fMonadGhc_closure, sat_sefx_closure, sat_sefD_closure}),
 (cepR,
  {GhcMonad.$fMonadGhc_closure, sat_sefx_closure, sat_sefD_closure}),
 (cepS, {})]



==================== after setInfoTableStackMap ====================
sat_sefE_entry() //  [R2, R1]
        { info_tbl: [(cepO,
                      label: sat_sefE_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepO:
          _sefw::P64 = R2;   // CmmAssign
          _sefE::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
      cepQ:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
      cepS:
          HpAlloc = 40;   // CmmAssign
          goto cepP;   // CmmBranch
      cepP:
          R2 = _sefw::P64;   // CmmAssign
          R1 = _sefE::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepR:
          _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefD_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cepb::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefx_info;   // CmmStore
          P64[Hp] = _sefw::P64;   // CmmStore
          _cepH::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepH::P64;   // CmmStore
          P64[Sp - 8] = _cepb::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefE_entry() //  [R2, R1]
        { info_tbl: [(cepO,
                      label: sat_sefE_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepO:
          _sefw::P64 = R2;   // CmmAssign
          _sefE::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
      cepQ:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
      cepS:
          HpAlloc = 40;   // CmmAssign
          goto cepP;   // CmmBranch
      cepP:
          R2 = _sefw::P64;   // CmmAssign
          R1 = _sefE::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepR:
          _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefD_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cepb::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefx_info;   // CmmStore
          P64[Hp] = _sefw::P64;   // CmmStore
          _cepH::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepH::P64;   // CmmStore
          P64[Sp - 8] = _cepb::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cepX:
      _sefv::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
  cepY:
      R1 = _sefv::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepZ:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefv::P64;   // CmmStore
      _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
      R3 = _sefu::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.desugarModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cepX:
      _sefv::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
  cepY:
      R1 = _sefv::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepZ:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefv::P64;   // CmmStore
      _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
      R3 = _sefu::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.desugarModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cepX:
      _sefv::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
  cepY:
      R1 = _sefv::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cepZ:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefv::P64;   // CmmStore
      _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
      R3 = _sefu::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.desugarModule_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cepX,
  {GHC.desugarModule_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (cepY, {}),
 (cepZ,
  {GHC.desugarModule_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefv_entry() //  [R1]
        { info_tbl: [(cepX,
                      label: sat_sefv_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepX:
          _sefv::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
      cepY:
          R1 = _sefv::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepZ:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefv::P64;   // CmmStore
          _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
          R3 = _sefu::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.desugarModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefv_entry() //  [R1]
        { info_tbl: [(cepX,
                      label: sat_sefv_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cepX:
          _sefv::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
      cepY:
          R1 = _sefv::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepZ:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefv::P64;   // CmmStore
          _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
          R3 = _sefu::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.desugarModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceq0:
      _sefu::P64 = R2;   // CmmAssign
      _sefF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
  ceq2:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
  ceq4:
      HpAlloc = 40;   // CmmAssign
      goto ceq1;   // CmmBranch
  ceq1:
      R2 = _sefu::P64;   // CmmAssign
      R1 = _sefF::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceq3:
      _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefE_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep6::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefv_info;   // CmmStore
      P64[Hp] = _sefu::P64;   // CmmStore
      _cepT::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cepT::P64;   // CmmStore
      P64[(old + 16)] = _cep6::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceq0:
      _sefu::P64 = R2;   // CmmAssign
      _sefF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
  ceq2:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
  ceq4:
      HpAlloc = 40;   // CmmAssign
      goto ceq1;   // CmmBranch
  ceq1:
      R2 = _sefu::P64;   // CmmAssign
      R1 = _sefF::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceq3:
      _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefE_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep6::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefv_info;   // CmmStore
      P64[Hp] = _sefu::P64;   // CmmStore
      _cepT::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cepT::P64;   // CmmStore
      P64[(old + 16)] = _cep6::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceq0:
      _sefu::P64 = R2;   // CmmAssign
      _sefF::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
  ceq2:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
  ceq4:
      HpAlloc = 40;   // CmmAssign
      goto ceq1;   // CmmBranch
  ceq1:
      R2 = _sefu::P64;   // CmmAssign
      R1 = _sefF::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceq3:
      _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefE_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep6::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefv_info;   // CmmStore
      P64[Hp] = _sefu::P64;   // CmmStore
      _cepT::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _cepT::P64;   // CmmStore
      P64[Sp - 8] = _cep6::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceq0,
  {GhcMonad.$fMonadGhc_closure, sat_sefv_closure, sat_sefE_closure}),
 (ceq1, {}),
 (ceq2,
  {GhcMonad.$fMonadGhc_closure, sat_sefv_closure, sat_sefE_closure}),
 (ceq3,
  {GhcMonad.$fMonadGhc_closure, sat_sefv_closure, sat_sefE_closure}),
 (ceq4, {})]



==================== after setInfoTableStackMap ====================
sat_sefF_entry() //  [R2, R1]
        { info_tbl: [(ceq0,
                      label: sat_sefF_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceq0:
          _sefu::P64 = R2;   // CmmAssign
          _sefF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
      ceq2:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
      ceq4:
          HpAlloc = 40;   // CmmAssign
          goto ceq1;   // CmmBranch
      ceq1:
          R2 = _sefu::P64;   // CmmAssign
          R1 = _sefF::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceq3:
          _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefE_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep6::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefv_info;   // CmmStore
          P64[Hp] = _sefu::P64;   // CmmStore
          _cepT::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepT::P64;   // CmmStore
          P64[Sp - 8] = _cep6::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefF_entry() //  [R2, R1]
        { info_tbl: [(ceq0,
                      label: sat_sefF_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceq0:
          _sefu::P64 = R2;   // CmmAssign
          _sefF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
      ceq2:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
      ceq4:
          HpAlloc = 40;   // CmmAssign
          goto ceq1;   // CmmBranch
      ceq1:
          R2 = _sefu::P64;   // CmmAssign
          R1 = _sefF::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceq3:
          _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefE_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep6::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefv_info;   // CmmStore
          P64[Hp] = _sefu::P64;   // CmmStore
          _cepT::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepT::P64;   // CmmStore
          P64[Sp - 8] = _cep6::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceq9:
      _seft::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
  ceqa:
      R1 = _seft::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqb:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seft::P64;   // CmmStore
      _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
      R3 = _sefs::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.typecheckModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceq9:
      _seft::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
  ceqa:
      R1 = _seft::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqb:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _seft::P64;   // CmmStore
      _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
      R3 = _sefs::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.typecheckModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceq9:
      _seft::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
  ceqa:
      R1 = _seft::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqb:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _seft::P64;   // CmmStore
      _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
      R3 = _sefs::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.typecheckModule_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceq9,
  {GHC.typecheckModule_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (ceqa, {}),
 (ceqb,
  {GHC.typecheckModule_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_seft_entry() //  [R1]
        { info_tbl: [(ceq9,
                      label: sat_seft_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceq9:
          _seft::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
      ceqa:
          R1 = _seft::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seft::P64;   // CmmStore
          _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
          R3 = _sefs::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.typecheckModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_seft_entry() //  [R1]
        { info_tbl: [(ceq9,
                      label: sat_seft_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceq9:
          _seft::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
      ceqa:
          R1 = _seft::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seft::P64;   // CmmStore
          _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
          R3 = _sefs::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.typecheckModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqc:
      _sefs::P64 = R2;   // CmmAssign
      _sefG::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
  ceqe:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
  ceqg:
      HpAlloc = 40;   // CmmAssign
      goto ceqd;   // CmmBranch
  ceqd:
      R2 = _sefs::P64;   // CmmAssign
      R1 = _sefG::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqf:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefF_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep1::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seft_info;   // CmmStore
      P64[Hp] = _sefs::P64;   // CmmStore
      _ceq5::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceq5::P64;   // CmmStore
      P64[(old + 16)] = _cep1::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqc:
      _sefs::P64 = R2;   // CmmAssign
      _sefG::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
  ceqe:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
  ceqg:
      HpAlloc = 40;   // CmmAssign
      goto ceqd;   // CmmBranch
  ceqd:
      R2 = _sefs::P64;   // CmmAssign
      R1 = _sefG::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqf:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefF_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep1::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seft_info;   // CmmStore
      P64[Hp] = _sefs::P64;   // CmmStore
      _ceq5::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceq5::P64;   // CmmStore
      P64[(old + 16)] = _cep1::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqc:
      _sefs::P64 = R2;   // CmmAssign
      _sefG::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
  ceqe:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
  ceqg:
      HpAlloc = 40;   // CmmAssign
      goto ceqd;   // CmmBranch
  ceqd:
      R2 = _sefs::P64;   // CmmAssign
      R1 = _sefG::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqf:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefF_info;   // CmmStore
      P64[Hp - 24] = _sefs::P64;   // CmmStore
      _cep1::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_seft_info;   // CmmStore
      P64[Hp] = _sefs::P64;   // CmmStore
      _ceq5::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _ceq5::P64;   // CmmStore
      P64[Sp - 8] = _cep1::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceqc,
  {GhcMonad.$fMonadGhc_closure, sat_seft_closure, sat_sefF_closure}),
 (ceqd, {}),
 (ceqe,
  {GhcMonad.$fMonadGhc_closure, sat_seft_closure, sat_sefF_closure}),
 (ceqf,
  {GhcMonad.$fMonadGhc_closure, sat_seft_closure, sat_sefF_closure}),
 (ceqg, {})]



==================== after setInfoTableStackMap ====================
sat_sefG_entry() //  [R2, R1]
        { info_tbl: [(ceqc,
                      label: sat_sefG_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqc:
          _sefs::P64 = R2;   // CmmAssign
          _sefG::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
      ceqe:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
      ceqg:
          HpAlloc = 40;   // CmmAssign
          goto ceqd;   // CmmBranch
      ceqd:
          R2 = _sefs::P64;   // CmmAssign
          R1 = _sefG::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqf:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefF_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep1::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seft_info;   // CmmStore
          P64[Hp] = _sefs::P64;   // CmmStore
          _ceq5::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceq5::P64;   // CmmStore
          P64[Sp - 8] = _cep1::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefG_entry() //  [R2, R1]
        { info_tbl: [(ceqc,
                      label: sat_sefG_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqc:
          _sefs::P64 = R2;   // CmmAssign
          _sefG::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
      ceqe:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
      ceqg:
          HpAlloc = 40;   // CmmAssign
          goto ceqd;   // CmmBranch
      ceqd:
          R2 = _sefs::P64;   // CmmAssign
          R1 = _sefG::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqf:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefF_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep1::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seft_info;   // CmmStore
          P64[Hp] = _sefs::P64;   // CmmStore
          _ceq5::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceq5::P64;   // CmmStore
          P64[Sp - 8] = _cep1::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceql:
      _sefr::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
  ceqm:
      R1 = _sefr::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqn:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefr::P64;   // CmmStore
      _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
      R3 = _sefq::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.parseModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceql:
      _sefr::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
  ceqm:
      R1 = _sefr::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqn:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefr::P64;   // CmmStore
      _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
      R3 = _sefq::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.parseModule_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceql:
      _sefr::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
  ceqm:
      R1 = _sefr::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqn:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefr::P64;   // CmmStore
      _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
      R3 = _sefq::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.parseModule_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceql, {GHC.parseModule_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (ceqm, {}),
 (ceqn, {GHC.parseModule_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefr_entry() //  [R1]
        { info_tbl: [(ceql,
                      label: sat_sefr_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceql:
          _sefr::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
      ceqm:
          R1 = _sefr::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefr::P64;   // CmmStore
          _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
          R3 = _sefq::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.parseModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefr_entry() //  [R1]
        { info_tbl: [(ceql,
                      label: sat_sefr_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceql:
          _sefr::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
      ceqm:
          R1 = _sefr::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefr::P64;   // CmmStore
          _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
          R3 = _sefq::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.parseModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqo:
      _sefq::P64 = R2;   // CmmAssign
      _sefH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
  ceqq:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
  ceqs:
      HpAlloc = 40;   // CmmAssign
      goto ceqp;   // CmmBranch
  ceqp:
      R2 = _sefq::P64;   // CmmAssign
      R1 = _sefH::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqr:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefG_info;   // CmmStore
      _ceoW::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefr_info;   // CmmStore
      P64[Hp] = _sefq::P64;   // CmmStore
      _ceqh::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceqh::P64;   // CmmStore
      P64[(old + 16)] = _ceoW::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqo:
      _sefq::P64 = R2;   // CmmAssign
      _sefH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
  ceqq:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
  ceqs:
      HpAlloc = 40;   // CmmAssign
      goto ceqp;   // CmmBranch
  ceqp:
      R2 = _sefq::P64;   // CmmAssign
      R1 = _sefH::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqr:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefG_info;   // CmmStore
      _ceoW::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefr_info;   // CmmStore
      P64[Hp] = _sefq::P64;   // CmmStore
      _ceqh::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceqh::P64;   // CmmStore
      P64[(old + 16)] = _ceoW::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqo:
      _sefq::P64 = R2;   // CmmAssign
      _sefH::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
  ceqq:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
  ceqs:
      HpAlloc = 40;   // CmmAssign
      goto ceqp;   // CmmBranch
  ceqp:
      R2 = _sefq::P64;   // CmmAssign
      R1 = _sefH::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqr:
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefG_info;   // CmmStore
      _ceoW::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefr_info;   // CmmStore
      P64[Hp] = _sefq::P64;   // CmmStore
      _ceqh::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _ceqh::P64;   // CmmStore
      P64[Sp - 8] = _ceoW::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceqo,
  {GhcMonad.$fMonadGhc_closure, sat_sefr_closure, sat_sefG_closure}),
 (ceqp, {}),
 (ceqq,
  {GhcMonad.$fMonadGhc_closure, sat_sefr_closure, sat_sefG_closure}),
 (ceqr,
  {GhcMonad.$fMonadGhc_closure, sat_sefr_closure, sat_sefG_closure}),
 (ceqs, {})]



==================== after setInfoTableStackMap ====================
sat_sefH_entry() //  [R2, R1]
        { info_tbl: [(ceqo,
                      label: sat_sefH_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqo:
          _sefq::P64 = R2;   // CmmAssign
          _sefH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
      ceqq:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
      ceqs:
          HpAlloc = 40;   // CmmAssign
          goto ceqp;   // CmmBranch
      ceqp:
          R2 = _sefq::P64;   // CmmAssign
          R1 = _sefH::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqr:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefG_info;   // CmmStore
          _ceoW::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefr_info;   // CmmStore
          P64[Hp] = _sefq::P64;   // CmmStore
          _ceqh::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceqh::P64;   // CmmStore
          P64[Sp - 8] = _ceoW::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefH_entry() //  [R2, R1]
        { info_tbl: [(ceqo,
                      label: sat_sefH_info
                      rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqo:
          _sefq::P64 = R2;   // CmmAssign
          _sefH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
      ceqq:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
      ceqs:
          HpAlloc = 40;   // CmmAssign
          goto ceqp;   // CmmBranch
      ceqp:
          R2 = _sefq::P64;   // CmmAssign
          R1 = _sefH::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqr:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefG_info;   // CmmStore
          _ceoW::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefr_info;   // CmmStore
          P64[Hp] = _sefq::P64;   // CmmStore
          _ceqh::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceqh::P64;   // CmmStore
          P64[Sp - 8] = _ceoW::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqx:
      _sefp::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
  ceqy:
      R1 = _sefp::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqz:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefp::P64;   // CmmStore
      _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
      R3 = _sefk::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.getModSummary_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqx:
      _sefp::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
  ceqy:
      R1 = _sefp::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqz:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefp::P64;   // CmmStore
      _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
      R3 = _sefk::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.getModSummary_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqx:
      _sefp::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
  ceqy:
      R1 = _sefp::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqz:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefp::P64;   // CmmStore
      _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
      R3 = _sefk::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.getModSummary_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceqx,
  {GHC.getModSummary_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (ceqy, {}),
 (ceqz,
  {GHC.getModSummary_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefp_entry() //  [R1]
        { info_tbl: [(ceqx,
                      label: sat_sefp_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqx:
          _sefp::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
      ceqy:
          R1 = _sefp::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefp::P64;   // CmmStore
          _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
          R3 = _sefk::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.getModSummary_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefp_entry() //  [R1]
        { info_tbl: [(ceqx,
                      label: sat_sefp_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqx:
          _sefp::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
      ceqy:
          R1 = _sefp::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefp::P64;   // CmmStore
          _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
          R3 = _sefk::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.getModSummary_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqA:
      _sefI::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
  ceqC:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
  ceqE:
      HpAlloc = 40;   // CmmAssign
      goto ceqB;   // CmmBranch
  ceqB:
      R1 = _sefI::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefI::P64;   // CmmStore
      _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefH_info;   // CmmStore
      _ceoR::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefp_info;   // CmmStore
      P64[Hp] = _sefk::P64;   // CmmStore
      _ceqt::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqt::P64;   // CmmStore
      P64[(old + 32)] = _ceoR::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqA:
      _sefI::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
  ceqC:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
  ceqE:
      HpAlloc = 40;   // CmmAssign
      goto ceqB;   // CmmBranch
  ceqB:
      R1 = _sefI::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqD:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefI::P64;   // CmmStore
      _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefH_info;   // CmmStore
      _ceoR::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefp_info;   // CmmStore
      P64[Hp] = _sefk::P64;   // CmmStore
      _ceqt::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqt::P64;   // CmmStore
      P64[(old + 32)] = _ceoR::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqA:
      _sefI::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
  ceqC:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
  ceqE:
      HpAlloc = 40;   // CmmAssign
      goto ceqB;   // CmmBranch
  ceqB:
      R1 = _sefI::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqD:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefI::P64;   // CmmStore
      _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefH_info;   // CmmStore
      _ceoR::P64 = Hp - 31;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefp_info;   // CmmStore
      P64[Hp] = _sefk::P64;   // CmmStore
      _ceqt::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _ceqt::P64;   // CmmStore
      P64[Sp - 24] = _ceoR::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceqA,
  {GhcMonad.$fMonadGhc_closure, sat_sefp_closure, sat_sefH_closure}),
 (ceqB, {}),
 (ceqC,
  {GhcMonad.$fMonadGhc_closure, sat_sefp_closure, sat_sefH_closure}),
 (ceqD,
  {GhcMonad.$fMonadGhc_closure, sat_sefp_closure, sat_sefH_closure}),
 (ceqE, {})]



==================== after setInfoTableStackMap ====================
sat_sefI_entry() //  [R1]
        { info_tbl: [(ceqA,
                      label: sat_sefI_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqA:
          _sefI::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
      ceqC:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
      ceqE:
          HpAlloc = 40;   // CmmAssign
          goto ceqB;   // CmmBranch
      ceqB:
          R1 = _sefI::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefI::P64;   // CmmStore
          _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefH_info;   // CmmStore
          _ceoR::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefp_info;   // CmmStore
          P64[Hp] = _sefk::P64;   // CmmStore
          _ceqt::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqt::P64;   // CmmStore
          P64[Sp - 24] = _ceoR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefI_entry() //  [R1]
        { info_tbl: [(ceqA,
                      label: sat_sefI_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqA:
          _sefI::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
      ceqC:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
      ceqE:
          HpAlloc = 40;   // CmmAssign
          goto ceqB;   // CmmBranch
      ceqB:
          R1 = _sefI::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefI::P64;   // CmmStore
          _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefH_info;   // CmmStore
          _ceoR::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefp_info;   // CmmStore
          P64[Hp] = _sefk::P64;   // CmmStore
          _ceqt::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqt::P64;   // CmmStore
          P64[Sp - 24] = _ceoR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqJ:
      _sefo::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
  ceqK:
      R1 = _sefo::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqL:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefo::P64;   // CmmStore
      R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMake.load_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqJ:
      _sefo::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
  ceqK:
      R1 = _sefo::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqL:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefo::P64;   // CmmStore
      R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMake.load_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqJ:
      _sefo::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
  ceqK:
      R1 = _sefo::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqL:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefo::P64;   // CmmStore
      R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMake.load_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceqJ, {GhcMake.load_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (ceqK, {}),
 (ceqL, {GhcMake.load_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefo_entry() //  [R1]
        { info_tbl: [(ceqJ,
                      label: sat_sefo_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqJ:
          _sefo::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
      ceqK:
          R1 = _sefo::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqL:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefo::P64;   // CmmStore
          R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMake.load_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefo_entry() //  [R1]
        { info_tbl: [(ceqJ,
                      label: sat_sefo_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqJ:
          _sefo::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
      ceqK:
          R1 = _sefo::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqL:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefo::P64;   // CmmStore
          R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMake.load_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqM:
      _sefJ::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
  ceqO:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
  ceqQ:
      HpAlloc = 40;   // CmmAssign
      goto ceqN;   // CmmBranch
  ceqN:
      R1 = _sefJ::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqP:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefJ::P64;   // CmmStore
      _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefI_info;   // CmmStore
      P64[Hp - 16] = _sefk::P64;   // CmmStore
      _ceoN::P64 = Hp - 32;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefo_info;   // CmmStore
      _ceqF::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqF::P64;   // CmmStore
      P64[(old + 32)] = _ceoN::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqM:
      _sefJ::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
  ceqO:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
  ceqQ:
      HpAlloc = 40;   // CmmAssign
      goto ceqN;   // CmmBranch
  ceqN:
      R1 = _sefJ::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqP:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefJ::P64;   // CmmStore
      _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefI_info;   // CmmStore
      P64[Hp - 16] = _sefk::P64;   // CmmStore
      _ceoN::P64 = Hp - 32;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefo_info;   // CmmStore
      _ceqF::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqF::P64;   // CmmStore
      P64[(old + 32)] = _ceoN::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqM:
      _sefJ::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
  ceqO:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
  ceqQ:
      HpAlloc = 40;   // CmmAssign
      goto ceqN;   // CmmBranch
  ceqN:
      R1 = _sefJ::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  ceqP:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefJ::P64;   // CmmStore
      _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefI_info;   // CmmStore
      P64[Hp - 16] = _sefk::P64;   // CmmStore
      _ceoN::P64 = Hp - 32;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefo_info;   // CmmStore
      _ceqF::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _ceqF::P64;   // CmmStore
      P64[Sp - 24] = _ceoN::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceqM,
  {GhcMonad.$fMonadGhc_closure, sat_sefo_closure, sat_sefI_closure}),
 (ceqN, {}),
 (ceqO,
  {GhcMonad.$fMonadGhc_closure, sat_sefo_closure, sat_sefI_closure}),
 (ceqP,
  {GhcMonad.$fMonadGhc_closure, sat_sefo_closure, sat_sefI_closure}),
 (ceqQ, {})]



==================== after setInfoTableStackMap ====================
sat_sefJ_entry() //  [R1]
        { info_tbl: [(ceqM,
                      label: sat_sefJ_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqM:
          _sefJ::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
      ceqO:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
      ceqQ:
          HpAlloc = 40;   // CmmAssign
          goto ceqN;   // CmmBranch
      ceqN:
          R1 = _sefJ::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefJ::P64;   // CmmStore
          _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefI_info;   // CmmStore
          P64[Hp - 16] = _sefk::P64;   // CmmStore
          _ceoN::P64 = Hp - 32;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefo_info;   // CmmStore
          _ceqF::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqF::P64;   // CmmStore
          P64[Sp - 24] = _ceoN::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefJ_entry() //  [R1]
        { info_tbl: [(ceqM,
                      label: sat_sefJ_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqM:
          _sefJ::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
      ceqO:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
      ceqQ:
          HpAlloc = 40;   // CmmAssign
          goto ceqN;   // CmmBranch
      ceqN:
          R1 = _sefJ::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefJ::P64;   // CmmStore
          _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefI_info;   // CmmStore
          P64[Hp - 16] = _sefk::P64;   // CmmStore
          _ceoN::P64 = Hp - 32;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefo_info;   // CmmStore
          _ceqF::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqF::P64;   // CmmStore
          P64[Sp - 24] = _ceoN::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  ceqX:
      _sefn::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
  ceqZ:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
  cer1:
      HpAlloc = 48;   // CmmAssign
      goto ceqY;   // CmmBranch
  ceqY:
      R1 = _sefn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer0:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefn::P64;   // CmmStore
      _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
      I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
      P64[Hp - 32] = _sefk::P64;   // CmmStore
      _ceqV::P64 = Hp - 39;   // CmmAssign
      I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
      P64[Hp - 16] = _ceqV::P64;   // CmmStore
      P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
      P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
      _ceqW::P64 = Hp - 23;   // CmmAssign
      R3 = _ceqW::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.addTarget_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  ceqX:
      _sefn::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
  ceqZ:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
  cer1:
      HpAlloc = 48;   // CmmAssign
      goto ceqY;   // CmmBranch
  ceqY:
      R1 = _sefn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer0:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefn::P64;   // CmmStore
      _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
      I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
      P64[Hp - 32] = _sefk::P64;   // CmmStore
      _ceqV::P64 = Hp - 39;   // CmmAssign
      I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
      P64[Hp - 16] = _ceqV::P64;   // CmmStore
      P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
      P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
      _ceqW::P64 = Hp - 23;   // CmmAssign
      R3 = _ceqW::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.addTarget_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  ceqX:
      _sefn::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
  ceqZ:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
  cer1:
      HpAlloc = 48;   // CmmAssign
      goto ceqY;   // CmmBranch
  ceqY:
      R1 = _sefn::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer0:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefn::P64;   // CmmStore
      _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
      I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
      P64[Hp - 32] = _sefk::P64;   // CmmStore
      _ceqV::P64 = Hp - 39;   // CmmAssign
      I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
      P64[Hp - 16] = _ceqV::P64;   // CmmStore
      P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
      P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
      _ceqW::P64 = Hp - 23;   // CmmAssign
      R3 = _ceqW::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.addTarget_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(ceqX, {GHC.addTarget_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (ceqY, {}),
 (ceqZ, {GHC.addTarget_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (cer0, {GHC.addTarget_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (cer1, {})]



==================== after setInfoTableStackMap ====================
sat_sefn_entry() //  [R1]
        { info_tbl: [(ceqX,
                      label: sat_sefn_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqX:
          _sefn::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
      ceqZ:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
      cer1:
          HpAlloc = 48;   // CmmAssign
          goto ceqY;   // CmmBranch
      ceqY:
          R1 = _sefn::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefn::P64;   // CmmStore
          _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
          I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
          P64[Hp - 32] = _sefk::P64;   // CmmStore
          _ceqV::P64 = Hp - 39;   // CmmAssign
          I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
          P64[Hp - 16] = _ceqV::P64;   // CmmStore
          P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
          P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
          _ceqW::P64 = Hp - 23;   // CmmAssign
          R3 = _ceqW::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.addTarget_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefn_entry() //  [R1]
        { info_tbl: [(ceqX,
                      label: sat_sefn_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      ceqX:
          _sefn::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
      ceqZ:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
      cer1:
          HpAlloc = 48;   // CmmAssign
          goto ceqY;   // CmmBranch
      ceqY:
          R1 = _sefn::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefn::P64;   // CmmStore
          _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
          I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
          P64[Hp - 32] = _sefk::P64;   // CmmStore
          _ceqV::P64 = Hp - 39;   // CmmAssign
          I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
          P64[Hp - 16] = _ceqV::P64;   // CmmStore
          P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
          P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
          _ceqW::P64 = Hp - 23;   // CmmAssign
          R3 = _ceqW::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.addTarget_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cer2:
      _sefK::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
  cer4:
      Hp = Hp + 72;   // CmmAssign
      if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
  cer6:
      HpAlloc = 72;   // CmmAssign
      goto cer3;   // CmmBranch
  cer3:
      R1 = _sefK::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer5:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefK::P64;   // CmmStore
      _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 64] = mn_sefk_info;   // CmmStore
      P64[Hp - 48] = _seeY::P64;   // CmmStore
      _ceoC::P64 = Hp - 64;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefJ_info;   // CmmStore
      P64[Hp - 24] = _ceoC::P64;   // CmmStore
      _ceoJ::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefn_info;   // CmmStore
      P64[Hp] = _ceoC::P64;   // CmmStore
      _ceqR::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqR::P64;   // CmmStore
      P64[(old + 32)] = _ceoJ::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cer2:
      _sefK::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
  cer4:
      Hp = Hp + 72;   // CmmAssign
      if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
  cer6:
      HpAlloc = 72;   // CmmAssign
      goto cer3;   // CmmBranch
  cer3:
      R1 = _sefK::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer5:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefK::P64;   // CmmStore
      _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 64] = mn_sefk_info;   // CmmStore
      P64[Hp - 48] = _seeY::P64;   // CmmStore
      _ceoC::P64 = Hp - 64;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefJ_info;   // CmmStore
      P64[Hp - 24] = _ceoC::P64;   // CmmStore
      _ceoJ::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefn_info;   // CmmStore
      P64[Hp] = _ceoC::P64;   // CmmStore
      _ceqR::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _ceqR::P64;   // CmmStore
      P64[(old + 32)] = _ceoJ::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cer2:
      _sefK::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
  cer4:
      Hp = Hp + 72;   // CmmAssign
      if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
  cer6:
      HpAlloc = 72;   // CmmAssign
      goto cer3;   // CmmBranch
  cer3:
      R1 = _sefK::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cer5:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefK::P64;   // CmmStore
      _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 64] = mn_sefk_info;   // CmmStore
      P64[Hp - 48] = _seeY::P64;   // CmmStore
      _ceoC::P64 = Hp - 64;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefJ_info;   // CmmStore
      P64[Hp - 24] = _ceoC::P64;   // CmmStore
      _ceoJ::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefn_info;   // CmmStore
      P64[Hp] = _ceoC::P64;   // CmmStore
      _ceqR::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _ceqR::P64;   // CmmStore
      P64[Sp - 24] = _ceoJ::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cer2,
  {GhcMonad.$fMonadGhc_closure, mn_sefk_closure, sat_sefn_closure,
   sat_sefJ_closure}),
 (cer3, {}),
 (cer4,
  {GhcMonad.$fMonadGhc_closure, mn_sefk_closure, sat_sefn_closure,
   sat_sefJ_closure}),
 (cer5,
  {GhcMonad.$fMonadGhc_closure, mn_sefk_closure, sat_sefn_closure,
   sat_sefJ_closure}),
 (cer6, {})]



==================== after setInfoTableStackMap ====================
sat_sefK_entry() //  [R1]
        { info_tbl: [(cer2,
                      label: sat_sefK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cer2:
          _sefK::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
      cer4:
          Hp = Hp + 72;   // CmmAssign
          if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
      cer6:
          HpAlloc = 72;   // CmmAssign
          goto cer3;   // CmmBranch
      cer3:
          R1 = _sefK::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer5:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefK::P64;   // CmmStore
          _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 64] = mn_sefk_info;   // CmmStore
          P64[Hp - 48] = _seeY::P64;   // CmmStore
          _ceoC::P64 = Hp - 64;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefJ_info;   // CmmStore
          P64[Hp - 24] = _ceoC::P64;   // CmmStore
          _ceoJ::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefn_info;   // CmmStore
          P64[Hp] = _ceoC::P64;   // CmmStore
          _ceqR::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqR::P64;   // CmmStore
          P64[Sp - 24] = _ceoJ::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefK_entry() //  [R1]
        { info_tbl: [(cer2,
                      label: sat_sefK_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cer2:
          _sefK::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
      cer4:
          Hp = Hp + 72;   // CmmAssign
          if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
      cer6:
          HpAlloc = 72;   // CmmAssign
          goto cer3;   // CmmBranch
      cer3:
          R1 = _sefK::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer5:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefK::P64;   // CmmStore
          _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 64] = mn_sefk_info;   // CmmStore
          P64[Hp - 48] = _seeY::P64;   // CmmStore
          _ceoC::P64 = Hp - 64;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefJ_info;   // CmmStore
          P64[Hp - 24] = _ceoC::P64;   // CmmStore
          _ceoJ::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefn_info;   // CmmStore
          P64[Hp] = _ceoC::P64;   // CmmStore
          _ceqR::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqR::P64;   // CmmStore
          P64[Sp - 24] = _ceoJ::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cerb:
      _sefj::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
  cerc:
      R1 = _sefj::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerd:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefj::P64;   // CmmStore
      _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
      R3 = _sefi::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cerb:
      _sefj::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
  cerc:
      R1 = _sefj::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerd:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefj::P64;   // CmmStore
      _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
      R3 = _sefi::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cerb:
      _sefj::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
  cerc:
      R1 = _sefj::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerd:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefj::P64;   // CmmStore
      _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
      R3 = _sefi::P64;   // CmmAssign
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cerb,
  {GHC.setSessionDynFlags_closure, GhcMonad.$fGhcMonadGhc_closure}),
 (cerc, {}),
 (cerd,
  {GHC.setSessionDynFlags_closure, GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefj_entry() //  [R1]
        { info_tbl: [(cerb,
                      label: sat_sefj_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerb:
          _sefj::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
      cerc:
          R1 = _sefj::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerd:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefj::P64;   // CmmStore
          _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
          R3 = _sefi::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefj_entry() //  [R1]
        { info_tbl: [(cerb,
                      label: sat_sefj_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerb:
          _sefj::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
      cerc:
          R1 = _sefj::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerd:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefj::P64;   // CmmStore
          _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
          R3 = _sefi::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cere:
      _sefi::P64 = R2;   // CmmAssign
      _sefL::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
  cerg:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
  ceri:
      HpAlloc = 48;   // CmmAssign
      goto cerf;   // CmmBranch
  cerf:
      R2 = _sefi::P64;   // CmmAssign
      R1 = _sefL::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerh:
      _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefK_info;   // CmmStore
      P64[Hp - 24] = _seeY::P64;   // CmmStore
      _ceoy::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefj_info;   // CmmStore
      P64[Hp] = _sefi::P64;   // CmmStore
      _cer7::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cer7::P64;   // CmmStore
      P64[(old + 16)] = _ceoy::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cere:
      _sefi::P64 = R2;   // CmmAssign
      _sefL::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
  cerg:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
  ceri:
      HpAlloc = 48;   // CmmAssign
      goto cerf;   // CmmBranch
  cerf:
      R2 = _sefi::P64;   // CmmAssign
      R1 = _sefL::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerh:
      _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefK_info;   // CmmStore
      P64[Hp - 24] = _seeY::P64;   // CmmStore
      _ceoy::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefj_info;   // CmmStore
      P64[Hp] = _sefi::P64;   // CmmStore
      _cer7::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cer7::P64;   // CmmStore
      P64[(old + 16)] = _ceoy::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cere:
      _sefi::P64 = R2;   // CmmAssign
      _sefL::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
  cerg:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
  ceri:
      HpAlloc = 48;   // CmmAssign
      goto cerf;   // CmmBranch
  cerf:
      R2 = _sefi::P64;   // CmmAssign
      R1 = _sefL::P64;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerh:
      _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_sefK_info;   // CmmStore
      P64[Hp - 24] = _seeY::P64;   // CmmStore
      _ceoy::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_sefj_info;   // CmmStore
      P64[Hp] = _sefi::P64;   // CmmStore
      _cer7::P64 = Hp - 16;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _cer7::P64;   // CmmStore
      P64[Sp - 8] = _ceoy::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cere,
  {GhcMonad.$fMonadGhc_closure, sat_sefj_closure, sat_sefK_closure}),
 (cerf, {}),
 (cerg,
  {GhcMonad.$fMonadGhc_closure, sat_sefj_closure, sat_sefK_closure}),
 (cerh,
  {GhcMonad.$fMonadGhc_closure, sat_sefj_closure, sat_sefK_closure}),
 (ceri, {})]



==================== after setInfoTableStackMap ====================
sat_sefL_entry() //  [R2, R1]
        { info_tbl: [(cere,
                      label: sat_sefL_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cere:
          _sefi::P64 = R2;   // CmmAssign
          _sefL::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
      cerg:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
      ceri:
          HpAlloc = 48;   // CmmAssign
          goto cerf;   // CmmBranch
      cerf:
          R2 = _sefi::P64;   // CmmAssign
          R1 = _sefL::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerh:
          _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefK_info;   // CmmStore
          P64[Hp - 24] = _seeY::P64;   // CmmStore
          _ceoy::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefj_info;   // CmmStore
          P64[Hp] = _sefi::P64;   // CmmStore
          _cer7::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cer7::P64;   // CmmStore
          P64[Sp - 8] = _ceoy::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefL_entry() //  [R2, R1]
        { info_tbl: [(cere,
                      label: sat_sefL_info
                      rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cere:
          _sefi::P64 = R2;   // CmmAssign
          _sefL::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
      cerg:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
      ceri:
          HpAlloc = 48;   // CmmAssign
          goto cerf;   // CmmBranch
      cerf:
          R2 = _sefi::P64;   // CmmAssign
          R1 = _sefL::P64;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerh:
          _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefK_info;   // CmmStore
          P64[Hp - 24] = _seeY::P64;   // CmmStore
          _ceoy::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefj_info;   // CmmStore
          P64[Hp] = _sefi::P64;   // CmmStore
          _cer7::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cer7::P64;   // CmmStore
          P64[Sp - 8] = _ceoy::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cern:
      _sefh::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cero; else goto cerp;   // CmmCondBranch
  cero:
      R1 = _sefh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerp:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefh::P64;   // CmmStore
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cern:
      _sefh::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cero; else goto cerp;   // CmmCondBranch
  cero:
      R1 = _sefh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerp:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefh::P64;   // CmmStore
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cern:
      _sefh::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
  cero:
      R1 = _sefh::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerp:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefh::P64;   // CmmStore
      R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
      R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cern,
  {GhcMonad.getSessionDynFlags_closure,
   GhcMonad.$fGhcMonadGhc_closure}),
 (cero, {}),
 (cerp,
  {GhcMonad.getSessionDynFlags_closure,
   GhcMonad.$fGhcMonadGhc_closure})]



==================== after setInfoTableStackMap ====================
sat_sefh_entry() //  [R1]
        { info_tbl: [(cern,
                      label: sat_sefh_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cern:
          _sefh::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
      cero:
          R1 = _sefh::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerp:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefh::P64;   // CmmStore
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefh_entry() //  [R1]
        { info_tbl: [(cern,
                      label: sat_sefh_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cern:
          _sefh::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
      cero:
          R1 = _sefh::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerp:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefh::P64;   // CmmStore
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cerq:
      _sefM::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerr; else goto cers;   // CmmCondBranch
  cers:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
  ceru:
      HpAlloc = 32;   // CmmAssign
      goto cerr;   // CmmBranch
  cerr:
      R1 = _sefM::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cert:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefM::P64;   // CmmStore
      _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefL_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceot::P64 = Hp - 23;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefh_info;   // CmmStore
      _cerj::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cerj::P64;   // CmmStore
      P64[(old + 32)] = _ceot::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cerq:
      _sefM::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerr; else goto cers;   // CmmCondBranch
  cers:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
  ceru:
      HpAlloc = 32;   // CmmAssign
      goto cerr;   // CmmBranch
  cerr:
      R1 = _sefM::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cert:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefM::P64;   // CmmStore
      _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefL_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceot::P64 = Hp - 23;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefh_info;   // CmmStore
      _cerj::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cerj::P64;   // CmmStore
      P64[(old + 32)] = _ceot::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cerq:
      _sefM::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
  cers:
      Hp = Hp + 32;   // CmmAssign
      if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
  ceru:
      HpAlloc = 32;   // CmmAssign
      goto cerr;   // CmmBranch
  cerr:
      R1 = _sefM::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cert:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefM::P64;   // CmmStore
      _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefL_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceot::P64 = Hp - 23;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_sefh_info;   // CmmStore
      _cerj::P64 = Hp - 8;   // CmmAssign
      R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _cerj::P64;   // CmmStore
      P64[Sp - 24] = _ceot::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cerq,
  {GhcMonad.$fMonadGhc_closure, sat_sefh_closure, sat_sefL_closure}),
 (cerr, {}),
 (cers,
  {GhcMonad.$fMonadGhc_closure, sat_sefh_closure, sat_sefL_closure}),
 (cert,
  {GhcMonad.$fMonadGhc_closure, sat_sefh_closure, sat_sefL_closure}),
 (ceru, {})]



==================== after setInfoTableStackMap ====================
sat_sefM_entry() //  [R1]
        { info_tbl: [(cerq,
                      label: sat_sefM_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerq:
          _sefM::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
      cers:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
      ceru:
          HpAlloc = 32;   // CmmAssign
          goto cerr;   // CmmBranch
      cerr:
          R1 = _sefM::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cert:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefM::P64;   // CmmStore
          _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefL_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceot::P64 = Hp - 23;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefh_info;   // CmmStore
          _cerj::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cerj::P64;   // CmmStore
          P64[Sp - 24] = _ceot::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefM_entry() //  [R1]
        { info_tbl: [(cerq,
                      label: sat_sefM_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerq:
          _sefM::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
      cers:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
      ceru:
          HpAlloc = 32;   // CmmAssign
          goto cerr;   // CmmBranch
      cerr:
          R1 = _sefM::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cert:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefM::P64;   // CmmStore
          _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefL_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceot::P64 = Hp - 23;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefh_info;   // CmmStore
          _cerj::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cerj::P64;   // CmmStore
          P64[Sp - 24] = _ceot::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cerw:
      _sefN::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerx; else goto cery;   // CmmCondBranch
  cery:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
  cerA:
      HpAlloc = 40;   // CmmAssign
      goto cerx;   // CmmBranch
  cerx:
      R1 = _sefN::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerz:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefN::P64;   // CmmStore
      _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
      _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefM_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceop::P64 = Hp - 32;   // CmmAssign
      I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
      P64[Hp] = _seeX::P64;   // CmmStore
      _cerv::P64 = Hp - 6;   // CmmAssign
      R3 = _ceop::P64;   // CmmAssign
      R2 = _cerv::P64;   // CmmAssign
      R1 = GHC.runGhc_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cerw:
      _sefN::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerx; else goto cery;   // CmmCondBranch
  cery:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
  cerA:
      HpAlloc = 40;   // CmmAssign
      goto cerx;   // CmmBranch
  cerx:
      R1 = _sefN::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerz:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _sefN::P64;   // CmmStore
      _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
      _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefM_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceop::P64 = Hp - 32;   // CmmAssign
      I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
      P64[Hp] = _seeX::P64;   // CmmStore
      _cerv::P64 = Hp - 6;   // CmmAssign
      R3 = _ceop::P64;   // CmmAssign
      R2 = _cerv::P64;   // CmmAssign
      R1 = GHC.runGhc_closure;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cerw:
      _sefN::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
  cery:
      Hp = Hp + 40;   // CmmAssign
      if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
  cerA:
      HpAlloc = 40;   // CmmAssign
      goto cerx;   // CmmBranch
  cerx:
      R1 = _sefN::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerz:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _sefN::P64;   // CmmStore
      _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
      _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 32] = sat_sefM_info;   // CmmStore
      P64[Hp - 16] = _seeY::P64;   // CmmStore
      _ceop::P64 = Hp - 32;   // CmmAssign
      I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
      P64[Hp] = _seeX::P64;   // CmmStore
      _cerv::P64 = Hp - 6;   // CmmAssign
      R3 = _ceop::P64;   // CmmAssign
      R2 = _cerv::P64;   // CmmAssign
      R1 = GHC.runGhc_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_pp_fast(R3,
                          R2,
                          R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cerw, {GHC.runGhc_closure, sat_sefM_closure}), (cerx, {}),
 (cery, {GHC.runGhc_closure, sat_sefM_closure}),
 (cerz, {GHC.runGhc_closure, sat_sefM_closure}), (cerA, {})]



==================== after setInfoTableStackMap ====================
sat_sefN_entry() //  [R1]
        { info_tbl: [(cerw,
                      label: sat_sefN_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerw:
          _sefN::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
      cery:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
      cerA:
          HpAlloc = 40;   // CmmAssign
          goto cerx;   // CmmBranch
      cerx:
          R1 = _sefN::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefN::P64;   // CmmStore
          _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
          _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefM_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceop::P64 = Hp - 32;   // CmmAssign
          I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
          P64[Hp] = _seeX::P64;   // CmmStore
          _cerv::P64 = Hp - 6;   // CmmAssign
          R3 = _ceop::P64;   // CmmAssign
          R2 = _cerv::P64;   // CmmAssign
          R1 = GHC.runGhc_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_sefN_entry() //  [R1]
        { info_tbl: [(cerw,
                      label: sat_sefN_info
                      rep:HeapRep 2 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerw:
          _sefN::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
      cery:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
      cerA:
          HpAlloc = 40;   // CmmAssign
          goto cerx;   // CmmBranch
      cerx:
          R1 = _sefN::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefN::P64;   // CmmStore
          _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
          _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefM_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceop::P64 = Hp - 32;   // CmmAssign
          I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
          P64[Hp] = _seeX::P64;   // CmmStore
          _cerv::P64 = Hp - 6;   // CmmAssign
          R3 = _ceop::P64;   // CmmAssign
          R2 = _cerv::P64;   // CmmAssign
          R1 = GHC.runGhc_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cerB:
      _seeY::P64 = R3;   // CmmAssign
      _seeX::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
  cerD:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
  cerF:
      HpAlloc = 64;   // CmmAssign
      goto cerC;   // CmmBranch
  cerC:
      R3 = _seeY::P64;   // CmmAssign
      R2 = _seeX::P64;   // CmmAssign
      R1 = Main.testOneFile_closure;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerE:
      // calling allocDynClosure
      I64[Hp - 56] = gq_seeZ_info;   // CmmStore
      _ceiW::P64 = Hp - 54;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segp_info;   // CmmStore
      P64[Hp - 32] = _ceiW::P64;   // CmmStore
      _cekl::P64 = Hp - 39;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefN_info;   // CmmStore
      P64[Hp - 8] = _seeX::P64;   // CmmStore
      P64[Hp] = _seeY::P64;   // CmmStore
      _ceol::P64 = Hp - 24;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceol::P64;   // CmmStore
      P64[(old + 16)] = _cekl::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cerB:
      _seeY::P64 = R3;   // CmmAssign
      _seeX::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
  cerD:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
  cerF:
      HpAlloc = 64;   // CmmAssign
      goto cerC;   // CmmBranch
  cerC:
      R3 = _seeY::P64;   // CmmAssign
      R2 = _seeX::P64;   // CmmAssign
      R1 = Main.testOneFile_closure;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerE:
      // calling allocDynClosure
      I64[Hp - 56] = gq_seeZ_info;   // CmmStore
      _ceiW::P64 = Hp - 54;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segp_info;   // CmmStore
      P64[Hp - 32] = _ceiW::P64;   // CmmStore
      _cekl::P64 = Hp - 39;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefN_info;   // CmmStore
      P64[Hp - 8] = _seeX::P64;   // CmmStore
      P64[Hp] = _seeY::P64;   // CmmStore
      _ceol::P64 = Hp - 24;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _ceol::P64;   // CmmStore
      P64[(old + 16)] = _cekl::P64;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cerB:
      _seeY::P64 = R3;   // CmmAssign
      _seeX::P64 = R2;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
  cerD:
      Hp = Hp + 64;   // CmmAssign
      if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
  cerF:
      HpAlloc = 64;   // CmmAssign
      goto cerC;   // CmmBranch
  cerC:
      R3 = _seeY::P64;   // CmmAssign
      R2 = _seeX::P64;   // CmmAssign
      R1 = Main.testOneFile_closure;   // CmmAssign
      call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cerE:
      // calling allocDynClosure
      I64[Hp - 56] = gq_seeZ_info;   // CmmStore
      _ceiW::P64 = Hp - 54;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segp_info;   // CmmStore
      P64[Hp - 32] = _ceiW::P64;   // CmmStore
      _cekl::P64 = Hp - 39;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 24] = sat_sefN_info;   // CmmStore
      P64[Hp - 8] = _seeX::P64;   // CmmStore
      P64[Hp] = _seeY::P64;   // CmmStore
      _ceol::P64 = Hp - 24;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 16] = _ceol::P64;   // CmmStore
      P64[Sp - 8] = _cekl::P64;   // CmmStore
      Sp = Sp - 24;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(cerB,
  {GHC.Base.$fMonadIO_closure, Main.testOneFile_closure,
   gq_seeZ_closure, sat_sefN_closure, sat_segp_closure}),
 (cerC, {Main.testOneFile_closure}),
 (cerD,
  {GHC.Base.$fMonadIO_closure, Main.testOneFile_closure,
   gq_seeZ_closure, sat_sefN_closure, sat_segp_closure}),
 (cerE,
  {GHC.Base.$fMonadIO_closure, gq_seeZ_closure, sat_sefN_closure,
   sat_segp_closure}),
 (cerF, {Main.testOneFile_closure})]



==================== after setInfoTableStackMap ====================
Main.testOneFile_entry() //  [R3, R2]
        { info_tbl: [(cerB,
                      label: Main.testOneFile_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerB:
          _seeY::P64 = R3;   // CmmAssign
          _seeX::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
      cerD:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
      cerF:
          HpAlloc = 64;   // CmmAssign
          goto cerC;   // CmmBranch
      cerC:
          R3 = _seeY::P64;   // CmmAssign
          R2 = _seeX::P64;   // CmmAssign
          R1 = Main.testOneFile_closure;   // CmmAssign
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerE:
          // calling allocDynClosure
          I64[Hp - 56] = gq_seeZ_info;   // CmmStore
          _ceiW::P64 = Hp - 54;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segp_info;   // CmmStore
          P64[Hp - 32] = _ceiW::P64;   // CmmStore
          _cekl::P64 = Hp - 39;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefN_info;   // CmmStore
          P64[Hp - 8] = _seeX::P64;   // CmmStore
          P64[Hp] = _seeY::P64;   // CmmStore
          _ceol::P64 = Hp - 24;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceol::P64;   // CmmStore
          P64[Sp - 8] = _cekl::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
Main.testOneFile_entry() //  [R3, R2]
        { info_tbl: [(cerB,
                      label: Main.testOneFile_info
                      rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cerB:
          _seeY::P64 = R3;   // CmmAssign
          _seeX::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
      cerD:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
      cerF:
          HpAlloc = 64;   // CmmAssign
          goto cerC;   // CmmBranch
      cerC:
          R3 = _seeY::P64;   // CmmAssign
          R2 = _seeX::P64;   // CmmAssign
          R1 = Main.testOneFile_closure;   // CmmAssign
          call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerE:
          // calling allocDynClosure
          I64[Hp - 56] = gq_seeZ_info;   // CmmStore
          _ceiW::P64 = Hp - 54;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segp_info;   // CmmStore
          P64[Hp - 32] = _ceiW::P64;   // CmmStore
          _cekl::P64 = Hp - 39;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefN_info;   // CmmStore
          P64[Hp - 8] = _seeX::P64;   // CmmStore
          P64[Hp] = _seeY::P64;   // CmmStore
          _ceol::P64 = Hp - 24;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceol::P64;   // CmmStore
          P64[Sp - 8] = _cekl::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . Main.testOneFile_closure" {
     Main.testOneFile_closure:
         const Main.testOneFile_info;
         const 0;
 },
 $dTypeable_sef3_entry() //  [R1]
         { info_tbl: [(ceje,
                       label: $dTypeable_sef3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceje:
           _sef3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
       cejf:
           R1 = _sef3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejg:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef3::P64;   // CmmStore
           _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
           R2 = _sef2::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 ds_sef4_entry() //  [R1]
         { info_tbl: [(cejl,
                       label: ds_sef4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejl:
           _sef4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
       cejm:
           R1 = _sef4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef4::P64;   // CmmStore
           R4 = GHC.Types.[]_closure+1;   // CmmAssign
           R3 = GHC.Types.[]_closure+1;   // CmmAssign
           R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
           R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 a4_sef5_entry() //  [R1]
         { info_tbl: [(cejt,
                       label: a4_sef5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejt:
           _sef5::P64 = R1;   // CmmAssign
           goto cejv;   // CmmBranch
       cejv:
           _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
           R1 = _sef4::P64 & (-8);   // CmmAssign
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefd_entry() //  [R2, R1]
         { info_tbl: [(cejB,
                       label: block_cejB_info
                       rep:StackRep []),
                      (cejH,
                       label: sat_sefd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} }),
                      (cejP,
                       label: block_cejP_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejH:
           _sef7::P64 = R2;   // CmmAssign
           _sefd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
       cejI:
           R2 = _sef7::P64;   // CmmAssign
           R1 = _sefd::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejJ:
           _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
           _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
           I64[Sp - 8] = cejB;   // CmmStore
           R4 = _sef7::P64;   // CmmAssign
           R3 = _sef5::P64;   // CmmAssign
           R2 = _sef3::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
       cejB:
           _sef8::P64 = R1;   // CmmAssign
           _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
           if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
       cejF:
           _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
           I64[Sp] = cejP;   // CmmStore
           R1 = _sef9::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
       cejR:
           call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejP:
           _sefa::P64 = R1;   // CmmAssign
           _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
           if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
       cek4:
           _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejX:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
       cek0:
           HpAlloc = 24;   // CmmAssign
           R1 = _sefa::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejZ:
           _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
           I64[Hp - 16] = :_con_info;   // CmmStore
           P64[Hp - 8] = _sefa::P64;   // CmmStore
           P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
           _cejV::P64 = Hp - 14;   // CmmAssign
           R1 = _cejV::P64;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejE:
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefe_entry() //  [R2, R1]
         { info_tbl: [(cek6,
                       label: sat_sefe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cek6:
           _sef2::P64 = R2;   // CmmAssign
           _sefe::P64 = R1;   // CmmAssign
           goto cek8;   // CmmBranch
       cek8:
           Hp = Hp + 80;   // CmmAssign
           if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
       ceka:
           HpAlloc = 80;   // CmmAssign
           goto cek7;   // CmmBranch
       cek7:
           R2 = _sef2::P64;   // CmmAssign
           R1 = _sefe::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cek9:
           // calling allocDynClosure
           I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
           P64[Hp - 56] = _sef2::P64;   // CmmStore
           _ceja::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = ds_sef4_info;   // CmmStore
           _cejh::P64 = Hp - 48;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = a4_sef5_info;   // CmmStore
           P64[Hp - 24] = _cejh::P64;   // CmmStore
           _cejo::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefd_info;   // CmmStore
           P64[Hp - 8] = _ceja::P64;   // CmmStore
           P64[Hp] = _cejo::P64;   // CmmStore
           _cejw::P64 = Hp - 15;   // CmmAssign
           R1 = _cejw::P64;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seff_entry() //  [R1]
         { info_tbl: [(cekb,
                       label: sat_seff_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekb:
           _seff::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
       cekd:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
       cekf:
           HpAlloc = 16;   // CmmAssign
           goto cekc;   // CmmBranch
       cekc:
           R1 = _seff::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceke:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seff::P64;   // CmmStore
           _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
           _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefe_info;   // CmmStore
           _cej5::P64 = Hp - 7;   // CmmAssign
           R5 = _sef1::P64;   // CmmAssign
           R4 = _sef0::P64;   // CmmAssign
           R3 = _cej5::P64;   // CmmAssign
           R2 = GHC.Base.++_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 gq_seeZ_entry() //  [R3, R2, R1]
         { info_tbl: [(cekg,
                       label: gq_seeZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekg:
           _sef1::P64 = R3;   // CmmAssign
           _sef0::P64 = R2;   // CmmAssign
           _seeZ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
       ceki:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
       cekk:
           HpAlloc = 32;   // CmmAssign
           goto cekh;   // CmmBranch
       cekh:
           R3 = _sef1::P64;   // CmmAssign
           R2 = _sef0::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekj:
           // calling allocDynClosure
           I64[Hp - 24] = sat_seff_info;   // CmmStore
           P64[Hp - 8] = _sef0::P64;   // CmmStore
           P64[Hp] = _sef1::P64;   // CmmStore
           _cej1::P64 = Hp - 24;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cej1::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 $dData_segd_entry() //  [R1]
         { info_tbl: [(cekD,
                       label: $dData_segd_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekD:
           _segd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
       cekE:
           R1 = _segd::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segd::P64;   // CmmStore
           R2 = ConLike.$fDataConLike_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData1_sege_entry() //  [R1]
         { info_tbl: [(cekK,
                       label: $dData1_sege_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekK:
           _sege::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
       cekL:
           R1 = _sege::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekM:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sege::P64;   // CmmStore
           R2 = TypeRep.$fDataType_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData2_segf_entry() //  [R1]
         { info_tbl: [(cekR,
                       label: $dData2_segf_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekR:
           _segf::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
       cekS:
           R1 = _segf::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segf::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData3_segg_entry() //  [R1]
         { info_tbl: [(cekY,
                       label: $dData3_segg_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekY:
           _segg::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
       cekZ:
           R1 = _segg::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segg::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData4_segh_entry() //  [R1]
         { info_tbl: [(cel5,
                       label: $dData4_segh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cel5:
           _segh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
       cel6:
           R1 = _segh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segh::P64;   // CmmStore
           _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
           R2 = _segg::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData5_segi_entry() //  [R1]
         { info_tbl: [(celc,
                       label: $dData5_segi_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celc:
           _segi::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
       celd:
           R1 = _segi::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cele:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segi::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segk_entry() //  [R1]
         { info_tbl: [(cels,
                       label: sat_segk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cels:
           _segk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
       celt:
           R1 = _segk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segk::P64;   // CmmStore
           _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
           R3 = _segj::P64;   // CmmAssign
           R2 = _segj::P64;   // CmmAssign
           R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segl_entry() //  [R1]
         { info_tbl: [(celv,
                       label: sat_segl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celv:
           _segl::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
       celx:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
       celz:
           HpAlloc = 24;   // CmmAssign
           goto celw;   // CmmBranch
       celw:
           R1 = _segl::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cely:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segl::P64;   // CmmStore
           _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segk_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celo::P64 = Hp - 16;   // CmmAssign
           R3 = _celo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segm_entry() //  [R1]
         { info_tbl: [(celA,
                       label: sat_segm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celA:
           _segm::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
       celC:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
       celE:
           HpAlloc = 24;   // CmmAssign
           goto celB;   // CmmBranch
       celB:
           R1 = _segm::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segm::P64;   // CmmStore
           _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segl_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celk::P64 = Hp - 16;   // CmmAssign
           R2 = _celk::P64;   // CmmAssign
           R1 = Bag.$fDataBag_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segn_entry() //  [R1]
         { info_tbl: [(celF,
                       label: sat_segn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celF:
           _segn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
       celH:
           Hp = Hp + 248;   // CmmAssign
           if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
       celJ:
           HpAlloc = 248;   // CmmAssign
           goto celG;   // CmmBranch
       celG:
           R1 = _segn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segn::P64;   // CmmStore
           _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
           _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 240] = $dData_segd_info;   // CmmStore
           _cekz::P64 = Hp - 240;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 224] = $dData1_sege_info;   // CmmStore
           _cekG::P64 = Hp - 224;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 208] = $dData2_segf_info;   // CmmStore
           _cekN::P64 = Hp - 208;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 192] = $dData3_segg_info;   // CmmStore
           _cekU::P64 = Hp - 192;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 176] = $dData4_segh_info;   // CmmStore
           P64[Hp - 160] = _cekU::P64;   // CmmStore
           _cel1::P64 = Hp - 176;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 152] = $dData5_segi_info;   // CmmStore
           _cel8::P64 = Hp - 152;   // CmmAssign
           I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 120] = _cel8::P64;   // CmmStore
           P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 88] = _cekN::P64;   // CmmStore
           P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
           P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
           P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 48] = _cekG::P64;   // CmmStore
           P64[Hp - 40] = _cekz::P64;   // CmmStore
           P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
           P64[Hp - 24] = _cel1::P64;   // CmmStore
           _celf::P64 = Hp - 135;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segm_info;   // CmmStore
           P64[Hp] = _celf::P64;   // CmmStore
           _celg::P64 = Hp - 16;   // CmmAssign
           R3 = _sefS::P64;   // CmmAssign
           R2 = _celg::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg8_entry() //  [R1]
         { info_tbl: [(cem4,
                       label: sat_seg8_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem4:
           _seg8::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
       cem5:
           R1 = _seg8::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cem6:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg8::P64;   // CmmStore
           R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg9_entry() //  [R1]
         { info_tbl: [(cem7,
                       label: sat_seg9_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem7:
           _seg9::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
       cem9:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
       cemb:
           HpAlloc = 16;   // CmmAssign
           goto cem8;   // CmmBranch
       cem8:
           R1 = _seg9::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cema:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg9::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg8_info;   // CmmStore
           _cem0::P64 = Hp - 8;   // CmmAssign
           R2 = _cem0::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg4_entry() //  [R1]
         { info_tbl: [(cems,
                       label: sat_seg4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cems:
           _seg4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
       cemt:
           R1 = _seg4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg4::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg5_entry() //  [R1]
         { info_tbl: [(cemv,
                       label: sat_seg5_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemv:
           _seg5::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
       cemx:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
       cemz:
           HpAlloc = 16;   // CmmAssign
           goto cemw;   // CmmBranch
       cemw:
           R1 = _seg5::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg5::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg4_info;   // CmmStore
           _cemo::P64 = Hp - 8;   // CmmAssign
           R3 = _cemo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg6_entry() //  [R1]
         { info_tbl: [(cemA,
                       label: sat_seg6_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemA:
           _seg6::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
       cemC:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
       cemE:
           HpAlloc = 16;   // CmmAssign
           goto cemB;   // CmmBranch
       cemB:
           R1 = _seg6::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg6::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg5_info;   // CmmStore
           _cemk::P64 = Hp - 8;   // CmmAssign
           R2 = _cemk::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg7_entry() //  [R1]
         { info_tbl: [(cemF,
                       label: sat_seg7_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemF:
           _seg7::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
       cemH:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
       cemJ:
           HpAlloc = 16;   // CmmAssign
           goto cemG;   // CmmBranch
       cemG:
           R1 = _seg7::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg7::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg6_info;   // CmmStore
           _cemg::P64 = Hp - 8;   // CmmAssign
           R2 = _cemg::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg1_entry() //  [R1]
         { info_tbl: [(cemW,
                       label: sat_seg1_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemW:
           _seg1::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
       cemX:
           R1 = _seg1::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg1::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg2_entry() //  [R1]
         { info_tbl: [(cemZ,
                       label: sat_seg2_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemZ:
           _seg2::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
       cen1:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
       cen3:
           HpAlloc = 16;   // CmmAssign
           goto cen0;   // CmmBranch
       cen0:
           R1 = _seg2::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg2::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg1_info;   // CmmStore
           _cemS::P64 = Hp - 8;   // CmmAssign
           R3 = _cemS::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg3_entry() //  [R1]
         { info_tbl: [(cen4,
                       label: sat_seg3_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cen4:
           _seg3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
       cen6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
       cen8:
           HpAlloc = 16;   // CmmAssign
           goto cen5;   // CmmBranch
       cen5:
           R1 = _seg3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg3::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg2_info;   // CmmStore
           _cemO::P64 = Hp - 8;   // CmmAssign
           R2 = _cemO::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefY_entry() //  [R1]
         { info_tbl: [(cenh,
                       label: sat_sefY_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenh:
           _sefY::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
       ceni:
           R1 = _sefY::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenj:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefY::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefX_entry() //  [R1]
         { info_tbl: [(ceno,
                       label: sat_sefX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceno:
           _sefX::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
       cenp:
           R1 = _sefX::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenq:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefX::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg0_entry() //  [R1]
         { info_tbl: [(cens,
                       label: sat_seg0_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cens:
           _seg0::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
       cenu:
           Hp = Hp + 152;   // CmmAssign
           if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
       cenw:
           HpAlloc = 152;   // CmmAssign
           goto cent;   // CmmBranch
       cent:
           R1 = _seg0::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenv:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg0::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 144] = sat_sefY_info;   // CmmStore
           _cend::P64 = Hp - 144;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 128] = sat_sefX_info;   // CmmStore
           _cenk::P64 = Hp - 128;   // CmmAssign
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 96] = _cenk::P64;   // CmmStore
           P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 64] = _cend::P64;   // CmmStore
           P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenr::P64 = Hp - 111;   // CmmAssign
           R2 = _cenr::P64;   // CmmAssign
           R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sega_entry() //  [R1]
         { info_tbl: [(cenx,
                       label: sat_sega_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenx:
           _sega::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
       cenz:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
       cenB:
           HpAlloc = 64;   // CmmAssign
           goto ceny;   // CmmBranch
       ceny:
           R1 = _sega::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sega::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 56] = sat_seg9_info;   // CmmStore
           _celW::P64 = Hp - 56;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_seg7_info;   // CmmStore
           _cemc::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_seg3_info;   // CmmStore
           _cemK::P64 = Hp - 24;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg0_info;   // CmmStore
           _cen9::P64 = Hp - 8;   // CmmAssign
           R5 = _celW::P64;   // CmmAssign
           R4 = _cemc::P64;   // CmmAssign
           R3 = _cemK::P64;   // CmmAssign
           R2 = _cen9::P64;   // CmmAssign
           R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pppp_fast(R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segb_entry() //  [R1]
         { info_tbl: [(cenC,
                       label: sat_segb_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenC:
           _segb::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
       cenE:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
       cenG:
           HpAlloc = 16;   // CmmAssign
           goto cenD;   // CmmBranch
       cenD:
           R1 = _segb::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segb::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sega_info;   // CmmStore
           _celS::P64 = Hp - 8;   // CmmAssign
           R2 = _celS::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segc_entry() //  [R1]
         { info_tbl: [(cenH,
                       label: sat_segc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenH:
           _segc::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
       cenJ:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
       cenL:
           HpAlloc = 16;   // CmmAssign
           goto cenI;   // CmmBranch
       cenI:
           R1 = _segc::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenK:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segc::P64;   // CmmStore
           _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
           _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segb_info;   // CmmStore
           _celO::P64 = Hp - 8;   // CmmAssign
           R3 = _sefR::P64;   // CmmAssign
           R2 = _celO::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefU_entry() //  [R1]
         { info_tbl: [(cenZ,
                       label: sat_sefU_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenZ:
           _sefU::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
       ceo1:
           Hp = Hp + 120;   // CmmAssign
           if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
       ceo3:
           HpAlloc = 120;   // CmmAssign
           goto ceo0;   // CmmBranch
       ceo0:
           R1 = _sefU::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefU::P64;   // CmmStore
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
           P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenY::P64 = Hp - 111;   // CmmAssign
           R2 = _cenY::P64;   // CmmAssign
           R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefV_entry() //  [R1]
         { info_tbl: [(ceo4,
                       label: sat_sefV_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo4:
           _sefV::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
       ceo6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
       ceo8:
           HpAlloc = 16;   // CmmAssign
           goto ceo5;   // CmmBranch
       ceo5:
           R1 = _sefV::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefV::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefU_info;   // CmmStore
           _cenU::P64 = Hp - 8;   // CmmAssign
           R3 = _cenU::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerG_srtd" {
     uerG_srtd:
         const SehZ_srt;
         const 33;
         const 6979518925;
 },
 sat_sefW_entry() //  [R1]
         { info_tbl: [(ceo9,
                       label: sat_sefW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo9:
           _sefW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
       ceob:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
       ceod:
           HpAlloc = 16;   // CmmAssign
           goto ceoa;   // CmmBranch
       ceoa:
           R1 = _sefW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoc:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefW::P64;   // CmmStore
           _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
           _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefV_info;   // CmmStore
           _cenQ::P64 = Hp - 8;   // CmmAssign
           R3 = _sefQ::P64;   // CmmAssign
           R2 = _cenQ::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerH_srtd" {
     uerH_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 section ""relreadonly" . uerI_srtd" {
     uerI_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 sat_segp_entry() //  [R2, R1]
         { info_tbl: [(cekq,
                       label: block_cekq_info
                       rep:StackRep [False]),
                      (ceoe,
                       label: sat_segp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoe:
           _sefO::P64 = R2;   // CmmAssign
           _segp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
       ceog:
           R2 = _sefO::P64;   // CmmAssign
           R1 = _segp::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoh:
           _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
           I64[Sp - 16] = cekq;   // CmmStore
           R1 = _sefO::P64;   // CmmAssign
           P64[Sp - 8] = _seeZ::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
       cekr:
           call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       cekq:
           _seeZ::P64 = P64[Sp + 8];   // CmmAssign
           _sefP::P64 = R1;   // CmmAssign
           Hp = Hp + 128;   // CmmAssign
           if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
       ceok:
           HpAlloc = 128;   // CmmAssign
           R1 = _sefP::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       ceoj:
           _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
           _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
           _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 120] = sat_segn_info;   // CmmStore
           P64[Hp - 104] = _seeZ::P64;   // CmmStore
           P64[Hp - 96] = _sefS::P64;   // CmmStore
           _cekv::P64 = Hp - 120;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 88] = sat_segc_info;   // CmmStore
           P64[Hp - 72] = _seeZ::P64;   // CmmStore
           P64[Hp - 64] = _sefR::P64;   // CmmStore
           _celK::P64 = Hp - 88;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 56] = sat_sefW_info;   // CmmStore
           P64[Hp - 40] = _seeZ::P64;   // CmmStore
           P64[Hp - 32] = _sefQ::P64;   // CmmStore
           _cenM::P64 = Hp - 56;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cenM::P64;   // CmmStore
           P64[Hp - 8] = _celK::P64;   // CmmStore
           P64[Hp] = _cekv::P64;   // CmmStore
           _ceof::P64 = Hp - 23;   // CmmAssign
           R3 = _ceof::P64;   // CmmAssign
           R2 = $dShow_reeF_closure;   // CmmAssign
           R1 = System.IO.print_closure;   // CmmAssign
           Sp = Sp + 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 mn_sefk_entry() //  [R1]
         { info_tbl: [(ceoG,
                       label: mn_sefk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoG:
           _sefk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
       ceoH:
           R1 = _sefk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefk::P64;   // CmmStore
           _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
           R2 = _seeY::P64;   // CmmAssign
           R1 = Module.mkModuleName_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefB_entry() //  [R1]
         { info_tbl: [(cepk,
                       label: sat_sefB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepk:
           _sefB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
       cepl:
           R1 = _sefB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepm:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefB::P64;   // CmmStore
           _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefA_entry() //  [R1]
         { info_tbl: [(cepr,
                       label: sat_sefA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepr:
           _sefA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
       ceps:
           R1 = _sefA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cept:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefA::P64;   // CmmStore
           _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefz_entry() //  [R1]
         { info_tbl: [(cepy,
                       label: sat_sefz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepy:
           _sefz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
       cepz:
           R1 = _sefz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefz::P64;   // CmmStore
           _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
           R2 = _sefs::P64;   // CmmAssign
           R1 = GHC.pm_parsed_source_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefD_entry() //  [R2, R1]
         { info_tbl: [(cepC,
                       label: sat_sefD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepC:
           _sefy::P64 = R2;   // CmmAssign
           _sefD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
       cepE:
           Hp = Hp + 104;   // CmmAssign
           if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
       cepG:
           HpAlloc = 104;   // CmmAssign
           goto cepD;   // CmmBranch
       cepD:
           R2 = _sefy::P64;   // CmmAssign
           R1 = _sefD::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepF:
           _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 96] = sat_sefB_info;   // CmmStore
           P64[Hp - 80] = _sefy::P64;   // CmmStore
           _cepg::P64 = Hp - 96;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 72] = sat_sefA_info;   // CmmStore
           P64[Hp - 56] = _sefy::P64;   // CmmStore
           _cepn::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = sat_sefz_info;   // CmmStore
           P64[Hp - 32] = _sefs::P64;   // CmmStore
           _cepu::P64 = Hp - 48;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cepu::P64;   // CmmStore
           P64[Hp - 8] = _cepn::P64;   // CmmStore
           P64[Hp] = _cepg::P64;   // CmmStore
           _cepB::P64 = Hp - 23;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cepB::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefx_entry() //  [R1]
         { info_tbl: [(cepL,
                       label: sat_sefx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepL:
           _sefx::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
       cepM:
           R1 = _sefx::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepN:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefx::P64;   // CmmStore
           _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
           R4 = _sefw::P64;   // CmmAssign
           R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           R1 = GHC.loadModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefE_entry() //  [R2, R1]
         { info_tbl: [(cepO,
                       label: sat_sefE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepO:
           _sefw::P64 = R2;   // CmmAssign
           _sefE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
       cepQ:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
       cepS:
           HpAlloc = 40;   // CmmAssign
           goto cepP;   // CmmBranch
       cepP:
           R2 = _sefw::P64;   // CmmAssign
           R1 = _sefE::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepR:
           _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefD_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cepb::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefx_info;   // CmmStore
           P64[Hp] = _sefw::P64;   // CmmStore
           _cepH::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepH::P64;   // CmmStore
           P64[Sp - 8] = _cepb::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefv_entry() //  [R1]
         { info_tbl: [(cepX,
                       label: sat_sefv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepX:
           _sefv::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
       cepY:
           R1 = _sefv::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepZ:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefv::P64;   // CmmStore
           _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
           R3 = _sefu::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.desugarModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefF_entry() //  [R2, R1]
         { info_tbl: [(ceq0,
                       label: sat_sefF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq0:
           _sefu::P64 = R2;   // CmmAssign
           _sefF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
       ceq2:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
       ceq4:
           HpAlloc = 40;   // CmmAssign
           goto ceq1;   // CmmBranch
       ceq1:
           R2 = _sefu::P64;   // CmmAssign
           R1 = _sefF::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceq3:
           _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefE_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep6::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefv_info;   // CmmStore
           P64[Hp] = _sefu::P64;   // CmmStore
           _cepT::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepT::P64;   // CmmStore
           P64[Sp - 8] = _cep6::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seft_entry() //  [R1]
         { info_tbl: [(ceq9,
                       label: sat_seft_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq9:
           _seft::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
       ceqa:
           R1 = _seft::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seft::P64;   // CmmStore
           _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
           R3 = _sefs::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.typecheckModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefG_entry() //  [R2, R1]
         { info_tbl: [(ceqc,
                       label: sat_sefG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqc:
           _sefs::P64 = R2;   // CmmAssign
           _sefG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
       ceqe:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
       ceqg:
           HpAlloc = 40;   // CmmAssign
           goto ceqd;   // CmmBranch
       ceqd:
           R2 = _sefs::P64;   // CmmAssign
           R1 = _sefG::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqf:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefF_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep1::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seft_info;   // CmmStore
           P64[Hp] = _sefs::P64;   // CmmStore
           _ceq5::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceq5::P64;   // CmmStore
           P64[Sp - 8] = _cep1::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefr_entry() //  [R1]
         { info_tbl: [(ceql,
                       label: sat_sefr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceql:
           _sefr::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
       ceqm:
           R1 = _sefr::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefr::P64;   // CmmStore
           _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
           R3 = _sefq::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.parseModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefH_entry() //  [R2, R1]
         { info_tbl: [(ceqo,
                       label: sat_sefH_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqo:
           _sefq::P64 = R2;   // CmmAssign
           _sefH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
       ceqq:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
       ceqs:
           HpAlloc = 40;   // CmmAssign
           goto ceqp;   // CmmBranch
       ceqp:
           R2 = _sefq::P64;   // CmmAssign
           R1 = _sefH::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqr:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefG_info;   // CmmStore
           _ceoW::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefr_info;   // CmmStore
           P64[Hp] = _sefq::P64;   // CmmStore
           _ceqh::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceqh::P64;   // CmmStore
           P64[Sp - 8] = _ceoW::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefp_entry() //  [R1]
         { info_tbl: [(ceqx,
                       label: sat_sefp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqx:
           _sefp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
       ceqy:
           R1 = _sefp::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefp::P64;   // CmmStore
           _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
           R3 = _sefk::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.getModSummary_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefI_entry() //  [R1]
         { info_tbl: [(ceqA,
                       label: sat_sefI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqA:
           _sefI::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
       ceqC:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
       ceqE:
           HpAlloc = 40;   // CmmAssign
           goto ceqB;   // CmmBranch
       ceqB:
           R1 = _sefI::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefI::P64;   // CmmStore
           _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefH_info;   // CmmStore
           _ceoR::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefp_info;   // CmmStore
           P64[Hp] = _sefk::P64;   // CmmStore
           _ceqt::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqt::P64;   // CmmStore
           P64[Sp - 24] = _ceoR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefo_entry() //  [R1]
         { info_tbl: [(ceqJ,
                       label: sat_sefo_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqJ:
           _sefo::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
       ceqK:
           R1 = _sefo::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqL:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefo::P64;   // CmmStore
           R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMake.load_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefJ_entry() //  [R1]
         { info_tbl: [(ceqM,
                       label: sat_sefJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqM:
           _sefJ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
       ceqO:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
       ceqQ:
           HpAlloc = 40;   // CmmAssign
           goto ceqN;   // CmmBranch
       ceqN:
           R1 = _sefJ::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefJ::P64;   // CmmStore
           _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefI_info;   // CmmStore
           P64[Hp - 16] = _sefk::P64;   // CmmStore
           _ceoN::P64 = Hp - 32;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefo_info;   // CmmStore
           _ceqF::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqF::P64;   // CmmStore
           P64[Sp - 24] = _ceoN::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefn_entry() //  [R1]
         { info_tbl: [(ceqX,
                       label: sat_sefn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqX:
           _sefn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
       ceqZ:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
       cer1:
           HpAlloc = 48;   // CmmAssign
           goto ceqY;   // CmmBranch
       ceqY:
           R1 = _sefn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefn::P64;   // CmmStore
           _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
           I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
           P64[Hp - 32] = _sefk::P64;   // CmmStore
           _ceqV::P64 = Hp - 39;   // CmmAssign
           I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
           P64[Hp - 16] = _ceqV::P64;   // CmmStore
           P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
           P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
           _ceqW::P64 = Hp - 23;   // CmmAssign
           R3 = _ceqW::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.addTarget_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefK_entry() //  [R1]
         { info_tbl: [(cer2,
                       label: sat_sefK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cer2:
           _sefK::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
       cer4:
           Hp = Hp + 72;   // CmmAssign
           if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
       cer6:
           HpAlloc = 72;   // CmmAssign
           goto cer3;   // CmmBranch
       cer3:
           R1 = _sefK::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer5:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefK::P64;   // CmmStore
           _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 64] = mn_sefk_info;   // CmmStore
           P64[Hp - 48] = _seeY::P64;   // CmmStore
           _ceoC::P64 = Hp - 64;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefJ_info;   // CmmStore
           P64[Hp - 24] = _ceoC::P64;   // CmmStore
           _ceoJ::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefn_info;   // CmmStore
           P64[Hp] = _ceoC::P64;   // CmmStore
           _ceqR::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqR::P64;   // CmmStore
           P64[Sp - 24] = _ceoJ::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefj_entry() //  [R1]
         { info_tbl: [(cerb,
                       label: sat_sefj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerb:
           _sefj::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
       cerc:
           R1 = _sefj::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerd:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefj::P64;   // CmmStore
           _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
           R3 = _sefi::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefL_entry() //  [R2, R1]
         { info_tbl: [(cere,
                       label: sat_sefL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cere:
           _sefi::P64 = R2;   // CmmAssign
           _sefL::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
       cerg:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
       ceri:
           HpAlloc = 48;   // CmmAssign
           goto cerf;   // CmmBranch
       cerf:
           R2 = _sefi::P64;   // CmmAssign
           R1 = _sefL::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerh:
           _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefK_info;   // CmmStore
           P64[Hp - 24] = _seeY::P64;   // CmmStore
           _ceoy::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefj_info;   // CmmStore
           P64[Hp] = _sefi::P64;   // CmmStore
           _cer7::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cer7::P64;   // CmmStore
           P64[Sp - 8] = _ceoy::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefh_entry() //  [R1]
         { info_tbl: [(cern,
                       label: sat_sefh_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cern:
           _sefh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
       cero:
           R1 = _sefh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerp:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefh::P64;   // CmmStore
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefM_entry() //  [R1]
         { info_tbl: [(cerq,
                       label: sat_sefM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerq:
           _sefM::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
       cers:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
       ceru:
           HpAlloc = 32;   // CmmAssign
           goto cerr;   // CmmBranch
       cerr:
           R1 = _sefM::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cert:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefM::P64;   // CmmStore
           _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefL_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceot::P64 = Hp - 23;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefh_info;   // CmmStore
           _cerj::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cerj::P64;   // CmmStore
           P64[Sp - 24] = _ceot::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefN_entry() //  [R1]
         { info_tbl: [(cerw,
                       label: sat_sefN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerw:
           _sefN::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
       cery:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
       cerA:
           HpAlloc = 40;   // CmmAssign
           goto cerx;   // CmmBranch
       cerx:
           R1 = _sefN::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefN::P64;   // CmmStore
           _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
           _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefM_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceop::P64 = Hp - 32;   // CmmAssign
           I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
           P64[Hp] = _seeX::P64;   // CmmStore
           _cerv::P64 = Hp - 6;   // CmmAssign
           R3 = _ceop::P64;   // CmmAssign
           R2 = _cerv::P64;   // CmmAssign
           R1 = GHC.runGhc_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerJ_srtd" {
     uerJ_srtd:
         const SehZ_srt;
         const 52;
         const 4503599627370445;
 },
 Main.testOneFile_entry() //  [R3, R2]
         { info_tbl: [(cerB,
                       label: Main.testOneFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerB:
           _seeY::P64 = R3;   // CmmAssign
           _seeX::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
       cerD:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
       cerF:
           HpAlloc = 64;   // CmmAssign
           goto cerC;   // CmmBranch
       cerC:
           R3 = _seeY::P64;   // CmmAssign
           R2 = _seeX::P64;   // CmmAssign
           R1 = Main.testOneFile_closure;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerE:
           // calling allocDynClosure
           I64[Hp - 56] = gq_seeZ_info;   // CmmStore
           _ceiW::P64 = Hp - 54;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segp_info;   // CmmStore
           P64[Hp - 32] = _ceiW::P64;   // CmmStore
           _cekl::P64 = Hp - 39;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefN_info;   // CmmStore
           P64[Hp - 8] = _seeX::P64;   // CmmStore
           P64[Hp] = _seeY::P64;   // CmmStore
           _ceol::P64 = Hp - 24;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceol::P64;   // CmmStore
           P64[Sp - 8] = _cekl::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . Main.testOneFile_closure" {
     Main.testOneFile_closure:
         const Main.testOneFile_info;
         const 0;
 },
 $dTypeable_sef3_entry() //  [R1]
         { info_tbl: [(ceje,
                       label: $dTypeable_sef3_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceje:
           _sef3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
       cejf:
           R1 = _sef3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejg:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef3::P64;   // CmmStore
           _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
           R2 = _sef2::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 ds_sef4_entry() //  [R1]
         { info_tbl: [(cejl,
                       label: ds_sef4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejl:
           _sef4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
       cejm:
           R1 = _sef4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef4::P64;   // CmmStore
           R4 = GHC.Types.[]_closure+1;   // CmmAssign
           R3 = GHC.Types.[]_closure+1;   // CmmAssign
           R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
           R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 a4_sef5_entry() //  [R1]
         { info_tbl: [(cejt,
                       label: a4_sef5_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 3} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejt:
           _sef5::P64 = R1;   // CmmAssign
           goto cejv;   // CmmBranch
       cejv:
           _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
           R1 = _sef4::P64 & (-8);   // CmmAssign
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefd_entry() //  [R2, R1]
         { info_tbl: [(cejB,
                       label: block_cejB_info
                       rep:StackRep []),
                      (cejH,
                       label: sat_sefd_info
                       rep:HeapRep 2 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} }),
                      (cejP,
                       label: block_cejP_info
                       rep:StackRep [])]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cejH:
           _sef7::P64 = R2;   // CmmAssign
           _sefd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
       cejI:
           R2 = _sef7::P64;   // CmmAssign
           R1 = _sefd::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejJ:
           _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
           _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
           I64[Sp - 8] = cejB;   // CmmStore
           R4 = _sef7::P64;   // CmmAssign
           R3 = _sef5::P64;   // CmmAssign
           R2 = _sef3::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
       cejB:
           _sef8::P64 = R1;   // CmmAssign
           _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
           if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
       cejF:
           _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
           I64[Sp] = cejP;   // CmmStore
           R1 = _sef9::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
       cejR:
           call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejP:
           _sefa::P64 = R1;   // CmmAssign
           _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
           if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
       cek4:
           _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejX:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
       cek0:
           HpAlloc = 24;   // CmmAssign
           R1 = _sefa::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejZ:
           _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
           I64[Hp - 16] = :_con_info;   // CmmStore
           P64[Hp - 8] = _sefa::P64;   // CmmStore
           P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
           _cejV::P64 = Hp - 14;   // CmmAssign
           R1 = _cejV::P64;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejE:
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefe_entry() //  [R2, R1]
         { info_tbl: [(cek6,
                       label: sat_sefe_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cek6:
           _sef2::P64 = R2;   // CmmAssign
           _sefe::P64 = R1;   // CmmAssign
           goto cek8;   // CmmBranch
       cek8:
           Hp = Hp + 80;   // CmmAssign
           if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
       ceka:
           HpAlloc = 80;   // CmmAssign
           goto cek7;   // CmmBranch
       cek7:
           R2 = _sef2::P64;   // CmmAssign
           R1 = _sefe::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cek9:
           // calling allocDynClosure
           I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
           P64[Hp - 56] = _sef2::P64;   // CmmStore
           _ceja::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = ds_sef4_info;   // CmmStore
           _cejh::P64 = Hp - 48;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = a4_sef5_info;   // CmmStore
           P64[Hp - 24] = _cejh::P64;   // CmmStore
           _cejo::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefd_info;   // CmmStore
           P64[Hp - 8] = _ceja::P64;   // CmmStore
           P64[Hp] = _cejo::P64;   // CmmStore
           _cejw::P64 = Hp - 15;   // CmmAssign
           R1 = _cejw::P64;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seff_entry() //  [R1]
         { info_tbl: [(cekb,
                       label: sat_seff_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekb:
           _seff::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
       cekd:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
       cekf:
           HpAlloc = 16;   // CmmAssign
           goto cekc;   // CmmBranch
       cekc:
           R1 = _seff::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceke:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seff::P64;   // CmmStore
           _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
           _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefe_info;   // CmmStore
           _cej5::P64 = Hp - 7;   // CmmAssign
           R5 = _sef1::P64;   // CmmAssign
           R4 = _sef0::P64;   // CmmAssign
           R3 = _cej5::P64;   // CmmAssign
           R2 = GHC.Base.++_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 gq_seeZ_entry() //  [R3, R2, R1]
         { info_tbl: [(cekg,
                       label: gq_seeZ_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekg:
           _sef1::P64 = R3;   // CmmAssign
           _sef0::P64 = R2;   // CmmAssign
           _seeZ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
       ceki:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
       cekk:
           HpAlloc = 32;   // CmmAssign
           goto cekh;   // CmmBranch
       cekh:
           R3 = _sef1::P64;   // CmmAssign
           R2 = _sef0::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekj:
           // calling allocDynClosure
           I64[Hp - 24] = sat_seff_info;   // CmmStore
           P64[Hp - 8] = _sef0::P64;   // CmmStore
           P64[Hp] = _sef1::P64;   // CmmStore
           _cej1::P64 = Hp - 24;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cej1::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 $dData_segd_entry() //  [R1]
         { info_tbl: [(cekD,
                       label: $dData_segd_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekD:
           _segd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
       cekE:
           R1 = _segd::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segd::P64;   // CmmStore
           R2 = ConLike.$fDataConLike_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData1_sege_entry() //  [R1]
         { info_tbl: [(cekK,
                       label: $dData1_sege_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekK:
           _sege::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
       cekL:
           R1 = _sege::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekM:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sege::P64;   // CmmStore
           R2 = TypeRep.$fDataType_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData2_segf_entry() //  [R1]
         { info_tbl: [(cekR,
                       label: $dData2_segf_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekR:
           _segf::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
       cekS:
           R1 = _segf::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segf::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData3_segg_entry() //  [R1]
         { info_tbl: [(cekY,
                       label: $dData3_segg_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cekY:
           _segg::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
       cekZ:
           R1 = _segg::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segg::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData4_segh_entry() //  [R1]
         { info_tbl: [(cel5,
                       label: $dData4_segh_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cel5:
           _segh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
       cel6:
           R1 = _segh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segh::P64;   // CmmStore
           _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
           R2 = _segg::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData5_segi_entry() //  [R1]
         { info_tbl: [(celc,
                       label: $dData5_segi_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celc:
           _segi::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
       celd:
           R1 = _segi::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cele:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segi::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segk_entry() //  [R1]
         { info_tbl: [(cels,
                       label: sat_segk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cels:
           _segk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
       celt:
           R1 = _segk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segk::P64;   // CmmStore
           _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
           R3 = _segj::P64;   // CmmAssign
           R2 = _segj::P64;   // CmmAssign
           R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segl_entry() //  [R1]
         { info_tbl: [(celv,
                       label: sat_segl_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celv:
           _segl::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
       celx:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
       celz:
           HpAlloc = 24;   // CmmAssign
           goto celw;   // CmmBranch
       celw:
           R1 = _segl::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cely:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segl::P64;   // CmmStore
           _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segk_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celo::P64 = Hp - 16;   // CmmAssign
           R3 = _celo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segm_entry() //  [R1]
         { info_tbl: [(celA,
                       label: sat_segm_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celA:
           _segm::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
       celC:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
       celE:
           HpAlloc = 24;   // CmmAssign
           goto celB;   // CmmBranch
       celB:
           R1 = _segm::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segm::P64;   // CmmStore
           _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segl_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celk::P64 = Hp - 16;   // CmmAssign
           R2 = _celk::P64;   // CmmAssign
           R1 = Bag.$fDataBag_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segn_entry() //  [R1]
         { info_tbl: [(celF,
                       label: sat_segn_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       celF:
           _segn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
       celH:
           Hp = Hp + 248;   // CmmAssign
           if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
       celJ:
           HpAlloc = 248;   // CmmAssign
           goto celG;   // CmmBranch
       celG:
           R1 = _segn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segn::P64;   // CmmStore
           _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
           _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 240] = $dData_segd_info;   // CmmStore
           _cekz::P64 = Hp - 240;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 224] = $dData1_sege_info;   // CmmStore
           _cekG::P64 = Hp - 224;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 208] = $dData2_segf_info;   // CmmStore
           _cekN::P64 = Hp - 208;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 192] = $dData3_segg_info;   // CmmStore
           _cekU::P64 = Hp - 192;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 176] = $dData4_segh_info;   // CmmStore
           P64[Hp - 160] = _cekU::P64;   // CmmStore
           _cel1::P64 = Hp - 176;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 152] = $dData5_segi_info;   // CmmStore
           _cel8::P64 = Hp - 152;   // CmmAssign
           I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 120] = _cel8::P64;   // CmmStore
           P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 88] = _cekN::P64;   // CmmStore
           P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
           P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
           P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 48] = _cekG::P64;   // CmmStore
           P64[Hp - 40] = _cekz::P64;   // CmmStore
           P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
           P64[Hp - 24] = _cel1::P64;   // CmmStore
           _celf::P64 = Hp - 135;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segm_info;   // CmmStore
           P64[Hp] = _celf::P64;   // CmmStore
           _celg::P64 = Hp - 16;   // CmmAssign
           R3 = _sefS::P64;   // CmmAssign
           R2 = _celg::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg8_entry() //  [R1]
         { info_tbl: [(cem4,
                       label: sat_seg8_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem4:
           _seg8::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
       cem5:
           R1 = _seg8::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cem6:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg8::P64;   // CmmStore
           R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg9_entry() //  [R1]
         { info_tbl: [(cem7,
                       label: sat_seg9_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cem7:
           _seg9::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
       cem9:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
       cemb:
           HpAlloc = 16;   // CmmAssign
           goto cem8;   // CmmBranch
       cem8:
           R1 = _seg9::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cema:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg9::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg8_info;   // CmmStore
           _cem0::P64 = Hp - 8;   // CmmAssign
           R2 = _cem0::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg4_entry() //  [R1]
         { info_tbl: [(cems,
                       label: sat_seg4_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cems:
           _seg4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
       cemt:
           R1 = _seg4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg4::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg5_entry() //  [R1]
         { info_tbl: [(cemv,
                       label: sat_seg5_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemv:
           _seg5::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
       cemx:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
       cemz:
           HpAlloc = 16;   // CmmAssign
           goto cemw;   // CmmBranch
       cemw:
           R1 = _seg5::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg5::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg4_info;   // CmmStore
           _cemo::P64 = Hp - 8;   // CmmAssign
           R3 = _cemo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg6_entry() //  [R1]
         { info_tbl: [(cemA,
                       label: sat_seg6_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemA:
           _seg6::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
       cemC:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
       cemE:
           HpAlloc = 16;   // CmmAssign
           goto cemB;   // CmmBranch
       cemB:
           R1 = _seg6::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg6::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg5_info;   // CmmStore
           _cemk::P64 = Hp - 8;   // CmmAssign
           R2 = _cemk::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg7_entry() //  [R1]
         { info_tbl: [(cemF,
                       label: sat_seg7_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemF:
           _seg7::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
       cemH:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
       cemJ:
           HpAlloc = 16;   // CmmAssign
           goto cemG;   // CmmBranch
       cemG:
           R1 = _seg7::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg7::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg6_info;   // CmmStore
           _cemg::P64 = Hp - 8;   // CmmAssign
           R2 = _cemg::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg1_entry() //  [R1]
         { info_tbl: [(cemW,
                       label: sat_seg1_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemW:
           _seg1::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
       cemX:
           R1 = _seg1::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg1::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg2_entry() //  [R1]
         { info_tbl: [(cemZ,
                       label: sat_seg2_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cemZ:
           _seg2::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
       cen1:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
       cen3:
           HpAlloc = 16;   // CmmAssign
           goto cen0;   // CmmBranch
       cen0:
           R1 = _seg2::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg2::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg1_info;   // CmmStore
           _cemS::P64 = Hp - 8;   // CmmAssign
           R3 = _cemS::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg3_entry() //  [R1]
         { info_tbl: [(cen4,
                       label: sat_seg3_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cen4:
           _seg3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
       cen6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
       cen8:
           HpAlloc = 16;   // CmmAssign
           goto cen5;   // CmmBranch
       cen5:
           R1 = _seg3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg3::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg2_info;   // CmmStore
           _cemO::P64 = Hp - 8;   // CmmAssign
           R2 = _cemO::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefY_entry() //  [R1]
         { info_tbl: [(cenh,
                       label: sat_sefY_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenh:
           _sefY::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
       ceni:
           R1 = _sefY::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenj:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefY::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefX_entry() //  [R1]
         { info_tbl: [(ceno,
                       label: sat_sefX_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceno:
           _sefX::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
       cenp:
           R1 = _sefX::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenq:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefX::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg0_entry() //  [R1]
         { info_tbl: [(cens,
                       label: sat_seg0_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cens:
           _seg0::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
       cenu:
           Hp = Hp + 152;   // CmmAssign
           if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
       cenw:
           HpAlloc = 152;   // CmmAssign
           goto cent;   // CmmBranch
       cent:
           R1 = _seg0::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenv:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg0::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 144] = sat_sefY_info;   // CmmStore
           _cend::P64 = Hp - 144;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 128] = sat_sefX_info;   // CmmStore
           _cenk::P64 = Hp - 128;   // CmmAssign
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 96] = _cenk::P64;   // CmmStore
           P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 64] = _cend::P64;   // CmmStore
           P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenr::P64 = Hp - 111;   // CmmAssign
           R2 = _cenr::P64;   // CmmAssign
           R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sega_entry() //  [R1]
         { info_tbl: [(cenx,
                       label: sat_sega_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenx:
           _sega::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
       cenz:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
       cenB:
           HpAlloc = 64;   // CmmAssign
           goto ceny;   // CmmBranch
       ceny:
           R1 = _sega::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sega::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 56] = sat_seg9_info;   // CmmStore
           _celW::P64 = Hp - 56;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_seg7_info;   // CmmStore
           _cemc::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_seg3_info;   // CmmStore
           _cemK::P64 = Hp - 24;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg0_info;   // CmmStore
           _cen9::P64 = Hp - 8;   // CmmAssign
           R5 = _celW::P64;   // CmmAssign
           R4 = _cemc::P64;   // CmmAssign
           R3 = _cemK::P64;   // CmmAssign
           R2 = _cen9::P64;   // CmmAssign
           R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pppp_fast(R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segb_entry() //  [R1]
         { info_tbl: [(cenC,
                       label: sat_segb_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenC:
           _segb::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
       cenE:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
       cenG:
           HpAlloc = 16;   // CmmAssign
           goto cenD;   // CmmBranch
       cenD:
           R1 = _segb::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segb::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sega_info;   // CmmStore
           _celS::P64 = Hp - 8;   // CmmAssign
           R2 = _celS::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segc_entry() //  [R1]
         { info_tbl: [(cenH,
                       label: sat_segc_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenH:
           _segc::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
       cenJ:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
       cenL:
           HpAlloc = 16;   // CmmAssign
           goto cenI;   // CmmBranch
       cenI:
           R1 = _segc::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenK:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segc::P64;   // CmmStore
           _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
           _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segb_info;   // CmmStore
           _celO::P64 = Hp - 8;   // CmmAssign
           R3 = _sefR::P64;   // CmmAssign
           R2 = _celO::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefU_entry() //  [R1]
         { info_tbl: [(cenZ,
                       label: sat_sefU_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cenZ:
           _sefU::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
       ceo1:
           Hp = Hp + 120;   // CmmAssign
           if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
       ceo3:
           HpAlloc = 120;   // CmmAssign
           goto ceo0;   // CmmBranch
       ceo0:
           R1 = _sefU::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefU::P64;   // CmmStore
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
           P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenY::P64 = Hp - 111;   // CmmAssign
           R2 = _cenY::P64;   // CmmAssign
           R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefV_entry() //  [R1]
         { info_tbl: [(ceo4,
                       label: sat_sefV_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo4:
           _sefV::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
       ceo6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
       ceo8:
           HpAlloc = 16;   // CmmAssign
           goto ceo5;   // CmmBranch
       ceo5:
           R1 = _sefV::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefV::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefU_info;   // CmmStore
           _cenU::P64 = Hp - 8;   // CmmAssign
           R3 = _cenU::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerG_srtd" {
     uerG_srtd:
         const SehZ_srt;
         const 33;
         const 6979518925;
 },
 sat_sefW_entry() //  [R1]
         { info_tbl: [(ceo9,
                       label: sat_sefW_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceo9:
           _sefW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
       ceob:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
       ceod:
           HpAlloc = 16;   // CmmAssign
           goto ceoa;   // CmmBranch
       ceoa:
           R1 = _sefW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoc:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefW::P64;   // CmmStore
           _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
           _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefV_info;   // CmmStore
           _cenQ::P64 = Hp - 8;   // CmmAssign
           R3 = _sefQ::P64;   // CmmAssign
           R2 = _cenQ::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerH_srtd" {
     uerH_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 section ""relreadonly" . uerI_srtd" {
     uerI_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 sat_segp_entry() //  [R2, R1]
         { info_tbl: [(cekq,
                       label: block_cekq_info
                       rep:StackRep [False]),
                      (ceoe,
                       label: sat_segp_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoe:
           _sefO::P64 = R2;   // CmmAssign
           _segp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
       ceog:
           R2 = _sefO::P64;   // CmmAssign
           R1 = _segp::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoh:
           _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
           I64[Sp - 16] = cekq;   // CmmStore
           R1 = _sefO::P64;   // CmmAssign
           P64[Sp - 8] = _seeZ::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
       cekr:
           call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       cekq:
           _seeZ::P64 = P64[Sp + 8];   // CmmAssign
           _sefP::P64 = R1;   // CmmAssign
           Hp = Hp + 128;   // CmmAssign
           if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
       ceok:
           HpAlloc = 128;   // CmmAssign
           R1 = _sefP::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       ceoj:
           _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
           _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
           _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 120] = sat_segn_info;   // CmmStore
           P64[Hp - 104] = _seeZ::P64;   // CmmStore
           P64[Hp - 96] = _sefS::P64;   // CmmStore
           _cekv::P64 = Hp - 120;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 88] = sat_segc_info;   // CmmStore
           P64[Hp - 72] = _seeZ::P64;   // CmmStore
           P64[Hp - 64] = _sefR::P64;   // CmmStore
           _celK::P64 = Hp - 88;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 56] = sat_sefW_info;   // CmmStore
           P64[Hp - 40] = _seeZ::P64;   // CmmStore
           P64[Hp - 32] = _sefQ::P64;   // CmmStore
           _cenM::P64 = Hp - 56;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cenM::P64;   // CmmStore
           P64[Hp - 8] = _celK::P64;   // CmmStore
           P64[Hp] = _cekv::P64;   // CmmStore
           _ceof::P64 = Hp - 23;   // CmmAssign
           R3 = _ceof::P64;   // CmmAssign
           R2 = $dShow_reeF_closure;   // CmmAssign
           R1 = System.IO.print_closure;   // CmmAssign
           Sp = Sp + 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 mn_sefk_entry() //  [R1]
         { info_tbl: [(ceoG,
                       label: mn_sefk_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceoG:
           _sefk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
       ceoH:
           R1 = _sefk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefk::P64;   // CmmStore
           _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
           R2 = _seeY::P64;   // CmmAssign
           R1 = Module.mkModuleName_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefB_entry() //  [R1]
         { info_tbl: [(cepk,
                       label: sat_sefB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepk:
           _sefB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
       cepl:
           R1 = _sefB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepm:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefB::P64;   // CmmStore
           _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefA_entry() //  [R1]
         { info_tbl: [(cepr,
                       label: sat_sefA_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepr:
           _sefA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
       ceps:
           R1 = _sefA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cept:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefA::P64;   // CmmStore
           _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefz_entry() //  [R1]
         { info_tbl: [(cepy,
                       label: sat_sefz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepy:
           _sefz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
       cepz:
           R1 = _sefz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefz::P64;   // CmmStore
           _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
           R2 = _sefs::P64;   // CmmAssign
           R1 = GHC.pm_parsed_source_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefD_entry() //  [R2, R1]
         { info_tbl: [(cepC,
                       label: sat_sefD_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepC:
           _sefy::P64 = R2;   // CmmAssign
           _sefD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
       cepE:
           Hp = Hp + 104;   // CmmAssign
           if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
       cepG:
           HpAlloc = 104;   // CmmAssign
           goto cepD;   // CmmBranch
       cepD:
           R2 = _sefy::P64;   // CmmAssign
           R1 = _sefD::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepF:
           _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 96] = sat_sefB_info;   // CmmStore
           P64[Hp - 80] = _sefy::P64;   // CmmStore
           _cepg::P64 = Hp - 96;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 72] = sat_sefA_info;   // CmmStore
           P64[Hp - 56] = _sefy::P64;   // CmmStore
           _cepn::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = sat_sefz_info;   // CmmStore
           P64[Hp - 32] = _sefs::P64;   // CmmStore
           _cepu::P64 = Hp - 48;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cepu::P64;   // CmmStore
           P64[Hp - 8] = _cepn::P64;   // CmmStore
           P64[Hp] = _cepg::P64;   // CmmStore
           _cepB::P64 = Hp - 23;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cepB::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefx_entry() //  [R1]
         { info_tbl: [(cepL,
                       label: sat_sefx_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepL:
           _sefx::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
       cepM:
           R1 = _sefx::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepN:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefx::P64;   // CmmStore
           _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
           R4 = _sefw::P64;   // CmmAssign
           R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           R1 = GHC.loadModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefE_entry() //  [R2, R1]
         { info_tbl: [(cepO,
                       label: sat_sefE_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepO:
           _sefw::P64 = R2;   // CmmAssign
           _sefE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
       cepQ:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
       cepS:
           HpAlloc = 40;   // CmmAssign
           goto cepP;   // CmmBranch
       cepP:
           R2 = _sefw::P64;   // CmmAssign
           R1 = _sefE::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepR:
           _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefD_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cepb::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefx_info;   // CmmStore
           P64[Hp] = _sefw::P64;   // CmmStore
           _cepH::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepH::P64;   // CmmStore
           P64[Sp - 8] = _cepb::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefv_entry() //  [R1]
         { info_tbl: [(cepX,
                       label: sat_sefv_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cepX:
           _sefv::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
       cepY:
           R1 = _sefv::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepZ:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefv::P64;   // CmmStore
           _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
           R3 = _sefu::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.desugarModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefF_entry() //  [R2, R1]
         { info_tbl: [(ceq0,
                       label: sat_sefF_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq0:
           _sefu::P64 = R2;   // CmmAssign
           _sefF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
       ceq2:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
       ceq4:
           HpAlloc = 40;   // CmmAssign
           goto ceq1;   // CmmBranch
       ceq1:
           R2 = _sefu::P64;   // CmmAssign
           R1 = _sefF::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceq3:
           _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefE_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep6::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefv_info;   // CmmStore
           P64[Hp] = _sefu::P64;   // CmmStore
           _cepT::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepT::P64;   // CmmStore
           P64[Sp - 8] = _cep6::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seft_entry() //  [R1]
         { info_tbl: [(ceq9,
                       label: sat_seft_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceq9:
           _seft::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
       ceqa:
           R1 = _seft::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seft::P64;   // CmmStore
           _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
           R3 = _sefs::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.typecheckModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefG_entry() //  [R2, R1]
         { info_tbl: [(ceqc,
                       label: sat_sefG_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqc:
           _sefs::P64 = R2;   // CmmAssign
           _sefG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
       ceqe:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
       ceqg:
           HpAlloc = 40;   // CmmAssign
           goto ceqd;   // CmmBranch
       ceqd:
           R2 = _sefs::P64;   // CmmAssign
           R1 = _sefG::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqf:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefF_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep1::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seft_info;   // CmmStore
           P64[Hp] = _sefs::P64;   // CmmStore
           _ceq5::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceq5::P64;   // CmmStore
           P64[Sp - 8] = _cep1::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefr_entry() //  [R1]
         { info_tbl: [(ceql,
                       label: sat_sefr_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceql:
           _sefr::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
       ceqm:
           R1 = _sefr::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefr::P64;   // CmmStore
           _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
           R3 = _sefq::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.parseModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefH_entry() //  [R2, R1]
         { info_tbl: [(ceqo,
                       label: sat_sefH_info
                       rep:HeapRep 1 nonptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqo:
           _sefq::P64 = R2;   // CmmAssign
           _sefH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
       ceqq:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
       ceqs:
           HpAlloc = 40;   // CmmAssign
           goto ceqp;   // CmmBranch
       ceqp:
           R2 = _sefq::P64;   // CmmAssign
           R1 = _sefH::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqr:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefG_info;   // CmmStore
           _ceoW::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefr_info;   // CmmStore
           P64[Hp] = _sefq::P64;   // CmmStore
           _ceqh::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceqh::P64;   // CmmStore
           P64[Sp - 8] = _ceoW::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefp_entry() //  [R1]
         { info_tbl: [(ceqx,
                       label: sat_sefp_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqx:
           _sefp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
       ceqy:
           R1 = _sefp::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefp::P64;   // CmmStore
           _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
           R3 = _sefk::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.getModSummary_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefI_entry() //  [R1]
         { info_tbl: [(ceqA,
                       label: sat_sefI_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqA:
           _sefI::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
       ceqC:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
       ceqE:
           HpAlloc = 40;   // CmmAssign
           goto ceqB;   // CmmBranch
       ceqB:
           R1 = _sefI::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefI::P64;   // CmmStore
           _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefH_info;   // CmmStore
           _ceoR::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefp_info;   // CmmStore
           P64[Hp] = _sefk::P64;   // CmmStore
           _ceqt::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqt::P64;   // CmmStore
           P64[Sp - 24] = _ceoR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefo_entry() //  [R1]
         { info_tbl: [(ceqJ,
                       label: sat_sefo_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqJ:
           _sefo::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
       ceqK:
           R1 = _sefo::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqL:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefo::P64;   // CmmStore
           R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMake.load_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefJ_entry() //  [R1]
         { info_tbl: [(ceqM,
                       label: sat_sefJ_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqM:
           _sefJ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
       ceqO:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
       ceqQ:
           HpAlloc = 40;   // CmmAssign
           goto ceqN;   // CmmBranch
       ceqN:
           R1 = _sefJ::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefJ::P64;   // CmmStore
           _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefI_info;   // CmmStore
           P64[Hp - 16] = _sefk::P64;   // CmmStore
           _ceoN::P64 = Hp - 32;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefo_info;   // CmmStore
           _ceqF::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqF::P64;   // CmmStore
           P64[Sp - 24] = _ceoN::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefn_entry() //  [R1]
         { info_tbl: [(ceqX,
                       label: sat_sefn_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       ceqX:
           _sefn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
       ceqZ:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
       cer1:
           HpAlloc = 48;   // CmmAssign
           goto ceqY;   // CmmBranch
       ceqY:
           R1 = _sefn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefn::P64;   // CmmStore
           _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
           I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
           P64[Hp - 32] = _sefk::P64;   // CmmStore
           _ceqV::P64 = Hp - 39;   // CmmAssign
           I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
           P64[Hp - 16] = _ceqV::P64;   // CmmStore
           P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
           P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
           _ceqW::P64 = Hp - 23;   // CmmAssign
           R3 = _ceqW::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.addTarget_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefK_entry() //  [R1]
         { info_tbl: [(cer2,
                       label: sat_sefK_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cer2:
           _sefK::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
       cer4:
           Hp = Hp + 72;   // CmmAssign
           if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
       cer6:
           HpAlloc = 72;   // CmmAssign
           goto cer3;   // CmmBranch
       cer3:
           R1 = _sefK::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer5:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefK::P64;   // CmmStore
           _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 64] = mn_sefk_info;   // CmmStore
           P64[Hp - 48] = _seeY::P64;   // CmmStore
           _ceoC::P64 = Hp - 64;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefJ_info;   // CmmStore
           P64[Hp - 24] = _ceoC::P64;   // CmmStore
           _ceoJ::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefn_info;   // CmmStore
           P64[Hp] = _ceoC::P64;   // CmmStore
           _ceqR::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqR::P64;   // CmmStore
           P64[Sp - 24] = _ceoJ::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefj_entry() //  [R1]
         { info_tbl: [(cerb,
                       label: sat_sefj_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerb:
           _sefj::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
       cerc:
           R1 = _sefj::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerd:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefj::P64;   // CmmStore
           _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
           R3 = _sefi::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefL_entry() //  [R2, R1]
         { info_tbl: [(cere,
                       label: sat_sefL_info
                       rep:HeapRep 1 ptrs { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cere:
           _sefi::P64 = R2;   // CmmAssign
           _sefL::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
       cerg:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
       ceri:
           HpAlloc = 48;   // CmmAssign
           goto cerf;   // CmmBranch
       cerf:
           R2 = _sefi::P64;   // CmmAssign
           R1 = _sefL::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerh:
           _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefK_info;   // CmmStore
           P64[Hp - 24] = _seeY::P64;   // CmmStore
           _ceoy::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefj_info;   // CmmStore
           P64[Hp] = _sefi::P64;   // CmmStore
           _cer7::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cer7::P64;   // CmmStore
           P64[Sp - 8] = _ceoy::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefh_entry() //  [R1]
         { info_tbl: [(cern,
                       label: sat_sefh_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cern:
           _sefh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
       cero:
           R1 = _sefh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerp:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefh::P64;   // CmmStore
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefM_entry() //  [R1]
         { info_tbl: [(cerq,
                       label: sat_sefM_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerq:
           _sefM::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
       cers:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
       ceru:
           HpAlloc = 32;   // CmmAssign
           goto cerr;   // CmmBranch
       cerr:
           R1 = _sefM::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cert:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefM::P64;   // CmmStore
           _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefL_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceot::P64 = Hp - 23;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefh_info;   // CmmStore
           _cerj::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cerj::P64;   // CmmStore
           P64[Sp - 24] = _ceot::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefN_entry() //  [R1]
         { info_tbl: [(cerw,
                       label: sat_sefN_info
                       rep:HeapRep 2 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerw:
           _sefN::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
       cery:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
       cerA:
           HpAlloc = 40;   // CmmAssign
           goto cerx;   // CmmBranch
       cerx:
           R1 = _sefN::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefN::P64;   // CmmStore
           _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
           _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefM_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceop::P64 = Hp - 32;   // CmmAssign
           I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
           P64[Hp] = _seeX::P64;   // CmmStore
           _cerv::P64 = Hp - 6;   // CmmAssign
           R3 = _ceop::P64;   // CmmAssign
           R2 = _cerv::P64;   // CmmAssign
           R1 = GHC.runGhc_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerJ_srtd" {
     uerJ_srtd:
         const SehZ_srt;
         const 52;
         const 4503599627370445;
 },
 Main.testOneFile_entry() //  [R3, R2]
         { info_tbl: [(cerB,
                       label: Main.testOneFile_info
                       rep:HeapRep static { Fun {arity: 2 fun_type: ArgSpec 15} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cerB:
           _seeY::P64 = R3;   // CmmAssign
           _seeX::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
       cerD:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
       cerF:
           HpAlloc = 64;   // CmmAssign
           goto cerC;   // CmmBranch
       cerC:
           R3 = _seeY::P64;   // CmmAssign
           R2 = _seeX::P64;   // CmmAssign
           R1 = Main.testOneFile_closure;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerE:
           // calling allocDynClosure
           I64[Hp - 56] = gq_seeZ_info;   // CmmStore
           _ceiW::P64 = Hp - 54;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segp_info;   // CmmStore
           P64[Hp - 32] = _ceiW::P64;   // CmmStore
           _cekl::P64 = Hp - 39;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefN_info;   // CmmStore
           P64[Hp - 8] = _seeX::P64;   // CmmStore
           P64[Hp] = _seeY::P64;   // CmmStore
           _ceol::P64 = Hp - 24;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceol::P64;   // CmmStore
           P64[Sp - 8] = _cekl::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . Main.testOneFile_closure" {
     Main.testOneFile_closure:
         const Main.testOneFile_info;
         const 0;
 },
 $dTypeable_sef3_entry() //  [R1]
         { [(ceje,
             $dTypeable_sef3_info:
                 const 1;
                 const 17;)]
         }
     {offset
       ceje:
           _sef3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
       cejf:
           R1 = _sef3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejg:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef3::P64;   // CmmStore
           _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
           R2 = _sef2::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 ds_sef4_entry() //  [R1]
         { [(cejl,
             ds_sef4_info:
                 const SehZ_srt-ds_sef4_info+48;
                 const 0;
                 const 12884901904;)]
         }
     {offset
       cejl:
           _sef4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
       cejm:
           R1 = _sef4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sef4::P64;   // CmmStore
           R4 = GHC.Types.[]_closure+1;   // CmmAssign
           R3 = GHC.Types.[]_closure+1;   // CmmAssign
           R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
           R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 a4_sef5_entry() //  [R1]
         { [(cejt,
             a4_sef5_info:
                 const 4294967299;
                 const 1;
                 const 10;)]
         }
     {offset
       cejt:
           _sef5::P64 = R1;   // CmmAssign
           goto cejv;   // CmmBranch
       cejv:
           _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
           R1 = _sef4::P64 & (-8);   // CmmAssign
           call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefd_entry() //  [R2, R1]
         { [(cejB,
             block_cejB_info:
                 const 0;
                 const 32;),
            (cejH,
             sat_sefd_info:
                 const SehZ_srt-sat_sefd_info;
                 const 4294967301;
                 const 2;
                 const 4294967308;),
            (cejP,
             block_cejP_info:
                 const 0;
                 const 32;)]
         }
     {offset
       cejH:
           _sef7::P64 = R2;   // CmmAssign
           _sefd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 16 < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
       cejI:
           R2 = _sef7::P64;   // CmmAssign
           R1 = _sefd::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejJ:
           _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
           _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
           I64[Sp - 8] = cejB;   // CmmStore
           R4 = _sef7::P64;   // CmmAssign
           R3 = _sef5::P64;   // CmmAssign
           R2 = _sef3::P64;   // CmmAssign
           R1 = Data.Typeable.cast_closure;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
       cejB:
           _sef8::P64 = R1;   // CmmAssign
           _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
           if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
       cejF:
           _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
           I64[Sp] = cejP;   // CmmStore
           R1 = _sef9::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
       cejR:
           call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejP:
           _sefa::P64 = R1;   // CmmAssign
           _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
           if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
       cek4:
           _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejX:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto cek0; else goto cejZ;   // CmmCondBranch
       cek0:
           HpAlloc = 24;   // CmmAssign
           R1 = _sefa::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
       cejZ:
           _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
           I64[Hp - 16] = :_con_info;   // CmmStore
           P64[Hp - 8] = _sefa::P64;   // CmmStore
           P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
           _cejV::P64 = Hp - 14;   // CmmAssign
           R1 = _cejV::P64;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cejE:
           R1 = []_closure+1;   // CmmAssign
           Sp = Sp + 8;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefe_entry() //  [R2, R1]
         { [(cek6,
             sat_sefe_info:
                 const SehZ_srt-sat_sefe_info;
                 const 4294967301;
                 const 4294967296;
                 const 828928688139;)]
         }
     {offset
       cek6:
           _sef2::P64 = R2;   // CmmAssign
           _sefe::P64 = R1;   // CmmAssign
           goto cek8;   // CmmBranch
       cek8:
           Hp = Hp + 80;   // CmmAssign
           if (Hp > HpLim) goto ceka; else goto cek9;   // CmmCondBranch
       ceka:
           HpAlloc = 80;   // CmmAssign
           goto cek7;   // CmmBranch
       cek7:
           R2 = _sef2::P64;   // CmmAssign
           R1 = _sefe::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cek9:
           // calling allocDynClosure
           I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
           P64[Hp - 56] = _sef2::P64;   // CmmStore
           _ceja::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = ds_sef4_info;   // CmmStore
           _cejh::P64 = Hp - 48;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = a4_sef5_info;   // CmmStore
           P64[Hp - 24] = _cejh::P64;   // CmmStore
           _cejo::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefd_info;   // CmmStore
           P64[Hp - 8] = _ceja::P64;   // CmmStore
           P64[Hp] = _cejo::P64;   // CmmStore
           _cejw::P64 = Hp - 15;   // CmmAssign
           R1 = _cejw::P64;   // CmmAssign
           call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seff_entry() //  [R1]
         { [(cekb,
             sat_seff_info:
                 const SehZ_srt-sat_seff_info;
                 const 2;
                 const 1945620185107;)]
         }
     {offset
       cekb:
           _seff::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
       cekd:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cekf; else goto ceke;   // CmmCondBranch
       cekf:
           HpAlloc = 16;   // CmmAssign
           goto cekc;   // CmmBranch
       cekc:
           R1 = _seff::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceke:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seff::P64;   // CmmStore
           _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
           _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefe_info;   // CmmStore
           _cej5::P64 = Hp - 7;   // CmmAssign
           R5 = _sef1::P64;   // CmmAssign
           R4 = _sef0::P64;   // CmmAssign
           R3 = _cej5::P64;   // CmmAssign
           R2 = GHC.Base.++_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.everything_info(R5,
                                     R4,
                                     R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 gq_seeZ_entry() //  [R3, R2, R1]
         { [(cekg,
             gq_seeZ_info:
                 const SehZ_srt-gq_seeZ_info;
                 const 8589934607;
                 const 4294967296;
                 const 1979979923467;)]
         }
     {offset
       cekg:
           _sef1::P64 = R3;   // CmmAssign
           _sef0::P64 = R2;   // CmmAssign
           _seeZ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
       ceki:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto cekk; else goto cekj;   // CmmCondBranch
       cekk:
           HpAlloc = 32;   // CmmAssign
           goto cekh;   // CmmBranch
       cekh:
           R3 = _sef1::P64;   // CmmAssign
           R2 = _sef0::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekj:
           // calling allocDynClosure
           I64[Hp - 24] = sat_seff_info;   // CmmStore
           P64[Hp - 8] = _sef0::P64;   // CmmStore
           P64[Hp] = _sef1::P64;   // CmmStore
           _cej1::P64 = Hp - 24;   // CmmAssign
           R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cej1::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 $dData_segd_entry() //  [R1]
         { [(cekD,
             $dData_segd_info:
                 const SehZ_srt-$dData_segd_info+72;
                 const 0;
                 const 12884901904;)]
         }
     {offset
       cekD:
           _segd::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
       cekE:
           R1 = _segd::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segd::P64;   // CmmStore
           R2 = ConLike.$fDataConLike_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData1_sege_entry() //  [R1]
         { [(cekK,
             $dData1_sege_info:
                 const SehZ_srt-$dData1_sege_info+72;
                 const 0;
                 const 21474836496;)]
         }
     {offset
       cekK:
           _sege::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
       cekL:
           R1 = _sege::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekM:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sege::P64;   // CmmStore
           R2 = TypeRep.$fDataType_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData2_segf_entry() //  [R1]
         { [(cekR,
             $dData2_segf_info:
                 const SehZ_srt-$dData2_segf_info+72;
                 const 0;
                 const 38654705680;)]
         }
     {offset
       cekR:
           _segf::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
       cekS:
           R1 = _segf::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cekT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segf::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData3_segg_entry() //  [R1]
         { [(cekY,
             $dData3_segg_info:
                 const SehZ_srt-$dData3_segg_info+96;
                 const 0;
                 const 12884901904;)]
         }
     {offset
       cekY:
           _segg::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
       cekZ:
           R1 = _segg::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segg::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData4_segh_entry() //  [R1]
         { [(cel5,
             $dData4_segh_info:
                 const SehZ_srt-$dData4_segh_info+72;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       cel5:
           _segh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
       cel6:
           R1 = _segh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cel7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segh::P64;   // CmmStore
           _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
           R2 = _segg::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 $dData5_segi_entry() //  [R1]
         { [(celc,
             $dData5_segi_info:
                 const SehZ_srt-$dData5_segi_info+96;
                 const 0;
                 const 21474836496;)]
         }
     {offset
       celc:
           _segi::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celd; else goto cele;   // CmmCondBranch
       celd:
           R1 = _segi::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cele:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segi::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segk_entry() //  [R1]
         { [(cels,
             sat_segk_info:
                 const SehZ_srt-sat_segk_info+120;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       cels:
           _segk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celt; else goto celu;   // CmmCondBranch
       celt:
           R1 = _segk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segk::P64;   // CmmStore
           _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
           R3 = _segj::P64;   // CmmAssign
           R2 = _segj::P64;   // CmmAssign
           R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segl_entry() //  [R1]
         { [(celv,
             sat_segl_info:
                 const SehZ_srt-sat_segl_info+120;
                 const 1;
                 const 30064771089;)]
         }
     {offset
       celv:
           _segl::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celw; else goto celx;   // CmmCondBranch
       celx:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celz; else goto cely;   // CmmCondBranch
       celz:
           HpAlloc = 24;   // CmmAssign
           goto celw;   // CmmBranch
       celw:
           R1 = _segl::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cely:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segl::P64;   // CmmStore
           _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segk_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celo::P64 = Hp - 16;   // CmmAssign
           R3 = _celo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segm_entry() //  [R1]
         { [(celA,
             sat_segm_info:
                 const SehZ_srt-sat_segm_info+120;
                 const 1;
                 const 64424509457;)]
         }
     {offset
       celA:
           _segm::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celB; else goto celC;   // CmmCondBranch
       celC:
           Hp = Hp + 24;   // CmmAssign
           if (Hp > HpLim) goto celE; else goto celD;   // CmmCondBranch
       celE:
           HpAlloc = 24;   // CmmAssign
           goto celB;   // CmmBranch
       celB:
           R1 = _segm::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segm::P64;   // CmmStore
           _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segl_info;   // CmmStore
           P64[Hp] = _segj::P64;   // CmmStore
           _celk::P64 = Hp - 16;   // CmmAssign
           R2 = _celk::P64;   // CmmAssign
           R1 = Bag.$fDataBag_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segn_entry() //  [R1]
         { [(celF,
             sat_segn_info:
                 const SehZ_srt-sat_segn_info;
                 const 2;
                 const 72057374994595859;)]
         }
     {offset
       celF:
           _segn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto celG; else goto celH;   // CmmCondBranch
       celH:
           Hp = Hp + 248;   // CmmAssign
           if (Hp > HpLim) goto celJ; else goto celI;   // CmmCondBranch
       celJ:
           HpAlloc = 248;   // CmmAssign
           goto celG;   // CmmBranch
       celG:
           R1 = _segn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       celI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segn::P64;   // CmmStore
           _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
           _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 240] = $dData_segd_info;   // CmmStore
           _cekz::P64 = Hp - 240;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 224] = $dData1_sege_info;   // CmmStore
           _cekG::P64 = Hp - 224;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 208] = $dData2_segf_info;   // CmmStore
           _cekN::P64 = Hp - 208;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 192] = $dData3_segg_info;   // CmmStore
           _cekU::P64 = Hp - 192;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 176] = $dData4_segh_info;   // CmmStore
           P64[Hp - 160] = _cekU::P64;   // CmmStore
           _cel1::P64 = Hp - 176;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 152] = $dData5_segi_info;   // CmmStore
           _cel8::P64 = Hp - 152;   // CmmAssign
           I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 120] = _cel8::P64;   // CmmStore
           P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 88] = _cekN::P64;   // CmmStore
           P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
           P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
           P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
           P64[Hp - 48] = _cekG::P64;   // CmmStore
           P64[Hp - 40] = _cekz::P64;   // CmmStore
           P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
           P64[Hp - 24] = _cel1::P64;   // CmmStore
           _celf::P64 = Hp - 135;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segm_info;   // CmmStore
           P64[Hp] = _celf::P64;   // CmmStore
           _celg::P64 = Hp - 16;   // CmmAssign
           R3 = _sefS::P64;   // CmmAssign
           R2 = _celg::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg8_entry() //  [R1]
         { [(cem4,
             sat_seg8_info:
                 const SehZ_srt-sat_seg8_info+128;
                 const 0;
                 const 1112396529680;)]
         }
     {offset
       cem4:
           _seg8::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
       cem5:
           R1 = _seg8::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cem6:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg8::P64;   // CmmStore
           R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg9_entry() //  [R1]
         { [(cem7,
             sat_seg9_info:
                 const SehZ_srt-sat_seg9_info+128;
                 const 0;
                 const 3311419785232;)]
         }
     {offset
       cem7:
           _seg9::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
       cem9:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemb; else goto cema;   // CmmCondBranch
       cemb:
           HpAlloc = 16;   // CmmAssign
           goto cem8;   // CmmBranch
       cem8:
           R1 = _seg9::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cema:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg9::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg8_info;   // CmmStore
           _cem0::P64 = Hp - 8;   // CmmAssign
           R2 = _cem0::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg4_entry() //  [R1]
         { [(cems,
             sat_seg4_info:
                 const SehZ_srt-sat_seg4_info+96;
                 const 0;
                 const 70373039144976;)]
         }
     {offset
       cems:
           _seg4::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
       cemt:
           R1 = _seg4::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemu:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg4::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg5_entry() //  [R1]
         { [(cemv,
             sat_seg5_info:
                 const SehZ_srt-sat_seg5_info+96;
                 const 0;
                 const 70579197575184;)]
         }
     {offset
       cemv:
           _seg5::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
       cemx:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemz; else goto cemy;   // CmmCondBranch
       cemz:
           HpAlloc = 16;   // CmmAssign
           goto cemw;   // CmmBranch
       cemw:
           R1 = _seg5::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg5::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg4_info;   // CmmStore
           _cemo::P64 = Hp - 8;   // CmmAssign
           R3 = _cemo::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg6_entry() //  [R1]
         { [(cemA,
             sat_seg6_info:
                 const SehZ_srt-sat_seg6_info+72;
                 const 0;
                 const 564637875568656;)]
         }
     {offset
       cemA:
           _seg6::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
       cemC:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemE; else goto cemD;   // CmmCondBranch
       cemE:
           HpAlloc = 16;   // CmmAssign
           goto cemB;   // CmmBranch
       cemB:
           R1 = _seg6::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg6::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg5_info;   // CmmStore
           _cemk::P64 = Hp - 8;   // CmmAssign
           R2 = _cemk::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg7_entry() //  [R1]
         { [(cemF,
             sat_seg7_info:
                 const SehZ_srt-sat_seg7_info+72;
                 const 0;
                 const 846112852279312;)]
         }
     {offset
       cemF:
           _seg7::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
       cemH:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cemJ; else goto cemI;   // CmmCondBranch
       cemJ:
           HpAlloc = 16;   // CmmAssign
           goto cemG;   // CmmBranch
       cemG:
           R1 = _seg7::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg7::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg6_info;   // CmmStore
           _cemg::P64 = Hp - 8;   // CmmAssign
           R2 = _cemg::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg1_entry() //  [R1]
         { [(cemW,
             sat_seg1_info:
                 const SehZ_srt-sat_seg1_info+96;
                 const 0;
                 const 140741783322640;)]
         }
     {offset
       cemW:
           _seg1::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
       cemX:
           R1 = _seg1::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cemY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg1::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg2_entry() //  [R1]
         { [(cemZ,
             sat_seg2_info:
                 const SehZ_srt-sat_seg2_info+96;
                 const 0;
                 const 140947941752848;)]
         }
     {offset
       cemZ:
           _seg2::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
       cen1:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen3; else goto cen2;   // CmmCondBranch
       cen3:
           HpAlloc = 16;   // CmmAssign
           goto cen0;   // CmmBranch
       cen0:
           R1 = _seg2::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg2::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg1_info;   // CmmStore
           _cemS::P64 = Hp - 8;   // CmmAssign
           R3 = _cemS::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg3_entry() //  [R1]
         { [(cen4,
             sat_seg3_info:
                 const SehZ_srt-sat_seg3_info+72;
                 const 0;
                 const 1127587828989968;)]
         }
     {offset
       cen4:
           _seg3::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
       cen6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cen8; else goto cen7;   // CmmCondBranch
       cen8:
           HpAlloc = 16;   // CmmAssign
           goto cen5;   // CmmBranch
       cen5:
           R1 = _seg3::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cen7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg3::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg2_info;   // CmmStore
           _cemO::P64 = Hp - 8;   // CmmAssign
           R2 = _cemO::P64;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefY_entry() //  [R1]
         { [(cenh,
             sat_sefY_info:
                 const SehZ_srt-sat_sefY_info+72;
                 const 0;
                 const 38654705680;)]
         }
     {offset
       cenh:
           _sefY::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
       ceni:
           R1 = _sefY::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenj:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefY::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = Data.Data.$fData[]_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefX_entry() //  [R1]
         { [(ceno,
             sat_sefX_info:
                 const SehZ_srt-sat_sefX_info+96;
                 const 0;
                 const 21474836496;)]
         }
     {offset
       ceno:
           _sefX::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
       cenp:
           R1 = _sefX::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenq:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefX::P64;   // CmmStore
           R2 = Name.$fDataName_closure;   // CmmAssign
           R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_seg0_entry() //  [R1]
         { [(cens,
             sat_seg0_info:
                 const SehZ_srt-sat_seg0_info+72;
                 const 0;
                 const 6768769674248208;)]
         }
     {offset
       cens:
           _seg0::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cent; else goto cenu;   // CmmCondBranch
       cenu:
           Hp = Hp + 152;   // CmmAssign
           if (Hp > HpLim) goto cenw; else goto cenv;   // CmmCondBranch
       cenw:
           HpAlloc = 152;   // CmmAssign
           goto cent;   // CmmBranch
       cent:
           R1 = _seg0::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenv:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seg0::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 144] = sat_sefY_info;   // CmmStore
           _cend::P64 = Hp - 144;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 128] = sat_sefX_info;   // CmmStore
           _cenk::P64 = Hp - 128;   // CmmAssign
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 96] = _cenk::P64;   // CmmStore
           P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
           P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
           P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 64] = _cend::P64;   // CmmStore
           P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenr::P64 = Hp - 111;   // CmmAssign
           R2 = _cenr::P64;   // CmmAssign
           R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sega_entry() //  [R1]
         { [(cenx,
             sat_sega_info:
                 const SehZ_srt-sat_sega_info+72;
                 const 0;
                 const 17888680521760784;)]
         }
     {offset
       cenx:
           _sega::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
       cenz:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cenB; else goto cenA;   // CmmCondBranch
       cenB:
           HpAlloc = 64;   // CmmAssign
           goto ceny;   // CmmBranch
       ceny:
           R1 = _sega::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sega::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 56] = sat_seg9_info;   // CmmStore
           _celW::P64 = Hp - 56;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_seg7_info;   // CmmStore
           _cemc::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_seg3_info;   // CmmStore
           _cemK::P64 = Hp - 24;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_seg0_info;   // CmmStore
           _cen9::P64 = Hp - 8;   // CmmAssign
           R5 = _celW::P64;   // CmmAssign
           R4 = _cemc::P64;   // CmmAssign
           R3 = _cemK::P64;   // CmmAssign
           R2 = _cen9::P64;   // CmmAssign
           R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pppp_fast(R5,
                                 R4,
                                 R3,
                                 R2,
                                 R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segb_entry() //  [R1]
         { [(cenC,
             sat_segb_info:
                 const SehZ_srt-sat_segb_info+72;
                 const 0;
                 const 17888680521760784;)]
         }
     {offset
       cenC:
           _segb::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
       cenE:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenG; else goto cenF;   // CmmCondBranch
       cenG:
           HpAlloc = 16;   // CmmAssign
           goto cenD;   // CmmBranch
       cenD:
           R1 = _segb::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenF:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segb::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sega_info;   // CmmStore
           _celS::P64 = Hp - 8;   // CmmAssign
           R2 = _celS::P64;   // CmmAssign
           R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segc_entry() //  [R1]
         { [(cenH,
             sat_segc_info:
                 const SehZ_srt-sat_segc_info;
                 const 2;
                 const 9159006407121436691;)]
         }
     {offset
       cenH:
           _segc::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
       cenJ:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cenL; else goto cenK;   // CmmCondBranch
       cenL:
           HpAlloc = 16;   // CmmAssign
           goto cenI;   // CmmBranch
       cenI:
           R1 = _segc::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cenK:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segc::P64;   // CmmStore
           _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
           _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segb_info;   // CmmStore
           _celO::P64 = Hp - 8;   // CmmAssign
           R3 = _sefR::P64;   // CmmAssign
           R2 = _celO::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefU_entry() //  [R1]
         { [(cenZ,
             sat_sefU_info:
                 const SehZ_srt-sat_sefU_info+232;
                 const 0;
                 const 55834574864;)]
         }
     {offset
       cenZ:
           _sefU::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
       ceo1:
           Hp = Hp + 120;   // CmmAssign
           if (Hp > HpLim) goto ceo3; else goto ceo2;   // CmmCondBranch
       ceo3:
           HpAlloc = 120;   // CmmAssign
           goto ceo0;   // CmmBranch
       ceo0:
           R1 = _sefU::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo2:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefU::P64;   // CmmStore
           I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
           P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
           P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
           _cenY::P64 = Hp - 111;   // CmmAssign
           R2 = _cenY::P64;   // CmmAssign
           R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefV_entry() //  [R1]
         { [(ceo4,
             sat_sefV_info:
                 const SehZ_srt-sat_sefV_info+128;
                 const 0;
                 const 457409722056720;)]
         }
     {offset
       ceo4:
           _sefV::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
       ceo6:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceo8; else goto ceo7;   // CmmCondBranch
       ceo8:
           HpAlloc = 16;   // CmmAssign
           goto ceo5;   // CmmBranch
       ceo5:
           R1 = _sefV::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceo7:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefV::P64;   // CmmStore
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefU_info;   // CmmStore
           _cenU::P64 = Hp - 8;   // CmmAssign
           R3 = _cenU::P64;   // CmmAssign
           R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
           R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerG_srtd" {
     uerG_srtd:
         const SehZ_srt;
         const 33;
         const 6979518925;
 },
 sat_sefW_entry() //  [R1]
         { [(ceo9,
             sat_sefW_info:
                 const uerG_srtd-sat_sefW_info;
                 const 2;
                 const 18446744069414584339;)]
         }
     {offset
       ceo9:
           _sefW::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
       ceob:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto ceod; else goto ceoc;   // CmmCondBranch
       ceod:
           HpAlloc = 16;   // CmmAssign
           goto ceoa;   // CmmBranch
       ceoa:
           R1 = _sefW::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoc:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefW::P64;   // CmmStore
           _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
           _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefV_info;   // CmmStore
           _cenQ::P64 = Hp - 8;   // CmmAssign
           R3 = _sefQ::P64;   // CmmAssign
           R2 = _cenQ::P64;   // CmmAssign
           R1 = _seeZ::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call gq_seeZ_info(R3,
                             R2,
                             R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerH_srtd" {
     uerH_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 section ""relreadonly" . uerI_srtd" {
     uerI_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;
 },
 sat_segp_entry() //  [R2, R1]
         { [(cekq,
             block_cekq_info:
                 const uerH_srtd-block_cekq_info;
                 const 1;
                 const 18446744069414584352;),
            (ceoe,
             sat_segp_info:
                 const uerI_srtd-sat_segp_info;
                 const 4294967301;
                 const 1;
                 const 18446744069414584330;)]
         }
     {offset
       ceoe:
           _sefO::P64 = R2;   // CmmAssign
           _segp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
       ceog:
           R2 = _sefO::P64;   // CmmAssign
           R1 = _segp::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoh:
           _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
           I64[Sp - 16] = cekq;   // CmmStore
           R1 = _sefO::P64;   // CmmAssign
           P64[Sp - 8] = _seeZ::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
       cekr:
           call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       cekq:
           _seeZ::P64 = P64[Sp + 8];   // CmmAssign
           _sefP::P64 = R1;   // CmmAssign
           Hp = Hp + 128;   // CmmAssign
           if (Hp > HpLim) goto ceok; else goto ceoj;   // CmmCondBranch
       ceok:
           HpAlloc = 128;   // CmmAssign
           R1 = _sefP::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
       ceoj:
           _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
           _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
           _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 120] = sat_segn_info;   // CmmStore
           P64[Hp - 104] = _seeZ::P64;   // CmmStore
           P64[Hp - 96] = _sefS::P64;   // CmmStore
           _cekv::P64 = Hp - 120;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 88] = sat_segc_info;   // CmmStore
           P64[Hp - 72] = _seeZ::P64;   // CmmStore
           P64[Hp - 64] = _sefR::P64;   // CmmStore
           _celK::P64 = Hp - 88;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 56] = sat_sefW_info;   // CmmStore
           P64[Hp - 40] = _seeZ::P64;   // CmmStore
           P64[Hp - 32] = _sefQ::P64;   // CmmStore
           _cenM::P64 = Hp - 56;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cenM::P64;   // CmmStore
           P64[Hp - 8] = _celK::P64;   // CmmStore
           P64[Hp] = _cekv::P64;   // CmmStore
           _ceof::P64 = Hp - 23;   // CmmAssign
           R3 = _ceof::P64;   // CmmAssign
           R2 = $dShow_reeF_closure;   // CmmAssign
           R1 = System.IO.print_closure;   // CmmAssign
           Sp = Sp + 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 8, res: 0, upd: 8;   // CmmCall
     }
 },
 mn_sefk_entry() //  [R1]
         { [(ceoG,
             mn_sefk_info:
                 const SehZ_srt-mn_sefk_info+280;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       ceoG:
           _sefk::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
       ceoH:
           R1 = _sefk::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceoI:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefk::P64;   // CmmStore
           _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
           R2 = _seeY::P64;   // CmmAssign
           R1 = Module.mkModuleName_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefB_entry() //  [R1]
         { [(cepk,
             sat_sefB_info:
                 const SehZ_srt-sat_sefB_info+288;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       cepk:
           _sefB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
       cepl:
           R1 = _sefB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepm:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefB::P64;   // CmmStore
           _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefA_entry() //  [R1]
         { [(cepr,
             sat_sefA_info:
                 const SehZ_srt-sat_sefA_info+288;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       cepr:
           _sefA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 40 < SpLim) goto ceps; else goto cept;   // CmmCondBranch
       ceps:
           R1 = _sefA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cept:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefA::P64;   // CmmStore
           _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           I64[Sp - 32] = stg_ap_p_info;   // CmmStore
           P64[Sp - 24] = _sefy::P64;   // CmmStore
           Sp = Sp - 32;   // CmmAssign
           call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefz_entry() //  [R1]
         { [(cepy,
             sat_sefz_info:
                 const SehZ_srt-sat_sefz_info+296;
                 const 1;
                 const 4294967313;)]
         }
     {offset
       cepy:
           _sefz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
       cepz:
           R1 = _sefz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepA:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefz::P64;   // CmmStore
           _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
           R2 = _sefs::P64;   // CmmAssign
           R1 = GHC.pm_parsed_source_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefD_entry() //  [R2, R1]
         { [(cepC,
             sat_sefD_info:
                 const SehZ_srt-sat_sefD_info+288;
                 const 4294967301;
                 const 1;
                 const 30064771082;)]
         }
     {offset
       cepC:
           _sefy::P64 = R2;   // CmmAssign
           _sefD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
       cepE:
           Hp = Hp + 104;   // CmmAssign
           if (Hp > HpLim) goto cepG; else goto cepF;   // CmmCondBranch
       cepG:
           HpAlloc = 104;   // CmmAssign
           goto cepD;   // CmmBranch
       cepD:
           R2 = _sefy::P64;   // CmmAssign
           R1 = _sefD::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepF:
           _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 96] = sat_sefB_info;   // CmmStore
           P64[Hp - 80] = _sefy::P64;   // CmmStore
           _cepg::P64 = Hp - 96;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 72] = sat_sefA_info;   // CmmStore
           P64[Hp - 56] = _sefy::P64;   // CmmStore
           _cepn::P64 = Hp - 72;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 48] = sat_sefz_info;   // CmmStore
           P64[Hp - 32] = _sefs::P64;   // CmmStore
           _cepu::P64 = Hp - 48;   // CmmAssign
           I64[Hp - 24] = (,,)_con_info;   // CmmStore
           P64[Hp - 16] = _cepu::P64;   // CmmStore
           P64[Hp - 8] = _cepn::P64;   // CmmStore
           P64[Hp] = _cepg::P64;   // CmmStore
           _cepB::P64 = Hp - 23;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 16] = stg_ap_p_info;   // CmmStore
           P64[Sp - 8] = _cepB::P64;   // CmmStore
           Sp = Sp - 16;   // CmmAssign
           call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefx_entry() //  [R1]
         { [(cepL,
             sat_sefx_info:
                 const SehZ_srt-sat_sefx_info+288;
                 const 1;
                 const 107374182417;)]
         }
     {offset
       cepL:
           _sefx::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
       cepM:
           R1 = _sefx::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepN:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefx::P64;   // CmmStore
           _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
           R4 = _sefw::P64;   // CmmAssign
           R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
           R1 = GHC.loadModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_ppp_fast(R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefE_entry() //  [R2, R1]
         { [(cepO,
             sat_sefE_info:
                 const SehZ_srt-sat_sefE_info+288;
                 const 4294967301;
                 const 1;
                 const 133143986186;)]
         }
     {offset
       cepO:
           _sefw::P64 = R2;   // CmmAssign
           _sefE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
       cepQ:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cepS; else goto cepR;   // CmmCondBranch
       cepS:
           HpAlloc = 40;   // CmmAssign
           goto cepP;   // CmmBranch
       cepP:
           R2 = _sefw::P64;   // CmmAssign
           R1 = _sefE::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepR:
           _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefD_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cepb::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefx_info;   // CmmStore
           P64[Hp] = _sefw::P64;   // CmmStore
           _cepH::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepH::P64;   // CmmStore
           P64[Sp - 8] = _cepb::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefv_entry() //  [R1]
         { [(cepX,
             sat_sefv_info:
                 const SehZ_srt-sat_sefv_info+320;
                 const 1;
                 const 12884901905;)]
         }
     {offset
       cepX:
           _sefv::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
       cepY:
           R1 = _sefv::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cepZ:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefv::P64;   // CmmStore
           _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
           R3 = _sefu::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.desugarModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefF_entry() //  [R2, R1]
         { [(ceq0,
             sat_sefF_info:
                 const SehZ_srt-sat_sefF_info+288;
                 const 4294967301;
                 const 1;
                 const 270582939658;)]
         }
     {offset
       ceq0:
           _sefu::P64 = R2;   // CmmAssign
           _sefF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
       ceq2:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceq4; else goto ceq3;   // CmmCondBranch
       ceq4:
           HpAlloc = 40;   // CmmAssign
           goto ceq1;   // CmmBranch
       ceq1:
           R2 = _sefu::P64;   // CmmAssign
           R1 = _sefF::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceq3:
           _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefE_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep6::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefv_info;   // CmmStore
           P64[Hp] = _sefu::P64;   // CmmStore
           _cepT::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cepT::P64;   // CmmStore
           P64[Sp - 8] = _cep6::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_seft_entry() //  [R1]
         { [(ceq9,
             sat_seft_info:
                 const SehZ_srt-sat_seft_info+320;
                 const 1;
                 const 21474836497;)]
         }
     {offset
       ceq9:
           _seft::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
       ceqa:
           R1 = _seft::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _seft::P64;   // CmmStore
           _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
           R3 = _sefs::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.typecheckModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefG_entry() //  [R2, R1]
         { [(ceqc,
             sat_sefG_info:
                 const SehZ_srt-sat_sefG_info+288;
                 const 4294967301;
                 const 4294967296;
                 const 545460846603;)]
         }
     {offset
       ceqc:
           _sefs::P64 = R2;   // CmmAssign
           _sefG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
       ceqe:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqg; else goto ceqf;   // CmmCondBranch
       ceqg:
           HpAlloc = 40;   // CmmAssign
           goto ceqd;   // CmmBranch
       ceqd:
           R2 = _sefs::P64;   // CmmAssign
           R1 = _sefG::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqf:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefF_info;   // CmmStore
           P64[Hp - 24] = _sefs::P64;   // CmmStore
           _cep1::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_seft_info;   // CmmStore
           P64[Hp] = _sefs::P64;   // CmmStore
           _ceq5::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceq5::P64;   // CmmStore
           P64[Sp - 8] = _cep1::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefr_entry() //  [R1]
         { [(ceql,
             sat_sefr_info:
                 const SehZ_srt-sat_sefr_info+320;
                 const 1;
                 const 38654705681;)]
         }
     {offset
       ceql:
           _sefr::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
       ceqm:
           R1 = _sefr::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqn:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefr::P64;   // CmmStore
           _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
           R3 = _sefq::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.parseModule_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefH_entry() //  [R2, R1]
         { [(ceqo,
             sat_sefH_info:
                 const SehZ_srt-sat_sefH_info+288;
                 const 4294967301;
                 const 4294967296;
                 const 1095216660491;)]
         }
     {offset
       ceqo:
           _sefq::P64 = R2;   // CmmAssign
           _sefH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
       ceqq:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqs; else goto ceqr;   // CmmCondBranch
       ceqs:
           HpAlloc = 40;   // CmmAssign
           goto ceqp;   // CmmBranch
       ceqp:
           R2 = _sefq::P64;   // CmmAssign
           R1 = _sefH::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqr:
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefG_info;   // CmmStore
           _ceoW::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefr_info;   // CmmStore
           P64[Hp] = _sefq::P64;   // CmmStore
           _ceqh::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceqh::P64;   // CmmStore
           P64[Sp - 8] = _ceoW::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefp_entry() //  [R1]
         { [(ceqx,
             sat_sefp_info:
                 const SehZ_srt-sat_sefp_info+320;
                 const 1;
                 const 73014444049;)]
         }
     {offset
       ceqx:
           _sefp::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
       ceqy:
           R1 = _sefp::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefp::P64;   // CmmStore
           _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
           R3 = _sefk::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.getModSummary_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefI_entry() //  [R1]
         { [(ceqA,
             sat_sefI_info:
                 const SehZ_srt-sat_sefI_info+288;
                 const 1;
                 const 2194728288273;)]
         }
     {offset
       ceqA:
           _sefI::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
       ceqC:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqE; else goto ceqD;   // CmmCondBranch
       ceqE:
           HpAlloc = 40;   // CmmAssign
           goto ceqB;   // CmmBranch
       ceqB:
           R1 = _sefI::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqD:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefI::P64;   // CmmStore
           _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefH_info;   // CmmStore
           _ceoR::P64 = Hp - 31;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefp_info;   // CmmStore
           P64[Hp] = _sefk::P64;   // CmmStore
           _ceqt::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqt::P64;   // CmmStore
           P64[Sp - 24] = _ceoR::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefo_entry() //  [R1]
         { [(ceqJ,
             sat_sefo_info:
                 const SehZ_srt-sat_sefo_info+320;
                 const 0;
                 const 141733920784;)]
         }
     {offset
       ceqJ:
           _sefo::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
       ceqK:
           R1 = _sefo::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqL:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefo::P64;   // CmmStore
           R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMake.load_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefJ_entry() //  [R1]
         { [(ceqM,
             sat_sefJ_info:
                 const SehZ_srt-sat_sefJ_info+288;
                 const 1;
                 const 4393751543825;)]
         }
     {offset
       ceqM:
           _sefJ::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
       ceqO:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto ceqQ; else goto ceqP;   // CmmCondBranch
       ceqQ:
           HpAlloc = 40;   // CmmAssign
           goto ceqN;   // CmmBranch
       ceqN:
           R1 = _sefJ::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       ceqP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefJ::P64;   // CmmStore
           _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefI_info;   // CmmStore
           P64[Hp - 16] = _sefk::P64;   // CmmStore
           _ceoN::P64 = Hp - 32;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefo_info;   // CmmStore
           _ceqF::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqF::P64;   // CmmStore
           P64[Sp - 24] = _ceoN::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefn_entry() //  [R1]
         { [(ceqX,
             sat_sefn_info:
                 const SehZ_srt-sat_sefn_info+320;
                 const 1;
                 const 279172874257;)]
         }
     {offset
       ceqX:
           _sefn::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
       ceqZ:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cer1; else goto cer0;   // CmmCondBranch
       cer1:
           HpAlloc = 48;   // CmmAssign
           goto ceqY;   // CmmBranch
       ceqY:
           R1 = _sefn::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer0:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefn::P64;   // CmmStore
           _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
           I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
           P64[Hp - 32] = _sefk::P64;   // CmmStore
           _ceqV::P64 = Hp - 39;   // CmmAssign
           I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
           P64[Hp - 16] = _ceqV::P64;   // CmmStore
           P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
           P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
           _ceqW::P64 = Hp - 23;   // CmmAssign
           R3 = _ceqW::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.addTarget_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefK_entry() //  [R1]
         { [(cer2,
             sat_sefK_info:
                 const SehZ_srt-sat_sefK_info+280;
                 const 1;
                 const 17587891077137;)]
         }
     {offset
       cer2:
           _sefK::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
       cer4:
           Hp = Hp + 72;   // CmmAssign
           if (Hp > HpLim) goto cer6; else goto cer5;   // CmmCondBranch
       cer6:
           HpAlloc = 72;   // CmmAssign
           goto cer3;   // CmmBranch
       cer3:
           R1 = _sefK::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cer5:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefK::P64;   // CmmStore
           _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 64] = mn_sefk_info;   // CmmStore
           P64[Hp - 48] = _seeY::P64;   // CmmStore
           _ceoC::P64 = Hp - 64;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefJ_info;   // CmmStore
           P64[Hp - 24] = _ceoC::P64;   // CmmStore
           _ceoJ::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefn_info;   // CmmStore
           P64[Hp] = _ceoC::P64;   // CmmStore
           _ceqR::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _ceqR::P64;   // CmmStore
           P64[Sp - 24] = _ceoJ::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefj_entry() //  [R1]
         { [(cerb,
             sat_sefj_info:
                 const SehZ_srt-sat_sefj_info+320;
                 const 1;
                 const 554050781201;)]
         }
     {offset
       cerb:
           _sefj::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
       cerc:
           R1 = _sefj::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerd:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefj::P64;   // CmmStore
           _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
           R3 = _sefi::P64;   // CmmAssign
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefL_entry() //  [R2, R1]
         { [(cere,
             sat_sefL_info:
                 const SehZ_srt-sat_sefL_info+280;
                 const 4294967301;
                 const 1;
                 const 35180077121546;)]
         }
     {offset
       cere:
           _sefi::P64 = R2;   // CmmAssign
           _sefL::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
       cerg:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto ceri; else goto cerh;   // CmmCondBranch
       ceri:
           HpAlloc = 48;   // CmmAssign
           goto cerf;   // CmmBranch
       cerf:
           R2 = _sefi::P64;   // CmmAssign
           R1 = _sefL::P64;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerh:
           _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_sefK_info;   // CmmStore
           P64[Hp - 24] = _seeY::P64;   // CmmStore
           _ceoy::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_sefj_info;   // CmmStore
           P64[Hp] = _sefi::P64;   // CmmStore
           _cer7::P64 = Hp - 16;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _cer7::P64;   // CmmStore
           P64[Sp - 8] = _ceoy::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 },
 sat_sefh_entry() //  [R1]
         { [(cern,
             sat_sefh_info:
                 const SehZ_srt-sat_sefh_info+320;
                 const 0;
                 const 1103806595088;)]
         }
     {offset
       cern:
           _sefh::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cero; else goto cerp;   // CmmCondBranch
       cero:
           R1 = _sefh::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerp:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefh::P64;   // CmmStore
           R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
           R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefM_entry() //  [R1]
         { [(cerq,
             sat_sefM_info:
                 const SehZ_srt-sat_sefM_info+280;
                 const 1;
                 const 70364449210385;)]
         }
     {offset
       cerq:
           _sefM::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cerr; else goto cers;   // CmmCondBranch
       cers:
           Hp = Hp + 32;   // CmmAssign
           if (Hp > HpLim) goto ceru; else goto cert;   // CmmCondBranch
       ceru:
           HpAlloc = 32;   // CmmAssign
           goto cerr;   // CmmBranch
       cerr:
           R1 = _sefM::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cert:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefM::P64;   // CmmStore
           _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefL_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceot::P64 = Hp - 23;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_sefh_info;   // CmmStore
           _cerj::P64 = Hp - 8;   // CmmAssign
           R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cerj::P64;   // CmmStore
           P64[Sp - 24] = _ceot::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_sefN_entry() //  [R1]
         { [(cerw,
             sat_sefN_info:
                 const SehZ_srt-sat_sefN_info+280;
                 const 2;
                 const 140733193388051;)]
         }
     {offset
       cerw:
           _sefN::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cerx; else goto cery;   // CmmCondBranch
       cery:
           Hp = Hp + 40;   // CmmAssign
           if (Hp > HpLim) goto cerA; else goto cerz;   // CmmCondBranch
       cerA:
           HpAlloc = 40;   // CmmAssign
           goto cerx;   // CmmBranch
       cerx:
           R1 = _sefN::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerz:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _sefN::P64;   // CmmStore
           _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
           _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 32] = sat_sefM_info;   // CmmStore
           P64[Hp - 16] = _seeY::P64;   // CmmStore
           _ceop::P64 = Hp - 32;   // CmmAssign
           I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
           P64[Hp] = _seeX::P64;   // CmmStore
           _cerv::P64 = Hp - 6;   // CmmAssign
           R3 = _ceop::P64;   // CmmAssign
           R2 = _cerv::P64;   // CmmAssign
           R1 = GHC.runGhc_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_pp_fast(R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""relreadonly" . uerJ_srtd" {
     uerJ_srtd:
         const SehZ_srt;
         const 52;
         const 4503599627370445;
 },
 Main.testOneFile_entry() //  [R3, R2]
         { [(cerB,
             Main.testOneFile_info:
                 const uerJ_srtd-Main.testOneFile_info;
                 const 8589934607;
                 const 0;
                 const 18446744069414584335;)]
         }
     {offset
       cerB:
           _seeY::P64 = R3;   // CmmAssign
           _seeX::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
       cerD:
           Hp = Hp + 64;   // CmmAssign
           if (Hp > HpLim) goto cerF; else goto cerE;   // CmmCondBranch
       cerF:
           HpAlloc = 64;   // CmmAssign
           goto cerC;   // CmmBranch
       cerC:
           R3 = _seeY::P64;   // CmmAssign
           R2 = _seeX::P64;   // CmmAssign
           R1 = Main.testOneFile_closure;   // CmmAssign
           call (stg_gc_fun)(R3, R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cerE:
           // calling allocDynClosure
           I64[Hp - 56] = gq_seeZ_info;   // CmmStore
           _ceiW::P64 = Hp - 54;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segp_info;   // CmmStore
           P64[Hp - 32] = _ceiW::P64;   // CmmStore
           _cekl::P64 = Hp - 39;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 24] = sat_sefN_info;   // CmmStore
           P64[Hp - 8] = _seeX::P64;   // CmmStore
           P64[Hp] = _seeY::P64;   // CmmStore
           _ceol::P64 = Hp - 24;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 16] = _ceol::P64;   // CmmStore
           P64[Sp - 8] = _cekl::P64;   // CmmStore
           Sp = Sp - 24;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . Main.testOneFile_closure" {
    Main.testOneFile_closure:
        const Main.testOneFile_info;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl Main.testOneFile_closure
.type Main.testOneFile_closure, @object
Main.testOneFile_closure:
	.quad	Main.testOneFile_info
	.quad	0



==================== Liveness annotations added ====================
section ""data" . Main.testOneFile_closure" {
    (1,
     Main.testOneFile_closure:
         const Main.testOneFile_info;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl Main.testOneFile_closure
.type Main.testOneFile_closure, @object
Main.testOneFile_closure:
	.quad	Main.testOneFile_info
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl Main.testOneFile_closure
.type Main.testOneFile_closure, @object
Main.testOneFile_closure:
	.quad	Main.testOneFile_info
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl Main.testOneFile_closure
.type Main.testOneFile_closure, @object
Main.testOneFile_closure:
	.quad	Main.testOneFile_info
	.quad	0



==================== Optimised Cmm ====================
$dTypeable_sef3_entry() //  [R1]
        { [(ceje,
            $dTypeable_sef3_info:
                const 1;
                const 17;)]
        }
    {offset
      ceje:
          _sef3::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cejf; else goto cejg;   // CmmCondBranch
      cejf:
          R1 = _sef3::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejg:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef3::P64;   // CmmStore
          _sef2::P64 = P64[_sef3::P64 + 16];   // CmmAssign
          R2 = _sef2::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Data.Data.$p1Data_info(R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.quad	1
	.quad	17
$dTypeable_sef3_info:
_ceje:
	movq %rbx,%vI_sef3
	leaq -16(%rbp),%vI_nerM
	cmpq %r15,%vI_nerM
	jb _cejf
	jmp _cejg
_cejf:
	movq %vI_sef3,%rbx
	jmp *-16(%r13)
_cejg:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sef3,-8(%rbp)
	movq 16(%vI_sef3),%vI_sef2
	movq %vI_sef2,%r14
	addq $-16,%rbp
	jmp Data.Data.$p1Data_info
	.size $dTypeable_sef3_info, .-$dTypeable_sef3_info



==================== Liveness annotations added ====================
$dTypeable_sef3_entry() //  [R1]
        { [(ceje,
            $dTypeable_sef3_info:
                const 1;
                const 17;)]
          # entryIds         = [ceje]
          # liveVRegsOnEntry = Just [(ceje, [R1 :-> %r1]),
                                     (cejf, [sef3 :-> %vI_sef3]), (cejg, [sef3 :-> %vI_sef3])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceje:
            	movq %rbx,%vI_sef3
                    # born:    %vI_sef3
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nerM
                    # born:    %vI_nerM
                     
            	cmpq %r15,%vI_nerM
                    # r_dying: %vI_nerM
                     
            	jb _cejf
                     
            	jmp _cejg
                    # r_dying: %vI_sef3
                     ,
     NONREC
        cejf:
            	movq %vI_sef3,%rbx
                    # born:    %r1
                    # r_dying: %vI_sef3
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cejg:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sef3,-8(%rbp)
                     
            	movq 16(%vI_sef3),%vI_sef2
                    # born:    %vI_sef2
                    # r_dying: %vI_sef3
                     
            	movq %vI_sef2,%r14
                    # born:    %r14
                    # r_dying: %vI_sef2
                     
            	addq $-16,%rbp
                     
            	jmp Data.Data.$p1Data_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.quad	1
	.quad	17
$dTypeable_sef3_info:
_ceje:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejf
	jmp _cejg
_cejf:
	jmp *-16(%r13)
_cejg:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	addq $-16,%rbp
	jmp Data.Data.$p1Data_info
	.size $dTypeable_sef3_info, .-$dTypeable_sef3_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.quad	1
	.quad	17
$dTypeable_sef3_info:
_ceje:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejf
_cejg:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	addq $-16,%rbp
	jmp Data.Data.$p1Data_info
_cejf:
	jmp *-16(%r13)
	.size $dTypeable_sef3_info, .-$dTypeable_sef3_info



==================== Asm code ====================
.section .text
.align 8
	.quad	1
	.quad	17
$dTypeable_sef3_info:
_ceje:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejf
_cejg:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	addq $-16,%rbp
	jmp Data.Data.$p1Data_info
_cejf:
	jmp *-16(%r13)
	.size $dTypeable_sef3_info, .-$dTypeable_sef3_info



==================== Optimised Cmm ====================
ds_sef4_entry() //  [R1]
        { [(cejl,
            ds_sef4_info:
                const SehZ_srt-ds_sef4_info+48;
                const 0;
                const 12884901904;)]
        }
    {offset
      cejl:
          _sef4::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cejm; else goto cejn;   // CmmCondBranch
      cejm:
          R1 = _sef4::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sef4::P64;   // CmmStore
          R4 = GHC.Types.[]_closure+1;   // CmmAssign
          R3 = GHC.Types.[]_closure+1;   // CmmAssign
          R2 = SrcLoc.$tcSrcSpan_closure;   // CmmAssign
          R1 = Data.Typeable.Internal.mkPolyTyConApp_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(ds_sef4_info)+48
	.long	0
	.quad	0
	.quad	12884901904
ds_sef4_info:
_cejl:
	movq %rbx,%vI_sef4
	leaq -16(%rbp),%vI_nerP
	cmpq %r15,%vI_nerP
	jb _cejm
	jmp _cejn
_cejm:
	movq %vI_sef4,%rbx
	jmp *-16(%r13)
_cejn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sef4,-8(%rbp)
	movl $GHC.Types.[]_closure+1,%edi
	movl $GHC.Types.[]_closure+1,%esi
	movl $SrcLoc.$tcSrcSpan_closure,%r14d
	movl $Data.Typeable.Internal.mkPolyTyConApp_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
	.size ds_sef4_info, .-ds_sef4_info



==================== Liveness annotations added ====================
ds_sef4_entry() //  [R1]
        { [(cejl,
            ds_sef4_info:
                const SehZ_srt-ds_sef4_info+48;
                const 0;
                const 12884901904;)]
          # entryIds         = [cejl]
          # liveVRegsOnEntry = Just [(cejl, [R1 :-> %r1]),
                                     (cejm, [sef4 :-> %vI_sef4]), (cejn, [sef4 :-> %vI_sef4])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cejl:
            	movq %rbx,%vI_sef4
                    # born:    %vI_sef4
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nerP
                    # born:    %vI_nerP
                     
            	cmpq %r15,%vI_nerP
                    # r_dying: %vI_nerP
                     
            	jb _cejm
                     
            	jmp _cejn
                    # r_dying: %vI_sef4
                     ,
     NONREC
        cejm:
            	movq %vI_sef4,%rbx
                    # born:    %r1
                    # r_dying: %vI_sef4
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cejn:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sef4,-8(%rbp)
                    # r_dying: %vI_sef4
                     
            	movl $GHC.Types.[]_closure+1,%edi
                    # born:    %r5
                     
            	movl $GHC.Types.[]_closure+1,%esi
                    # born:    %r4
                     
            	movl $SrcLoc.$tcSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $Data.Typeable.Internal.mkPolyTyConApp_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_ppp_fast
                    # r_dying: %r1 %r4 %r5 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(ds_sef4_info)+48
	.long	0
	.quad	0
	.quad	12884901904
ds_sef4_info:
_cejl:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejm
	jmp _cejn
_cejm:
	jmp *-16(%r13)
_cejn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GHC.Types.[]_closure+1,%edi
	movl $GHC.Types.[]_closure+1,%esi
	movl $SrcLoc.$tcSrcSpan_closure,%r14d
	movl $Data.Typeable.Internal.mkPolyTyConApp_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
	.size ds_sef4_info, .-ds_sef4_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(ds_sef4_info)+48
	.long	0
	.quad	0
	.quad	12884901904
ds_sef4_info:
_cejl:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejm
_cejn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GHC.Types.[]_closure+1,%edi
	movl $GHC.Types.[]_closure+1,%esi
	movl $SrcLoc.$tcSrcSpan_closure,%r14d
	movl $Data.Typeable.Internal.mkPolyTyConApp_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_cejm:
	jmp *-16(%r13)
	.size ds_sef4_info, .-ds_sef4_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(ds_sef4_info)+48
	.long	0
	.quad	0
	.quad	12884901904
ds_sef4_info:
_cejl:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cejm
_cejn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GHC.Types.[]_closure+1,%edi
	movl $GHC.Types.[]_closure+1,%esi
	movl $SrcLoc.$tcSrcSpan_closure,%r14d
	movl $Data.Typeable.Internal.mkPolyTyConApp_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_cejm:
	jmp *-16(%r13)
	.size ds_sef4_info, .-ds_sef4_info



==================== Optimised Cmm ====================
a4_sef5_entry() //  [R1]
        { [(cejt,
            a4_sef5_info:
                const 4294967299;
                const 1;
                const 10;)]
        }
    {offset
      cejt:
          _sef5::P64 = R1;   // CmmAssign
          goto cejv;   // CmmBranch
      cejv:
          _sef4::P64 = P64[_sef5::P64 + 7];   // CmmAssign
          R1 = _sef4::P64 & (-8);   // CmmAssign
          call (I64[R1])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.quad	4294967299
	.quad	1
	.quad	10
a4_sef5_info:
_cejt:
	movq %rbx,%vI_sef5
	jmp _cejv
_cejv:
	movq 7(%vI_sef5),%vI_sef4
	movq %vI_sef4,%rbx
	andq $-8,%rbx
	jmp *(%rbx)
	.size a4_sef5_info, .-a4_sef5_info



==================== Liveness annotations added ====================
a4_sef5_entry() //  [R1]
        { [(cejt,
            a4_sef5_info:
                const 4294967299;
                const 1;
                const 10;)]
          # entryIds         = [cejt]
          # liveVRegsOnEntry = Just [(cejt, [R1 :-> %r1]),
                                     (cejv, [sef5 :-> %vI_sef5])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cejt:
            	movq %rbx,%vI_sef5
                    # born:    %vI_sef5
                    # r_dying: %r1
                     
            	jmp _cejv
                    # r_dying: %vI_sef5
                     ,
     NONREC
        cejv:
            	movq 7(%vI_sef5),%vI_sef4
                    # born:    %vI_sef4
                    # r_dying: %vI_sef5
                     
            	movq %vI_sef4,%rbx
                    # born:    %r1
                    # r_dying: %vI_sef4
                     
            	andq $-8,%rbx
                     
            	jmp *(%rbx)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.quad	4294967299
	.quad	1
	.quad	10
a4_sef5_info:
_cejt:
	jmp _cejv
_cejv:
	movq 7(%rbx),%rax
	movq %rax,%rbx
	andq $-8,%rbx
	jmp *(%rbx)
	.size a4_sef5_info, .-a4_sef5_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.quad	4294967299
	.quad	1
	.quad	10
a4_sef5_info:
_cejt:
_cejv:
	movq 7(%rbx),%rax
	movq %rax,%rbx
	andq $-8,%rbx
	jmp *(%rbx)
	.size a4_sef5_info, .-a4_sef5_info



==================== Asm code ====================
.section .text
.align 8
	.quad	4294967299
	.quad	1
	.quad	10
a4_sef5_info:
_cejt:
_cejv:
	movq 7(%rbx),%rax
	movq %rax,%rbx
	andq $-8,%rbx
	jmp *(%rbx)
	.size a4_sef5_info, .-a4_sef5_info



==================== Optimised Cmm ====================
sat_sefd_entry() //  [R2, R1]
        { [(cejB,
            block_cejB_info:
                const 0;
                const 32;),
           (cejH,
            sat_sefd_info:
                const SehZ_srt-sat_sefd_info;
                const 4294967301;
                const 2;
                const 4294967308;),
           (cejP,
            block_cejP_info:
                const 0;
                const 32;)]
        }
    {offset
      cejH:
          _sef7::P64 = R2;   // CmmAssign
          _sefd::P64 = R1;   // CmmAssign
          if ((Sp + -8) < SpLim) goto cejI; else goto cejJ;   // CmmCondBranch
      cejI:
          R2 = _sef7::P64;   // CmmAssign
          R1 = _sefd::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejJ:
          _sef3::P64 = P64[_sefd::P64 + 7];   // CmmAssign
          _sef5::P64 = P64[_sefd::P64 + 15];   // CmmAssign
          I64[Sp - 8] = block_cejB_info;   // CmmStore
          R4 = _sef7::P64;   // CmmAssign
          R3 = _sef5::P64;   // CmmAssign
          R2 = _sef3::P64;   // CmmAssign
          R1 = Data.Typeable.cast_closure;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) returns to cejB, args: 8, res: 8, upd: 8;   // CmmCall
      cejB:
          _sef8::P64 = R1;   // CmmAssign
          _cejG::P64 = _sef8::P64 & 7;   // CmmAssign
          if (_cejG::P64 != 1) goto cejF; else goto cejE;   // CmmCondBranch
      cejF:
          _sef9::P64 = P64[_sef8::P64 + 6];   // CmmAssign
          I64[Sp] = block_cejP_info;   // CmmStore
          R1 = _sef9::P64;   // CmmAssign
          if (R1 & 7 != 0) goto cejP; else goto cejR;   // CmmCondBranch
      cejR:
          call (I64[R1])(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejP:
          _sefa::P64 = R1;   // CmmAssign
          _cek5::P64 = _sefa::P64 & 7;   // CmmAssign
          if (_cek5::P64 != 1) goto cek4; else goto cejX;   // CmmCondBranch
      cek4:
          _sefc::P64 = P64[_sefa::P64 + 6];   // CmmAssign
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejX:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cek0; else goto cejZ;   // CmmCondBranch
      cek0:
          I64[BaseReg + 904] = 24;   // CmmStore
          R1 = _sefa::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cejP, args: 8, res: 8, upd: 8;   // CmmCall
      cejZ:
          _sefb::P64 = P64[_sefa::P64 + 7];   // CmmAssign
          I64[Hp - 16] = :_con_info;   // CmmStore
          P64[Hp - 8] = _sefa::P64;   // CmmStore
          P64[Hp] = GHC.Types.[]_closure+1;   // CmmStore
          _cejV::P64 = Hp - 14;   // CmmAssign
          R1 = _cejV::P64;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cejE:
          R1 = []_closure+1;   // CmmAssign
          Sp = Sp + 8;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefd_info)+0
	.long	0
	.quad	4294967301
	.quad	2
	.quad	4294967308
sat_sefd_info:
_cejH:
	movq %r14,%vI_sef7
	movq %rbx,%vI_sefd
	leaq -8(%rbp),%vI_nerV
	cmpq %r15,%vI_nerV
	jb _cejI
	jmp _cejJ
	.quad	0
	.quad	32
block_cejB_info:
_cejB:
	movq %rbx,%vI_sef8
	movq %vI_sef8,%vI_cejG
	andl $7,%vI_cejG
	cmpq $1,%vI_cejG
	jne _cejF
	jmp _cejE
_cejE:
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
_cejF:
	movq 6(%vI_sef8),%vI_sef9
	movq $block_cejP_info,(%rbp)
	movq %vI_sef9,%rbx
	testb $7,%bl
	jne _cejP
	jmp _cejR
_cejI:
	movq %vI_sef7,%r14
	movq %vI_sefd,%rbx
	jmp *-8(%r13)
_cejJ:
	movq 7(%vI_sefd),%vI_sef3
	movq 15(%vI_sefd),%vI_sef5
	movq $block_cejB_info,-8(%rbp)
	movq %vI_sef7,%rdi
	movq %vI_sef5,%rsi
	movq %vI_sef3,%r14
	movl $Data.Typeable.cast_closure,%ebx
	addq $-8,%rbp
	jmp stg_ap_ppp_fast
	.quad	0
	.quad	32
block_cejP_info:
_cejP:
	movq %rbx,%vI_sefa
	movq %vI_sefa,%vI_cek5
	andl $7,%vI_cek5
	cmpq $1,%vI_cek5
	jne _cek4
	jmp _cejX
_cejR:
	jmp *(%rbx)
_cejX:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _cek0
	jmp _cejZ
_cejZ:
	movq 7(%vI_sefa),%vI_sefb
	movq $:_con_info,-16(%r12)
	movq %vI_sefa,-8(%r12)
	movq $GHC.Types.[]_closure+1,(%r12)
	leaq -14(%r12),%vI_cejV
	movq %vI_cejV,%rbx
	addq $8,%rbp
	jmp *(%rbp)
_cek0:
	movq $24,904(%r13)
	movq %vI_sefa,%rbx
	jmp stg_gc_unpt_r1
_cek4:
	movq 6(%vI_sefa),%vI_sefc
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
	.size sat_sefd_info, .-sat_sefd_info



==================== Liveness annotations added ====================
sat_sefd_entry() //  [R2, R1]
        { [(cejB,
            block_cejB_info:
                const 0;
                const 32;),
           (cejH,
            sat_sefd_info:
                const SehZ_srt-sat_sefd_info;
                const 4294967301;
                const 2;
                const 4294967308;),
           (cejP,
            block_cejP_info:
                const 0;
                const 32;)]
          # entryIds         = [cejH, cejB, cejP]
          # liveVRegsOnEntry = Just [(cejB, [R1 :-> %r1]), (cejE, []),
                                     (cejF, [sef8 :-> %vI_sef8]), (cejH, [R1 :-> %r1, Re :-> %r14]),
                                     (cejI, [sef7 :-> %vI_sef7, sefd :-> %vI_sefd]),
                                     (cejJ, [sef7 :-> %vI_sef7, sefd :-> %vI_sefd]),
                                     (cejP, [R1 :-> %r1]), (cejR, [R1 :-> %r1]),
                                     (cejX, [sefa :-> %vI_sefa]), (cejZ, [sefa :-> %vI_sefa]),
                                     (cek0, [sefa :-> %vI_sefa]), (cek4, [sefa :-> %vI_sefa])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cejH:
            	movq %r14,%vI_sef7
                    # born:    %vI_sef7
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefd
                    # born:    %vI_sefd
                    # r_dying: %r1
                     
            	leaq -8(%rbp),%vI_nerV
                    # born:    %vI_nerV
                     
            	cmpq %r15,%vI_nerV
                    # r_dying: %vI_nerV
                     
            	jb _cejI
                     
            	jmp _cejJ
                    # r_dying: %vI_sef7 %vI_sefd
                     ,
     NONREC
        cejB:
            	movq %rbx,%vI_sef8
                    # born:    %vI_sef8
                    # r_dying: %r1
                     
            	movq %vI_sef8,%vI_cejG
                    # born:    %vI_cejG
                     
            	andl $7,%vI_cejG
                     
            	cmpq $1,%vI_cejG
                    # r_dying: %vI_cejG
                     
            	jne _cejF
                    # r_dying: %vI_sef8
                     
            	jmp _cejE
                     ,
     NONREC
        cejE:
            	movl $[]_closure+1,%ebx
                    # born:    %r1
                     
            	addq $8,%rbp
                     
            	jmp *(%rbp)
                    # r_dying: %r1
                     ,
     NONREC
        cejF:
            	movq 6(%vI_sef8),%vI_sef9
                    # born:    %vI_sef9
                    # r_dying: %vI_sef8
                     
            	movq $block_cejP_info,(%rbp)
                     
            	movq %vI_sef9,%rbx
                    # born:    %r1
                    # r_dying: %vI_sef9
                     
            	testb $7,%bl
                     
            	jne _cejP
                     
            	jmp _cejR
                    # r_dying: %r1
                     ,
     NONREC
        cejI:
            	movq %vI_sef7,%r14
                    # born:    %r14
                    # r_dying: %vI_sef7
                     
            	movq %vI_sefd,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefd
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cejJ:
            	movq 7(%vI_sefd),%vI_sef3
                    # born:    %vI_sef3
                     
            	movq 15(%vI_sefd),%vI_sef5
                    # born:    %vI_sef5
                    # r_dying: %vI_sefd
                     
            	movq $block_cejB_info,-8(%rbp)
                     
            	movq %vI_sef7,%rdi
                    # born:    %r5
                    # r_dying: %vI_sef7
                     
            	movq %vI_sef5,%rsi
                    # born:    %r4
                    # r_dying: %vI_sef5
                     
            	movq %vI_sef3,%r14
                    # born:    %r14
                    # r_dying: %vI_sef3
                     
            	movl $Data.Typeable.cast_closure,%ebx
                    # born:    %r1
                     
            	addq $-8,%rbp
                     
            	jmp stg_ap_ppp_fast
                    # r_dying: %r1 %r4 %r5 %r14
                     ,
     NONREC
        cejP:
            	movq %rbx,%vI_sefa
                    # born:    %vI_sefa
                    # r_dying: %r1
                     
            	movq %vI_sefa,%vI_cek5
                    # born:    %vI_cek5
                     
            	andl $7,%vI_cek5
                     
            	cmpq $1,%vI_cek5
                    # r_dying: %vI_cek5
                     
            	jne _cek4
                     
            	jmp _cejX
                    # r_dying: %vI_sefa
                     ,
     NONREC
        cejR:
            	jmp *(%rbx)
                    # r_dying: %r1
                     ,
     NONREC
        cejX:
            	addq $24,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cek0
                     
            	jmp _cejZ
                    # r_dying: %vI_sefa
                     ,
     NONREC
        cejZ:
            	movq 7(%vI_sefa),%vI_sefb
                    # born:    %vI_sefb
                    # w_dying: %vI_sefb
                     
            	movq $:_con_info,-16(%r12)
                     
            	movq %vI_sefa,-8(%r12)
                    # r_dying: %vI_sefa
                     
            	movq $GHC.Types.[]_closure+1,(%r12)
                     
            	leaq -14(%r12),%vI_cejV
                    # born:    %vI_cejV
                     
            	movq %vI_cejV,%rbx
                    # born:    %r1
                    # r_dying: %vI_cejV
                     
            	addq $8,%rbp
                     
            	jmp *(%rbp)
                    # r_dying: %r1
                     ,
     NONREC
        cek0:
            	movq $24,904(%r13)
                     
            	movq %vI_sefa,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefa
                     
            	jmp stg_gc_unpt_r1
                    # r_dying: %r1
                     ,
     NONREC
        cek4:
            	movq 6(%vI_sefa),%vI_sefc
                    # born:    %vI_sefc
                    # r_dying: %vI_sefa
                    # w_dying: %vI_sefc
                     
            	movl $[]_closure+1,%ebx
                    # born:    %r1
                     
            	addq $8,%rbp
                     
            	jmp *(%rbp)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefd_info)+0
	.long	0
	.quad	4294967301
	.quad	2
	.quad	4294967308
sat_sefd_info:
_cejH:
	leaq -8(%rbp),%rax
	cmpq %r15,%rax
	jb _cejI
	jmp _cejJ
	.quad	0
	.quad	32
block_cejB_info:
_cejB:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cejF
	jmp _cejE
_cejE:
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
_cejF:
	movq 6(%rbx),%rax
	movq $block_cejP_info,(%rbp)
	movq %rax,%rbx
	testb $7,%bl
	jne _cejP
	jmp _cejR
_cejI:
	jmp *-8(%r13)
_cejJ:
	movq 7(%rbx),%rax
	movq 15(%rbx),%rbx
	movq $block_cejB_info,-8(%rbp)
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	movl $Data.Typeable.cast_closure,%ebx
	addq $-8,%rbp
	jmp stg_ap_ppp_fast
	.quad	0
	.quad	32
block_cejP_info:
_cejP:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cek4
	jmp _cejX
_cejR:
	jmp *(%rbx)
_cejX:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _cek0
	jmp _cejZ
_cejZ:
	movq 7(%rbx),%rax
	movq $:_con_info,-16(%r12)
	movq %rbx,-8(%r12)
	movq $GHC.Types.[]_closure+1,(%r12)
	leaq -14(%r12),%rax
	movq %rax,%rbx
	addq $8,%rbp
	jmp *(%rbp)
_cek0:
	movq $24,904(%r13)
	jmp stg_gc_unpt_r1
_cek4:
	movq 6(%rbx),%rax
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
	.size sat_sefd_info, .-sat_sefd_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefd_info)+0
	.long	0
	.quad	4294967301
	.quad	2
	.quad	4294967308
sat_sefd_info:
_cejH:
	leaq -8(%rbp),%rax
	cmpq %r15,%rax
	jb _cejI
_cejJ:
	movq 7(%rbx),%rax
	movq 15(%rbx),%rbx
	movq $block_cejB_info,-8(%rbp)
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	movl $Data.Typeable.cast_closure,%ebx
	addq $-8,%rbp
	jmp stg_ap_ppp_fast
	.quad	0
	.quad	32
block_cejB_info:
_cejB:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cejF
_cejE:
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
_cejF:
	movq 6(%rbx),%rax
	movq $block_cejP_info,(%rbp)
	movq %rax,%rbx
	testb $7,%bl
	jne _cejP
_cejR:
	jmp *(%rbx)
_cejI:
	jmp *-8(%r13)
	.quad	0
	.quad	32
block_cejP_info:
_cejP:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cek4
_cejX:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _cek0
_cejZ:
	movq 7(%rbx),%rax
	movq $:_con_info,-16(%r12)
	movq %rbx,-8(%r12)
	movq $GHC.Types.[]_closure+1,(%r12)
	leaq -14(%r12),%rax
	movq %rax,%rbx
	addq $8,%rbp
	jmp *(%rbp)
_cek0:
	movq $24,904(%r13)
	jmp stg_gc_unpt_r1
_cek4:
	movq 6(%rbx),%rax
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
	.size sat_sefd_info, .-sat_sefd_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefd_info)+0
	.long	0
	.quad	4294967301
	.quad	2
	.quad	4294967308
sat_sefd_info:
_cejH:
	leaq -8(%rbp),%rax
	cmpq %r15,%rax
	jb _cejI
_cejJ:
	movq 7(%rbx),%rax
	movq 15(%rbx),%rbx
	movq $block_cejB_info,-8(%rbp)
	movq %r14,%rdi
	movq %rbx,%rsi
	movq %rax,%r14
	movl $Data.Typeable.cast_closure,%ebx
	addq $-8,%rbp
	jmp stg_ap_ppp_fast
	.quad	0
	.quad	32
block_cejB_info:
_cejB:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cejF
_cejE:
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
_cejF:
	movq 6(%rbx),%rax
	movq $block_cejP_info,(%rbp)
	movq %rax,%rbx
	testb $7,%bl
	jne _cejP
_cejR:
	jmp *(%rbx)
_cejI:
	jmp *-8(%r13)
	.quad	0
	.quad	32
block_cejP_info:
_cejP:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cek4
_cejX:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _cek0
_cejZ:
	movq 7(%rbx),%rax
	movq $:_con_info,-16(%r12)
	movq %rbx,-8(%r12)
	movq $GHC.Types.[]_closure+1,(%r12)
	leaq -14(%r12),%rax
	movq %rax,%rbx
	addq $8,%rbp
	jmp *(%rbp)
_cek0:
	movq $24,904(%r13)
	jmp stg_gc_unpt_r1
_cek4:
	movq 6(%rbx),%rax
	movl $[]_closure+1,%ebx
	addq $8,%rbp
	jmp *(%rbp)
	.size sat_sefd_info, .-sat_sefd_info



==================== Optimised Cmm ====================
sat_sefe_entry() //  [R2, R1]
        { [(cek6,
            sat_sefe_info:
                const SehZ_srt-sat_sefe_info;
                const 4294967301;
                const 4294967296;
                const 828928688139;)]
        }
    {offset
      cek6:
          _sef2::P64 = R2;   // CmmAssign
          _sefe::P64 = R1;   // CmmAssign
          goto cek8;   // CmmBranch
      cek8:
          Hp = Hp + 80;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceka; else goto cek9;   // CmmCondBranch
      ceka:
          I64[BaseReg + 904] = 80;   // CmmStore
          goto cek7;   // CmmBranch
      cek7:
          R2 = _sef2::P64;   // CmmAssign
          R1 = _sefe::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cek9:
          // calling allocDynClosure
          I64[Hp - 72] = $dTypeable_sef3_info;   // CmmStore
          P64[Hp - 56] = _sef2::P64;   // CmmStore
          _ceja::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = ds_sef4_info;   // CmmStore
          _cejh::P64 = Hp - 48;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = a4_sef5_info;   // CmmStore
          P64[Hp - 24] = _cejh::P64;   // CmmStore
          _cejo::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefd_info;   // CmmStore
          P64[Hp - 8] = _ceja::P64;   // CmmStore
          P64[Hp] = _cejo::P64;   // CmmStore
          _cejw::P64 = Hp - 15;   // CmmAssign
          R1 = _cejw::P64;   // CmmAssign
          call (P64[Sp])(R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefe_info)+0
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	828928688139
sat_sefe_info:
_cek6:
	movq %r14,%vI_sef2
	movq %rbx,%vI_sefe
	jmp _cek8
_cek7:
	movq %vI_sef2,%r14
	movq %vI_sefe,%rbx
	jmp *-8(%r13)
_cek8:
	addq $80,%r12
	cmpq 856(%r13),%r12
	ja _ceka
	jmp _cek9
_cek9:
	movq $$dTypeable_sef3_info,-72(%r12)
	movq %vI_sef2,-56(%r12)
	leaq -72(%r12),%vI_ceja
	movq $ds_sef4_info,-48(%r12)
	leaq -48(%r12),%vI_cejh
	movq $a4_sef5_info,-32(%r12)
	movq %vI_cejh,-24(%r12)
	leaq -31(%r12),%vI_cejo
	movq $sat_sefd_info,-16(%r12)
	movq %vI_ceja,-8(%r12)
	movq %vI_cejo,(%r12)
	leaq -15(%r12),%vI_cejw
	movq %vI_cejw,%rbx
	jmp *(%rbp)
_ceka:
	movq $80,904(%r13)
	jmp _cek7
	.size sat_sefe_info, .-sat_sefe_info



==================== Liveness annotations added ====================
sat_sefe_entry() //  [R2, R1]
        { [(cek6,
            sat_sefe_info:
                const SehZ_srt-sat_sefe_info;
                const 4294967301;
                const 4294967296;
                const 828928688139;)]
          # entryIds         = [cek6]
          # liveVRegsOnEntry = Just [(cek6, [R1 :-> %r1, Re :-> %r14]),
                                     (cek7, [sef2 :-> %vI_sef2, sefe :-> %vI_sefe]),
                                     (cek8, [sef2 :-> %vI_sef2, sefe :-> %vI_sefe]),
                                     (cek9, [sef2 :-> %vI_sef2]),
                                     (ceka, [sef2 :-> %vI_sef2, sefe :-> %vI_sefe])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cek6:
            	movq %r14,%vI_sef2
                    # born:    %vI_sef2
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefe
                    # born:    %vI_sefe
                    # r_dying: %r1
                     
            	jmp _cek8
                    # r_dying: %vI_sef2 %vI_sefe
                     ,
     NONREC
        cek8:
            	addq $80,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceka
                    # r_dying: %vI_sefe
                     
            	jmp _cek9
                    # r_dying: %vI_sef2
                     ,
     NONREC
        ceka:
            	movq $80,904(%r13)
                     
            	jmp _cek7
                    # r_dying: %vI_sef2 %vI_sefe
                     ,
     NONREC
        cek7:
            	movq %vI_sef2,%r14
                    # born:    %r14
                    # r_dying: %vI_sef2
                     
            	movq %vI_sefe,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefe
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cek9:
            	movq $$dTypeable_sef3_info,-72(%r12)
                     
            	movq %vI_sef2,-56(%r12)
                    # r_dying: %vI_sef2
                     
            	leaq -72(%r12),%vI_ceja
                    # born:    %vI_ceja
                     
            	movq $ds_sef4_info,-48(%r12)
                     
            	leaq -48(%r12),%vI_cejh
                    # born:    %vI_cejh
                     
            	movq $a4_sef5_info,-32(%r12)
                     
            	movq %vI_cejh,-24(%r12)
                    # r_dying: %vI_cejh
                     
            	leaq -31(%r12),%vI_cejo
                    # born:    %vI_cejo
                     
            	movq $sat_sefd_info,-16(%r12)
                     
            	movq %vI_ceja,-8(%r12)
                    # r_dying: %vI_ceja
                     
            	movq %vI_cejo,(%r12)
                    # r_dying: %vI_cejo
                     
            	leaq -15(%r12),%vI_cejw
                    # born:    %vI_cejw
                     
            	movq %vI_cejw,%rbx
                    # born:    %r1
                    # r_dying: %vI_cejw
                     
            	jmp *(%rbp)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefe_info)+0
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	828928688139
sat_sefe_info:
_cek6:
	jmp _cek8
_cek8:
	addq $80,%r12
	cmpq 856(%r13),%r12
	ja _ceka
	jmp _cek9
_ceka:
	movq $80,904(%r13)
	jmp _cek7
_cek7:
	jmp *-8(%r13)
_cek9:
	movq $$dTypeable_sef3_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rax
	movq $ds_sef4_info,-48(%r12)
	leaq -48(%r12),%rbx
	movq $a4_sef5_info,-32(%r12)
	movq %rbx,-24(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefd_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rbx,(%r12)
	leaq -15(%r12),%rax
	movq %rax,%rbx
	jmp *(%rbp)
	.size sat_sefe_info, .-sat_sefe_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefe_info)+0
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	828928688139
sat_sefe_info:
_cek6:
_cek8:
	addq $80,%r12
	cmpq 856(%r13),%r12
	ja _ceka
_cek9:
	movq $$dTypeable_sef3_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rax
	movq $ds_sef4_info,-48(%r12)
	leaq -48(%r12),%rbx
	movq $a4_sef5_info,-32(%r12)
	movq %rbx,-24(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefd_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rbx,(%r12)
	leaq -15(%r12),%rax
	movq %rax,%rbx
	jmp *(%rbp)
_ceka:
	movq $80,904(%r13)
_cek7:
	jmp *-8(%r13)
	.size sat_sefe_info, .-sat_sefe_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefe_info)+0
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	828928688139
sat_sefe_info:
_cek6:
_cek8:
	addq $80,%r12
	cmpq 856(%r13),%r12
	ja _ceka
_cek9:
	movq $$dTypeable_sef3_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rax
	movq $ds_sef4_info,-48(%r12)
	leaq -48(%r12),%rbx
	movq $a4_sef5_info,-32(%r12)
	movq %rbx,-24(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefd_info,-16(%r12)
	movq %rax,-8(%r12)
	movq %rbx,(%r12)
	leaq -15(%r12),%rax
	movq %rax,%rbx
	jmp *(%rbp)
_ceka:
	movq $80,904(%r13)
_cek7:
	jmp *-8(%r13)
	.size sat_sefe_info, .-sat_sefe_info



==================== Optimised Cmm ====================
sat_seff_entry() //  [R1]
        { [(cekb,
            sat_seff_info:
                const SehZ_srt-sat_seff_info;
                const 2;
                const 1945620185107;)]
        }
    {offset
      cekb:
          _seff::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekc; else goto cekd;   // CmmCondBranch
      cekd:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cekf; else goto ceke;   // CmmCondBranch
      cekf:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cekc;   // CmmBranch
      cekc:
          R1 = _seff::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceke:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seff::P64;   // CmmStore
          _sef0::P64 = P64[_seff::P64 + 16];   // CmmAssign
          _sef1::P64 = P64[_seff::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefe_info;   // CmmStore
          _cej5::P64 = Hp - 7;   // CmmAssign
          R5 = _sef1::P64;   // CmmAssign
          R4 = _sef0::P64;   // CmmAssign
          R3 = _cej5::P64;   // CmmAssign
          R2 = GHC.Base.++_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.everything_info(R5,
                                    R4,
                                    R3,
                                    R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seff_info)+0
	.long	0
	.quad	2
	.quad	1945620185107
sat_seff_info:
_cekb:
	movq %rbx,%vI_seff
	leaq -16(%rbp),%vI_nes2
	cmpq %r15,%vI_nes2
	jb _cekc
	jmp _cekd
_cekc:
	movq %vI_seff,%rbx
	jmp *-16(%r13)
_cekd:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cekf
	jmp _ceke
_ceke:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seff,-8(%rbp)
	movq 16(%vI_seff),%vI_sef0
	movq 24(%vI_seff),%vI_sef1
	movq $sat_sefe_info,-8(%r12)
	leaq -7(%r12),%vI_cej5
	movq %vI_sef1,%r8
	movq %vI_sef0,%rdi
	movq %vI_cej5,%rsi
	movl $GHC.Base.++_closure,%r14d
	addq $-16,%rbp
	jmp Main.everything_info
_cekf:
	movq $16,904(%r13)
	jmp _cekc
	.size sat_seff_info, .-sat_seff_info



==================== Liveness annotations added ====================
sat_seff_entry() //  [R1]
        { [(cekb,
            sat_seff_info:
                const SehZ_srt-sat_seff_info;
                const 2;
                const 1945620185107;)]
          # entryIds         = [cekb]
          # liveVRegsOnEntry = Just [(cekb, [R1 :-> %r1]),
                                     (cekc, [seff :-> %vI_seff]), (cekd, [seff :-> %vI_seff]),
                                     (ceke, [seff :-> %vI_seff]), (cekf, [seff :-> %vI_seff])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekb:
            	movq %rbx,%vI_seff
                    # born:    %vI_seff
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nes2
                    # born:    %vI_nes2
                     
            	cmpq %r15,%vI_nes2
                    # r_dying: %vI_nes2
                     
            	jb _cekc
                     
            	jmp _cekd
                    # r_dying: %vI_seff
                     ,
     NONREC
        cekd:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cekf
                     
            	jmp _ceke
                    # r_dying: %vI_seff
                     ,
     NONREC
        cekf:
            	movq $16,904(%r13)
                     
            	jmp _cekc
                    # r_dying: %vI_seff
                     ,
     NONREC
        cekc:
            	movq %vI_seff,%rbx
                    # born:    %r1
                    # r_dying: %vI_seff
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceke:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seff,-8(%rbp)
                     
            	movq 16(%vI_seff),%vI_sef0
                    # born:    %vI_sef0
                     
            	movq 24(%vI_seff),%vI_sef1
                    # born:    %vI_sef1
                    # r_dying: %vI_seff
                     
            	movq $sat_sefe_info,-8(%r12)
                     
            	leaq -7(%r12),%vI_cej5
                    # born:    %vI_cej5
                     
            	movq %vI_sef1,%r8
                    # born:    %r8
                    # r_dying: %vI_sef1
                     
            	movq %vI_sef0,%rdi
                    # born:    %r5
                    # r_dying: %vI_sef0
                     
            	movq %vI_cej5,%rsi
                    # born:    %r4
                    # r_dying: %vI_cej5
                     
            	movl $GHC.Base.++_closure,%r14d
                    # born:    %r14
                     
            	addq $-16,%rbp
                     
            	jmp Main.everything_info
                    # r_dying: %r4 %r5 %r8 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seff_info)+0
	.long	0
	.quad	2
	.quad	1945620185107
sat_seff_info:
_cekb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekc
	jmp _cekd
_cekd:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cekf
	jmp _ceke
_cekf:
	movq $16,904(%r13)
	jmp _cekc
_cekc:
	jmp *-16(%r13)
_ceke:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefe_info,-8(%r12)
	leaq -7(%r12),%rcx
	movq %rbx,%r8
	movq %rax,%rdi
	movq %rcx,%rsi
	movl $GHC.Base.++_closure,%r14d
	addq $-16,%rbp
	jmp Main.everything_info
	.size sat_seff_info, .-sat_seff_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seff_info)+0
	.long	0
	.quad	2
	.quad	1945620185107
sat_seff_info:
_cekb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekc
_cekd:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cekf
_ceke:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefe_info,-8(%r12)
	leaq -7(%r12),%rcx
	movq %rbx,%r8
	movq %rax,%rdi
	movq %rcx,%rsi
	movl $GHC.Base.++_closure,%r14d
	addq $-16,%rbp
	jmp Main.everything_info
_cekf:
	movq $16,904(%r13)
_cekc:
	jmp *-16(%r13)
	.size sat_seff_info, .-sat_seff_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seff_info)+0
	.long	0
	.quad	2
	.quad	1945620185107
sat_seff_info:
_cekb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekc
_cekd:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cekf
_ceke:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefe_info,-8(%r12)
	leaq -7(%r12),%rcx
	movq %rbx,%r8
	movq %rax,%rdi
	movq %rcx,%rsi
	movl $GHC.Base.++_closure,%r14d
	addq $-16,%rbp
	jmp Main.everything_info
_cekf:
	movq $16,904(%r13)
_cekc:
	jmp *-16(%r13)
	.size sat_seff_info, .-sat_seff_info



==================== Optimised Cmm ====================
gq_seeZ_entry() //  [R3, R2, R1]
        { [(cekg,
            gq_seeZ_info:
                const SehZ_srt-gq_seeZ_info;
                const 8589934607;
                const 4294967296;
                const 1979979923467;)]
        }
    {offset
      cekg:
          _sef1::P64 = R3;   // CmmAssign
          _sef0::P64 = R2;   // CmmAssign
          _seeZ::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekh; else goto ceki;   // CmmCondBranch
      ceki:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cekk; else goto cekj;   // CmmCondBranch
      cekk:
          I64[BaseReg + 904] = 32;   // CmmStore
          goto cekh;   // CmmBranch
      cekh:
          R3 = _sef1::P64;   // CmmAssign
          R2 = _sef0::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R3,
                                  R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekj:
          // calling allocDynClosure
          I64[Hp - 24] = sat_seff_info;   // CmmStore
          P64[Hp - 8] = _sef0::P64;   // CmmStore
          P64[Hp] = _sef1::P64;   // CmmStore
          _cej1::P64 = Hp - 24;   // CmmAssign
          R2 = Data.Foldable.$fFoldable[]_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cej1::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call Data.Foldable.length_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(gq_seeZ_info)+0
	.long	0
	.quad	8589934607
	.quad	4294967296
	.quad	1979979923467
gq_seeZ_info:
_cekg:
	movq %rsi,%vI_sef1
	movq %r14,%vI_sef0
	movq %rbx,%vI_seeZ
	leaq -16(%rbp),%vI_nes5
	cmpq %r15,%vI_nes5
	jb _cekh
	jmp _ceki
_cekh:
	movq %vI_sef1,%rsi
	movq %vI_sef0,%r14
	movq %vI_seeZ,%rbx
	jmp *-8(%r13)
_ceki:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _cekk
	jmp _cekj
_cekj:
	movq $sat_seff_info,-24(%r12)
	movq %vI_sef0,-8(%r12)
	movq %vI_sef1,(%r12)
	leaq -24(%r12),%vI_cej1
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %vI_cej1,-8(%rbp)
	addq $-16,%rbp
	jmp Data.Foldable.length_info
_cekk:
	movq $32,904(%r13)
	jmp _cekh
	.size gq_seeZ_info, .-gq_seeZ_info



==================== Liveness annotations added ====================
gq_seeZ_entry() //  [R3, R2, R1]
        { [(cekg,
            gq_seeZ_info:
                const SehZ_srt-gq_seeZ_info;
                const 8589934607;
                const 4294967296;
                const 1979979923467;)]
          # entryIds         = [cekg]
          # liveVRegsOnEntry = Just [(cekg,
                                      [R1 :-> %r1, R4 :-> %r4, Re :-> %r14]),
                                     (cekh,
                                      [seeZ :-> %vI_seeZ, sef0 :-> %vI_sef0, sef1 :-> %vI_sef1]),
                                     (ceki,
                                      [seeZ :-> %vI_seeZ, sef0 :-> %vI_sef0, sef1 :-> %vI_sef1]),
                                     (cekj, [sef0 :-> %vI_sef0, sef1 :-> %vI_sef1]),
                                     (cekk,
                                      [seeZ :-> %vI_seeZ, sef0 :-> %vI_sef0, sef1 :-> %vI_sef1])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekg:
            	movq %rsi,%vI_sef1
                    # born:    %vI_sef1
                    # r_dying: %r4
                     
            	movq %r14,%vI_sef0
                    # born:    %vI_sef0
                    # r_dying: %r14
                     
            	movq %rbx,%vI_seeZ
                    # born:    %vI_seeZ
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nes5
                    # born:    %vI_nes5
                     
            	cmpq %r15,%vI_nes5
                    # r_dying: %vI_nes5
                     
            	jb _cekh
                     
            	jmp _ceki
                    # r_dying: %vI_seeZ %vI_sef0 %vI_sef1
                     ,
     NONREC
        ceki:
            	addq $32,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cekk
                    # r_dying: %vI_seeZ
                     
            	jmp _cekj
                    # r_dying: %vI_sef0 %vI_sef1
                     ,
     NONREC
        cekk:
            	movq $32,904(%r13)
                     
            	jmp _cekh
                    # r_dying: %vI_seeZ %vI_sef0 %vI_sef1
                     ,
     NONREC
        cekh:
            	movq %vI_sef1,%rsi
                    # born:    %r4
                    # r_dying: %vI_sef1
                     
            	movq %vI_sef0,%r14
                    # born:    %r14
                    # r_dying: %vI_sef0
                     
            	movq %vI_seeZ,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeZ
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r4 %r14
                     ,
     NONREC
        cekj:
            	movq $sat_seff_info,-24(%r12)
                     
            	movq %vI_sef0,-8(%r12)
                    # r_dying: %vI_sef0
                     
            	movq %vI_sef1,(%r12)
                    # r_dying: %vI_sef1
                     
            	leaq -24(%r12),%vI_cej1
                    # born:    %vI_cej1
                     
            	movl $Data.Foldable.$fFoldable[]_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_p_info,-16(%rbp)
                     
            	movq %vI_cej1,-8(%rbp)
                    # r_dying: %vI_cej1
                     
            	addq $-16,%rbp
                     
            	jmp Data.Foldable.length_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(gq_seeZ_info)+0
	.long	0
	.quad	8589934607
	.quad	4294967296
	.quad	1979979923467
gq_seeZ_info:
_cekg:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekh
	jmp _ceki
_ceki:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _cekk
	jmp _cekj
_cekk:
	movq $32,904(%r13)
	jmp _cekh
_cekh:
	jmp *-8(%r13)
_cekj:
	movq $sat_seff_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rax
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp Data.Foldable.length_info
	.size gq_seeZ_info, .-gq_seeZ_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(gq_seeZ_info)+0
	.long	0
	.quad	8589934607
	.quad	4294967296
	.quad	1979979923467
gq_seeZ_info:
_cekg:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekh
_ceki:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _cekk
_cekj:
	movq $sat_seff_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rax
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp Data.Foldable.length_info
_cekk:
	movq $32,904(%r13)
_cekh:
	jmp *-8(%r13)
	.size gq_seeZ_info, .-gq_seeZ_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(gq_seeZ_info)+0
	.long	0
	.quad	8589934607
	.quad	4294967296
	.quad	1979979923467
gq_seeZ_info:
_cekg:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekh
_ceki:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _cekk
_cekj:
	movq $sat_seff_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rax
	movl $Data.Foldable.$fFoldable[]_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp Data.Foldable.length_info
_cekk:
	movq $32,904(%r13)
_cekh:
	jmp *-8(%r13)
	.size gq_seeZ_info, .-gq_seeZ_info



==================== Optimised Cmm ====================
$dData_segd_entry() //  [R1]
        { [(cekD,
            $dData_segd_info:
                const SehZ_srt-$dData_segd_info+72;
                const 0;
                const 12884901904;)]
        }
    {offset
      cekD:
          _segd::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekE; else goto cekF;   // CmmCondBranch
      cekE:
          R1 = _segd::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segd::P64;   // CmmStore
          R2 = ConLike.$fDataConLike_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData_segd_info)+72
	.long	0
	.quad	0
	.quad	12884901904
$dData_segd_info:
_cekD:
	movq %rbx,%vI_segd
	leaq -16(%rbp),%vI_nes8
	cmpq %r15,%vI_nes8
	jb _cekE
	jmp _cekF
_cekE:
	movq %vI_segd,%rbx
	jmp *-16(%r13)
_cekF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segd,-8(%rbp)
	movl $ConLike.$fDataConLike_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData_segd_info, .-$dData_segd_info



==================== Liveness annotations added ====================
$dData_segd_entry() //  [R1]
        { [(cekD,
            $dData_segd_info:
                const SehZ_srt-$dData_segd_info+72;
                const 0;
                const 12884901904;)]
          # entryIds         = [cekD]
          # liveVRegsOnEntry = Just [(cekD, [R1 :-> %r1]),
                                     (cekE, [segd :-> %vI_segd]), (cekF, [segd :-> %vI_segd])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekD:
            	movq %rbx,%vI_segd
                    # born:    %vI_segd
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nes8
                    # born:    %vI_nes8
                     
            	cmpq %r15,%vI_nes8
                    # r_dying: %vI_nes8
                     
            	jb _cekE
                     
            	jmp _cekF
                    # r_dying: %vI_segd
                     ,
     NONREC
        cekE:
            	movq %vI_segd,%rbx
                    # born:    %r1
                    # r_dying: %vI_segd
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cekF:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segd,-8(%rbp)
                    # r_dying: %vI_segd
                     
            	movl $ConLike.$fDataConLike_closure,%r14d
                    # born:    %r14
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData_segd_info)+72
	.long	0
	.quad	0
	.quad	12884901904
$dData_segd_info:
_cekD:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekE
	jmp _cekF
_cekE:
	jmp *-16(%r13)
_cekF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $ConLike.$fDataConLike_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData_segd_info, .-$dData_segd_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData_segd_info)+72
	.long	0
	.quad	0
	.quad	12884901904
$dData_segd_info:
_cekD:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekE
_cekF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $ConLike.$fDataConLike_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekE:
	jmp *-16(%r13)
	.size $dData_segd_info, .-$dData_segd_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData_segd_info)+72
	.long	0
	.quad	0
	.quad	12884901904
$dData_segd_info:
_cekD:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekE
_cekF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $ConLike.$fDataConLike_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekE:
	jmp *-16(%r13)
	.size $dData_segd_info, .-$dData_segd_info



==================== Optimised Cmm ====================
$dData1_sege_entry() //  [R1]
        { [(cekK,
            $dData1_sege_info:
                const SehZ_srt-$dData1_sege_info+72;
                const 0;
                const 21474836496;)]
        }
    {offset
      cekK:
          _sege::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekL; else goto cekM;   // CmmCondBranch
      cekL:
          R1 = _sege::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekM:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sege::P64;   // CmmStore
          R2 = TypeRep.$fDataType_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData1_sege_info)+72
	.long	0
	.quad	0
	.quad	21474836496
$dData1_sege_info:
_cekK:
	movq %rbx,%vI_sege
	leaq -16(%rbp),%vI_nesb
	cmpq %r15,%vI_nesb
	jb _cekL
	jmp _cekM
_cekL:
	movq %vI_sege,%rbx
	jmp *-16(%r13)
_cekM:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sege,-8(%rbp)
	movl $TypeRep.$fDataType_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData1_sege_info, .-$dData1_sege_info



==================== Liveness annotations added ====================
$dData1_sege_entry() //  [R1]
        { [(cekK,
            $dData1_sege_info:
                const SehZ_srt-$dData1_sege_info+72;
                const 0;
                const 21474836496;)]
          # entryIds         = [cekK]
          # liveVRegsOnEntry = Just [(cekK, [R1 :-> %r1]),
                                     (cekL, [sege :-> %vI_sege]), (cekM, [sege :-> %vI_sege])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekK:
            	movq %rbx,%vI_sege
                    # born:    %vI_sege
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesb
                    # born:    %vI_nesb
                     
            	cmpq %r15,%vI_nesb
                    # r_dying: %vI_nesb
                     
            	jb _cekL
                     
            	jmp _cekM
                    # r_dying: %vI_sege
                     ,
     NONREC
        cekL:
            	movq %vI_sege,%rbx
                    # born:    %r1
                    # r_dying: %vI_sege
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cekM:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sege,-8(%rbp)
                    # r_dying: %vI_sege
                     
            	movl $TypeRep.$fDataType_closure,%r14d
                    # born:    %r14
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData1_sege_info)+72
	.long	0
	.quad	0
	.quad	21474836496
$dData1_sege_info:
_cekK:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekL
	jmp _cekM
_cekL:
	jmp *-16(%r13)
_cekM:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $TypeRep.$fDataType_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData1_sege_info, .-$dData1_sege_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData1_sege_info)+72
	.long	0
	.quad	0
	.quad	21474836496
$dData1_sege_info:
_cekK:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekL
_cekM:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $TypeRep.$fDataType_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekL:
	jmp *-16(%r13)
	.size $dData1_sege_info, .-$dData1_sege_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData1_sege_info)+72
	.long	0
	.quad	0
	.quad	21474836496
$dData1_sege_info:
_cekK:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekL
_cekM:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $TypeRep.$fDataType_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekL:
	jmp *-16(%r13)
	.size $dData1_sege_info, .-$dData1_sege_info



==================== Optimised Cmm ====================
$dData2_segf_entry() //  [R1]
        { [(cekR,
            $dData2_segf_info:
                const SehZ_srt-$dData2_segf_info+72;
                const 0;
                const 38654705680;)]
        }
    {offset
      cekR:
          _segf::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekS; else goto cekT;   // CmmCondBranch
      cekS:
          R1 = _segf::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cekT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segf::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData2_segf_info)+72
	.long	0
	.quad	0
	.quad	38654705680
$dData2_segf_info:
_cekR:
	movq %rbx,%vI_segf
	leaq -16(%rbp),%vI_nese
	cmpq %r15,%vI_nese
	jb _cekS
	jmp _cekT
_cekS:
	movq %vI_segf,%rbx
	jmp *-16(%r13)
_cekT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segf,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData2_segf_info, .-$dData2_segf_info



==================== Liveness annotations added ====================
$dData2_segf_entry() //  [R1]
        { [(cekR,
            $dData2_segf_info:
                const SehZ_srt-$dData2_segf_info+72;
                const 0;
                const 38654705680;)]
          # entryIds         = [cekR]
          # liveVRegsOnEntry = Just [(cekR, [R1 :-> %r1]),
                                     (cekS, [segf :-> %vI_segf]), (cekT, [segf :-> %vI_segf])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekR:
            	movq %rbx,%vI_segf
                    # born:    %vI_segf
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nese
                    # born:    %vI_nese
                     
            	cmpq %r15,%vI_nese
                    # r_dying: %vI_nese
                     
            	jb _cekS
                     
            	jmp _cekT
                    # r_dying: %vI_segf
                     ,
     NONREC
        cekS:
            	movq %vI_segf,%rbx
                    # born:    %r1
                    # r_dying: %vI_segf
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cekT:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segf,-8(%rbp)
                    # r_dying: %vI_segf
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData2_segf_info)+72
	.long	0
	.quad	0
	.quad	38654705680
$dData2_segf_info:
_cekR:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekS
	jmp _cekT
_cekS:
	jmp *-16(%r13)
_cekT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData2_segf_info, .-$dData2_segf_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData2_segf_info)+72
	.long	0
	.quad	0
	.quad	38654705680
$dData2_segf_info:
_cekR:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekS
_cekT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekS:
	jmp *-16(%r13)
	.size $dData2_segf_info, .-$dData2_segf_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData2_segf_info)+72
	.long	0
	.quad	0
	.quad	38654705680
$dData2_segf_info:
_cekR:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekS
_cekT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekS:
	jmp *-16(%r13)
	.size $dData2_segf_info, .-$dData2_segf_info



==================== Optimised Cmm ====================
$dData3_segg_entry() //  [R1]
        { [(cekY,
            $dData3_segg_info:
                const SehZ_srt-$dData3_segg_info+96;
                const 0;
                const 12884901904;)]
        }
    {offset
      cekY:
          _segg::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cekZ; else goto cel0;   // CmmCondBranch
      cekZ:
          R1 = _segg::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segg::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = FieldLabel.$fDataFieldLbl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData3_segg_info)+96
	.long	0
	.quad	0
	.quad	12884901904
$dData3_segg_info:
_cekY:
	movq %rbx,%vI_segg
	leaq -16(%rbp),%vI_nesh
	cmpq %r15,%vI_nesh
	jb _cekZ
	jmp _cel0
_cekZ:
	movq %vI_segg,%rbx
	jmp *-16(%r13)
_cel0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segg,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $FieldLabel.$fDataFieldLbl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData3_segg_info, .-$dData3_segg_info



==================== Liveness annotations added ====================
$dData3_segg_entry() //  [R1]
        { [(cekY,
            $dData3_segg_info:
                const SehZ_srt-$dData3_segg_info+96;
                const 0;
                const 12884901904;)]
          # entryIds         = [cekY]
          # liveVRegsOnEntry = Just [(cekY, [R1 :-> %r1]),
                                     (cekZ, [segg :-> %vI_segg]), (cel0, [segg :-> %vI_segg])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cekY:
            	movq %rbx,%vI_segg
                    # born:    %vI_segg
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesh
                    # born:    %vI_nesh
                     
            	cmpq %r15,%vI_nesh
                    # r_dying: %vI_nesh
                     
            	jb _cekZ
                     
            	jmp _cel0
                    # r_dying: %vI_segg
                     ,
     NONREC
        cekZ:
            	movq %vI_segg,%rbx
                    # born:    %r1
                    # r_dying: %vI_segg
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cel0:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segg,-8(%rbp)
                    # r_dying: %vI_segg
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $FieldLabel.$fDataFieldLbl_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData3_segg_info)+96
	.long	0
	.quad	0
	.quad	12884901904
$dData3_segg_info:
_cekY:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekZ
	jmp _cel0
_cekZ:
	jmp *-16(%r13)
_cel0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $FieldLabel.$fDataFieldLbl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData3_segg_info, .-$dData3_segg_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData3_segg_info)+96
	.long	0
	.quad	0
	.quad	12884901904
$dData3_segg_info:
_cekY:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekZ
_cel0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $FieldLabel.$fDataFieldLbl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekZ:
	jmp *-16(%r13)
	.size $dData3_segg_info, .-$dData3_segg_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData3_segg_info)+96
	.long	0
	.quad	0
	.quad	12884901904
$dData3_segg_info:
_cekY:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cekZ
_cel0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $FieldLabel.$fDataFieldLbl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cekZ:
	jmp *-16(%r13)
	.size $dData3_segg_info, .-$dData3_segg_info



==================== Optimised Cmm ====================
$dData4_segh_entry() //  [R1]
        { [(cel5,
            $dData4_segh_info:
                const SehZ_srt-$dData4_segh_info+72;
                const 1;
                const 4294967313;)]
        }
    {offset
      cel5:
          _segh::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cel6; else goto cel7;   // CmmCondBranch
      cel6:
          R1 = _segh::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cel7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segh::P64;   // CmmStore
          _segg::P64 = P64[_segh::P64 + 16];   // CmmAssign
          R2 = _segg::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData4_segh_info)+72
	.long	0
	.quad	1
	.quad	4294967313
$dData4_segh_info:
_cel5:
	movq %rbx,%vI_segh
	leaq -16(%rbp),%vI_nesk
	cmpq %r15,%vI_nesk
	jb _cel6
	jmp _cel7
_cel6:
	movq %vI_segh,%rbx
	jmp *-16(%r13)
_cel7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segh,-8(%rbp)
	movq 16(%vI_segh),%vI_segg
	movq %vI_segg,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData4_segh_info, .-$dData4_segh_info



==================== Liveness annotations added ====================
$dData4_segh_entry() //  [R1]
        { [(cel5,
            $dData4_segh_info:
                const SehZ_srt-$dData4_segh_info+72;
                const 1;
                const 4294967313;)]
          # entryIds         = [cel5]
          # liveVRegsOnEntry = Just [(cel5, [R1 :-> %r1]),
                                     (cel6, [segh :-> %vI_segh]), (cel7, [segh :-> %vI_segh])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cel5:
            	movq %rbx,%vI_segh
                    # born:    %vI_segh
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesk
                    # born:    %vI_nesk
                     
            	cmpq %r15,%vI_nesk
                    # r_dying: %vI_nesk
                     
            	jb _cel6
                     
            	jmp _cel7
                    # r_dying: %vI_segh
                     ,
     NONREC
        cel6:
            	movq %vI_segh,%rbx
                    # born:    %r1
                    # r_dying: %vI_segh
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cel7:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segh,-8(%rbp)
                     
            	movq 16(%vI_segh),%vI_segg
                    # born:    %vI_segg
                    # r_dying: %vI_segh
                     
            	movq %vI_segg,%r14
                    # born:    %r14
                    # r_dying: %vI_segg
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData4_segh_info)+72
	.long	0
	.quad	1
	.quad	4294967313
$dData4_segh_info:
_cel5:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cel6
	jmp _cel7
_cel6:
	jmp *-16(%r13)
_cel7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData4_segh_info, .-$dData4_segh_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData4_segh_info)+72
	.long	0
	.quad	1
	.quad	4294967313
$dData4_segh_info:
_cel5:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cel6
_cel7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cel6:
	jmp *-16(%r13)
	.size $dData4_segh_info, .-$dData4_segh_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData4_segh_info)+72
	.long	0
	.quad	1
	.quad	4294967313
$dData4_segh_info:
_cel5:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cel6
_cel7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cel6:
	jmp *-16(%r13)
	.size $dData4_segh_info, .-$dData4_segh_info



==================== Optimised Cmm ====================
$dData5_segi_entry() //  [R1]
        { [(celc,
            $dData5_segi_info:
                const SehZ_srt-$dData5_segi_info+96;
                const 0;
                const 21474836496;)]
        }
    {offset
      celc:
          _segi::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto celd; else goto cele;   // CmmCondBranch
      celd:
          R1 = _segi::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cele:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segi::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData5_segi_info)+96
	.long	0
	.quad	0
	.quad	21474836496
$dData5_segi_info:
_celc:
	movq %rbx,%vI_segi
	leaq -16(%rbp),%vI_nesn
	cmpq %r15,%vI_nesn
	jb _celd
	jmp _cele
_celd:
	movq %vI_segi,%rbx
	jmp *-16(%r13)
_cele:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segi,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData5_segi_info, .-$dData5_segi_info



==================== Liveness annotations added ====================
$dData5_segi_entry() //  [R1]
        { [(celc,
            $dData5_segi_info:
                const SehZ_srt-$dData5_segi_info+96;
                const 0;
                const 21474836496;)]
          # entryIds         = [celc]
          # liveVRegsOnEntry = Just [(celc, [R1 :-> %r1]),
                                     (celd, [segi :-> %vI_segi]), (cele, [segi :-> %vI_segi])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        celc:
            	movq %rbx,%vI_segi
                    # born:    %vI_segi
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesn
                    # born:    %vI_nesn
                     
            	cmpq %r15,%vI_nesn
                    # r_dying: %vI_nesn
                     
            	jb _celd
                     
            	jmp _cele
                    # r_dying: %vI_segi
                     ,
     NONREC
        celd:
            	movq %vI_segi,%rbx
                    # born:    %r1
                    # r_dying: %vI_segi
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cele:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segi,-8(%rbp)
                    # r_dying: %vI_segi
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $UniqFM.$fDataUniqFM_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-($dData5_segi_info)+96
	.long	0
	.quad	0
	.quad	21474836496
$dData5_segi_info:
_celc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celd
	jmp _cele
_celd:
	jmp *-16(%r13)
_cele:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size $dData5_segi_info, .-$dData5_segi_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-($dData5_segi_info)+96
	.long	0
	.quad	0
	.quad	21474836496
$dData5_segi_info:
_celc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celd
_cele:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_celd:
	jmp *-16(%r13)
	.size $dData5_segi_info, .-$dData5_segi_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-($dData5_segi_info)+96
	.long	0
	.quad	0
	.quad	21474836496
$dData5_segi_info:
_celc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celd
_cele:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_celd:
	jmp *-16(%r13)
	.size $dData5_segi_info, .-$dData5_segi_info



==================== Optimised Cmm ====================
sat_segk_entry() //  [R1]
        { [(cels,
            sat_segk_info:
                const SehZ_srt-sat_segk_info+120;
                const 1;
                const 4294967313;)]
        }
    {offset
      cels:
          _segk::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto celt; else goto celu;   // CmmCondBranch
      celt:
          R1 = _segk::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segk::P64;   // CmmStore
          _segj::P64 = P64[_segk::P64 + 16];   // CmmAssign
          R3 = _segj::P64;   // CmmAssign
          R2 = _segj::P64;   // CmmAssign
          R1 = HsBinds.$fDataHsBindLR_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segk_info)+120
	.long	0
	.quad	1
	.quad	4294967313
sat_segk_info:
_cels:
	movq %rbx,%vI_segk
	leaq -16(%rbp),%vI_nesq
	cmpq %r15,%vI_nesq
	jb _celt
	jmp _celu
_celt:
	movq %vI_segk,%rbx
	jmp *-16(%r13)
_celu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segk,-8(%rbp)
	movq 16(%vI_segk),%vI_segj
	movq %vI_segj,%rsi
	movq %vI_segj,%r14
	movl $HsBinds.$fDataHsBindLR_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_segk_info, .-sat_segk_info



==================== Liveness annotations added ====================
sat_segk_entry() //  [R1]
        { [(cels,
            sat_segk_info:
                const SehZ_srt-sat_segk_info+120;
                const 1;
                const 4294967313;)]
          # entryIds         = [cels]
          # liveVRegsOnEntry = Just [(cels, [R1 :-> %r1]),
                                     (celt, [segk :-> %vI_segk]), (celu, [segk :-> %vI_segk])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cels:
            	movq %rbx,%vI_segk
                    # born:    %vI_segk
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesq
                    # born:    %vI_nesq
                     
            	cmpq %r15,%vI_nesq
                    # r_dying: %vI_nesq
                     
            	jb _celt
                     
            	jmp _celu
                    # r_dying: %vI_segk
                     ,
     NONREC
        celt:
            	movq %vI_segk,%rbx
                    # born:    %r1
                    # r_dying: %vI_segk
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        celu:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segk,-8(%rbp)
                     
            	movq 16(%vI_segk),%vI_segj
                    # born:    %vI_segj
                    # r_dying: %vI_segk
                     
            	movq %vI_segj,%rsi
                    # born:    %r4
                     
            	movq %vI_segj,%r14
                    # born:    %r14
                    # r_dying: %vI_segj
                     
            	movl $HsBinds.$fDataHsBindLR_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segk_info)+120
	.long	0
	.quad	1
	.quad	4294967313
sat_segk_info:
_cels:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celt
	jmp _celu
_celt:
	jmp *-16(%r13)
_celu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movq %rax,%r14
	movl $HsBinds.$fDataHsBindLR_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_segk_info, .-sat_segk_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segk_info)+120
	.long	0
	.quad	1
	.quad	4294967313
sat_segk_info:
_cels:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celt
_celu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movq %rax,%r14
	movl $HsBinds.$fDataHsBindLR_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_celt:
	jmp *-16(%r13)
	.size sat_segk_info, .-sat_segk_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segk_info)+120
	.long	0
	.quad	1
	.quad	4294967313
sat_segk_info:
_cels:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celt
_celu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movq %rax,%r14
	movl $HsBinds.$fDataHsBindLR_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_celt:
	jmp *-16(%r13)
	.size sat_segk_info, .-sat_segk_info



==================== Optimised Cmm ====================
sat_segl_entry() //  [R1]
        { [(celv,
            sat_segl_info:
                const SehZ_srt-sat_segl_info+120;
                const 1;
                const 30064771089;)]
        }
    {offset
      celv:
          _segl::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto celw; else goto celx;   // CmmCondBranch
      celx:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto celz; else goto cely;   // CmmCondBranch
      celz:
          I64[BaseReg + 904] = 24;   // CmmStore
          goto celw;   // CmmBranch
      celw:
          R1 = _segl::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cely:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segl::P64;   // CmmStore
          _segj::P64 = P64[_segl::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segk_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celo::P64 = Hp - 16;   // CmmAssign
          R3 = _celo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segl_info)+120
	.long	0
	.quad	1
	.quad	30064771089
sat_segl_info:
_celv:
	movq %rbx,%vI_segl
	leaq -16(%rbp),%vI_nest
	cmpq %r15,%vI_nest
	jb _celw
	jmp _celx
_celw:
	movq %vI_segl,%rbx
	jmp *-16(%r13)
_celx:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celz
	jmp _cely
_cely:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segl,-8(%rbp)
	movq 16(%vI_segl),%vI_segj
	movq $sat_segk_info,-16(%r12)
	movq %vI_segj,(%r12)
	leaq -16(%r12),%vI_celo
	movq %vI_celo,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_celz:
	movq $24,904(%r13)
	jmp _celw
	.size sat_segl_info, .-sat_segl_info



==================== Liveness annotations added ====================
sat_segl_entry() //  [R1]
        { [(celv,
            sat_segl_info:
                const SehZ_srt-sat_segl_info+120;
                const 1;
                const 30064771089;)]
          # entryIds         = [celv]
          # liveVRegsOnEntry = Just [(celv, [R1 :-> %r1]),
                                     (celw, [segl :-> %vI_segl]), (celx, [segl :-> %vI_segl]),
                                     (cely, [segl :-> %vI_segl]), (celz, [segl :-> %vI_segl])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        celv:
            	movq %rbx,%vI_segl
                    # born:    %vI_segl
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nest
                    # born:    %vI_nest
                     
            	cmpq %r15,%vI_nest
                    # r_dying: %vI_nest
                     
            	jb _celw
                     
            	jmp _celx
                    # r_dying: %vI_segl
                     ,
     NONREC
        celx:
            	addq $24,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _celz
                     
            	jmp _cely
                    # r_dying: %vI_segl
                     ,
     NONREC
        celz:
            	movq $24,904(%r13)
                     
            	jmp _celw
                    # r_dying: %vI_segl
                     ,
     NONREC
        celw:
            	movq %vI_segl,%rbx
                    # born:    %r1
                    # r_dying: %vI_segl
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cely:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segl,-8(%rbp)
                     
            	movq 16(%vI_segl),%vI_segj
                    # born:    %vI_segj
                    # r_dying: %vI_segl
                     
            	movq $sat_segk_info,-16(%r12)
                     
            	movq %vI_segj,(%r12)
                    # r_dying: %vI_segj
                     
            	leaq -16(%r12),%vI_celo
                    # born:    %vI_celo
                     
            	movq %vI_celo,%rsi
                    # born:    %r4
                    # r_dying: %vI_celo
                     
            	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $SrcLoc.$fDataGenLocated_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segl_info)+120
	.long	0
	.quad	1
	.quad	30064771089
sat_segl_info:
_celv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celw
	jmp _celx
_celx:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celz
	jmp _cely
_celz:
	movq $24,904(%r13)
	jmp _celw
_celw:
	jmp *-16(%r13)
_cely:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segk_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_segl_info, .-sat_segl_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segl_info)+120
	.long	0
	.quad	1
	.quad	30064771089
sat_segl_info:
_celv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celw
_celx:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celz
_cely:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segk_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_celz:
	movq $24,904(%r13)
_celw:
	jmp *-16(%r13)
	.size sat_segl_info, .-sat_segl_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segl_info)+120
	.long	0
	.quad	1
	.quad	30064771089
sat_segl_info:
_celv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celw
_celx:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celz
_cely:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segk_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_celz:
	movq $24,904(%r13)
_celw:
	jmp *-16(%r13)
	.size sat_segl_info, .-sat_segl_info



==================== Optimised Cmm ====================
sat_segm_entry() //  [R1]
        { [(celA,
            sat_segm_info:
                const SehZ_srt-sat_segm_info+120;
                const 1;
                const 64424509457;)]
        }
    {offset
      celA:
          _segm::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto celB; else goto celC;   // CmmCondBranch
      celC:
          Hp = Hp + 24;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto celE; else goto celD;   // CmmCondBranch
      celE:
          I64[BaseReg + 904] = 24;   // CmmStore
          goto celB;   // CmmBranch
      celB:
          R1 = _segm::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segm::P64;   // CmmStore
          _segj::P64 = P64[_segm::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segl_info;   // CmmStore
          P64[Hp] = _segj::P64;   // CmmStore
          _celk::P64 = Hp - 16;   // CmmAssign
          R2 = _celk::P64;   // CmmAssign
          R1 = Bag.$fDataBag_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segm_info)+120
	.long	0
	.quad	1
	.quad	64424509457
sat_segm_info:
_celA:
	movq %rbx,%vI_segm
	leaq -16(%rbp),%vI_nesw
	cmpq %r15,%vI_nesw
	jb _celB
	jmp _celC
_celB:
	movq %vI_segm,%rbx
	jmp *-16(%r13)
_celC:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celE
	jmp _celD
_celD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segm,-8(%rbp)
	movq 16(%vI_segm),%vI_segj
	movq $sat_segl_info,-16(%r12)
	movq %vI_segj,(%r12)
	leaq -16(%r12),%vI_celk
	movq %vI_celk,%r14
	movl $Bag.$fDataBag_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_celE:
	movq $24,904(%r13)
	jmp _celB
	.size sat_segm_info, .-sat_segm_info



==================== Liveness annotations added ====================
sat_segm_entry() //  [R1]
        { [(celA,
            sat_segm_info:
                const SehZ_srt-sat_segm_info+120;
                const 1;
                const 64424509457;)]
          # entryIds         = [celA]
          # liveVRegsOnEntry = Just [(celA, [R1 :-> %r1]),
                                     (celB, [segm :-> %vI_segm]), (celC, [segm :-> %vI_segm]),
                                     (celD, [segm :-> %vI_segm]), (celE, [segm :-> %vI_segm])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        celA:
            	movq %rbx,%vI_segm
                    # born:    %vI_segm
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesw
                    # born:    %vI_nesw
                     
            	cmpq %r15,%vI_nesw
                    # r_dying: %vI_nesw
                     
            	jb _celB
                     
            	jmp _celC
                    # r_dying: %vI_segm
                     ,
     NONREC
        celC:
            	addq $24,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _celE
                     
            	jmp _celD
                    # r_dying: %vI_segm
                     ,
     NONREC
        celE:
            	movq $24,904(%r13)
                     
            	jmp _celB
                    # r_dying: %vI_segm
                     ,
     NONREC
        celB:
            	movq %vI_segm,%rbx
                    # born:    %r1
                    # r_dying: %vI_segm
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        celD:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segm,-8(%rbp)
                     
            	movq 16(%vI_segm),%vI_segj
                    # born:    %vI_segj
                    # r_dying: %vI_segm
                     
            	movq $sat_segl_info,-16(%r12)
                     
            	movq %vI_segj,(%r12)
                    # r_dying: %vI_segj
                     
            	leaq -16(%r12),%vI_celk
                    # born:    %vI_celk
                     
            	movq %vI_celk,%r14
                    # born:    %r14
                    # r_dying: %vI_celk
                     
            	movl $Bag.$fDataBag_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segm_info)+120
	.long	0
	.quad	1
	.quad	64424509457
sat_segm_info:
_celA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celB
	jmp _celC
_celC:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celE
	jmp _celD
_celE:
	movq $24,904(%r13)
	jmp _celB
_celB:
	jmp *-16(%r13)
_celD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segl_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%r14
	movl $Bag.$fDataBag_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_segm_info, .-sat_segm_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segm_info)+120
	.long	0
	.quad	1
	.quad	64424509457
sat_segm_info:
_celA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celB
_celC:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celE
_celD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segl_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%r14
	movl $Bag.$fDataBag_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_celE:
	movq $24,904(%r13)
_celB:
	jmp *-16(%r13)
	.size sat_segm_info, .-sat_segm_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segm_info)+120
	.long	0
	.quad	1
	.quad	64424509457
sat_segm_info:
_celA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celB
_celC:
	addq $24,%r12
	cmpq 856(%r13),%r12
	ja _celE
_celD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segl_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movq %rax,%r14
	movl $Bag.$fDataBag_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_celE:
	movq $24,904(%r13)
_celB:
	jmp *-16(%r13)
	.size sat_segm_info, .-sat_segm_info



==================== Optimised Cmm ====================
sat_segn_entry() //  [R1]
        { [(celF,
            sat_segn_info:
                const SehZ_srt-sat_segn_info;
                const 2;
                const 72057374994595859;)]
        }
    {offset
      celF:
          _segn::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto celG; else goto celH;   // CmmCondBranch
      celH:
          Hp = Hp + 248;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto celJ; else goto celI;   // CmmCondBranch
      celJ:
          I64[BaseReg + 904] = 248;   // CmmStore
          goto celG;   // CmmBranch
      celG:
          R1 = _segn::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      celI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segn::P64;   // CmmStore
          _seeZ::P64 = P64[_segn::P64 + 16];   // CmmAssign
          _sefS::P64 = P64[_segn::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 240] = $dData_segd_info;   // CmmStore
          _cekz::P64 = Hp - 240;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 224] = $dData1_sege_info;   // CmmStore
          _cekG::P64 = Hp - 224;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 208] = $dData2_segf_info;   // CmmStore
          _cekN::P64 = Hp - 208;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 192] = $dData3_segg_info;   // CmmStore
          _cekU::P64 = Hp - 192;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 176] = $dData4_segh_info;   // CmmStore
          P64[Hp - 160] = _cekU::P64;   // CmmStore
          _cel1::P64 = Hp - 176;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 152] = $dData5_segi_info;   // CmmStore
          _cel8::P64 = Hp - 152;   // CmmAssign
          I64[Hp - 136] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 128] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 120] = _cel8::P64;   // CmmStore
          P64[Hp - 112] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 104] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 96] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 88] = _cekN::P64;   // CmmStore
          P64[Hp - 80] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 72] = TypeRep.$fDataType_closure;   // CmmStore
          P64[Hp - 64] = Coercion.$fDataCoercion_closure;   // CmmStore
          P64[Hp - 56] = Var.$fDataVar_closure;   // CmmStore
          P64[Hp - 48] = _cekG::P64;   // CmmStore
          P64[Hp - 40] = _cekz::P64;   // CmmStore
          P64[Hp - 32] = TcEvidence.$fDataHsWrapper_closure;   // CmmStore
          P64[Hp - 24] = _cel1::P64;   // CmmStore
          _celf::P64 = Hp - 135;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segm_info;   // CmmStore
          P64[Hp] = _celf::P64;   // CmmStore
          _celg::P64 = Hp - 16;   // CmmAssign
          R3 = _sefS::P64;   // CmmAssign
          R2 = _celg::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segn_info)+0
	.long	0
	.quad	2
	.quad	72057374994595859
sat_segn_info:
_celF:
	movq %rbx,%vI_segn
	leaq -16(%rbp),%vI_nesz
	cmpq %r15,%vI_nesz
	jb _celG
	jmp _celH
_celG:
	movq %vI_segn,%rbx
	jmp *-16(%r13)
_celH:
	addq $248,%r12
	cmpq 856(%r13),%r12
	ja _celJ
	jmp _celI
_celI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segn,-8(%rbp)
	movq 16(%vI_segn),%vI_seeZ
	movq 24(%vI_segn),%vI_sefS
	movq $$dData_segd_info,-240(%r12)
	leaq -240(%r12),%vI_cekz
	movq $$dData1_sege_info,-224(%r12)
	leaq -224(%r12),%vI_cekG
	movq $$dData2_segf_info,-208(%r12)
	leaq -208(%r12),%vI_cekN
	movq $$dData3_segg_info,-192(%r12)
	leaq -192(%r12),%vI_cekU
	movq $$dData4_segh_info,-176(%r12)
	movq %vI_cekU,-160(%r12)
	leaq -176(%r12),%vI_cel1
	movq $$dData5_segi_info,-152(%r12)
	leaq -152(%r12),%vI_cel8
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-136(%r12)
	movq $Var.$fDataVar_closure,-128(%r12)
	movq %vI_cel8,-120(%r12)
	movq $BasicTypes.$fDataFixity_closure,-112(%r12)
	movq $Data.Data.$fDataBool_closure,-104(%r12)
	movq $Name.$fDataName_closure,-96(%r12)
	movq %vI_cekN,-88(%r12)
	movq $Var.$fDataVar_closure,-80(%r12)
	movq $TypeRep.$fDataType_closure,-72(%r12)
	movq $Coercion.$fDataCoercion_closure,-64(%r12)
	movq $Var.$fDataVar_closure,-56(%r12)
	movq %vI_cekG,-48(%r12)
	movq %vI_cekz,-40(%r12)
	movq $TcEvidence.$fDataHsWrapper_closure,-32(%r12)
	movq %vI_cel1,-24(%r12)
	leaq -135(%r12),%vI_celf
	movq $sat_segm_info,-16(%r12)
	movq %vI_celf,(%r12)
	leaq -16(%r12),%vI_celg
	movq %vI_sefS,%rsi
	movq %vI_celg,%r14
	movq %vI_seeZ,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_celJ:
	movq $248,904(%r13)
	jmp _celG
	.size sat_segn_info, .-sat_segn_info



==================== Liveness annotations added ====================
sat_segn_entry() //  [R1]
        { [(celF,
            sat_segn_info:
                const SehZ_srt-sat_segn_info;
                const 2;
                const 72057374994595859;)]
          # entryIds         = [celF]
          # liveVRegsOnEntry = Just [(celF, [R1 :-> %r1]),
                                     (celG, [segn :-> %vI_segn]), (celH, [segn :-> %vI_segn]),
                                     (celI, [segn :-> %vI_segn]), (celJ, [segn :-> %vI_segn])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        celF:
            	movq %rbx,%vI_segn
                    # born:    %vI_segn
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesz
                    # born:    %vI_nesz
                     
            	cmpq %r15,%vI_nesz
                    # r_dying: %vI_nesz
                     
            	jb _celG
                     
            	jmp _celH
                    # r_dying: %vI_segn
                     ,
     NONREC
        celH:
            	addq $248,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _celJ
                     
            	jmp _celI
                    # r_dying: %vI_segn
                     ,
     NONREC
        celJ:
            	movq $248,904(%r13)
                     
            	jmp _celG
                    # r_dying: %vI_segn
                     ,
     NONREC
        celG:
            	movq %vI_segn,%rbx
                    # born:    %r1
                    # r_dying: %vI_segn
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        celI:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segn,-8(%rbp)
                     
            	movq 16(%vI_segn),%vI_seeZ
                    # born:    %vI_seeZ
                     
            	movq 24(%vI_segn),%vI_sefS
                    # born:    %vI_sefS
                    # r_dying: %vI_segn
                     
            	movq $$dData_segd_info,-240(%r12)
                     
            	leaq -240(%r12),%vI_cekz
                    # born:    %vI_cekz
                     
            	movq $$dData1_sege_info,-224(%r12)
                     
            	leaq -224(%r12),%vI_cekG
                    # born:    %vI_cekG
                     
            	movq $$dData2_segf_info,-208(%r12)
                     
            	leaq -208(%r12),%vI_cekN
                    # born:    %vI_cekN
                     
            	movq $$dData3_segg_info,-192(%r12)
                     
            	leaq -192(%r12),%vI_cekU
                    # born:    %vI_cekU
                     
            	movq $$dData4_segh_info,-176(%r12)
                     
            	movq %vI_cekU,-160(%r12)
                    # r_dying: %vI_cekU
                     
            	leaq -176(%r12),%vI_cel1
                    # born:    %vI_cel1
                     
            	movq $$dData5_segi_info,-152(%r12)
                     
            	leaq -152(%r12),%vI_cel8
                    # born:    %vI_cel8
                     
            	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-136(%r12)
                     
            	movq $Var.$fDataVar_closure,-128(%r12)
                     
            	movq %vI_cel8,-120(%r12)
                    # r_dying: %vI_cel8
                     
            	movq $BasicTypes.$fDataFixity_closure,-112(%r12)
                     
            	movq $Data.Data.$fDataBool_closure,-104(%r12)
                     
            	movq $Name.$fDataName_closure,-96(%r12)
                     
            	movq %vI_cekN,-88(%r12)
                    # r_dying: %vI_cekN
                     
            	movq $Var.$fDataVar_closure,-80(%r12)
                     
            	movq $TypeRep.$fDataType_closure,-72(%r12)
                     
            	movq $Coercion.$fDataCoercion_closure,-64(%r12)
                     
            	movq $Var.$fDataVar_closure,-56(%r12)
                     
            	movq %vI_cekG,-48(%r12)
                    # r_dying: %vI_cekG
                     
            	movq %vI_cekz,-40(%r12)
                    # r_dying: %vI_cekz
                     
            	movq $TcEvidence.$fDataHsWrapper_closure,-32(%r12)
                     
            	movq %vI_cel1,-24(%r12)
                    # r_dying: %vI_cel1
                     
            	leaq -135(%r12),%vI_celf
                    # born:    %vI_celf
                     
            	movq $sat_segm_info,-16(%r12)
                     
            	movq %vI_celf,(%r12)
                    # r_dying: %vI_celf
                     
            	leaq -16(%r12),%vI_celg
                    # born:    %vI_celg
                     
            	movq %vI_sefS,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefS
                     
            	movq %vI_celg,%r14
                    # born:    %r14
                    # r_dying: %vI_celg
                     
            	movq %vI_seeZ,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeZ
                     
            	addq $-16,%rbp
                     
            	jmp gq_seeZ_info
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segn_info)+0
	.long	0
	.quad	2
	.quad	72057374994595859
sat_segn_info:
_celF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celG
	jmp _celH
_celH:
	addq $248,%r12
	cmpq 856(%r13),%r12
	ja _celJ
	jmp _celI
_celJ:
	movq $248,904(%r13)
	jmp _celG
_celG:
	jmp *-16(%r13)
_celI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $$dData_segd_info,-240(%r12)
	leaq -240(%r12),%rcx
	movq $$dData1_sege_info,-224(%r12)
	leaq -224(%r12),%rdx
	movq $$dData2_segf_info,-208(%r12)
	leaq -208(%r12),%rsi
	movq $$dData3_segg_info,-192(%r12)
	leaq -192(%r12),%rdi
	movq $$dData4_segh_info,-176(%r12)
	movq %rdi,-160(%r12)
	leaq -176(%r12),%rdi
	movq $$dData5_segi_info,-152(%r12)
	leaq -152(%r12),%r8
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-136(%r12)
	movq $Var.$fDataVar_closure,-128(%r12)
	movq %r8,-120(%r12)
	movq $BasicTypes.$fDataFixity_closure,-112(%r12)
	movq $Data.Data.$fDataBool_closure,-104(%r12)
	movq $Name.$fDataName_closure,-96(%r12)
	movq %rsi,-88(%r12)
	movq $Var.$fDataVar_closure,-80(%r12)
	movq $TypeRep.$fDataType_closure,-72(%r12)
	movq $Coercion.$fDataCoercion_closure,-64(%r12)
	movq $Var.$fDataVar_closure,-56(%r12)
	movq %rdx,-48(%r12)
	movq %rcx,-40(%r12)
	movq $TcEvidence.$fDataHsWrapper_closure,-32(%r12)
	movq %rdi,-24(%r12)
	leaq -135(%r12),%rcx
	movq $sat_segm_info,-16(%r12)
	movq %rcx,(%r12)
	leaq -16(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
	.size sat_segn_info, .-sat_segn_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segn_info)+0
	.long	0
	.quad	2
	.quad	72057374994595859
sat_segn_info:
_celF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celG
_celH:
	addq $248,%r12
	cmpq 856(%r13),%r12
	ja _celJ
_celI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $$dData_segd_info,-240(%r12)
	leaq -240(%r12),%rcx
	movq $$dData1_sege_info,-224(%r12)
	leaq -224(%r12),%rdx
	movq $$dData2_segf_info,-208(%r12)
	leaq -208(%r12),%rsi
	movq $$dData3_segg_info,-192(%r12)
	leaq -192(%r12),%rdi
	movq $$dData4_segh_info,-176(%r12)
	movq %rdi,-160(%r12)
	leaq -176(%r12),%rdi
	movq $$dData5_segi_info,-152(%r12)
	leaq -152(%r12),%r8
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-136(%r12)
	movq $Var.$fDataVar_closure,-128(%r12)
	movq %r8,-120(%r12)
	movq $BasicTypes.$fDataFixity_closure,-112(%r12)
	movq $Data.Data.$fDataBool_closure,-104(%r12)
	movq $Name.$fDataName_closure,-96(%r12)
	movq %rsi,-88(%r12)
	movq $Var.$fDataVar_closure,-80(%r12)
	movq $TypeRep.$fDataType_closure,-72(%r12)
	movq $Coercion.$fDataCoercion_closure,-64(%r12)
	movq $Var.$fDataVar_closure,-56(%r12)
	movq %rdx,-48(%r12)
	movq %rcx,-40(%r12)
	movq $TcEvidence.$fDataHsWrapper_closure,-32(%r12)
	movq %rdi,-24(%r12)
	leaq -135(%r12),%rcx
	movq $sat_segm_info,-16(%r12)
	movq %rcx,(%r12)
	leaq -16(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_celJ:
	movq $248,904(%r13)
_celG:
	jmp *-16(%r13)
	.size sat_segn_info, .-sat_segn_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segn_info)+0
	.long	0
	.quad	2
	.quad	72057374994595859
sat_segn_info:
_celF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _celG
_celH:
	addq $248,%r12
	cmpq 856(%r13),%r12
	ja _celJ
_celI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $$dData_segd_info,-240(%r12)
	leaq -240(%r12),%rcx
	movq $$dData1_sege_info,-224(%r12)
	leaq -224(%r12),%rdx
	movq $$dData2_segf_info,-208(%r12)
	leaq -208(%r12),%rsi
	movq $$dData3_segg_info,-192(%r12)
	leaq -192(%r12),%rdi
	movq $$dData4_segh_info,-176(%r12)
	movq %rdi,-160(%r12)
	leaq -176(%r12),%rdi
	movq $$dData5_segi_info,-152(%r12)
	leaq -152(%r12),%r8
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-136(%r12)
	movq $Var.$fDataVar_closure,-128(%r12)
	movq %r8,-120(%r12)
	movq $BasicTypes.$fDataFixity_closure,-112(%r12)
	movq $Data.Data.$fDataBool_closure,-104(%r12)
	movq $Name.$fDataName_closure,-96(%r12)
	movq %rsi,-88(%r12)
	movq $Var.$fDataVar_closure,-80(%r12)
	movq $TypeRep.$fDataType_closure,-72(%r12)
	movq $Coercion.$fDataCoercion_closure,-64(%r12)
	movq $Var.$fDataVar_closure,-56(%r12)
	movq %rdx,-48(%r12)
	movq %rcx,-40(%r12)
	movq $TcEvidence.$fDataHsWrapper_closure,-32(%r12)
	movq %rdi,-24(%r12)
	leaq -135(%r12),%rcx
	movq $sat_segm_info,-16(%r12)
	movq %rcx,(%r12)
	leaq -16(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_celJ:
	movq $248,904(%r13)
_celG:
	jmp *-16(%r13)
	.size sat_segn_info, .-sat_segn_info



==================== Optimised Cmm ====================
sat_seg8_entry() //  [R1]
        { [(cem4,
            sat_seg8_info:
                const SehZ_srt-sat_seg8_info+128;
                const 0;
                const 1112396529680;)]
        }
    {offset
      cem4:
          _seg8::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cem5; else goto cem6;   // CmmCondBranch
      cem5:
          R1 = _seg8::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cem6:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg8::P64;   // CmmStore
          R3 = HsDoc.$fDataHsDocString_closure;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg8_info)+128
	.long	0
	.quad	0
	.quad	1112396529680
sat_seg8_info:
_cem4:
	movq %rbx,%vI_seg8
	leaq -16(%rbp),%vI_nesC
	cmpq %r15,%vI_nesC
	jb _cem5
	jmp _cem6
_cem5:
	movq %vI_seg8,%rbx
	jmp *-16(%r13)
_cem6:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg8,-8(%rbp)
	movl $HsDoc.$fDataHsDocString_closure,%esi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seg8_info, .-sat_seg8_info



==================== Liveness annotations added ====================
sat_seg8_entry() //  [R1]
        { [(cem4,
            sat_seg8_info:
                const SehZ_srt-sat_seg8_info+128;
                const 0;
                const 1112396529680;)]
          # entryIds         = [cem4]
          # liveVRegsOnEntry = Just [(cem4, [R1 :-> %r1]),
                                     (cem5, [seg8 :-> %vI_seg8]), (cem6, [seg8 :-> %vI_seg8])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cem4:
            	movq %rbx,%vI_seg8
                    # born:    %vI_seg8
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesC
                    # born:    %vI_nesC
                     
            	cmpq %r15,%vI_nesC
                    # r_dying: %vI_nesC
                     
            	jb _cem5
                     
            	jmp _cem6
                    # r_dying: %vI_seg8
                     ,
     NONREC
        cem5:
            	movq %vI_seg8,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg8
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cem6:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg8,-8(%rbp)
                    # r_dying: %vI_seg8
                     
            	movl $HsDoc.$fDataHsDocString_closure,%esi
                    # born:    %r4
                     
            	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $SrcLoc.$fDataGenLocated_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg8_info)+128
	.long	0
	.quad	0
	.quad	1112396529680
sat_seg8_info:
_cem4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem5
	jmp _cem6
_cem5:
	jmp *-16(%r13)
_cem6:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $HsDoc.$fDataHsDocString_closure,%esi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seg8_info, .-sat_seg8_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg8_info)+128
	.long	0
	.quad	0
	.quad	1112396529680
sat_seg8_info:
_cem4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem5
_cem6:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $HsDoc.$fDataHsDocString_closure,%esi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cem5:
	jmp *-16(%r13)
	.size sat_seg8_info, .-sat_seg8_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg8_info)+128
	.long	0
	.quad	0
	.quad	1112396529680
sat_seg8_info:
_cem4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem5
_cem6:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $HsDoc.$fDataHsDocString_closure,%esi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cem5:
	jmp *-16(%r13)
	.size sat_seg8_info, .-sat_seg8_info



==================== Optimised Cmm ====================
sat_seg9_entry() //  [R1]
        { [(cem7,
            sat_seg9_info:
                const SehZ_srt-sat_seg9_info+128;
                const 0;
                const 3311419785232;)]
        }
    {offset
      cem7:
          _seg9::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cem8; else goto cem9;   // CmmCondBranch
      cem9:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cemb; else goto cema;   // CmmCondBranch
      cemb:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cem8;   // CmmBranch
      cem8:
          R1 = _seg9::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cema:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg9::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg8_info;   // CmmStore
          _cem0::P64 = Hp - 8;   // CmmAssign
          R2 = _cem0::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg9_info)+128
	.long	0
	.quad	0
	.quad	3311419785232
sat_seg9_info:
_cem7:
	movq %rbx,%vI_seg9
	leaq -16(%rbp),%vI_nesF
	cmpq %r15,%vI_nesF
	jb _cem8
	jmp _cem9
_cem8:
	movq %vI_seg9,%rbx
	jmp *-16(%r13)
_cem9:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemb
	jmp _cema
_cema:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg9,-8(%rbp)
	movq $sat_seg8_info,-8(%r12)
	leaq -8(%r12),%vI_cem0
	movq %vI_cem0,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemb:
	movq $16,904(%r13)
	jmp _cem8
	.size sat_seg9_info, .-sat_seg9_info



==================== Liveness annotations added ====================
sat_seg9_entry() //  [R1]
        { [(cem7,
            sat_seg9_info:
                const SehZ_srt-sat_seg9_info+128;
                const 0;
                const 3311419785232;)]
          # entryIds         = [cem7]
          # liveVRegsOnEntry = Just [(cem7, [R1 :-> %r1]),
                                     (cem8, [seg9 :-> %vI_seg9]), (cem9, [seg9 :-> %vI_seg9]),
                                     (cema, [seg9 :-> %vI_seg9]), (cemb, [seg9 :-> %vI_seg9])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cem7:
            	movq %rbx,%vI_seg9
                    # born:    %vI_seg9
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesF
                    # born:    %vI_nesF
                     
            	cmpq %r15,%vI_nesF
                    # r_dying: %vI_nesF
                     
            	jb _cem8
                     
            	jmp _cem9
                    # r_dying: %vI_seg9
                     ,
     NONREC
        cem9:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cemb
                     
            	jmp _cema
                    # r_dying: %vI_seg9
                     ,
     NONREC
        cemb:
            	movq $16,904(%r13)
                     
            	jmp _cem8
                    # r_dying: %vI_seg9
                     ,
     NONREC
        cem8:
            	movq %vI_seg9,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg9
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cema:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg9,-8(%rbp)
                    # r_dying: %vI_seg9
                     
            	movq $sat_seg8_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cem0
                    # born:    %vI_cem0
                     
            	movq %vI_cem0,%r14
                    # born:    %r14
                    # r_dying: %vI_cem0
                     
            	movl $Data.Data.$fDataMaybe_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg9_info)+128
	.long	0
	.quad	0
	.quad	3311419785232
sat_seg9_info:
_cem7:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem8
	jmp _cem9
_cem9:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemb
	jmp _cema
_cemb:
	movq $16,904(%r13)
	jmp _cem8
_cem8:
	jmp *-16(%r13)
_cema:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg8_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg9_info, .-sat_seg9_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg9_info)+128
	.long	0
	.quad	0
	.quad	3311419785232
sat_seg9_info:
_cem7:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem8
_cem9:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemb
_cema:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg8_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemb:
	movq $16,904(%r13)
_cem8:
	jmp *-16(%r13)
	.size sat_seg9_info, .-sat_seg9_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg9_info)+128
	.long	0
	.quad	0
	.quad	3311419785232
sat_seg9_info:
_cem7:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cem8
_cem9:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemb
_cema:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg8_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemb:
	movq $16,904(%r13)
_cem8:
	jmp *-16(%r13)
	.size sat_seg9_info, .-sat_seg9_info



==================== Optimised Cmm ====================
sat_seg4_entry() //  [R1]
        { [(cems,
            sat_seg4_info:
                const SehZ_srt-sat_seg4_info+96;
                const 0;
                const 70373039144976;)]
        }
    {offset
      cems:
          _seg4::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cemt; else goto cemu;   // CmmCondBranch
      cemt:
          R1 = _seg4::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemu:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg4::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataIE_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg4_info)+96
	.long	0
	.quad	0
	.quad	70373039144976
sat_seg4_info:
_cems:
	movq %rbx,%vI_seg4
	leaq -16(%rbp),%vI_nesI
	cmpq %r15,%vI_nesI
	jb _cemt
	jmp _cemu
_cemt:
	movq %vI_seg4,%rbx
	jmp *-16(%r13)
_cemu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg4,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataIE_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg4_info, .-sat_seg4_info



==================== Liveness annotations added ====================
sat_seg4_entry() //  [R1]
        { [(cems,
            sat_seg4_info:
                const SehZ_srt-sat_seg4_info+96;
                const 0;
                const 70373039144976;)]
          # entryIds         = [cems]
          # liveVRegsOnEntry = Just [(cems, [R1 :-> %r1]),
                                     (cemt, [seg4 :-> %vI_seg4]), (cemu, [seg4 :-> %vI_seg4])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cems:
            	movq %rbx,%vI_seg4
                    # born:    %vI_seg4
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesI
                    # born:    %vI_nesI
                     
            	cmpq %r15,%vI_nesI
                    # r_dying: %vI_nesI
                     
            	jb _cemt
                     
            	jmp _cemu
                    # r_dying: %vI_seg4
                     ,
     NONREC
        cemt:
            	movq %vI_seg4,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg4
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cemu:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg4,-8(%rbp)
                    # r_dying: %vI_seg4
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $HsImpExp.$fDataIE_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg4_info)+96
	.long	0
	.quad	0
	.quad	70373039144976
sat_seg4_info:
_cems:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemt
	jmp _cemu
_cemt:
	jmp *-16(%r13)
_cemu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataIE_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg4_info, .-sat_seg4_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg4_info)+96
	.long	0
	.quad	0
	.quad	70373039144976
sat_seg4_info:
_cems:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemt
_cemu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataIE_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemt:
	jmp *-16(%r13)
	.size sat_seg4_info, .-sat_seg4_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg4_info)+96
	.long	0
	.quad	0
	.quad	70373039144976
sat_seg4_info:
_cems:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemt
_cemu:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataIE_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemt:
	jmp *-16(%r13)
	.size sat_seg4_info, .-sat_seg4_info



==================== Optimised Cmm ====================
sat_seg5_entry() //  [R1]
        { [(cemv,
            sat_seg5_info:
                const SehZ_srt-sat_seg5_info+96;
                const 0;
                const 70579197575184;)]
        }
    {offset
      cemv:
          _seg5::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cemw; else goto cemx;   // CmmCondBranch
      cemx:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cemz; else goto cemy;   // CmmCondBranch
      cemz:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cemw;   // CmmBranch
      cemw:
          R1 = _seg5::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg5::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg4_info;   // CmmStore
          _cemo::P64 = Hp - 8;   // CmmAssign
          R3 = _cemo::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg5_info)+96
	.long	0
	.quad	0
	.quad	70579197575184
sat_seg5_info:
_cemv:
	movq %rbx,%vI_seg5
	leaq -16(%rbp),%vI_nesL
	cmpq %r15,%vI_nesL
	jb _cemw
	jmp _cemx
_cemw:
	movq %vI_seg5,%rbx
	jmp *-16(%r13)
_cemx:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemz
	jmp _cemy
_cemy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg5,-8(%rbp)
	movq $sat_seg4_info,-8(%r12)
	leaq -8(%r12),%vI_cemo
	movq %vI_cemo,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cemz:
	movq $16,904(%r13)
	jmp _cemw
	.size sat_seg5_info, .-sat_seg5_info



==================== Liveness annotations added ====================
sat_seg5_entry() //  [R1]
        { [(cemv,
            sat_seg5_info:
                const SehZ_srt-sat_seg5_info+96;
                const 0;
                const 70579197575184;)]
          # entryIds         = [cemv]
          # liveVRegsOnEntry = Just [(cemv, [R1 :-> %r1]),
                                     (cemw, [seg5 :-> %vI_seg5]), (cemx, [seg5 :-> %vI_seg5]),
                                     (cemy, [seg5 :-> %vI_seg5]), (cemz, [seg5 :-> %vI_seg5])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cemv:
            	movq %rbx,%vI_seg5
                    # born:    %vI_seg5
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesL
                    # born:    %vI_nesL
                     
            	cmpq %r15,%vI_nesL
                    # r_dying: %vI_nesL
                     
            	jb _cemw
                     
            	jmp _cemx
                    # r_dying: %vI_seg5
                     ,
     NONREC
        cemx:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cemz
                     
            	jmp _cemy
                    # r_dying: %vI_seg5
                     ,
     NONREC
        cemz:
            	movq $16,904(%r13)
                     
            	jmp _cemw
                    # r_dying: %vI_seg5
                     ,
     NONREC
        cemw:
            	movq %vI_seg5,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg5
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cemy:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg5,-8(%rbp)
                    # r_dying: %vI_seg5
                     
            	movq $sat_seg4_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cemo
                    # born:    %vI_cemo
                     
            	movq %vI_cemo,%rsi
                    # born:    %r4
                    # r_dying: %vI_cemo
                     
            	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $SrcLoc.$fDataGenLocated_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg5_info)+96
	.long	0
	.quad	0
	.quad	70579197575184
sat_seg5_info:
_cemv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemw
	jmp _cemx
_cemx:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemz
	jmp _cemy
_cemz:
	movq $16,904(%r13)
	jmp _cemw
_cemw:
	jmp *-16(%r13)
_cemy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg4_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seg5_info, .-sat_seg5_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg5_info)+96
	.long	0
	.quad	0
	.quad	70579197575184
sat_seg5_info:
_cemv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemw
_cemx:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemz
_cemy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg4_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cemz:
	movq $16,904(%r13)
_cemw:
	jmp *-16(%r13)
	.size sat_seg5_info, .-sat_seg5_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg5_info)+96
	.long	0
	.quad	0
	.quad	70579197575184
sat_seg5_info:
_cemv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemw
_cemx:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemz
_cemy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg4_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cemz:
	movq $16,904(%r13)
_cemw:
	jmp *-16(%r13)
	.size sat_seg5_info, .-sat_seg5_info



==================== Optimised Cmm ====================
sat_seg6_entry() //  [R1]
        { [(cemA,
            sat_seg6_info:
                const SehZ_srt-sat_seg6_info+72;
                const 0;
                const 564637875568656;)]
        }
    {offset
      cemA:
          _seg6::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cemB; else goto cemC;   // CmmCondBranch
      cemC:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cemE; else goto cemD;   // CmmCondBranch
      cemE:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cemB;   // CmmBranch
      cemB:
          R1 = _seg6::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg6::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg5_info;   // CmmStore
          _cemk::P64 = Hp - 8;   // CmmAssign
          R2 = _cemk::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg6_info)+72
	.long	0
	.quad	0
	.quad	564637875568656
sat_seg6_info:
_cemA:
	movq %rbx,%vI_seg6
	leaq -16(%rbp),%vI_nesO
	cmpq %r15,%vI_nesO
	jb _cemB
	jmp _cemC
_cemB:
	movq %vI_seg6,%rbx
	jmp *-16(%r13)
_cemC:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemE
	jmp _cemD
_cemD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg6,-8(%rbp)
	movq $sat_seg5_info,-8(%r12)
	leaq -8(%r12),%vI_cemk
	movq %vI_cemk,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemE:
	movq $16,904(%r13)
	jmp _cemB
	.size sat_seg6_info, .-sat_seg6_info



==================== Liveness annotations added ====================
sat_seg6_entry() //  [R1]
        { [(cemA,
            sat_seg6_info:
                const SehZ_srt-sat_seg6_info+72;
                const 0;
                const 564637875568656;)]
          # entryIds         = [cemA]
          # liveVRegsOnEntry = Just [(cemA, [R1 :-> %r1]),
                                     (cemB, [seg6 :-> %vI_seg6]), (cemC, [seg6 :-> %vI_seg6]),
                                     (cemD, [seg6 :-> %vI_seg6]), (cemE, [seg6 :-> %vI_seg6])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cemA:
            	movq %rbx,%vI_seg6
                    # born:    %vI_seg6
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesO
                    # born:    %vI_nesO
                     
            	cmpq %r15,%vI_nesO
                    # r_dying: %vI_nesO
                     
            	jb _cemB
                     
            	jmp _cemC
                    # r_dying: %vI_seg6
                     ,
     NONREC
        cemC:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cemE
                     
            	jmp _cemD
                    # r_dying: %vI_seg6
                     ,
     NONREC
        cemE:
            	movq $16,904(%r13)
                     
            	jmp _cemB
                    # r_dying: %vI_seg6
                     ,
     NONREC
        cemB:
            	movq %vI_seg6,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg6
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cemD:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg6,-8(%rbp)
                    # r_dying: %vI_seg6
                     
            	movq $sat_seg5_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cemk
                    # born:    %vI_cemk
                     
            	movq %vI_cemk,%r14
                    # born:    %r14
                    # r_dying: %vI_cemk
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg6_info)+72
	.long	0
	.quad	0
	.quad	564637875568656
sat_seg6_info:
_cemA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemB
	jmp _cemC
_cemC:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemE
	jmp _cemD
_cemE:
	movq $16,904(%r13)
	jmp _cemB
_cemB:
	jmp *-16(%r13)
_cemD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg5_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg6_info, .-sat_seg6_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg6_info)+72
	.long	0
	.quad	0
	.quad	564637875568656
sat_seg6_info:
_cemA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemB
_cemC:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemE
_cemD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg5_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemE:
	movq $16,904(%r13)
_cemB:
	jmp *-16(%r13)
	.size sat_seg6_info, .-sat_seg6_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg6_info)+72
	.long	0
	.quad	0
	.quad	564637875568656
sat_seg6_info:
_cemA:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemB
_cemC:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemE
_cemD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg5_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemE:
	movq $16,904(%r13)
_cemB:
	jmp *-16(%r13)
	.size sat_seg6_info, .-sat_seg6_info



==================== Optimised Cmm ====================
sat_seg7_entry() //  [R1]
        { [(cemF,
            sat_seg7_info:
                const SehZ_srt-sat_seg7_info+72;
                const 0;
                const 846112852279312;)]
        }
    {offset
      cemF:
          _seg7::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cemG; else goto cemH;   // CmmCondBranch
      cemH:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cemJ; else goto cemI;   // CmmCondBranch
      cemJ:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cemG;   // CmmBranch
      cemG:
          R1 = _seg7::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg7::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg6_info;   // CmmStore
          _cemg::P64 = Hp - 8;   // CmmAssign
          R2 = _cemg::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg7_info)+72
	.long	0
	.quad	0
	.quad	846112852279312
sat_seg7_info:
_cemF:
	movq %rbx,%vI_seg7
	leaq -16(%rbp),%vI_nesR
	cmpq %r15,%vI_nesR
	jb _cemG
	jmp _cemH
_cemG:
	movq %vI_seg7,%rbx
	jmp *-16(%r13)
_cemH:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemJ
	jmp _cemI
_cemI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg7,-8(%rbp)
	movq $sat_seg6_info,-8(%r12)
	leaq -8(%r12),%vI_cemg
	movq %vI_cemg,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemJ:
	movq $16,904(%r13)
	jmp _cemG
	.size sat_seg7_info, .-sat_seg7_info



==================== Liveness annotations added ====================
sat_seg7_entry() //  [R1]
        { [(cemF,
            sat_seg7_info:
                const SehZ_srt-sat_seg7_info+72;
                const 0;
                const 846112852279312;)]
          # entryIds         = [cemF]
          # liveVRegsOnEntry = Just [(cemF, [R1 :-> %r1]),
                                     (cemG, [seg7 :-> %vI_seg7]), (cemH, [seg7 :-> %vI_seg7]),
                                     (cemI, [seg7 :-> %vI_seg7]), (cemJ, [seg7 :-> %vI_seg7])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cemF:
            	movq %rbx,%vI_seg7
                    # born:    %vI_seg7
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesR
                    # born:    %vI_nesR
                     
            	cmpq %r15,%vI_nesR
                    # r_dying: %vI_nesR
                     
            	jb _cemG
                     
            	jmp _cemH
                    # r_dying: %vI_seg7
                     ,
     NONREC
        cemH:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cemJ
                     
            	jmp _cemI
                    # r_dying: %vI_seg7
                     ,
     NONREC
        cemJ:
            	movq $16,904(%r13)
                     
            	jmp _cemG
                    # r_dying: %vI_seg7
                     ,
     NONREC
        cemG:
            	movq %vI_seg7,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg7
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cemI:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg7,-8(%rbp)
                    # r_dying: %vI_seg7
                     
            	movq $sat_seg6_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cemg
                    # born:    %vI_cemg
                     
            	movq %vI_cemg,%r14
                    # born:    %r14
                    # r_dying: %vI_cemg
                     
            	movl $Data.Data.$fDataMaybe_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg7_info)+72
	.long	0
	.quad	0
	.quad	846112852279312
sat_seg7_info:
_cemF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemG
	jmp _cemH
_cemH:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemJ
	jmp _cemI
_cemJ:
	movq $16,904(%r13)
	jmp _cemG
_cemG:
	jmp *-16(%r13)
_cemI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg6_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg7_info, .-sat_seg7_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg7_info)+72
	.long	0
	.quad	0
	.quad	846112852279312
sat_seg7_info:
_cemF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemG
_cemH:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemJ
_cemI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg6_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemJ:
	movq $16,904(%r13)
_cemG:
	jmp *-16(%r13)
	.size sat_seg7_info, .-sat_seg7_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg7_info)+72
	.long	0
	.quad	0
	.quad	846112852279312
sat_seg7_info:
_cemF:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemG
_cemH:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cemJ
_cemI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg6_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemJ:
	movq $16,904(%r13)
_cemG:
	jmp *-16(%r13)
	.size sat_seg7_info, .-sat_seg7_info



==================== Optimised Cmm ====================
sat_seg1_entry() //  [R1]
        { [(cemW,
            sat_seg1_info:
                const SehZ_srt-sat_seg1_info+96;
                const 0;
                const 140741783322640;)]
        }
    {offset
      cemW:
          _seg1::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cemX; else goto cemY;   // CmmCondBranch
      cemX:
          R1 = _seg1::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cemY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg1::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = HsImpExp.$fDataImportDecl_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg1_info)+96
	.long	0
	.quad	0
	.quad	140741783322640
sat_seg1_info:
_cemW:
	movq %rbx,%vI_seg1
	leaq -16(%rbp),%vI_nesU
	cmpq %r15,%vI_nesU
	jb _cemX
	jmp _cemY
_cemX:
	movq %vI_seg1,%rbx
	jmp *-16(%r13)
_cemY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg1,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataImportDecl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg1_info, .-sat_seg1_info



==================== Liveness annotations added ====================
sat_seg1_entry() //  [R1]
        { [(cemW,
            sat_seg1_info:
                const SehZ_srt-sat_seg1_info+96;
                const 0;
                const 140741783322640;)]
          # entryIds         = [cemW]
          # liveVRegsOnEntry = Just [(cemW, [R1 :-> %r1]),
                                     (cemX, [seg1 :-> %vI_seg1]), (cemY, [seg1 :-> %vI_seg1])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cemW:
            	movq %rbx,%vI_seg1
                    # born:    %vI_seg1
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesU
                    # born:    %vI_nesU
                     
            	cmpq %r15,%vI_nesU
                    # r_dying: %vI_nesU
                     
            	jb _cemX
                     
            	jmp _cemY
                    # r_dying: %vI_seg1
                     ,
     NONREC
        cemX:
            	movq %vI_seg1,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg1
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cemY:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg1,-8(%rbp)
                    # r_dying: %vI_seg1
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $HsImpExp.$fDataImportDecl_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg1_info)+96
	.long	0
	.quad	0
	.quad	140741783322640
sat_seg1_info:
_cemW:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemX
	jmp _cemY
_cemX:
	jmp *-16(%r13)
_cemY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataImportDecl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg1_info, .-sat_seg1_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg1_info)+96
	.long	0
	.quad	0
	.quad	140741783322640
sat_seg1_info:
_cemW:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemX
_cemY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataImportDecl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemX:
	jmp *-16(%r13)
	.size sat_seg1_info, .-sat_seg1_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg1_info)+96
	.long	0
	.quad	0
	.quad	140741783322640
sat_seg1_info:
_cemW:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cemX
_cemY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $HsImpExp.$fDataImportDecl_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cemX:
	jmp *-16(%r13)
	.size sat_seg1_info, .-sat_seg1_info



==================== Optimised Cmm ====================
sat_seg2_entry() //  [R1]
        { [(cemZ,
            sat_seg2_info:
                const SehZ_srt-sat_seg2_info+96;
                const 0;
                const 140947941752848;)]
        }
    {offset
      cemZ:
          _seg2::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cen0; else goto cen1;   // CmmCondBranch
      cen1:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cen3; else goto cen2;   // CmmCondBranch
      cen3:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cen0;   // CmmBranch
      cen0:
          R1 = _seg2::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg2::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg1_info;   // CmmStore
          _cemS::P64 = Hp - 8;   // CmmAssign
          R3 = _cemS::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg2_info)+96
	.long	0
	.quad	0
	.quad	140947941752848
sat_seg2_info:
_cemZ:
	movq %rbx,%vI_seg2
	leaq -16(%rbp),%vI_nesX
	cmpq %r15,%vI_nesX
	jb _cen0
	jmp _cen1
_cen0:
	movq %vI_seg2,%rbx
	jmp *-16(%r13)
_cen1:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen3
	jmp _cen2
_cen2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg2,-8(%rbp)
	movq $sat_seg1_info,-8(%r12)
	leaq -8(%r12),%vI_cemS
	movq %vI_cemS,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cen3:
	movq $16,904(%r13)
	jmp _cen0
	.size sat_seg2_info, .-sat_seg2_info



==================== Liveness annotations added ====================
sat_seg2_entry() //  [R1]
        { [(cemZ,
            sat_seg2_info:
                const SehZ_srt-sat_seg2_info+96;
                const 0;
                const 140947941752848;)]
          # entryIds         = [cemZ]
          # liveVRegsOnEntry = Just [(cemZ, [R1 :-> %r1]),
                                     (cen0, [seg2 :-> %vI_seg2]), (cen1, [seg2 :-> %vI_seg2]),
                                     (cen2, [seg2 :-> %vI_seg2]), (cen3, [seg2 :-> %vI_seg2])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cemZ:
            	movq %rbx,%vI_seg2
                    # born:    %vI_seg2
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nesX
                    # born:    %vI_nesX
                     
            	cmpq %r15,%vI_nesX
                    # r_dying: %vI_nesX
                     
            	jb _cen0
                     
            	jmp _cen1
                    # r_dying: %vI_seg2
                     ,
     NONREC
        cen1:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cen3
                     
            	jmp _cen2
                    # r_dying: %vI_seg2
                     ,
     NONREC
        cen3:
            	movq $16,904(%r13)
                     
            	jmp _cen0
                    # r_dying: %vI_seg2
                     ,
     NONREC
        cen0:
            	movq %vI_seg2,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg2
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cen2:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg2,-8(%rbp)
                    # r_dying: %vI_seg2
                     
            	movq $sat_seg1_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cemS
                    # born:    %vI_cemS
                     
            	movq %vI_cemS,%rsi
                    # born:    %r4
                    # r_dying: %vI_cemS
                     
            	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $SrcLoc.$fDataGenLocated_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg2_info)+96
	.long	0
	.quad	0
	.quad	140947941752848
sat_seg2_info:
_cemZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen0
	jmp _cen1
_cen1:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen3
	jmp _cen2
_cen3:
	movq $16,904(%r13)
	jmp _cen0
_cen0:
	jmp *-16(%r13)
_cen2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg1_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seg2_info, .-sat_seg2_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg2_info)+96
	.long	0
	.quad	0
	.quad	140947941752848
sat_seg2_info:
_cemZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen0
_cen1:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen3
_cen2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg1_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cen3:
	movq $16,904(%r13)
_cen0:
	jmp *-16(%r13)
	.size sat_seg2_info, .-sat_seg2_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg2_info)+96
	.long	0
	.quad	0
	.quad	140947941752848
sat_seg2_info:
_cemZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen0
_cen1:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen3
_cen2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg1_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cen3:
	movq $16,904(%r13)
_cen0:
	jmp *-16(%r13)
	.size sat_seg2_info, .-sat_seg2_info



==================== Optimised Cmm ====================
sat_seg3_entry() //  [R1]
        { [(cen4,
            sat_seg3_info:
                const SehZ_srt-sat_seg3_info+72;
                const 0;
                const 1127587828989968;)]
        }
    {offset
      cen4:
          _seg3::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cen5; else goto cen6;   // CmmCondBranch
      cen6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cen8; else goto cen7;   // CmmCondBranch
      cen8:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cen5;   // CmmBranch
      cen5:
          R1 = _seg3::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cen7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg3::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg2_info;   // CmmStore
          _cemO::P64 = Hp - 8;   // CmmAssign
          R2 = _cemO::P64;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg3_info)+72
	.long	0
	.quad	0
	.quad	1127587828989968
sat_seg3_info:
_cen4:
	movq %rbx,%vI_seg3
	leaq -16(%rbp),%vI_net0
	cmpq %r15,%vI_net0
	jb _cen5
	jmp _cen6
_cen5:
	movq %vI_seg3,%rbx
	jmp *-16(%r13)
_cen6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen8
	jmp _cen7
_cen7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg3,-8(%rbp)
	movq $sat_seg2_info,-8(%r12)
	leaq -8(%r12),%vI_cemO
	movq %vI_cemO,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cen8:
	movq $16,904(%r13)
	jmp _cen5
	.size sat_seg3_info, .-sat_seg3_info



==================== Liveness annotations added ====================
sat_seg3_entry() //  [R1]
        { [(cen4,
            sat_seg3_info:
                const SehZ_srt-sat_seg3_info+72;
                const 0;
                const 1127587828989968;)]
          # entryIds         = [cen4]
          # liveVRegsOnEntry = Just [(cen4, [R1 :-> %r1]),
                                     (cen5, [seg3 :-> %vI_seg3]), (cen6, [seg3 :-> %vI_seg3]),
                                     (cen7, [seg3 :-> %vI_seg3]), (cen8, [seg3 :-> %vI_seg3])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cen4:
            	movq %rbx,%vI_seg3
                    # born:    %vI_seg3
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_net0
                    # born:    %vI_net0
                     
            	cmpq %r15,%vI_net0
                    # r_dying: %vI_net0
                     
            	jb _cen5
                     
            	jmp _cen6
                    # r_dying: %vI_seg3
                     ,
     NONREC
        cen6:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cen8
                     
            	jmp _cen7
                    # r_dying: %vI_seg3
                     ,
     NONREC
        cen8:
            	movq $16,904(%r13)
                     
            	jmp _cen5
                    # r_dying: %vI_seg3
                     ,
     NONREC
        cen5:
            	movq %vI_seg3,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg3
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cen7:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg3,-8(%rbp)
                    # r_dying: %vI_seg3
                     
            	movq $sat_seg2_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cemO
                    # born:    %vI_cemO
                     
            	movq %vI_cemO,%r14
                    # born:    %r14
                    # r_dying: %vI_cemO
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg3_info)+72
	.long	0
	.quad	0
	.quad	1127587828989968
sat_seg3_info:
_cen4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen5
	jmp _cen6
_cen6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen8
	jmp _cen7
_cen8:
	movq $16,904(%r13)
	jmp _cen5
_cen5:
	jmp *-16(%r13)
_cen7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg2_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg3_info, .-sat_seg3_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg3_info)+72
	.long	0
	.quad	0
	.quad	1127587828989968
sat_seg3_info:
_cen4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen5
_cen6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen8
_cen7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg2_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cen8:
	movq $16,904(%r13)
_cen5:
	jmp *-16(%r13)
	.size sat_seg3_info, .-sat_seg3_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg3_info)+72
	.long	0
	.quad	0
	.quad	1127587828989968
sat_seg3_info:
_cen4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cen5
_cen6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cen8
_cen7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg2_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cen8:
	movq $16,904(%r13)
_cen5:
	jmp *-16(%r13)
	.size sat_seg3_info, .-sat_seg3_info



==================== Optimised Cmm ====================
sat_sefY_entry() //  [R1]
        { [(cenh,
            sat_sefY_info:
                const SehZ_srt-sat_sefY_info+72;
                const 0;
                const 38654705680;)]
        }
    {offset
      cenh:
          _sefY::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceni; else goto cenj;   // CmmCondBranch
      ceni:
          R1 = _sefY::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenj:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefY::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = Data.Data.$fData[]_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefY_info)+72
	.long	0
	.quad	0
	.quad	38654705680
sat_sefY_info:
_cenh:
	movq %rbx,%vI_sefY
	leaq -16(%rbp),%vI_net3
	cmpq %r15,%vI_net3
	jb _ceni
	jmp _cenj
_ceni:
	movq %vI_sefY,%rbx
	jmp *-16(%r13)
_cenj:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefY,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefY_info, .-sat_sefY_info



==================== Liveness annotations added ====================
sat_sefY_entry() //  [R1]
        { [(cenh,
            sat_sefY_info:
                const SehZ_srt-sat_sefY_info+72;
                const 0;
                const 38654705680;)]
          # entryIds         = [cenh]
          # liveVRegsOnEntry = Just [(cenh, [R1 :-> %r1]),
                                     (ceni, [sefY :-> %vI_sefY]), (cenj, [sefY :-> %vI_sefY])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cenh:
            	movq %rbx,%vI_sefY
                    # born:    %vI_sefY
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_net3
                    # born:    %vI_net3
                     
            	cmpq %r15,%vI_net3
                    # r_dying: %vI_net3
                     
            	jb _ceni
                     
            	jmp _cenj
                    # r_dying: %vI_sefY
                     ,
     NONREC
        ceni:
            	movq %vI_sefY,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefY
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenj:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefY,-8(%rbp)
                    # r_dying: %vI_sefY
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $Data.Data.$fData[]_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefY_info)+72
	.long	0
	.quad	0
	.quad	38654705680
sat_sefY_info:
_cenh:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceni
	jmp _cenj
_ceni:
	jmp *-16(%r13)
_cenj:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefY_info, .-sat_sefY_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefY_info)+72
	.long	0
	.quad	0
	.quad	38654705680
sat_sefY_info:
_cenh:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceni
_cenj:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceni:
	jmp *-16(%r13)
	.size sat_sefY_info, .-sat_sefY_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefY_info)+72
	.long	0
	.quad	0
	.quad	38654705680
sat_sefY_info:
_cenh:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceni
_cenj:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $Data.Data.$fData[]_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceni:
	jmp *-16(%r13)
	.size sat_sefY_info, .-sat_sefY_info



==================== Optimised Cmm ====================
sat_sefX_entry() //  [R1]
        { [(ceno,
            sat_sefX_info:
                const SehZ_srt-sat_sefX_info+96;
                const 0;
                const 21474836496;)]
        }
    {offset
      ceno:
          _sefX::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cenp; else goto cenq;   // CmmCondBranch
      cenp:
          R1 = _sefX::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenq:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefX::P64;   // CmmStore
          R2 = Name.$fDataName_closure;   // CmmAssign
          R1 = UniqFM.$fDataUniqFM_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefX_info)+96
	.long	0
	.quad	0
	.quad	21474836496
sat_sefX_info:
_ceno:
	movq %rbx,%vI_sefX
	leaq -16(%rbp),%vI_net6
	cmpq %r15,%vI_net6
	jb _cenp
	jmp _cenq
_cenp:
	movq %vI_sefX,%rbx
	jmp *-16(%r13)
_cenq:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefX,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefX_info, .-sat_sefX_info



==================== Liveness annotations added ====================
sat_sefX_entry() //  [R1]
        { [(ceno,
            sat_sefX_info:
                const SehZ_srt-sat_sefX_info+96;
                const 0;
                const 21474836496;)]
          # entryIds         = [ceno]
          # liveVRegsOnEntry = Just [(ceno, [R1 :-> %r1]),
                                     (cenp, [sefX :-> %vI_sefX]), (cenq, [sefX :-> %vI_sefX])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceno:
            	movq %rbx,%vI_sefX
                    # born:    %vI_sefX
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_net6
                    # born:    %vI_net6
                     
            	cmpq %r15,%vI_net6
                    # r_dying: %vI_net6
                     
            	jb _cenp
                     
            	jmp _cenq
                    # r_dying: %vI_sefX
                     ,
     NONREC
        cenp:
            	movq %vI_sefX,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefX
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenq:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefX,-8(%rbp)
                    # r_dying: %vI_sefX
                     
            	movl $Name.$fDataName_closure,%r14d
                    # born:    %r14
                     
            	movl $UniqFM.$fDataUniqFM_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefX_info)+96
	.long	0
	.quad	0
	.quad	21474836496
sat_sefX_info:
_ceno:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenp
	jmp _cenq
_cenp:
	jmp *-16(%r13)
_cenq:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefX_info, .-sat_sefX_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefX_info)+96
	.long	0
	.quad	0
	.quad	21474836496
sat_sefX_info:
_ceno:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenp
_cenq:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenp:
	jmp *-16(%r13)
	.size sat_sefX_info, .-sat_sefX_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefX_info)+96
	.long	0
	.quad	0
	.quad	21474836496
sat_sefX_info:
_ceno:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenp
_cenq:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $Name.$fDataName_closure,%r14d
	movl $UniqFM.$fDataUniqFM_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenp:
	jmp *-16(%r13)
	.size sat_sefX_info, .-sat_sefX_info



==================== Optimised Cmm ====================
sat_seg0_entry() //  [R1]
        { [(cens,
            sat_seg0_info:
                const SehZ_srt-sat_seg0_info+72;
                const 0;
                const 6768769674248208;)]
        }
    {offset
      cens:
          _seg0::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cent; else goto cenu;   // CmmCondBranch
      cenu:
          Hp = Hp + 152;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cenw; else goto cenv;   // CmmCondBranch
      cenw:
          I64[BaseReg + 904] = 152;   // CmmStore
          goto cent;   // CmmBranch
      cent:
          R1 = _seg0::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenv:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seg0::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 144] = sat_sefY_info;   // CmmStore
          _cend::P64 = Hp - 144;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 128] = sat_sefX_info;   // CmmStore
          _cenk::P64 = Hp - 128;   // CmmAssign
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 96] = _cenk::P64;   // CmmStore
          P64[Hp - 88] = BasicTypes.$fDataFixity_closure;   // CmmStore
          P64[Hp - 80] = Data.Data.$fDataBool_closure;   // CmmStore
          P64[Hp - 72] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 64] = _cend::P64;   // CmmStore
          P64[Hp - 56] = Name.$fDataName_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenr::P64 = Hp - 111;   // CmmAssign
          R2 = _cenr::P64;   // CmmAssign
          R1 = HsDecls.$fDataHsGroup_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg0_info)+72
	.long	0
	.quad	0
	.quad	6768769674248208
sat_seg0_info:
_cens:
	movq %rbx,%vI_seg0
	leaq -16(%rbp),%vI_net9
	cmpq %r15,%vI_net9
	jb _cent
	jmp _cenu
_cent:
	movq %vI_seg0,%rbx
	jmp *-16(%r13)
_cenu:
	addq $152,%r12
	cmpq 856(%r13),%r12
	ja _cenw
	jmp _cenv
_cenv:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seg0,-8(%rbp)
	movq $sat_sefY_info,-144(%r12)
	leaq -144(%r12),%vI_cend
	movq $sat_sefX_info,-128(%r12)
	leaq -128(%r12),%vI_cenk
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $Name.$fDataName_closure,-104(%r12)
	movq %vI_cenk,-96(%r12)
	movq $BasicTypes.$fDataFixity_closure,-88(%r12)
	movq $Data.Data.$fDataBool_closure,-80(%r12)
	movq $Name.$fDataName_closure,-72(%r12)
	movq %vI_cend,-64(%r12)
	movq $Name.$fDataName_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%vI_cenr
	movq %vI_cenr,%r14
	movl $HsDecls.$fDataHsGroup_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenw:
	movq $152,904(%r13)
	jmp _cent
	.size sat_seg0_info, .-sat_seg0_info



==================== Liveness annotations added ====================
sat_seg0_entry() //  [R1]
        { [(cens,
            sat_seg0_info:
                const SehZ_srt-sat_seg0_info+72;
                const 0;
                const 6768769674248208;)]
          # entryIds         = [cens]
          # liveVRegsOnEntry = Just [(cens, [R1 :-> %r1]),
                                     (cent, [seg0 :-> %vI_seg0]), (cenu, [seg0 :-> %vI_seg0]),
                                     (cenv, [seg0 :-> %vI_seg0]), (cenw, [seg0 :-> %vI_seg0])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cens:
            	movq %rbx,%vI_seg0
                    # born:    %vI_seg0
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_net9
                    # born:    %vI_net9
                     
            	cmpq %r15,%vI_net9
                    # r_dying: %vI_net9
                     
            	jb _cent
                     
            	jmp _cenu
                    # r_dying: %vI_seg0
                     ,
     NONREC
        cenu:
            	addq $152,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cenw
                     
            	jmp _cenv
                    # r_dying: %vI_seg0
                     ,
     NONREC
        cenw:
            	movq $152,904(%r13)
                     
            	jmp _cent
                    # r_dying: %vI_seg0
                     ,
     NONREC
        cent:
            	movq %vI_seg0,%rbx
                    # born:    %r1
                    # r_dying: %vI_seg0
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenv:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seg0,-8(%rbp)
                    # r_dying: %vI_seg0
                     
            	movq $sat_sefY_info,-144(%r12)
                     
            	leaq -144(%r12),%vI_cend
                    # born:    %vI_cend
                     
            	movq $sat_sefX_info,-128(%r12)
                     
            	leaq -128(%r12),%vI_cenk
                    # born:    %vI_cenk
                     
            	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
                     
            	movq $Name.$fDataName_closure,-104(%r12)
                     
            	movq %vI_cenk,-96(%r12)
                    # r_dying: %vI_cenk
                     
            	movq $BasicTypes.$fDataFixity_closure,-88(%r12)
                     
            	movq $Data.Data.$fDataBool_closure,-80(%r12)
                     
            	movq $Name.$fDataName_closure,-72(%r12)
                     
            	movq %vI_cend,-64(%r12)
                    # r_dying: %vI_cend
                     
            	movq $Name.$fDataName_closure,-56(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
                     
            	leaq -111(%r12),%vI_cenr
                    # born:    %vI_cenr
                     
            	movq %vI_cenr,%r14
                    # born:    %r14
                    # r_dying: %vI_cenr
                     
            	movl $HsDecls.$fDataHsGroup_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg0_info)+72
	.long	0
	.quad	0
	.quad	6768769674248208
sat_seg0_info:
_cens:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cent
	jmp _cenu
_cenu:
	addq $152,%r12
	cmpq 856(%r13),%r12
	ja _cenw
	jmp _cenv
_cenw:
	movq $152,904(%r13)
	jmp _cent
_cent:
	jmp *-16(%r13)
_cenv:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefY_info,-144(%r12)
	leaq -144(%r12),%rax
	movq $sat_sefX_info,-128(%r12)
	leaq -128(%r12),%rbx
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $Name.$fDataName_closure,-104(%r12)
	movq %rbx,-96(%r12)
	movq $BasicTypes.$fDataFixity_closure,-88(%r12)
	movq $Data.Data.$fDataBool_closure,-80(%r12)
	movq $Name.$fDataName_closure,-72(%r12)
	movq %rax,-64(%r12)
	movq $Name.$fDataName_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsDecls.$fDataHsGroup_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_seg0_info, .-sat_seg0_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg0_info)+72
	.long	0
	.quad	0
	.quad	6768769674248208
sat_seg0_info:
_cens:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cent
_cenu:
	addq $152,%r12
	cmpq 856(%r13),%r12
	ja _cenw
_cenv:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefY_info,-144(%r12)
	leaq -144(%r12),%rax
	movq $sat_sefX_info,-128(%r12)
	leaq -128(%r12),%rbx
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $Name.$fDataName_closure,-104(%r12)
	movq %rbx,-96(%r12)
	movq $BasicTypes.$fDataFixity_closure,-88(%r12)
	movq $Data.Data.$fDataBool_closure,-80(%r12)
	movq $Name.$fDataName_closure,-72(%r12)
	movq %rax,-64(%r12)
	movq $Name.$fDataName_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsDecls.$fDataHsGroup_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenw:
	movq $152,904(%r13)
_cent:
	jmp *-16(%r13)
	.size sat_seg0_info, .-sat_seg0_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seg0_info)+72
	.long	0
	.quad	0
	.quad	6768769674248208
sat_seg0_info:
_cens:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cent
_cenu:
	addq $152,%r12
	cmpq 856(%r13),%r12
	ja _cenw
_cenv:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefY_info,-144(%r12)
	leaq -144(%r12),%rax
	movq $sat_sefX_info,-128(%r12)
	leaq -128(%r12),%rbx
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $Name.$fDataName_closure,-104(%r12)
	movq %rbx,-96(%r12)
	movq $BasicTypes.$fDataFixity_closure,-88(%r12)
	movq $Data.Data.$fDataBool_closure,-80(%r12)
	movq $Name.$fDataName_closure,-72(%r12)
	movq %rax,-64(%r12)
	movq $Name.$fDataName_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsDecls.$fDataHsGroup_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenw:
	movq $152,904(%r13)
_cent:
	jmp *-16(%r13)
	.size sat_seg0_info, .-sat_seg0_info



==================== Optimised Cmm ====================
sat_sega_entry() //  [R1]
        { [(cenx,
            sat_sega_info:
                const SehZ_srt-sat_sega_info+72;
                const 0;
                const 17888680521760784;)]
        }
    {offset
      cenx:
          _sega::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceny; else goto cenz;   // CmmCondBranch
      cenz:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cenB; else goto cenA;   // CmmCondBranch
      cenB:
          I64[BaseReg + 904] = 64;   // CmmStore
          goto ceny;   // CmmBranch
      ceny:
          R1 = _sega::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sega::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 56] = sat_seg9_info;   // CmmStore
          _celW::P64 = Hp - 56;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_seg7_info;   // CmmStore
          _cemc::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_seg3_info;   // CmmStore
          _cemK::P64 = Hp - 24;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_seg0_info;   // CmmStore
          _cen9::P64 = Hp - 8;   // CmmAssign
          R5 = _celW::P64;   // CmmAssign
          R4 = _cemc::P64;   // CmmAssign
          R3 = _cemK::P64;   // CmmAssign
          R2 = _cen9::P64;   // CmmAssign
          R1 = Data.Data.$fData(,,,)_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pppp_fast(R5,
                                R4,
                                R3,
                                R2,
                                R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sega_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_sega_info:
_cenx:
	movq %rbx,%vI_sega
	leaq -16(%rbp),%vI_netc
	cmpq %r15,%vI_netc
	jb _ceny
	jmp _cenz
_ceny:
	movq %vI_sega,%rbx
	jmp *-16(%r13)
_cenz:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cenB
	jmp _cenA
_cenA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sega,-8(%rbp)
	movq $sat_seg9_info,-56(%r12)
	leaq -56(%r12),%vI_celW
	movq $sat_seg7_info,-40(%r12)
	leaq -40(%r12),%vI_cemc
	movq $sat_seg3_info,-24(%r12)
	leaq -24(%r12),%vI_cemK
	movq $sat_seg0_info,-8(%r12)
	leaq -8(%r12),%vI_cen9
	movq %vI_celW,%r8
	movq %vI_cemc,%rdi
	movq %vI_cemK,%rsi
	movq %vI_cen9,%r14
	movl $Data.Data.$fData(,,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pppp_fast
_cenB:
	movq $64,904(%r13)
	jmp _ceny
	.size sat_sega_info, .-sat_sega_info



==================== Liveness annotations added ====================
sat_sega_entry() //  [R1]
        { [(cenx,
            sat_sega_info:
                const SehZ_srt-sat_sega_info+72;
                const 0;
                const 17888680521760784;)]
          # entryIds         = [cenx]
          # liveVRegsOnEntry = Just [(cenx, [R1 :-> %r1]),
                                     (ceny, [sega :-> %vI_sega]), (cenz, [sega :-> %vI_sega]),
                                     (cenA, [sega :-> %vI_sega]), (cenB, [sega :-> %vI_sega])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cenx:
            	movq %rbx,%vI_sega
                    # born:    %vI_sega
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netc
                    # born:    %vI_netc
                     
            	cmpq %r15,%vI_netc
                    # r_dying: %vI_netc
                     
            	jb _ceny
                     
            	jmp _cenz
                    # r_dying: %vI_sega
                     ,
     NONREC
        cenz:
            	addq $64,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cenB
                     
            	jmp _cenA
                    # r_dying: %vI_sega
                     ,
     NONREC
        cenB:
            	movq $64,904(%r13)
                     
            	jmp _ceny
                    # r_dying: %vI_sega
                     ,
     NONREC
        ceny:
            	movq %vI_sega,%rbx
                    # born:    %r1
                    # r_dying: %vI_sega
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenA:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sega,-8(%rbp)
                    # r_dying: %vI_sega
                     
            	movq $sat_seg9_info,-56(%r12)
                     
            	leaq -56(%r12),%vI_celW
                    # born:    %vI_celW
                     
            	movq $sat_seg7_info,-40(%r12)
                     
            	leaq -40(%r12),%vI_cemc
                    # born:    %vI_cemc
                     
            	movq $sat_seg3_info,-24(%r12)
                     
            	leaq -24(%r12),%vI_cemK
                    # born:    %vI_cemK
                     
            	movq $sat_seg0_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cen9
                    # born:    %vI_cen9
                     
            	movq %vI_celW,%r8
                    # born:    %r8
                    # r_dying: %vI_celW
                     
            	movq %vI_cemc,%rdi
                    # born:    %r5
                    # r_dying: %vI_cemc
                     
            	movq %vI_cemK,%rsi
                    # born:    %r4
                    # r_dying: %vI_cemK
                     
            	movq %vI_cen9,%r14
                    # born:    %r14
                    # r_dying: %vI_cen9
                     
            	movl $Data.Data.$fData(,,,)_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pppp_fast
                    # r_dying: %r1 %r4 %r5 %r8 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sega_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_sega_info:
_cenx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceny
	jmp _cenz
_cenz:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cenB
	jmp _cenA
_cenB:
	movq $64,904(%r13)
	jmp _ceny
_ceny:
	jmp *-16(%r13)
_cenA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg9_info,-56(%r12)
	leaq -56(%r12),%rax
	movq $sat_seg7_info,-40(%r12)
	leaq -40(%r12),%rbx
	movq $sat_seg3_info,-24(%r12)
	leaq -24(%r12),%rcx
	movq $sat_seg0_info,-8(%r12)
	leaq -8(%r12),%rdx
	movq %rax,%r8
	movq %rbx,%rdi
	movq %rcx,%rsi
	movq %rdx,%r14
	movl $Data.Data.$fData(,,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pppp_fast
	.size sat_sega_info, .-sat_sega_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sega_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_sega_info:
_cenx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceny
_cenz:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cenB
_cenA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg9_info,-56(%r12)
	leaq -56(%r12),%rax
	movq $sat_seg7_info,-40(%r12)
	leaq -40(%r12),%rbx
	movq $sat_seg3_info,-24(%r12)
	leaq -24(%r12),%rcx
	movq $sat_seg0_info,-8(%r12)
	leaq -8(%r12),%rdx
	movq %rax,%r8
	movq %rbx,%rdi
	movq %rcx,%rsi
	movq %rdx,%r14
	movl $Data.Data.$fData(,,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pppp_fast
_cenB:
	movq $64,904(%r13)
_ceny:
	jmp *-16(%r13)
	.size sat_sega_info, .-sat_sega_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sega_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_sega_info:
_cenx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceny
_cenz:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cenB
_cenA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_seg9_info,-56(%r12)
	leaq -56(%r12),%rax
	movq $sat_seg7_info,-40(%r12)
	leaq -40(%r12),%rbx
	movq $sat_seg3_info,-24(%r12)
	leaq -24(%r12),%rcx
	movq $sat_seg0_info,-8(%r12)
	leaq -8(%r12),%rdx
	movq %rax,%r8
	movq %rbx,%rdi
	movq %rcx,%rsi
	movq %rdx,%r14
	movl $Data.Data.$fData(,,,)_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pppp_fast
_cenB:
	movq $64,904(%r13)
_ceny:
	jmp *-16(%r13)
	.size sat_sega_info, .-sat_sega_info



==================== Optimised Cmm ====================
sat_segb_entry() //  [R1]
        { [(cenC,
            sat_segb_info:
                const SehZ_srt-sat_segb_info+72;
                const 0;
                const 17888680521760784;)]
        }
    {offset
      cenC:
          _segb::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cenD; else goto cenE;   // CmmCondBranch
      cenE:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cenG; else goto cenF;   // CmmCondBranch
      cenG:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cenD;   // CmmBranch
      cenD:
          R1 = _segb::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenF:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segb::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sega_info;   // CmmStore
          _celS::P64 = Hp - 8;   // CmmAssign
          R2 = _celS::P64;   // CmmAssign
          R1 = Data.Data.$fDataMaybe_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segb_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_segb_info:
_cenC:
	movq %rbx,%vI_segb
	leaq -16(%rbp),%vI_netf
	cmpq %r15,%vI_netf
	jb _cenD
	jmp _cenE
_cenD:
	movq %vI_segb,%rbx
	jmp *-16(%r13)
_cenE:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenG
	jmp _cenF
_cenF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segb,-8(%rbp)
	movq $sat_sega_info,-8(%r12)
	leaq -8(%r12),%vI_celS
	movq %vI_celS,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenG:
	movq $16,904(%r13)
	jmp _cenD
	.size sat_segb_info, .-sat_segb_info



==================== Liveness annotations added ====================
sat_segb_entry() //  [R1]
        { [(cenC,
            sat_segb_info:
                const SehZ_srt-sat_segb_info+72;
                const 0;
                const 17888680521760784;)]
          # entryIds         = [cenC]
          # liveVRegsOnEntry = Just [(cenC, [R1 :-> %r1]),
                                     (cenD, [segb :-> %vI_segb]), (cenE, [segb :-> %vI_segb]),
                                     (cenF, [segb :-> %vI_segb]), (cenG, [segb :-> %vI_segb])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cenC:
            	movq %rbx,%vI_segb
                    # born:    %vI_segb
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netf
                    # born:    %vI_netf
                     
            	cmpq %r15,%vI_netf
                    # r_dying: %vI_netf
                     
            	jb _cenD
                     
            	jmp _cenE
                    # r_dying: %vI_segb
                     ,
     NONREC
        cenE:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cenG
                     
            	jmp _cenF
                    # r_dying: %vI_segb
                     ,
     NONREC
        cenG:
            	movq $16,904(%r13)
                     
            	jmp _cenD
                    # r_dying: %vI_segb
                     ,
     NONREC
        cenD:
            	movq %vI_segb,%rbx
                    # born:    %r1
                    # r_dying: %vI_segb
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenF:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segb,-8(%rbp)
                    # r_dying: %vI_segb
                     
            	movq $sat_sega_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_celS
                    # born:    %vI_celS
                     
            	movq %vI_celS,%r14
                    # born:    %r14
                    # r_dying: %vI_celS
                     
            	movl $Data.Data.$fDataMaybe_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segb_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_segb_info:
_cenC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenD
	jmp _cenE
_cenE:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenG
	jmp _cenF
_cenG:
	movq $16,904(%r13)
	jmp _cenD
_cenD:
	jmp *-16(%r13)
_cenF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sega_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_segb_info, .-sat_segb_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segb_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_segb_info:
_cenC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenD
_cenE:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenG
_cenF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sega_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenG:
	movq $16,904(%r13)
_cenD:
	jmp *-16(%r13)
	.size sat_segb_info, .-sat_segb_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segb_info)+72
	.long	0
	.quad	0
	.quad	17888680521760784
sat_segb_info:
_cenC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenD
_cenE:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenG
_cenF:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sega_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%r14
	movl $Data.Data.$fDataMaybe_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cenG:
	movq $16,904(%r13)
_cenD:
	jmp *-16(%r13)
	.size sat_segb_info, .-sat_segb_info



==================== Optimised Cmm ====================
sat_segc_entry() //  [R1]
        { [(cenH,
            sat_segc_info:
                const SehZ_srt-sat_segc_info;
                const 2;
                const 9159006407121436691;)]
        }
    {offset
      cenH:
          _segc::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cenI; else goto cenJ;   // CmmCondBranch
      cenJ:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cenL; else goto cenK;   // CmmCondBranch
      cenL:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cenI;   // CmmBranch
      cenI:
          R1 = _segc::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cenK:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segc::P64;   // CmmStore
          _seeZ::P64 = P64[_segc::P64 + 16];   // CmmAssign
          _sefR::P64 = P64[_segc::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segb_info;   // CmmStore
          _celO::P64 = Hp - 8;   // CmmAssign
          R3 = _sefR::P64;   // CmmAssign
          R2 = _celO::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segc_info)+0
	.long	0
	.quad	2
	.quad	9159006407121436691
sat_segc_info:
_cenH:
	movq %rbx,%vI_segc
	leaq -16(%rbp),%vI_neti
	cmpq %r15,%vI_neti
	jb _cenI
	jmp _cenJ
_cenI:
	movq %vI_segc,%rbx
	jmp *-16(%r13)
_cenJ:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenL
	jmp _cenK
_cenK:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segc,-8(%rbp)
	movq 16(%vI_segc),%vI_seeZ
	movq 24(%vI_segc),%vI_sefR
	movq $sat_segb_info,-8(%r12)
	leaq -8(%r12),%vI_celO
	movq %vI_sefR,%rsi
	movq %vI_celO,%r14
	movq %vI_seeZ,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_cenL:
	movq $16,904(%r13)
	jmp _cenI
	.size sat_segc_info, .-sat_segc_info



==================== Liveness annotations added ====================
sat_segc_entry() //  [R1]
        { [(cenH,
            sat_segc_info:
                const SehZ_srt-sat_segc_info;
                const 2;
                const 9159006407121436691;)]
          # entryIds         = [cenH]
          # liveVRegsOnEntry = Just [(cenH, [R1 :-> %r1]),
                                     (cenI, [segc :-> %vI_segc]), (cenJ, [segc :-> %vI_segc]),
                                     (cenK, [segc :-> %vI_segc]), (cenL, [segc :-> %vI_segc])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cenH:
            	movq %rbx,%vI_segc
                    # born:    %vI_segc
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neti
                    # born:    %vI_neti
                     
            	cmpq %r15,%vI_neti
                    # r_dying: %vI_neti
                     
            	jb _cenI
                     
            	jmp _cenJ
                    # r_dying: %vI_segc
                     ,
     NONREC
        cenJ:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cenL
                     
            	jmp _cenK
                    # r_dying: %vI_segc
                     ,
     NONREC
        cenL:
            	movq $16,904(%r13)
                     
            	jmp _cenI
                    # r_dying: %vI_segc
                     ,
     NONREC
        cenI:
            	movq %vI_segc,%rbx
                    # born:    %r1
                    # r_dying: %vI_segc
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cenK:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segc,-8(%rbp)
                     
            	movq 16(%vI_segc),%vI_seeZ
                    # born:    %vI_seeZ
                     
            	movq 24(%vI_segc),%vI_sefR
                    # born:    %vI_sefR
                    # r_dying: %vI_segc
                     
            	movq $sat_segb_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_celO
                    # born:    %vI_celO
                     
            	movq %vI_sefR,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefR
                     
            	movq %vI_celO,%r14
                    # born:    %r14
                    # r_dying: %vI_celO
                     
            	movq %vI_seeZ,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeZ
                     
            	addq $-16,%rbp
                     
            	jmp gq_seeZ_info
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segc_info)+0
	.long	0
	.quad	2
	.quad	9159006407121436691
sat_segc_info:
_cenH:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenI
	jmp _cenJ
_cenJ:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenL
	jmp _cenK
_cenL:
	movq $16,904(%r13)
	jmp _cenI
_cenI:
	jmp *-16(%r13)
_cenK:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_segb_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
	.size sat_segc_info, .-sat_segc_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segc_info)+0
	.long	0
	.quad	2
	.quad	9159006407121436691
sat_segc_info:
_cenH:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenI
_cenJ:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenL
_cenK:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_segb_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_cenL:
	movq $16,904(%r13)
_cenI:
	jmp *-16(%r13)
	.size sat_segc_info, .-sat_segc_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segc_info)+0
	.long	0
	.quad	2
	.quad	9159006407121436691
sat_segc_info:
_cenH:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cenI
_cenJ:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cenL
_cenK:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_segb_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_cenL:
	movq $16,904(%r13)
_cenI:
	jmp *-16(%r13)
	.size sat_segc_info, .-sat_segc_info



==================== Optimised Cmm ====================
sat_sefU_entry() //  [R1]
        { [(cenZ,
            sat_sefU_info:
                const SehZ_srt-sat_sefU_info+232;
                const 0;
                const 55834574864;)]
        }
    {offset
      cenZ:
          _sefU::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceo0; else goto ceo1;   // CmmCondBranch
      ceo1:
          Hp = Hp + 120;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceo3; else goto ceo2;   // CmmCondBranch
      ceo3:
          I64[BaseReg + 904] = 120;   // CmmStore
          goto ceo0;   // CmmBranch
      ceo0:
          R1 = _sefU::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo2:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefU::P64;   // CmmStore
          I64[Hp - 112] = GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info;   // CmmStore
          P64[Hp - 104] = RdrName.$fDataRdrName_closure;   // CmmStore
          P64[Hp - 96] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 88] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 80] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 72] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 64] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 56] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 48] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 40] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 32] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 24] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 16] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp - 8] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          P64[Hp] = PlaceHolder.$fDataPlaceHolder_closure;   // CmmStore
          _cenY::P64 = Hp - 111;   // CmmAssign
          R2 = _cenY::P64;   // CmmAssign
          R1 = HsSyn.$fDataHsModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefU_info)+232
	.long	0
	.quad	0
	.quad	55834574864
sat_sefU_info:
_cenZ:
	movq %rbx,%vI_sefU
	leaq -16(%rbp),%vI_netl
	cmpq %r15,%vI_netl
	jb _ceo0
	jmp _ceo1
_ceo0:
	movq %vI_sefU,%rbx
	jmp *-16(%r13)
_ceo1:
	addq $120,%r12
	cmpq 856(%r13),%r12
	ja _ceo3
	jmp _ceo2
_ceo2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefU,-8(%rbp)
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $RdrName.$fDataRdrName_closure,-104(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-96(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-88(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-80(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-72(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-64(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%vI_cenY
	movq %vI_cenY,%r14
	movl $HsSyn.$fDataHsModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceo3:
	movq $120,904(%r13)
	jmp _ceo0
	.size sat_sefU_info, .-sat_sefU_info



==================== Liveness annotations added ====================
sat_sefU_entry() //  [R1]
        { [(cenZ,
            sat_sefU_info:
                const SehZ_srt-sat_sefU_info+232;
                const 0;
                const 55834574864;)]
          # entryIds         = [cenZ]
          # liveVRegsOnEntry = Just [(cenZ, [R1 :-> %r1]),
                                     (ceo0, [sefU :-> %vI_sefU]), (ceo1, [sefU :-> %vI_sefU]),
                                     (ceo2, [sefU :-> %vI_sefU]), (ceo3, [sefU :-> %vI_sefU])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cenZ:
            	movq %rbx,%vI_sefU
                    # born:    %vI_sefU
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netl
                    # born:    %vI_netl
                     
            	cmpq %r15,%vI_netl
                    # r_dying: %vI_netl
                     
            	jb _ceo0
                     
            	jmp _ceo1
                    # r_dying: %vI_sefU
                     ,
     NONREC
        ceo1:
            	addq $120,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceo3
                     
            	jmp _ceo2
                    # r_dying: %vI_sefU
                     ,
     NONREC
        ceo3:
            	movq $120,904(%r13)
                     
            	jmp _ceo0
                    # r_dying: %vI_sefU
                     ,
     NONREC
        ceo0:
            	movq %vI_sefU,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefU
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceo2:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefU,-8(%rbp)
                    # r_dying: %vI_sefU
                     
            	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
                     
            	movq $RdrName.$fDataRdrName_closure,-104(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-96(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-88(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-80(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-72(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-64(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-56(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
                     
            	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
                     
            	leaq -111(%r12),%vI_cenY
                    # born:    %vI_cenY
                     
            	movq %vI_cenY,%r14
                    # born:    %r14
                    # r_dying: %vI_cenY
                     
            	movl $HsSyn.$fDataHsModule_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefU_info)+232
	.long	0
	.quad	0
	.quad	55834574864
sat_sefU_info:
_cenZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo0
	jmp _ceo1
_ceo1:
	addq $120,%r12
	cmpq 856(%r13),%r12
	ja _ceo3
	jmp _ceo2
_ceo3:
	movq $120,904(%r13)
	jmp _ceo0
_ceo0:
	jmp *-16(%r13)
_ceo2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $RdrName.$fDataRdrName_closure,-104(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-96(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-88(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-80(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-72(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-64(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsSyn.$fDataHsModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefU_info, .-sat_sefU_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefU_info)+232
	.long	0
	.quad	0
	.quad	55834574864
sat_sefU_info:
_cenZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo0
_ceo1:
	addq $120,%r12
	cmpq 856(%r13),%r12
	ja _ceo3
_ceo2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $RdrName.$fDataRdrName_closure,-104(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-96(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-88(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-80(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-72(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-64(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsSyn.$fDataHsModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceo3:
	movq $120,904(%r13)
_ceo0:
	jmp *-16(%r13)
	.size sat_sefU_info, .-sat_sefU_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefU_info)+232
	.long	0
	.quad	0
	.quad	55834574864
sat_sefU_info:
_cenZ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo0
_ceo1:
	addq $120,%r12
	cmpq 856(%r13),%r12
	ja _ceo3
_ceo2:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $GHC.Classes.D:(%,,,,,,,,,,,,,%)_con_info,-112(%r12)
	movq $RdrName.$fDataRdrName_closure,-104(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-96(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-88(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-80(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-72(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-64(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-56(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-48(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-40(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-32(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-24(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-16(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,-8(%r12)
	movq $PlaceHolder.$fDataPlaceHolder_closure,(%r12)
	leaq -111(%r12),%rax
	movq %rax,%r14
	movl $HsSyn.$fDataHsModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceo3:
	movq $120,904(%r13)
_ceo0:
	jmp *-16(%r13)
	.size sat_sefU_info, .-sat_sefU_info



==================== Optimised Cmm ====================
sat_sefV_entry() //  [R1]
        { [(ceo4,
            sat_sefV_info:
                const SehZ_srt-sat_sefV_info+128;
                const 0;
                const 457409722056720;)]
        }
    {offset
      ceo4:
          _sefV::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceo5; else goto ceo6;   // CmmCondBranch
      ceo6:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceo8; else goto ceo7;   // CmmCondBranch
      ceo8:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto ceo5;   // CmmBranch
      ceo5:
          R1 = _sefV::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceo7:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefV::P64;   // CmmStore
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefU_info;   // CmmStore
          _cenU::P64 = Hp - 8;   // CmmAssign
          R3 = _cenU::P64;   // CmmAssign
          R2 = SrcLoc.$fDataSrcSpan_closure;   // CmmAssign
          R1 = SrcLoc.$fDataGenLocated_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefV_info)+128
	.long	0
	.quad	0
	.quad	457409722056720
sat_sefV_info:
_ceo4:
	movq %rbx,%vI_sefV
	leaq -16(%rbp),%vI_neto
	cmpq %r15,%vI_neto
	jb _ceo5
	jmp _ceo6
_ceo5:
	movq %vI_sefV,%rbx
	jmp *-16(%r13)
_ceo6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceo8
	jmp _ceo7
_ceo7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefV,-8(%rbp)
	movq $sat_sefU_info,-8(%r12)
	leaq -8(%r12),%vI_cenU
	movq %vI_cenU,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceo8:
	movq $16,904(%r13)
	jmp _ceo5
	.size sat_sefV_info, .-sat_sefV_info



==================== Liveness annotations added ====================
sat_sefV_entry() //  [R1]
        { [(ceo4,
            sat_sefV_info:
                const SehZ_srt-sat_sefV_info+128;
                const 0;
                const 457409722056720;)]
          # entryIds         = [ceo4]
          # liveVRegsOnEntry = Just [(ceo4, [R1 :-> %r1]),
                                     (ceo5, [sefV :-> %vI_sefV]), (ceo6, [sefV :-> %vI_sefV]),
                                     (ceo7, [sefV :-> %vI_sefV]), (ceo8, [sefV :-> %vI_sefV])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceo4:
            	movq %rbx,%vI_sefV
                    # born:    %vI_sefV
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neto
                    # born:    %vI_neto
                     
            	cmpq %r15,%vI_neto
                    # r_dying: %vI_neto
                     
            	jb _ceo5
                     
            	jmp _ceo6
                    # r_dying: %vI_sefV
                     ,
     NONREC
        ceo6:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceo8
                     
            	jmp _ceo7
                    # r_dying: %vI_sefV
                     ,
     NONREC
        ceo8:
            	movq $16,904(%r13)
                     
            	jmp _ceo5
                    # r_dying: %vI_sefV
                     ,
     NONREC
        ceo5:
            	movq %vI_sefV,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefV
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceo7:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefV,-8(%rbp)
                    # r_dying: %vI_sefV
                     
            	movq $sat_sefU_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cenU
                    # born:    %vI_cenU
                     
            	movq %vI_cenU,%rsi
                    # born:    %r4
                    # r_dying: %vI_cenU
                     
            	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
                    # born:    %r14
                     
            	movl $SrcLoc.$fDataGenLocated_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefV_info)+128
	.long	0
	.quad	0
	.quad	457409722056720
sat_sefV_info:
_ceo4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo5
	jmp _ceo6
_ceo6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceo8
	jmp _ceo7
_ceo8:
	movq $16,904(%r13)
	jmp _ceo5
_ceo5:
	jmp *-16(%r13)
_ceo7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefU_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefV_info, .-sat_sefV_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefV_info)+128
	.long	0
	.quad	0
	.quad	457409722056720
sat_sefV_info:
_ceo4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo5
_ceo6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceo8
_ceo7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefU_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceo8:
	movq $16,904(%r13)
_ceo5:
	jmp *-16(%r13)
	.size sat_sefV_info, .-sat_sefV_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefV_info)+128
	.long	0
	.quad	0
	.quad	457409722056720
sat_sefV_info:
_ceo4:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceo5
_ceo6:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceo8
_ceo7:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq $sat_sefU_info,-8(%r12)
	leaq -8(%r12),%rax
	movq %rax,%rsi
	movl $SrcLoc.$fDataSrcSpan_closure,%r14d
	movl $SrcLoc.$fDataGenLocated_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceo8:
	movq $16,904(%r13)
_ceo5:
	jmp *-16(%r13)
	.size sat_sefV_info, .-sat_sefV_info



==================== Optimised Cmm ====================
section ""relreadonly" . uerG_srtd" {
    uerG_srtd:
        const SehZ_srt;
        const 33;
        const 6979518925;
}



==================== Native code ====================
.section .data.rel.ro
.align 8
.align 1
uerG_srtd:
	.quad	SehZ_srt
	.quad	33
	.quad	6979518925



==================== Liveness annotations added ====================
section ""relreadonly" . uerG_srtd" {
    (1,
     uerG_srtd:
         const SehZ_srt;
         const 33;
         const 6979518925;)
}



==================== Registers allocated ====================
.section .data.rel.ro
.align 8
.align 1
uerG_srtd:
	.quad	SehZ_srt
	.quad	33
	.quad	6979518925



==================== Synthetic instructions expanded ====================
.section .data.rel.ro
.align 8
.align 1
uerG_srtd:
	.quad	SehZ_srt
	.quad	33
	.quad	6979518925



==================== Asm code ====================
.section .data.rel.ro
.align 8
.align 1
uerG_srtd:
	.quad	SehZ_srt
	.quad	33
	.quad	6979518925



==================== Optimised Cmm ====================
sat_sefW_entry() //  [R1]
        { [(ceo9,
            sat_sefW_info:
                const uerG_srtd-sat_sefW_info;
                const 2;
                const 18446744069414584339;)]
        }
    {offset
      ceo9:
          _sefW::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceoa; else goto ceob;   // CmmCondBranch
      ceob:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceod; else goto ceoc;   // CmmCondBranch
      ceod:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto ceoa;   // CmmBranch
      ceoa:
          R1 = _sefW::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoc:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefW::P64;   // CmmStore
          _seeZ::P64 = P64[_sefW::P64 + 16];   // CmmAssign
          _sefQ::P64 = P64[_sefW::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefV_info;   // CmmStore
          _cenQ::P64 = Hp - 8;   // CmmAssign
          R3 = _sefQ::P64;   // CmmAssign
          R2 = _cenQ::P64;   // CmmAssign
          R1 = _seeZ::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call gq_seeZ_info(R3,
                            R2,
                            R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	uerG_srtd-(sat_sefW_info)+0
	.long	0
	.quad	2
	.quad	-4294967277
sat_sefW_info:
_ceo9:
	movq %rbx,%vI_sefW
	leaq -16(%rbp),%vI_nets
	cmpq %r15,%vI_nets
	jb _ceoa
	jmp _ceob
_ceoa:
	movq %vI_sefW,%rbx
	jmp *-16(%r13)
_ceob:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceod
	jmp _ceoc
_ceoc:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefW,-8(%rbp)
	movq 16(%vI_sefW),%vI_seeZ
	movq 24(%vI_sefW),%vI_sefQ
	movq $sat_sefV_info,-8(%r12)
	leaq -8(%r12),%vI_cenQ
	movq %vI_sefQ,%rsi
	movq %vI_cenQ,%r14
	movq %vI_seeZ,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_ceod:
	movq $16,904(%r13)
	jmp _ceoa
	.size sat_sefW_info, .-sat_sefW_info



==================== Liveness annotations added ====================
sat_sefW_entry() //  [R1]
        { [(ceo9,
            sat_sefW_info:
                const uerG_srtd-sat_sefW_info;
                const 2;
                const 18446744069414584339;)]
          # entryIds         = [ceo9]
          # liveVRegsOnEntry = Just [(ceo9, [R1 :-> %r1]),
                                     (ceoa, [sefW :-> %vI_sefW]), (ceob, [sefW :-> %vI_sefW]),
                                     (ceoc, [sefW :-> %vI_sefW]), (ceod, [sefW :-> %vI_sefW])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceo9:
            	movq %rbx,%vI_sefW
                    # born:    %vI_sefW
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nets
                    # born:    %vI_nets
                     
            	cmpq %r15,%vI_nets
                    # r_dying: %vI_nets
                     
            	jb _ceoa
                     
            	jmp _ceob
                    # r_dying: %vI_sefW
                     ,
     NONREC
        ceob:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceod
                     
            	jmp _ceoc
                    # r_dying: %vI_sefW
                     ,
     NONREC
        ceod:
            	movq $16,904(%r13)
                     
            	jmp _ceoa
                    # r_dying: %vI_sefW
                     ,
     NONREC
        ceoa:
            	movq %vI_sefW,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefW
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceoc:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefW,-8(%rbp)
                     
            	movq 16(%vI_sefW),%vI_seeZ
                    # born:    %vI_seeZ
                     
            	movq 24(%vI_sefW),%vI_sefQ
                    # born:    %vI_sefQ
                    # r_dying: %vI_sefW
                     
            	movq $sat_sefV_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cenQ
                    # born:    %vI_cenQ
                     
            	movq %vI_sefQ,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefQ
                     
            	movq %vI_cenQ,%r14
                    # born:    %r14
                    # r_dying: %vI_cenQ
                     
            	movq %vI_seeZ,%rbx
                    # born:    %r1
                    # r_dying: %vI_seeZ
                     
            	addq $-16,%rbp
                     
            	jmp gq_seeZ_info
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	uerG_srtd-(sat_sefW_info)+0
	.long	0
	.quad	2
	.quad	-4294967277
sat_sefW_info:
_ceo9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoa
	jmp _ceob
_ceob:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceod
	jmp _ceoc
_ceod:
	movq $16,904(%r13)
	jmp _ceoa
_ceoa:
	jmp *-16(%r13)
_ceoc:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefV_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
	.size sat_sefW_info, .-sat_sefW_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	uerG_srtd-(sat_sefW_info)+0
	.long	0
	.quad	2
	.quad	-4294967277
sat_sefW_info:
_ceo9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoa
_ceob:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceod
_ceoc:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefV_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_ceod:
	movq $16,904(%r13)
_ceoa:
	jmp *-16(%r13)
	.size sat_sefW_info, .-sat_sefW_info



==================== Asm code ====================
.section .text
.align 8
	.long	uerG_srtd-(sat_sefW_info)+0
	.long	0
	.quad	2
	.quad	-4294967277
sat_sefW_info:
_ceo9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoa
_ceob:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _ceod
_ceoc:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefV_info,-8(%r12)
	leaq -8(%r12),%rcx
	movq %rbx,%rsi
	movq %rcx,%r14
	movq %rax,%rbx
	addq $-16,%rbp
	jmp gq_seeZ_info
_ceod:
	movq $16,904(%r13)
_ceoa:
	jmp *-16(%r13)
	.size sat_sefW_info, .-sat_sefW_info



==================== Optimised Cmm ====================
section ""relreadonly" . uerH_srtd" {
    uerH_srtd:
        const SehZ_srt;
        const 35;
        const 34359738317;
}



==================== Native code ====================
.section .data.rel.ro
.align 8
.align 1
uerH_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Liveness annotations added ====================
section ""relreadonly" . uerH_srtd" {
    (1,
     uerH_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;)
}



==================== Registers allocated ====================
.section .data.rel.ro
.align 8
.align 1
uerH_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Synthetic instructions expanded ====================
.section .data.rel.ro
.align 8
.align 1
uerH_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Asm code ====================
.section .data.rel.ro
.align 8
.align 1
uerH_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Optimised Cmm ====================
section ""relreadonly" . uerI_srtd" {
    uerI_srtd:
        const SehZ_srt;
        const 35;
        const 34359738317;
}



==================== Native code ====================
.section .data.rel.ro
.align 8
.align 1
uerI_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Liveness annotations added ====================
section ""relreadonly" . uerI_srtd" {
    (1,
     uerI_srtd:
         const SehZ_srt;
         const 35;
         const 34359738317;)
}



==================== Registers allocated ====================
.section .data.rel.ro
.align 8
.align 1
uerI_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Synthetic instructions expanded ====================
.section .data.rel.ro
.align 8
.align 1
uerI_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Asm code ====================
.section .data.rel.ro
.align 8
.align 1
uerI_srtd:
	.quad	SehZ_srt
	.quad	35
	.quad	34359738317



==================== Optimised Cmm ====================
sat_segp_entry() //  [R2, R1]
        { [(cekq,
            block_cekq_info:
                const uerH_srtd-block_cekq_info;
                const 1;
                const 18446744069414584352;),
           (ceoe,
            sat_segp_info:
                const uerI_srtd-sat_segp_info;
                const 4294967301;
                const 1;
                const 18446744069414584330;)]
        }
    {offset
      ceoe:
          _sefO::P64 = R2;   // CmmAssign
          _segp::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceog; else goto ceoh;   // CmmCondBranch
      ceog:
          R2 = _sefO::P64;   // CmmAssign
          R1 = _segp::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoh:
          _seeZ::P64 = P64[_segp::P64 + 7];   // CmmAssign
          I64[Sp - 16] = block_cekq_info;   // CmmStore
          R1 = _sefO::P64;   // CmmAssign
          P64[Sp - 8] = _seeZ::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          if (R1 & 7 != 0) goto cekq; else goto cekr;   // CmmCondBranch
      cekr:
          call (I64[R1])(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      cekq:
          _seeZ::P64 = P64[Sp + 8];   // CmmAssign
          _sefP::P64 = R1;   // CmmAssign
          Hp = Hp + 128;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceok; else goto ceoj;   // CmmCondBranch
      ceok:
          I64[BaseReg + 904] = 128;   // CmmStore
          R1 = _sefP::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to cekq, args: 8, res: 8, upd: 8;   // CmmCall
      ceoj:
          _sefQ::P64 = P64[_sefP::P64 + 7];   // CmmAssign
          _sefR::P64 = P64[_sefP::P64 + 15];   // CmmAssign
          _sefS::P64 = P64[_sefP::P64 + 23];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 120] = sat_segn_info;   // CmmStore
          P64[Hp - 104] = _seeZ::P64;   // CmmStore
          P64[Hp - 96] = _sefS::P64;   // CmmStore
          _cekv::P64 = Hp - 120;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 88] = sat_segc_info;   // CmmStore
          P64[Hp - 72] = _seeZ::P64;   // CmmStore
          P64[Hp - 64] = _sefR::P64;   // CmmStore
          _celK::P64 = Hp - 88;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 56] = sat_sefW_info;   // CmmStore
          P64[Hp - 40] = _seeZ::P64;   // CmmStore
          P64[Hp - 32] = _sefQ::P64;   // CmmStore
          _cenM::P64 = Hp - 56;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cenM::P64;   // CmmStore
          P64[Hp - 8] = _celK::P64;   // CmmStore
          P64[Hp] = _cekv::P64;   // CmmStore
          _ceof::P64 = Hp - 23;   // CmmAssign
          R3 = _ceof::P64;   // CmmAssign
          R2 = $dShow_reeF_closure;   // CmmAssign
          R1 = System.IO.print_closure;   // CmmAssign
          Sp = Sp + 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 8, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	uerI_srtd-(sat_segp_info)+0
	.long	0
	.quad	4294967301
	.quad	1
	.quad	-4294967286
sat_segp_info:
_ceoe:
	movq %r14,%vI_sefO
	movq %rbx,%vI_segp
	leaq -16(%rbp),%vI_netx
	cmpq %r15,%vI_netx
	jb _ceog
	jmp _ceoh
	.long	uerH_srtd-(block_cekq_info)+0
	.long	0
	.quad	1
	.quad	-4294967264
block_cekq_info:
_cekq:
	movq 8(%rbp),%vI_seeZ
	movq %rbx,%vI_sefP
	addq $128,%r12
	cmpq 856(%r13),%r12
	ja _ceok
	jmp _ceoj
_cekr:
	jmp *(%rbx)
_ceog:
	movq %vI_sefO,%r14
	movq %vI_segp,%rbx
	jmp *-8(%r13)
_ceoh:
	movq 7(%vI_segp),%vI_seeZ
	movq $block_cekq_info,-16(%rbp)
	movq %vI_sefO,%rbx
	movq %vI_seeZ,-8(%rbp)
	addq $-16,%rbp
	testb $7,%bl
	jne _cekq
	jmp _cekr
_ceoj:
	movq 7(%vI_sefP),%vI_sefQ
	movq 15(%vI_sefP),%vI_sefR
	movq 23(%vI_sefP),%vI_sefS
	movq $sat_segn_info,-120(%r12)
	movq %vI_seeZ,-104(%r12)
	movq %vI_sefS,-96(%r12)
	leaq -120(%r12),%vI_cekv
	movq $sat_segc_info,-88(%r12)
	movq %vI_seeZ,-72(%r12)
	movq %vI_sefR,-64(%r12)
	leaq -88(%r12),%vI_celK
	movq $sat_sefW_info,-56(%r12)
	movq %vI_seeZ,-40(%r12)
	movq %vI_sefQ,-32(%r12)
	leaq -56(%r12),%vI_cenM
	movq $(,,)_con_info,-24(%r12)
	movq %vI_cenM,-16(%r12)
	movq %vI_celK,-8(%r12)
	movq %vI_cekv,(%r12)
	leaq -23(%r12),%vI_ceof
	movq %vI_ceof,%rsi
	movl $$dShow_reeF_closure,%r14d
	movl $System.IO.print_closure,%ebx
	addq $16,%rbp
	jmp stg_ap_pp_fast
_ceok:
	movq $128,904(%r13)
	movq %vI_sefP,%rbx
	jmp stg_gc_unpt_r1
	.size sat_segp_info, .-sat_segp_info



==================== Liveness annotations added ====================
sat_segp_entry() //  [R2, R1]
        { [(cekq,
            block_cekq_info:
                const uerH_srtd-block_cekq_info;
                const 1;
                const 18446744069414584352;),
           (ceoe,
            sat_segp_info:
                const uerI_srtd-sat_segp_info;
                const 4294967301;
                const 1;
                const 18446744069414584330;)]
          # entryIds         = [ceoe, cekq]
          # liveVRegsOnEntry = Just [(cekq, [R1 :-> %r1]),
                                     (cekr, [R1 :-> %r1]), (ceoe, [R1 :-> %r1, Re :-> %r14]),
                                     (ceog, [sefO :-> %vI_sefO, segp :-> %vI_segp]),
                                     (ceoh, [sefO :-> %vI_sefO, segp :-> %vI_segp]),
                                     (ceoj, [seeZ :-> %vI_seeZ, sefP :-> %vI_sefP]),
                                     (ceok, [sefP :-> %vI_sefP])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceoe:
            	movq %r14,%vI_sefO
                    # born:    %vI_sefO
                    # r_dying: %r14
                     
            	movq %rbx,%vI_segp
                    # born:    %vI_segp
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netx
                    # born:    %vI_netx
                     
            	cmpq %r15,%vI_netx
                    # r_dying: %vI_netx
                     
            	jb _ceog
                     
            	jmp _ceoh
                    # r_dying: %vI_sefO %vI_segp
                     ,
     NONREC
        ceoh:
            	movq 7(%vI_segp),%vI_seeZ
                    # born:    %vI_seeZ
                    # r_dying: %vI_segp
                     
            	movq $block_cekq_info,-16(%rbp)
                     
            	movq %vI_sefO,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefO
                     
            	movq %vI_seeZ,-8(%rbp)
                    # r_dying: %vI_seeZ
                     
            	addq $-16,%rbp
                     
            	testb $7,%bl
                     
            	jne _cekq
                     
            	jmp _cekr
                    # r_dying: %r1
                     ,
     NONREC
        cekq:
            	movq 8(%rbp),%vI_seeZ
                    # born:    %vI_seeZ
                     
            	movq %rbx,%vI_sefP
                    # born:    %vI_sefP
                    # r_dying: %r1
                     
            	addq $128,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceok
                     
            	jmp _ceoj
                    # r_dying: %vI_seeZ %vI_sefP
                     ,
     NONREC
        cekr:
            	jmp *(%rbx)
                    # r_dying: %r1
                     ,
     NONREC
        ceog:
            	movq %vI_sefO,%r14
                    # born:    %r14
                    # r_dying: %vI_sefO
                     
            	movq %vI_segp,%rbx
                    # born:    %r1
                    # r_dying: %vI_segp
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        ceoj:
            	movq 7(%vI_sefP),%vI_sefQ
                    # born:    %vI_sefQ
                     
            	movq 15(%vI_sefP),%vI_sefR
                    # born:    %vI_sefR
                     
            	movq 23(%vI_sefP),%vI_sefS
                    # born:    %vI_sefS
                    # r_dying: %vI_sefP
                     
            	movq $sat_segn_info,-120(%r12)
                     
            	movq %vI_seeZ,-104(%r12)
                     
            	movq %vI_sefS,-96(%r12)
                    # r_dying: %vI_sefS
                     
            	leaq -120(%r12),%vI_cekv
                    # born:    %vI_cekv
                     
            	movq $sat_segc_info,-88(%r12)
                     
            	movq %vI_seeZ,-72(%r12)
                     
            	movq %vI_sefR,-64(%r12)
                    # r_dying: %vI_sefR
                     
            	leaq -88(%r12),%vI_celK
                    # born:    %vI_celK
                     
            	movq $sat_sefW_info,-56(%r12)
                     
            	movq %vI_seeZ,-40(%r12)
                    # r_dying: %vI_seeZ
                     
            	movq %vI_sefQ,-32(%r12)
                    # r_dying: %vI_sefQ
                     
            	leaq -56(%r12),%vI_cenM
                    # born:    %vI_cenM
                     
            	movq $(,,)_con_info,-24(%r12)
                     
            	movq %vI_cenM,-16(%r12)
                    # r_dying: %vI_cenM
                     
            	movq %vI_celK,-8(%r12)
                    # r_dying: %vI_celK
                     
            	movq %vI_cekv,(%r12)
                    # r_dying: %vI_cekv
                     
            	leaq -23(%r12),%vI_ceof
                    # born:    %vI_ceof
                     
            	movq %vI_ceof,%rsi
                    # born:    %r4
                    # r_dying: %vI_ceof
                     
            	movl $$dShow_reeF_closure,%r14d
                    # born:    %r14
                     
            	movl $System.IO.print_closure,%ebx
                    # born:    %r1
                     
            	addq $16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ,
     NONREC
        ceok:
            	movq $128,904(%r13)
                     
            	movq %vI_sefP,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefP
                     
            	jmp stg_gc_unpt_r1
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	uerI_srtd-(sat_segp_info)+0
	.long	0
	.quad	4294967301
	.quad	1
	.quad	-4294967286
sat_segp_info:
_ceoe:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceog
	jmp _ceoh
_ceoh:
	movq 7(%rbx),%rax
	movq $block_cekq_info,-16(%rbp)
	movq %r14,%rbx
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	testb $7,%bl
	jne _cekq
	jmp _cekr
	.long	uerH_srtd-(block_cekq_info)+0
	.long	0
	.quad	1
	.quad	-4294967264
block_cekq_info:
_cekq:
	movq 8(%rbp),%rax
	addq $128,%r12
	cmpq 856(%r13),%r12
	ja _ceok
	jmp _ceoj
_cekr:
	jmp *(%rbx)
_ceog:
	jmp *-8(%r13)
_ceoj:
	movq 7(%rbx),%rcx
	movq 15(%rbx),%rdx
	movq 23(%rbx),%rbx
	movq $sat_segn_info,-120(%r12)
	movq %rax,-104(%r12)
	movq %rbx,-96(%r12)
	leaq -120(%r12),%rbx
	movq $sat_segc_info,-88(%r12)
	movq %rax,-72(%r12)
	movq %rdx,-64(%r12)
	leaq -88(%r12),%rdx
	movq $sat_sefW_info,-56(%r12)
	movq %rax,-40(%r12)
	movq %rcx,-32(%r12)
	leaq -56(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rdx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $$dShow_reeF_closure,%r14d
	movl $System.IO.print_closure,%ebx
	addq $16,%rbp
	jmp stg_ap_pp_fast
_ceok:
	movq $128,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segp_info, .-sat_segp_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	uerI_srtd-(sat_segp_info)+0
	.long	0
	.quad	4294967301
	.quad	1
	.quad	-4294967286
sat_segp_info:
_ceoe:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceog
_ceoh:
	movq 7(%rbx),%rax
	movq $block_cekq_info,-16(%rbp)
	movq %r14,%rbx
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	testb $7,%bl
	jne _cekq
_cekr:
	jmp *(%rbx)
	.long	uerH_srtd-(block_cekq_info)+0
	.long	0
	.quad	1
	.quad	-4294967264
block_cekq_info:
_cekq:
	movq 8(%rbp),%rax
	addq $128,%r12
	cmpq 856(%r13),%r12
	ja _ceok
_ceoj:
	movq 7(%rbx),%rcx
	movq 15(%rbx),%rdx
	movq 23(%rbx),%rbx
	movq $sat_segn_info,-120(%r12)
	movq %rax,-104(%r12)
	movq %rbx,-96(%r12)
	leaq -120(%r12),%rbx
	movq $sat_segc_info,-88(%r12)
	movq %rax,-72(%r12)
	movq %rdx,-64(%r12)
	leaq -88(%r12),%rdx
	movq $sat_sefW_info,-56(%r12)
	movq %rax,-40(%r12)
	movq %rcx,-32(%r12)
	leaq -56(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rdx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $$dShow_reeF_closure,%r14d
	movl $System.IO.print_closure,%ebx
	addq $16,%rbp
	jmp stg_ap_pp_fast
_ceog:
	jmp *-8(%r13)
_ceok:
	movq $128,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segp_info, .-sat_segp_info



==================== Asm code ====================
.section .text
.align 8
	.long	uerI_srtd-(sat_segp_info)+0
	.long	0
	.quad	4294967301
	.quad	1
	.quad	-4294967286
sat_segp_info:
_ceoe:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceog
_ceoh:
	movq 7(%rbx),%rax
	movq $block_cekq_info,-16(%rbp)
	movq %r14,%rbx
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	testb $7,%bl
	jne _cekq
_cekr:
	jmp *(%rbx)
	.long	uerH_srtd-(block_cekq_info)+0
	.long	0
	.quad	1
	.quad	-4294967264
block_cekq_info:
_cekq:
	movq 8(%rbp),%rax
	addq $128,%r12
	cmpq 856(%r13),%r12
	ja _ceok
_ceoj:
	movq 7(%rbx),%rcx
	movq 15(%rbx),%rdx
	movq 23(%rbx),%rbx
	movq $sat_segn_info,-120(%r12)
	movq %rax,-104(%r12)
	movq %rbx,-96(%r12)
	leaq -120(%r12),%rbx
	movq $sat_segc_info,-88(%r12)
	movq %rax,-72(%r12)
	movq %rdx,-64(%r12)
	leaq -88(%r12),%rdx
	movq $sat_sefW_info,-56(%r12)
	movq %rax,-40(%r12)
	movq %rcx,-32(%r12)
	leaq -56(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rdx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $$dShow_reeF_closure,%r14d
	movl $System.IO.print_closure,%ebx
	addq $16,%rbp
	jmp stg_ap_pp_fast
_ceog:
	jmp *-8(%r13)
_ceok:
	movq $128,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segp_info, .-sat_segp_info



==================== Optimised Cmm ====================
mn_sefk_entry() //  [R1]
        { [(ceoG,
            mn_sefk_info:
                const SehZ_srt-mn_sefk_info+280;
                const 1;
                const 4294967313;)]
        }
    {offset
      ceoG:
          _sefk::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceoH; else goto ceoI;   // CmmCondBranch
      ceoH:
          R1 = _sefk::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceoI:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefk::P64;   // CmmStore
          _seeY::P64 = P64[_sefk::P64 + 16];   // CmmAssign
          R2 = _seeY::P64;   // CmmAssign
          R1 = Module.mkModuleName_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(mn_sefk_info)+280
	.long	0
	.quad	1
	.quad	4294967313
mn_sefk_info:
_ceoG:
	movq %rbx,%vI_sefk
	leaq -16(%rbp),%vI_netA
	cmpq %r15,%vI_netA
	jb _ceoH
	jmp _ceoI
_ceoH:
	movq %vI_sefk,%rbx
	jmp *-16(%r13)
_ceoI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefk,-8(%rbp)
	movq 16(%vI_sefk),%vI_seeY
	movq %vI_seeY,%r14
	movl $Module.mkModuleName_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size mn_sefk_info, .-mn_sefk_info



==================== Liveness annotations added ====================
mn_sefk_entry() //  [R1]
        { [(ceoG,
            mn_sefk_info:
                const SehZ_srt-mn_sefk_info+280;
                const 1;
                const 4294967313;)]
          # entryIds         = [ceoG]
          # liveVRegsOnEntry = Just [(ceoG, [R1 :-> %r1]),
                                     (ceoH, [sefk :-> %vI_sefk]), (ceoI, [sefk :-> %vI_sefk])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceoG:
            	movq %rbx,%vI_sefk
                    # born:    %vI_sefk
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netA
                    # born:    %vI_netA
                     
            	cmpq %r15,%vI_netA
                    # r_dying: %vI_netA
                     
            	jb _ceoH
                     
            	jmp _ceoI
                    # r_dying: %vI_sefk
                     ,
     NONREC
        ceoH:
            	movq %vI_sefk,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefk
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceoI:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefk,-8(%rbp)
                     
            	movq 16(%vI_sefk),%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %vI_sefk
                     
            	movq %vI_seeY,%r14
                    # born:    %r14
                    # r_dying: %vI_seeY
                     
            	movl $Module.mkModuleName_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(mn_sefk_info)+280
	.long	0
	.quad	1
	.quad	4294967313
mn_sefk_info:
_ceoG:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoH
	jmp _ceoI
_ceoH:
	jmp *-16(%r13)
_ceoI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Module.mkModuleName_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size mn_sefk_info, .-mn_sefk_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(mn_sefk_info)+280
	.long	0
	.quad	1
	.quad	4294967313
mn_sefk_info:
_ceoG:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoH
_ceoI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Module.mkModuleName_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceoH:
	jmp *-16(%r13)
	.size mn_sefk_info, .-mn_sefk_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(mn_sefk_info)+280
	.long	0
	.quad	1
	.quad	4294967313
mn_sefk_info:
_ceoG:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceoH
_ceoI:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $Module.mkModuleName_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_ceoH:
	jmp *-16(%r13)
	.size mn_sefk_info, .-mn_sefk_info



==================== Optimised Cmm ====================
sat_sefB_entry() //  [R1]
        { [(cepk,
            sat_sefB_info:
                const SehZ_srt-sat_sefB_info+288;
                const 1;
                const 4294967313;)]
        }
    {offset
      cepk:
          _sefB::P64 = R1;   // CmmAssign
          if ((Sp + -32) < SpLim) goto cepl; else goto cepm;   // CmmCondBranch
      cepl:
          R1 = _sefB::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepm:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefB::P64;   // CmmStore
          _sefy::P64 = P64[_sefB::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.typecheckedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefB_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefB_info:
_cepk:
	movq %rbx,%vI_sefB
	leaq -32(%rbp),%vI_netD
	cmpq %r15,%vI_netD
	jb _cepl
	jmp _cepm
_cepl:
	movq %vI_sefB,%rbx
	jmp *-16(%r13)
_cepm:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefB,-8(%rbp)
	movq 16(%vI_sefB),%vI_sefy
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %vI_sefy,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.typecheckedSource_info
	.size sat_sefB_info, .-sat_sefB_info



==================== Liveness annotations added ====================
sat_sefB_entry() //  [R1]
        { [(cepk,
            sat_sefB_info:
                const SehZ_srt-sat_sefB_info+288;
                const 1;
                const 4294967313;)]
          # entryIds         = [cepk]
          # liveVRegsOnEntry = Just [(cepk, [R1 :-> %r1]),
                                     (cepl, [sefB :-> %vI_sefB]), (cepm, [sefB :-> %vI_sefB])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepk:
            	movq %rbx,%vI_sefB
                    # born:    %vI_sefB
                    # r_dying: %r1
                     
            	leaq -32(%rbp),%vI_netD
                    # born:    %vI_netD
                     
            	cmpq %r15,%vI_netD
                    # r_dying: %vI_netD
                     
            	jb _cepl
                     
            	jmp _cepm
                    # r_dying: %vI_sefB
                     ,
     NONREC
        cepl:
            	movq %vI_sefB,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefB
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cepm:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefB,-8(%rbp)
                     
            	movq 16(%vI_sefB),%vI_sefy
                    # born:    %vI_sefy
                    # r_dying: %vI_sefB
                     
            	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_p_info,-32(%rbp)
                     
            	movq %vI_sefy,-24(%rbp)
                    # r_dying: %vI_sefy
                     
            	addq $-32,%rbp
                     
            	jmp GHC.typecheckedSource_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefB_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefB_info:
_cepk:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _cepl
	jmp _cepm
_cepl:
	jmp *-16(%r13)
_cepm:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.typecheckedSource_info
	.size sat_sefB_info, .-sat_sefB_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefB_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefB_info:
_cepk:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _cepl
_cepm:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.typecheckedSource_info
_cepl:
	jmp *-16(%r13)
	.size sat_sefB_info, .-sat_sefB_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefB_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefB_info:
_cepk:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _cepl
_cepm:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.typecheckedSource_info
_cepl:
	jmp *-16(%r13)
	.size sat_sefB_info, .-sat_sefB_info



==================== Optimised Cmm ====================
sat_sefA_entry() //  [R1]
        { [(cepr,
            sat_sefA_info:
                const SehZ_srt-sat_sefA_info+288;
                const 1;
                const 4294967313;)]
        }
    {offset
      cepr:
          _sefA::P64 = R1;   // CmmAssign
          if ((Sp + -32) < SpLim) goto ceps; else goto cept;   // CmmCondBranch
      ceps:
          R1 = _sefA::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cept:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefA::P64;   // CmmStore
          _sefy::P64 = P64[_sefA::P64 + 16];   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          I64[Sp - 32] = stg_ap_p_info;   // CmmStore
          P64[Sp - 24] = _sefy::P64;   // CmmStore
          Sp = Sp - 32;   // CmmAssign
          call GHC.renamedSource_info(R2) args: 40, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefA_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefA_info:
_cepr:
	movq %rbx,%vI_sefA
	leaq -32(%rbp),%vI_netG
	cmpq %r15,%vI_netG
	jb _ceps
	jmp _cept
_ceps:
	movq %vI_sefA,%rbx
	jmp *-16(%r13)
_cept:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefA,-8(%rbp)
	movq 16(%vI_sefA),%vI_sefy
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %vI_sefy,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.renamedSource_info
	.size sat_sefA_info, .-sat_sefA_info



==================== Liveness annotations added ====================
sat_sefA_entry() //  [R1]
        { [(cepr,
            sat_sefA_info:
                const SehZ_srt-sat_sefA_info+288;
                const 1;
                const 4294967313;)]
          # entryIds         = [cepr]
          # liveVRegsOnEntry = Just [(cepr, [R1 :-> %r1]),
                                     (ceps, [sefA :-> %vI_sefA]), (cept, [sefA :-> %vI_sefA])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepr:
            	movq %rbx,%vI_sefA
                    # born:    %vI_sefA
                    # r_dying: %r1
                     
            	leaq -32(%rbp),%vI_netG
                    # born:    %vI_netG
                     
            	cmpq %r15,%vI_netG
                    # r_dying: %vI_netG
                     
            	jb _ceps
                     
            	jmp _cept
                    # r_dying: %vI_sefA
                     ,
     NONREC
        ceps:
            	movq %vI_sefA,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefA
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cept:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefA,-8(%rbp)
                     
            	movq 16(%vI_sefA),%vI_sefy
                    # born:    %vI_sefy
                    # r_dying: %vI_sefA
                     
            	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_p_info,-32(%rbp)
                     
            	movq %vI_sefy,-24(%rbp)
                    # r_dying: %vI_sefy
                     
            	addq $-32,%rbp
                     
            	jmp GHC.renamedSource_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefA_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefA_info:
_cepr:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceps
	jmp _cept
_ceps:
	jmp *-16(%r13)
_cept:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.renamedSource_info
	.size sat_sefA_info, .-sat_sefA_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefA_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefA_info:
_cepr:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceps
_cept:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.renamedSource_info
_ceps:
	jmp *-16(%r13)
	.size sat_sefA_info, .-sat_sefA_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefA_info)+288
	.long	0
	.quad	1
	.quad	4294967313
sat_sefA_info:
_cepr:
	leaq -32(%rbp),%rax
	cmpq %r15,%rax
	jb _ceps
_cept:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movq $stg_ap_p_info,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-32,%rbp
	jmp GHC.renamedSource_info
_ceps:
	jmp *-16(%r13)
	.size sat_sefA_info, .-sat_sefA_info



==================== Optimised Cmm ====================
sat_sefz_entry() //  [R1]
        { [(cepy,
            sat_sefz_info:
                const SehZ_srt-sat_sefz_info+296;
                const 1;
                const 4294967313;)]
        }
    {offset
      cepy:
          _sefz::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cepz; else goto cepA;   // CmmCondBranch
      cepz:
          R1 = _sefz::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepA:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefz::P64;   // CmmStore
          _sefs::P64 = P64[_sefz::P64 + 16];   // CmmAssign
          R2 = _sefs::P64;   // CmmAssign
          R1 = GHC.pm_parsed_source_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefz_info)+296
	.long	0
	.quad	1
	.quad	4294967313
sat_sefz_info:
_cepy:
	movq %rbx,%vI_sefz
	leaq -16(%rbp),%vI_netJ
	cmpq %r15,%vI_netJ
	jb _cepz
	jmp _cepA
_cepz:
	movq %vI_sefz,%rbx
	jmp *-16(%r13)
_cepA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefz,-8(%rbp)
	movq 16(%vI_sefz),%vI_sefs
	movq %vI_sefs,%r14
	movl $GHC.pm_parsed_source_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefz_info, .-sat_sefz_info



==================== Liveness annotations added ====================
sat_sefz_entry() //  [R1]
        { [(cepy,
            sat_sefz_info:
                const SehZ_srt-sat_sefz_info+296;
                const 1;
                const 4294967313;)]
          # entryIds         = [cepy]
          # liveVRegsOnEntry = Just [(cepy, [R1 :-> %r1]),
                                     (cepz, [sefz :-> %vI_sefz]), (cepA, [sefz :-> %vI_sefz])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepy:
            	movq %rbx,%vI_sefz
                    # born:    %vI_sefz
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netJ
                    # born:    %vI_netJ
                     
            	cmpq %r15,%vI_netJ
                    # r_dying: %vI_netJ
                     
            	jb _cepz
                     
            	jmp _cepA
                    # r_dying: %vI_sefz
                     ,
     NONREC
        cepz:
            	movq %vI_sefz,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefz
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cepA:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefz,-8(%rbp)
                     
            	movq 16(%vI_sefz),%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %vI_sefz
                     
            	movq %vI_sefs,%r14
                    # born:    %r14
                    # r_dying: %vI_sefs
                     
            	movl $GHC.pm_parsed_source_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefz_info)+296
	.long	0
	.quad	1
	.quad	4294967313
sat_sefz_info:
_cepy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepz
	jmp _cepA
_cepz:
	jmp *-16(%r13)
_cepA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $GHC.pm_parsed_source_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefz_info, .-sat_sefz_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefz_info)+296
	.long	0
	.quad	1
	.quad	4294967313
sat_sefz_info:
_cepy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepz
_cepA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $GHC.pm_parsed_source_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cepz:
	jmp *-16(%r13)
	.size sat_sefz_info, .-sat_sefz_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefz_info)+296
	.long	0
	.quad	1
	.quad	4294967313
sat_sefz_info:
_cepy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepz
_cepA:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%r14
	movl $GHC.pm_parsed_source_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cepz:
	jmp *-16(%r13)
	.size sat_sefz_info, .-sat_sefz_info



==================== Optimised Cmm ====================
sat_sefD_entry() //  [R2, R1]
        { [(cepC,
            sat_sefD_info:
                const SehZ_srt-sat_sefD_info+288;
                const 4294967301;
                const 1;
                const 30064771082;)]
        }
    {offset
      cepC:
          _sefy::P64 = R2;   // CmmAssign
          _sefD::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cepD; else goto cepE;   // CmmCondBranch
      cepE:
          Hp = Hp + 104;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cepG; else goto cepF;   // CmmCondBranch
      cepG:
          I64[BaseReg + 904] = 104;   // CmmStore
          goto cepD;   // CmmBranch
      cepD:
          R2 = _sefy::P64;   // CmmAssign
          R1 = _sefD::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepF:
          _sefs::P64 = P64[_sefD::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 96] = sat_sefB_info;   // CmmStore
          P64[Hp - 80] = _sefy::P64;   // CmmStore
          _cepg::P64 = Hp - 96;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 72] = sat_sefA_info;   // CmmStore
          P64[Hp - 56] = _sefy::P64;   // CmmStore
          _cepn::P64 = Hp - 72;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 48] = sat_sefz_info;   // CmmStore
          P64[Hp - 32] = _sefs::P64;   // CmmStore
          _cepu::P64 = Hp - 48;   // CmmAssign
          I64[Hp - 24] = (,,)_con_info;   // CmmStore
          P64[Hp - 16] = _cepu::P64;   // CmmStore
          P64[Hp - 8] = _cepn::P64;   // CmmStore
          P64[Hp] = _cepg::P64;   // CmmStore
          _cepB::P64 = Hp - 23;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 16] = stg_ap_p_info;   // CmmStore
          P64[Sp - 8] = _cepB::P64;   // CmmStore
          Sp = Sp - 16;   // CmmAssign
          call GHC.Base.return_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefD_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	30064771082
sat_sefD_info:
_cepC:
	movq %r14,%vI_sefy
	movq %rbx,%vI_sefD
	leaq -16(%rbp),%vI_netM
	cmpq %r15,%vI_netM
	jb _cepD
	jmp _cepE
_cepD:
	movq %vI_sefy,%r14
	movq %vI_sefD,%rbx
	jmp *-8(%r13)
_cepE:
	addq $104,%r12
	cmpq 856(%r13),%r12
	ja _cepG
	jmp _cepF
_cepF:
	movq 7(%vI_sefD),%vI_sefs
	movq $sat_sefB_info,-96(%r12)
	movq %vI_sefy,-80(%r12)
	leaq -96(%r12),%vI_cepg
	movq $sat_sefA_info,-72(%r12)
	movq %vI_sefy,-56(%r12)
	leaq -72(%r12),%vI_cepn
	movq $sat_sefz_info,-48(%r12)
	movq %vI_sefs,-32(%r12)
	leaq -48(%r12),%vI_cepu
	movq $(,,)_con_info,-24(%r12)
	movq %vI_cepu,-16(%r12)
	movq %vI_cepn,-8(%r12)
	movq %vI_cepg,(%r12)
	leaq -23(%r12),%vI_cepB
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %vI_cepB,-8(%rbp)
	addq $-16,%rbp
	jmp GHC.Base.return_info
_cepG:
	movq $104,904(%r13)
	jmp _cepD
	.size sat_sefD_info, .-sat_sefD_info



==================== Liveness annotations added ====================
sat_sefD_entry() //  [R2, R1]
        { [(cepC,
            sat_sefD_info:
                const SehZ_srt-sat_sefD_info+288;
                const 4294967301;
                const 1;
                const 30064771082;)]
          # entryIds         = [cepC]
          # liveVRegsOnEntry = Just [(cepC, [R1 :-> %r1, Re :-> %r14]),
                                     (cepD, [sefy :-> %vI_sefy, sefD :-> %vI_sefD]),
                                     (cepE, [sefy :-> %vI_sefy, sefD :-> %vI_sefD]),
                                     (cepF, [sefy :-> %vI_sefy, sefD :-> %vI_sefD]),
                                     (cepG, [sefy :-> %vI_sefy, sefD :-> %vI_sefD])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepC:
            	movq %r14,%vI_sefy
                    # born:    %vI_sefy
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefD
                    # born:    %vI_sefD
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netM
                    # born:    %vI_netM
                     
            	cmpq %r15,%vI_netM
                    # r_dying: %vI_netM
                     
            	jb _cepD
                     
            	jmp _cepE
                    # r_dying: %vI_sefy %vI_sefD
                     ,
     NONREC
        cepE:
            	addq $104,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cepG
                     
            	jmp _cepF
                    # r_dying: %vI_sefy %vI_sefD
                     ,
     NONREC
        cepG:
            	movq $104,904(%r13)
                     
            	jmp _cepD
                    # r_dying: %vI_sefy %vI_sefD
                     ,
     NONREC
        cepD:
            	movq %vI_sefy,%r14
                    # born:    %r14
                    # r_dying: %vI_sefy
                     
            	movq %vI_sefD,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefD
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cepF:
            	movq 7(%vI_sefD),%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %vI_sefD
                     
            	movq $sat_sefB_info,-96(%r12)
                     
            	movq %vI_sefy,-80(%r12)
                     
            	leaq -96(%r12),%vI_cepg
                    # born:    %vI_cepg
                     
            	movq $sat_sefA_info,-72(%r12)
                     
            	movq %vI_sefy,-56(%r12)
                    # r_dying: %vI_sefy
                     
            	leaq -72(%r12),%vI_cepn
                    # born:    %vI_cepn
                     
            	movq $sat_sefz_info,-48(%r12)
                     
            	movq %vI_sefs,-32(%r12)
                    # r_dying: %vI_sefs
                     
            	leaq -48(%r12),%vI_cepu
                    # born:    %vI_cepu
                     
            	movq $(,,)_con_info,-24(%r12)
                     
            	movq %vI_cepu,-16(%r12)
                    # r_dying: %vI_cepu
                     
            	movq %vI_cepn,-8(%r12)
                    # r_dying: %vI_cepn
                     
            	movq %vI_cepg,(%r12)
                    # r_dying: %vI_cepg
                     
            	leaq -23(%r12),%vI_cepB
                    # born:    %vI_cepB
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_p_info,-16(%rbp)
                     
            	movq %vI_cepB,-8(%rbp)
                    # r_dying: %vI_cepB
                     
            	addq $-16,%rbp
                     
            	jmp GHC.Base.return_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefD_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	30064771082
sat_sefD_info:
_cepC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepD
	jmp _cepE
_cepE:
	addq $104,%r12
	cmpq 856(%r13),%r12
	ja _cepG
	jmp _cepF
_cepG:
	movq $104,904(%r13)
	jmp _cepD
_cepD:
	jmp *-8(%r13)
_cepF:
	movq 7(%rbx),%rax
	movq $sat_sefB_info,-96(%r12)
	movq %r14,-80(%r12)
	leaq -96(%r12),%rbx
	movq $sat_sefA_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rcx
	movq $sat_sefz_info,-48(%r12)
	movq %rax,-32(%r12)
	leaq -48(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rcx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp GHC.Base.return_info
	.size sat_sefD_info, .-sat_sefD_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefD_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	30064771082
sat_sefD_info:
_cepC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepD
_cepE:
	addq $104,%r12
	cmpq 856(%r13),%r12
	ja _cepG
_cepF:
	movq 7(%rbx),%rax
	movq $sat_sefB_info,-96(%r12)
	movq %r14,-80(%r12)
	leaq -96(%r12),%rbx
	movq $sat_sefA_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rcx
	movq $sat_sefz_info,-48(%r12)
	movq %rax,-32(%r12)
	leaq -48(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rcx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp GHC.Base.return_info
_cepG:
	movq $104,904(%r13)
_cepD:
	jmp *-8(%r13)
	.size sat_sefD_info, .-sat_sefD_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefD_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	30064771082
sat_sefD_info:
_cepC:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepD
_cepE:
	addq $104,%r12
	cmpq 856(%r13),%r12
	ja _cepG
_cepF:
	movq 7(%rbx),%rax
	movq $sat_sefB_info,-96(%r12)
	movq %r14,-80(%r12)
	leaq -96(%r12),%rbx
	movq $sat_sefA_info,-72(%r12)
	movq %r14,-56(%r12)
	leaq -72(%r12),%rcx
	movq $sat_sefz_info,-48(%r12)
	movq %rax,-32(%r12)
	leaq -48(%r12),%rax
	movq $(,,)_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq %rcx,-8(%r12)
	movq %rbx,(%r12)
	leaq -23(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_p_info,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-16,%rbp
	jmp GHC.Base.return_info
_cepG:
	movq $104,904(%r13)
_cepD:
	jmp *-8(%r13)
	.size sat_sefD_info, .-sat_sefD_info



==================== Optimised Cmm ====================
sat_sefx_entry() //  [R1]
        { [(cepL,
            sat_sefx_info:
                const SehZ_srt-sat_sefx_info+288;
                const 1;
                const 107374182417;)]
        }
    {offset
      cepL:
          _sefx::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cepM; else goto cepN;   // CmmCondBranch
      cepM:
          R1 = _sefx::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepN:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefx::P64;   // CmmStore
          _sefw::P64 = P64[_sefx::P64 + 16];   // CmmAssign
          R4 = _sefw::P64;   // CmmAssign
          R3 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R2 = GHC.$fTypecheckedModDesugaredModule_closure;   // CmmAssign
          R1 = GHC.loadModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_ppp_fast(R4,
                               R3,
                               R2,
                               R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefx_info)+288
	.long	0
	.quad	1
	.quad	107374182417
sat_sefx_info:
_cepL:
	movq %rbx,%vI_sefx
	leaq -16(%rbp),%vI_netP
	cmpq %r15,%vI_netP
	jb _cepM
	jmp _cepN
_cepM:
	movq %vI_sefx,%rbx
	jmp *-16(%r13)
_cepN:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefx,-8(%rbp)
	movq 16(%vI_sefx),%vI_sefw
	movq %vI_sefw,%rdi
	movl $GhcMonad.$fGhcMonadGhc_closure,%esi
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movl $GHC.loadModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
	.size sat_sefx_info, .-sat_sefx_info



==================== Liveness annotations added ====================
sat_sefx_entry() //  [R1]
        { [(cepL,
            sat_sefx_info:
                const SehZ_srt-sat_sefx_info+288;
                const 1;
                const 107374182417;)]
          # entryIds         = [cepL]
          # liveVRegsOnEntry = Just [(cepL, [R1 :-> %r1]),
                                     (cepM, [sefx :-> %vI_sefx]), (cepN, [sefx :-> %vI_sefx])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepL:
            	movq %rbx,%vI_sefx
                    # born:    %vI_sefx
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netP
                    # born:    %vI_netP
                     
            	cmpq %r15,%vI_netP
                    # r_dying: %vI_netP
                     
            	jb _cepM
                     
            	jmp _cepN
                    # r_dying: %vI_sefx
                     ,
     NONREC
        cepM:
            	movq %vI_sefx,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefx
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cepN:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefx,-8(%rbp)
                     
            	movq 16(%vI_sefx),%vI_sefw
                    # born:    %vI_sefw
                    # r_dying: %vI_sefx
                     
            	movq %vI_sefw,%rdi
                    # born:    %r5
                    # r_dying: %vI_sefw
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%esi
                    # born:    %r4
                     
            	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.loadModule_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_ppp_fast
                    # r_dying: %r1 %r4 %r5 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefx_info)+288
	.long	0
	.quad	1
	.quad	107374182417
sat_sefx_info:
_cepL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepM
	jmp _cepN
_cepM:
	jmp *-16(%r13)
_cepN:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rdi
	movl $GhcMonad.$fGhcMonadGhc_closure,%esi
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movl $GHC.loadModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
	.size sat_sefx_info, .-sat_sefx_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefx_info)+288
	.long	0
	.quad	1
	.quad	107374182417
sat_sefx_info:
_cepL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepM
_cepN:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rdi
	movl $GhcMonad.$fGhcMonadGhc_closure,%esi
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movl $GHC.loadModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_cepM:
	jmp *-16(%r13)
	.size sat_sefx_info, .-sat_sefx_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefx_info)+288
	.long	0
	.quad	1
	.quad	107374182417
sat_sefx_info:
_cepL:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepM
_cepN:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rdi
	movl $GhcMonad.$fGhcMonadGhc_closure,%esi
	movl $GHC.$fTypecheckedModDesugaredModule_closure,%r14d
	movl $GHC.loadModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_ppp_fast
_cepM:
	jmp *-16(%r13)
	.size sat_sefx_info, .-sat_sefx_info



==================== Optimised Cmm ====================
sat_sefE_entry() //  [R2, R1]
        { [(cepO,
            sat_sefE_info:
                const SehZ_srt-sat_sefE_info+288;
                const 4294967301;
                const 1;
                const 133143986186;)]
        }
    {offset
      cepO:
          _sefw::P64 = R2;   // CmmAssign
          _sefE::P64 = R1;   // CmmAssign
          if ((Sp + -24) < SpLim) goto cepP; else goto cepQ;   // CmmCondBranch
      cepQ:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cepS; else goto cepR;   // CmmCondBranch
      cepS:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto cepP;   // CmmBranch
      cepP:
          R2 = _sefw::P64;   // CmmAssign
          R1 = _sefE::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepR:
          _sefs::P64 = P64[_sefE::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefD_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cepb::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefx_info;   // CmmStore
          P64[Hp] = _sefw::P64;   // CmmStore
          _cepH::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepH::P64;   // CmmStore
          P64[Sp - 8] = _cepb::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefE_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	133143986186
sat_sefE_info:
_cepO:
	movq %r14,%vI_sefw
	movq %rbx,%vI_sefE
	leaq -24(%rbp),%vI_netS
	cmpq %r15,%vI_netS
	jb _cepP
	jmp _cepQ
_cepP:
	movq %vI_sefw,%r14
	movq %vI_sefE,%rbx
	jmp *-8(%r13)
_cepQ:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cepS
	jmp _cepR
_cepR:
	movq 7(%vI_sefE),%vI_sefs
	movq $sat_sefD_info,-32(%r12)
	movq %vI_sefs,-24(%r12)
	leaq -31(%r12),%vI_cepb
	movq $sat_sefx_info,-16(%r12)
	movq %vI_sefw,(%r12)
	leaq -16(%r12),%vI_cepH
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_cepH,-16(%rbp)
	movq %vI_cepb,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cepS:
	movq $40,904(%r13)
	jmp _cepP
	.size sat_sefE_info, .-sat_sefE_info



==================== Liveness annotations added ====================
sat_sefE_entry() //  [R2, R1]
        { [(cepO,
            sat_sefE_info:
                const SehZ_srt-sat_sefE_info+288;
                const 4294967301;
                const 1;
                const 133143986186;)]
          # entryIds         = [cepO]
          # liveVRegsOnEntry = Just [(cepO, [R1 :-> %r1, Re :-> %r14]),
                                     (cepP, [sefw :-> %vI_sefw, sefE :-> %vI_sefE]),
                                     (cepQ, [sefw :-> %vI_sefw, sefE :-> %vI_sefE]),
                                     (cepR, [sefw :-> %vI_sefw, sefE :-> %vI_sefE]),
                                     (cepS, [sefw :-> %vI_sefw, sefE :-> %vI_sefE])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepO:
            	movq %r14,%vI_sefw
                    # born:    %vI_sefw
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefE
                    # born:    %vI_sefE
                    # r_dying: %r1
                     
            	leaq -24(%rbp),%vI_netS
                    # born:    %vI_netS
                     
            	cmpq %r15,%vI_netS
                    # r_dying: %vI_netS
                     
            	jb _cepP
                     
            	jmp _cepQ
                    # r_dying: %vI_sefw %vI_sefE
                     ,
     NONREC
        cepQ:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cepS
                     
            	jmp _cepR
                    # r_dying: %vI_sefw %vI_sefE
                     ,
     NONREC
        cepS:
            	movq $40,904(%r13)
                     
            	jmp _cepP
                    # r_dying: %vI_sefw %vI_sefE
                     ,
     NONREC
        cepP:
            	movq %vI_sefw,%r14
                    # born:    %r14
                    # r_dying: %vI_sefw
                     
            	movq %vI_sefE,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefE
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cepR:
            	movq 7(%vI_sefE),%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %vI_sefE
                     
            	movq $sat_sefD_info,-32(%r12)
                     
            	movq %vI_sefs,-24(%r12)
                    # r_dying: %vI_sefs
                     
            	leaq -31(%r12),%vI_cepb
                    # born:    %vI_cepb
                     
            	movq $sat_sefx_info,-16(%r12)
                     
            	movq %vI_sefw,(%r12)
                    # r_dying: %vI_sefw
                     
            	leaq -16(%r12),%vI_cepH
                    # born:    %vI_cepH
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_cepH,-16(%rbp)
                    # r_dying: %vI_cepH
                     
            	movq %vI_cepb,-8(%rbp)
                    # r_dying: %vI_cepb
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefE_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	133143986186
sat_sefE_info:
_cepO:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cepP
	jmp _cepQ
_cepQ:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cepS
	jmp _cepR
_cepS:
	movq $40,904(%r13)
	jmp _cepP
_cepP:
	jmp *-8(%r13)
_cepR:
	movq 7(%rbx),%rax
	movq $sat_sefD_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefx_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefE_info, .-sat_sefE_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefE_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	133143986186
sat_sefE_info:
_cepO:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cepP
_cepQ:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cepS
_cepR:
	movq 7(%rbx),%rax
	movq $sat_sefD_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefx_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cepS:
	movq $40,904(%r13)
_cepP:
	jmp *-8(%r13)
	.size sat_sefE_info, .-sat_sefE_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefE_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	133143986186
sat_sefE_info:
_cepO:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cepP
_cepQ:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cepS
_cepR:
	movq 7(%rbx),%rax
	movq $sat_sefD_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefx_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cepS:
	movq $40,904(%r13)
_cepP:
	jmp *-8(%r13)
	.size sat_sefE_info, .-sat_sefE_info



==================== Optimised Cmm ====================
sat_sefv_entry() //  [R1]
        { [(cepX,
            sat_sefv_info:
                const SehZ_srt-sat_sefv_info+320;
                const 1;
                const 12884901905;)]
        }
    {offset
      cepX:
          _sefv::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cepY; else goto cepZ;   // CmmCondBranch
      cepY:
          R1 = _sefv::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cepZ:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefv::P64;   // CmmStore
          _sefu::P64 = P64[_sefv::P64 + 16];   // CmmAssign
          R3 = _sefu::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.desugarModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefv_info)+320
	.long	0
	.quad	1
	.quad	12884901905
sat_sefv_info:
_cepX:
	movq %rbx,%vI_sefv
	leaq -16(%rbp),%vI_netV
	cmpq %r15,%vI_netV
	jb _cepY
	jmp _cepZ
_cepY:
	movq %vI_sefv,%rbx
	jmp *-16(%r13)
_cepZ:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefv,-8(%rbp)
	movq 16(%vI_sefv),%vI_sefu
	movq %vI_sefu,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.desugarModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefv_info, .-sat_sefv_info



==================== Liveness annotations added ====================
sat_sefv_entry() //  [R1]
        { [(cepX,
            sat_sefv_info:
                const SehZ_srt-sat_sefv_info+320;
                const 1;
                const 12884901905;)]
          # entryIds         = [cepX]
          # liveVRegsOnEntry = Just [(cepX, [R1 :-> %r1]),
                                     (cepY, [sefv :-> %vI_sefv]), (cepZ, [sefv :-> %vI_sefv])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cepX:
            	movq %rbx,%vI_sefv
                    # born:    %vI_sefv
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_netV
                    # born:    %vI_netV
                     
            	cmpq %r15,%vI_netV
                    # r_dying: %vI_netV
                     
            	jb _cepY
                     
            	jmp _cepZ
                    # r_dying: %vI_sefv
                     ,
     NONREC
        cepY:
            	movq %vI_sefv,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefv
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cepZ:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefv,-8(%rbp)
                     
            	movq 16(%vI_sefv),%vI_sefu
                    # born:    %vI_sefu
                    # r_dying: %vI_sefv
                     
            	movq %vI_sefu,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefu
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.desugarModule_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefv_info)+320
	.long	0
	.quad	1
	.quad	12884901905
sat_sefv_info:
_cepX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepY
	jmp _cepZ
_cepY:
	jmp *-16(%r13)
_cepZ:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.desugarModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefv_info, .-sat_sefv_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefv_info)+320
	.long	0
	.quad	1
	.quad	12884901905
sat_sefv_info:
_cepX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepY
_cepZ:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.desugarModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cepY:
	jmp *-16(%r13)
	.size sat_sefv_info, .-sat_sefv_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefv_info)+320
	.long	0
	.quad	1
	.quad	12884901905
sat_sefv_info:
_cepX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cepY
_cepZ:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.desugarModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cepY:
	jmp *-16(%r13)
	.size sat_sefv_info, .-sat_sefv_info



==================== Optimised Cmm ====================
sat_sefF_entry() //  [R2, R1]
        { [(ceq0,
            sat_sefF_info:
                const SehZ_srt-sat_sefF_info+288;
                const 4294967301;
                const 1;
                const 270582939658;)]
        }
    {offset
      ceq0:
          _sefu::P64 = R2;   // CmmAssign
          _sefF::P64 = R1;   // CmmAssign
          if ((Sp + -24) < SpLim) goto ceq1; else goto ceq2;   // CmmCondBranch
      ceq2:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceq4; else goto ceq3;   // CmmCondBranch
      ceq4:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto ceq1;   // CmmBranch
      ceq1:
          R2 = _sefu::P64;   // CmmAssign
          R1 = _sefF::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceq3:
          _sefs::P64 = P64[_sefF::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefE_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep6::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefv_info;   // CmmStore
          P64[Hp] = _sefu::P64;   // CmmStore
          _cepT::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cepT::P64;   // CmmStore
          P64[Sp - 8] = _cep6::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefF_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	270582939658
sat_sefF_info:
_ceq0:
	movq %r14,%vI_sefu
	movq %rbx,%vI_sefF
	leaq -24(%rbp),%vI_netY
	cmpq %r15,%vI_netY
	jb _ceq1
	jmp _ceq2
_ceq1:
	movq %vI_sefu,%r14
	movq %vI_sefF,%rbx
	jmp *-8(%r13)
_ceq2:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceq4
	jmp _ceq3
_ceq3:
	movq 7(%vI_sefF),%vI_sefs
	movq $sat_sefE_info,-32(%r12)
	movq %vI_sefs,-24(%r12)
	leaq -31(%r12),%vI_cep6
	movq $sat_sefv_info,-16(%r12)
	movq %vI_sefu,(%r12)
	leaq -16(%r12),%vI_cepT
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_cepT,-16(%rbp)
	movq %vI_cep6,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceq4:
	movq $40,904(%r13)
	jmp _ceq1
	.size sat_sefF_info, .-sat_sefF_info



==================== Liveness annotations added ====================
sat_sefF_entry() //  [R2, R1]
        { [(ceq0,
            sat_sefF_info:
                const SehZ_srt-sat_sefF_info+288;
                const 4294967301;
                const 1;
                const 270582939658;)]
          # entryIds         = [ceq0]
          # liveVRegsOnEntry = Just [(ceq0, [R1 :-> %r1, Re :-> %r14]),
                                     (ceq1, [sefu :-> %vI_sefu, sefF :-> %vI_sefF]),
                                     (ceq2, [sefu :-> %vI_sefu, sefF :-> %vI_sefF]),
                                     (ceq3, [sefu :-> %vI_sefu, sefF :-> %vI_sefF]),
                                     (ceq4, [sefu :-> %vI_sefu, sefF :-> %vI_sefF])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceq0:
            	movq %r14,%vI_sefu
                    # born:    %vI_sefu
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefF
                    # born:    %vI_sefF
                    # r_dying: %r1
                     
            	leaq -24(%rbp),%vI_netY
                    # born:    %vI_netY
                     
            	cmpq %r15,%vI_netY
                    # r_dying: %vI_netY
                     
            	jb _ceq1
                     
            	jmp _ceq2
                    # r_dying: %vI_sefu %vI_sefF
                     ,
     NONREC
        ceq2:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceq4
                     
            	jmp _ceq3
                    # r_dying: %vI_sefu %vI_sefF
                     ,
     NONREC
        ceq4:
            	movq $40,904(%r13)
                     
            	jmp _ceq1
                    # r_dying: %vI_sefu %vI_sefF
                     ,
     NONREC
        ceq1:
            	movq %vI_sefu,%r14
                    # born:    %r14
                    # r_dying: %vI_sefu
                     
            	movq %vI_sefF,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefF
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        ceq3:
            	movq 7(%vI_sefF),%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %vI_sefF
                     
            	movq $sat_sefE_info,-32(%r12)
                     
            	movq %vI_sefs,-24(%r12)
                    # r_dying: %vI_sefs
                     
            	leaq -31(%r12),%vI_cep6
                    # born:    %vI_cep6
                     
            	movq $sat_sefv_info,-16(%r12)
                     
            	movq %vI_sefu,(%r12)
                    # r_dying: %vI_sefu
                     
            	leaq -16(%r12),%vI_cepT
                    # born:    %vI_cepT
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_cepT,-16(%rbp)
                    # r_dying: %vI_cepT
                     
            	movq %vI_cep6,-8(%rbp)
                    # r_dying: %vI_cep6
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefF_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	270582939658
sat_sefF_info:
_ceq0:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceq1
	jmp _ceq2
_ceq2:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceq4
	jmp _ceq3
_ceq4:
	movq $40,904(%r13)
	jmp _ceq1
_ceq1:
	jmp *-8(%r13)
_ceq3:
	movq 7(%rbx),%rax
	movq $sat_sefE_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefv_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefF_info, .-sat_sefF_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefF_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	270582939658
sat_sefF_info:
_ceq0:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceq1
_ceq2:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceq4
_ceq3:
	movq 7(%rbx),%rax
	movq $sat_sefE_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefv_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceq4:
	movq $40,904(%r13)
_ceq1:
	jmp *-8(%r13)
	.size sat_sefF_info, .-sat_sefF_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefF_info)+288
	.long	0
	.quad	4294967301
	.quad	1
	.quad	270582939658
sat_sefF_info:
_ceq0:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceq1
_ceq2:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceq4
_ceq3:
	movq 7(%rbx),%rax
	movq $sat_sefE_info,-32(%r12)
	movq %rax,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefv_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceq4:
	movq $40,904(%r13)
_ceq1:
	jmp *-8(%r13)
	.size sat_sefF_info, .-sat_sefF_info



==================== Optimised Cmm ====================
sat_seft_entry() //  [R1]
        { [(ceq9,
            sat_seft_info:
                const SehZ_srt-sat_seft_info+320;
                const 1;
                const 21474836497;)]
        }
    {offset
      ceq9:
          _seft::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceqa; else goto ceqb;   // CmmCondBranch
      ceqa:
          R1 = _seft::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _seft::P64;   // CmmStore
          _sefs::P64 = P64[_seft::P64 + 16];   // CmmAssign
          R3 = _sefs::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.typecheckModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seft_info)+320
	.long	0
	.quad	1
	.quad	21474836497
sat_seft_info:
_ceq9:
	movq %rbx,%vI_seft
	leaq -16(%rbp),%vI_neu1
	cmpq %r15,%vI_neu1
	jb _ceqa
	jmp _ceqb
_ceqa:
	movq %vI_seft,%rbx
	jmp *-16(%r13)
_ceqb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_seft,-8(%rbp)
	movq 16(%vI_seft),%vI_sefs
	movq %vI_sefs,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.typecheckModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seft_info, .-sat_seft_info



==================== Liveness annotations added ====================
sat_seft_entry() //  [R1]
        { [(ceq9,
            sat_seft_info:
                const SehZ_srt-sat_seft_info+320;
                const 1;
                const 21474836497;)]
          # entryIds         = [ceq9]
          # liveVRegsOnEntry = Just [(ceq9, [R1 :-> %r1]),
                                     (ceqa, [seft :-> %vI_seft]), (ceqb, [seft :-> %vI_seft])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceq9:
            	movq %rbx,%vI_seft
                    # born:    %vI_seft
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neu1
                    # born:    %vI_neu1
                     
            	cmpq %r15,%vI_neu1
                    # r_dying: %vI_neu1
                     
            	jb _ceqa
                     
            	jmp _ceqb
                    # r_dying: %vI_seft
                     ,
     NONREC
        ceqa:
            	movq %vI_seft,%rbx
                    # born:    %r1
                    # r_dying: %vI_seft
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqb:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_seft,-8(%rbp)
                     
            	movq 16(%vI_seft),%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %vI_seft
                     
            	movq %vI_sefs,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefs
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.typecheckModule_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seft_info)+320
	.long	0
	.quad	1
	.quad	21474836497
sat_seft_info:
_ceq9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqa
	jmp _ceqb
_ceqa:
	jmp *-16(%r13)
_ceqb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.typecheckModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_seft_info, .-sat_seft_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seft_info)+320
	.long	0
	.quad	1
	.quad	21474836497
sat_seft_info:
_ceq9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqa
_ceqb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.typecheckModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqa:
	jmp *-16(%r13)
	.size sat_seft_info, .-sat_seft_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_seft_info)+320
	.long	0
	.quad	1
	.quad	21474836497
sat_seft_info:
_ceq9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqa
_ceqb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.typecheckModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqa:
	jmp *-16(%r13)
	.size sat_seft_info, .-sat_seft_info



==================== Optimised Cmm ====================
sat_sefG_entry() //  [R2, R1]
        { [(ceqc,
            sat_sefG_info:
                const SehZ_srt-sat_sefG_info+288;
                const 4294967301;
                const 4294967296;
                const 545460846603;)]
        }
    {offset
      ceqc:
          _sefs::P64 = R2;   // CmmAssign
          _sefG::P64 = R1;   // CmmAssign
          if ((Sp + -24) < SpLim) goto ceqd; else goto ceqe;   // CmmCondBranch
      ceqe:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceqg; else goto ceqf;   // CmmCondBranch
      ceqg:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto ceqd;   // CmmBranch
      ceqd:
          R2 = _sefs::P64;   // CmmAssign
          R1 = _sefG::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqf:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefF_info;   // CmmStore
          P64[Hp - 24] = _sefs::P64;   // CmmStore
          _cep1::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_seft_info;   // CmmStore
          P64[Hp] = _sefs::P64;   // CmmStore
          _ceq5::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceq5::P64;   // CmmStore
          P64[Sp - 8] = _cep1::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefG_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	545460846603
sat_sefG_info:
_ceqc:
	movq %r14,%vI_sefs
	movq %rbx,%vI_sefG
	leaq -24(%rbp),%vI_neu4
	cmpq %r15,%vI_neu4
	jb _ceqd
	jmp _ceqe
_ceqd:
	movq %vI_sefs,%r14
	movq %vI_sefG,%rbx
	jmp *-8(%r13)
_ceqe:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqg
	jmp _ceqf
_ceqf:
	movq $sat_sefF_info,-32(%r12)
	movq %vI_sefs,-24(%r12)
	leaq -31(%r12),%vI_cep1
	movq $sat_seft_info,-16(%r12)
	movq %vI_sefs,(%r12)
	leaq -16(%r12),%vI_ceq5
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_ceq5,-16(%rbp)
	movq %vI_cep1,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqg:
	movq $40,904(%r13)
	jmp _ceqd
	.size sat_sefG_info, .-sat_sefG_info



==================== Liveness annotations added ====================
sat_sefG_entry() //  [R2, R1]
        { [(ceqc,
            sat_sefG_info:
                const SehZ_srt-sat_sefG_info+288;
                const 4294967301;
                const 4294967296;
                const 545460846603;)]
          # entryIds         = [ceqc]
          # liveVRegsOnEntry = Just [(ceqc, [R1 :-> %r1, Re :-> %r14]),
                                     (ceqd, [sefs :-> %vI_sefs, sefG :-> %vI_sefG]),
                                     (ceqe, [sefs :-> %vI_sefs, sefG :-> %vI_sefG]),
                                     (ceqf, [sefs :-> %vI_sefs]),
                                     (ceqg, [sefs :-> %vI_sefs, sefG :-> %vI_sefG])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqc:
            	movq %r14,%vI_sefs
                    # born:    %vI_sefs
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefG
                    # born:    %vI_sefG
                    # r_dying: %r1
                     
            	leaq -24(%rbp),%vI_neu4
                    # born:    %vI_neu4
                     
            	cmpq %r15,%vI_neu4
                    # r_dying: %vI_neu4
                     
            	jb _ceqd
                     
            	jmp _ceqe
                    # r_dying: %vI_sefs %vI_sefG
                     ,
     NONREC
        ceqe:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceqg
                    # r_dying: %vI_sefG
                     
            	jmp _ceqf
                    # r_dying: %vI_sefs
                     ,
     NONREC
        ceqg:
            	movq $40,904(%r13)
                     
            	jmp _ceqd
                    # r_dying: %vI_sefs %vI_sefG
                     ,
     NONREC
        ceqd:
            	movq %vI_sefs,%r14
                    # born:    %r14
                    # r_dying: %vI_sefs
                     
            	movq %vI_sefG,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefG
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        ceqf:
            	movq $sat_sefF_info,-32(%r12)
                     
            	movq %vI_sefs,-24(%r12)
                     
            	leaq -31(%r12),%vI_cep1
                    # born:    %vI_cep1
                     
            	movq $sat_seft_info,-16(%r12)
                     
            	movq %vI_sefs,(%r12)
                    # r_dying: %vI_sefs
                     
            	leaq -16(%r12),%vI_ceq5
                    # born:    %vI_ceq5
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_ceq5,-16(%rbp)
                    # r_dying: %vI_ceq5
                     
            	movq %vI_cep1,-8(%rbp)
                    # r_dying: %vI_cep1
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefG_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	545460846603
sat_sefG_info:
_ceqc:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqd
	jmp _ceqe
_ceqe:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqg
	jmp _ceqf
_ceqg:
	movq $40,904(%r13)
	jmp _ceqd
_ceqd:
	jmp *-8(%r13)
_ceqf:
	movq $sat_sefF_info,-32(%r12)
	movq %r14,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_seft_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefG_info, .-sat_sefG_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefG_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	545460846603
sat_sefG_info:
_ceqc:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqd
_ceqe:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqg
_ceqf:
	movq $sat_sefF_info,-32(%r12)
	movq %r14,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_seft_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqg:
	movq $40,904(%r13)
_ceqd:
	jmp *-8(%r13)
	.size sat_sefG_info, .-sat_sefG_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefG_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	545460846603
sat_sefG_info:
_ceqc:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqd
_ceqe:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqg
_ceqf:
	movq $sat_sefF_info,-32(%r12)
	movq %r14,-24(%r12)
	leaq -31(%r12),%rax
	movq $sat_seft_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqg:
	movq $40,904(%r13)
_ceqd:
	jmp *-8(%r13)
	.size sat_sefG_info, .-sat_sefG_info



==================== Optimised Cmm ====================
sat_sefr_entry() //  [R1]
        { [(ceql,
            sat_sefr_info:
                const SehZ_srt-sat_sefr_info+320;
                const 1;
                const 38654705681;)]
        }
    {offset
      ceql:
          _sefr::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceqm; else goto ceqn;   // CmmCondBranch
      ceqm:
          R1 = _sefr::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqn:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefr::P64;   // CmmStore
          _sefq::P64 = P64[_sefr::P64 + 16];   // CmmAssign
          R3 = _sefq::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.parseModule_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefr_info)+320
	.long	0
	.quad	1
	.quad	38654705681
sat_sefr_info:
_ceql:
	movq %rbx,%vI_sefr
	leaq -16(%rbp),%vI_neu7
	cmpq %r15,%vI_neu7
	jb _ceqm
	jmp _ceqn
_ceqm:
	movq %vI_sefr,%rbx
	jmp *-16(%r13)
_ceqn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefr,-8(%rbp)
	movq 16(%vI_sefr),%vI_sefq
	movq %vI_sefq,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.parseModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefr_info, .-sat_sefr_info



==================== Liveness annotations added ====================
sat_sefr_entry() //  [R1]
        { [(ceql,
            sat_sefr_info:
                const SehZ_srt-sat_sefr_info+320;
                const 1;
                const 38654705681;)]
          # entryIds         = [ceql]
          # liveVRegsOnEntry = Just [(ceql, [R1 :-> %r1]),
                                     (ceqm, [sefr :-> %vI_sefr]), (ceqn, [sefr :-> %vI_sefr])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceql:
            	movq %rbx,%vI_sefr
                    # born:    %vI_sefr
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neu7
                    # born:    %vI_neu7
                     
            	cmpq %r15,%vI_neu7
                    # r_dying: %vI_neu7
                     
            	jb _ceqm
                     
            	jmp _ceqn
                    # r_dying: %vI_sefr
                     ,
     NONREC
        ceqm:
            	movq %vI_sefr,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefr
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqn:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefr,-8(%rbp)
                     
            	movq 16(%vI_sefr),%vI_sefq
                    # born:    %vI_sefq
                    # r_dying: %vI_sefr
                     
            	movq %vI_sefq,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefq
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.parseModule_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefr_info)+320
	.long	0
	.quad	1
	.quad	38654705681
sat_sefr_info:
_ceql:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqm
	jmp _ceqn
_ceqm:
	jmp *-16(%r13)
_ceqn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.parseModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefr_info, .-sat_sefr_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefr_info)+320
	.long	0
	.quad	1
	.quad	38654705681
sat_sefr_info:
_ceql:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqm
_ceqn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.parseModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqm:
	jmp *-16(%r13)
	.size sat_sefr_info, .-sat_sefr_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefr_info)+320
	.long	0
	.quad	1
	.quad	38654705681
sat_sefr_info:
_ceql:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqm
_ceqn:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.parseModule_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqm:
	jmp *-16(%r13)
	.size sat_sefr_info, .-sat_sefr_info



==================== Optimised Cmm ====================
sat_sefH_entry() //  [R2, R1]
        { [(ceqo,
            sat_sefH_info:
                const SehZ_srt-sat_sefH_info+288;
                const 4294967301;
                const 4294967296;
                const 1095216660491;)]
        }
    {offset
      ceqo:
          _sefq::P64 = R2;   // CmmAssign
          _sefH::P64 = R1;   // CmmAssign
          if ((Sp + -24) < SpLim) goto ceqp; else goto ceqq;   // CmmCondBranch
      ceqq:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceqs; else goto ceqr;   // CmmCondBranch
      ceqs:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto ceqp;   // CmmBranch
      ceqp:
          R2 = _sefq::P64;   // CmmAssign
          R1 = _sefH::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqr:
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefG_info;   // CmmStore
          _ceoW::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefr_info;   // CmmStore
          P64[Hp] = _sefq::P64;   // CmmStore
          _ceqh::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceqh::P64;   // CmmStore
          P64[Sp - 8] = _ceoW::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefH_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	1095216660491
sat_sefH_info:
_ceqo:
	movq %r14,%vI_sefq
	movq %rbx,%vI_sefH
	leaq -24(%rbp),%vI_neua
	cmpq %r15,%vI_neua
	jb _ceqp
	jmp _ceqq
_ceqp:
	movq %vI_sefq,%r14
	movq %vI_sefH,%rbx
	jmp *-8(%r13)
_ceqq:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqs
	jmp _ceqr
_ceqr:
	movq $sat_sefG_info,-32(%r12)
	leaq -31(%r12),%vI_ceoW
	movq $sat_sefr_info,-16(%r12)
	movq %vI_sefq,(%r12)
	leaq -16(%r12),%vI_ceqh
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_ceqh,-16(%rbp)
	movq %vI_ceoW,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqs:
	movq $40,904(%r13)
	jmp _ceqp
	.size sat_sefH_info, .-sat_sefH_info



==================== Liveness annotations added ====================
sat_sefH_entry() //  [R2, R1]
        { [(ceqo,
            sat_sefH_info:
                const SehZ_srt-sat_sefH_info+288;
                const 4294967301;
                const 4294967296;
                const 1095216660491;)]
          # entryIds         = [ceqo]
          # liveVRegsOnEntry = Just [(ceqo, [R1 :-> %r1, Re :-> %r14]),
                                     (ceqp, [sefq :-> %vI_sefq, sefH :-> %vI_sefH]),
                                     (ceqq, [sefq :-> %vI_sefq, sefH :-> %vI_sefH]),
                                     (ceqr, [sefq :-> %vI_sefq]),
                                     (ceqs, [sefq :-> %vI_sefq, sefH :-> %vI_sefH])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqo:
            	movq %r14,%vI_sefq
                    # born:    %vI_sefq
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefH
                    # born:    %vI_sefH
                    # r_dying: %r1
                     
            	leaq -24(%rbp),%vI_neua
                    # born:    %vI_neua
                     
            	cmpq %r15,%vI_neua
                    # r_dying: %vI_neua
                     
            	jb _ceqp
                     
            	jmp _ceqq
                    # r_dying: %vI_sefq %vI_sefH
                     ,
     NONREC
        ceqq:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceqs
                    # r_dying: %vI_sefH
                     
            	jmp _ceqr
                    # r_dying: %vI_sefq
                     ,
     NONREC
        ceqs:
            	movq $40,904(%r13)
                     
            	jmp _ceqp
                    # r_dying: %vI_sefq %vI_sefH
                     ,
     NONREC
        ceqp:
            	movq %vI_sefq,%r14
                    # born:    %r14
                    # r_dying: %vI_sefq
                     
            	movq %vI_sefH,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefH
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        ceqr:
            	movq $sat_sefG_info,-32(%r12)
                     
            	leaq -31(%r12),%vI_ceoW
                    # born:    %vI_ceoW
                     
            	movq $sat_sefr_info,-16(%r12)
                     
            	movq %vI_sefq,(%r12)
                    # r_dying: %vI_sefq
                     
            	leaq -16(%r12),%vI_ceqh
                    # born:    %vI_ceqh
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_ceqh,-16(%rbp)
                    # r_dying: %vI_ceqh
                     
            	movq %vI_ceoW,-8(%rbp)
                    # r_dying: %vI_ceoW
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefH_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	1095216660491
sat_sefH_info:
_ceqo:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqp
	jmp _ceqq
_ceqq:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqs
	jmp _ceqr
_ceqs:
	movq $40,904(%r13)
	jmp _ceqp
_ceqp:
	jmp *-8(%r13)
_ceqr:
	movq $sat_sefG_info,-32(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefr_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefH_info, .-sat_sefH_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefH_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	1095216660491
sat_sefH_info:
_ceqo:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqp
_ceqq:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqs
_ceqr:
	movq $sat_sefG_info,-32(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefr_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqs:
	movq $40,904(%r13)
_ceqp:
	jmp *-8(%r13)
	.size sat_sefH_info, .-sat_sefH_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefH_info)+288
	.long	0
	.quad	4294967301
	.quad	4294967296
	.quad	1095216660491
sat_sefH_info:
_ceqo:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqp
_ceqq:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqs
_ceqr:
	movq $sat_sefG_info,-32(%r12)
	leaq -31(%r12),%rax
	movq $sat_sefr_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_ceqs:
	movq $40,904(%r13)
_ceqp:
	jmp *-8(%r13)
	.size sat_sefH_info, .-sat_sefH_info



==================== Optimised Cmm ====================
sat_sefp_entry() //  [R1]
        { [(ceqx,
            sat_sefp_info:
                const SehZ_srt-sat_sefp_info+320;
                const 1;
                const 73014444049;)]
        }
    {offset
      ceqx:
          _sefp::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceqy; else goto ceqz;   // CmmCondBranch
      ceqy:
          R1 = _sefp::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefp::P64;   // CmmStore
          _sefk::P64 = P64[_sefp::P64 + 16];   // CmmAssign
          R3 = _sefk::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.getModSummary_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefp_info)+320
	.long	0
	.quad	1
	.quad	73014444049
sat_sefp_info:
_ceqx:
	movq %rbx,%vI_sefp
	leaq -16(%rbp),%vI_neud
	cmpq %r15,%vI_neud
	jb _ceqy
	jmp _ceqz
_ceqy:
	movq %vI_sefp,%rbx
	jmp *-16(%r13)
_ceqz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefp,-8(%rbp)
	movq 16(%vI_sefp),%vI_sefk
	movq %vI_sefk,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.getModSummary_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefp_info, .-sat_sefp_info



==================== Liveness annotations added ====================
sat_sefp_entry() //  [R1]
        { [(ceqx,
            sat_sefp_info:
                const SehZ_srt-sat_sefp_info+320;
                const 1;
                const 73014444049;)]
          # entryIds         = [ceqx]
          # liveVRegsOnEntry = Just [(ceqx, [R1 :-> %r1]),
                                     (ceqy, [sefp :-> %vI_sefp]), (ceqz, [sefp :-> %vI_sefp])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqx:
            	movq %rbx,%vI_sefp
                    # born:    %vI_sefp
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neud
                    # born:    %vI_neud
                     
            	cmpq %r15,%vI_neud
                    # r_dying: %vI_neud
                     
            	jb _ceqy
                     
            	jmp _ceqz
                    # r_dying: %vI_sefp
                     ,
     NONREC
        ceqy:
            	movq %vI_sefp,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefp
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqz:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefp,-8(%rbp)
                     
            	movq 16(%vI_sefp),%vI_sefk
                    # born:    %vI_sefk
                    # r_dying: %vI_sefp
                     
            	movq %vI_sefk,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefk
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.getModSummary_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefp_info)+320
	.long	0
	.quad	1
	.quad	73014444049
sat_sefp_info:
_ceqx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqy
	jmp _ceqz
_ceqy:
	jmp *-16(%r13)
_ceqz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.getModSummary_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefp_info, .-sat_sefp_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefp_info)+320
	.long	0
	.quad	1
	.quad	73014444049
sat_sefp_info:
_ceqx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqy
_ceqz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.getModSummary_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqy:
	jmp *-16(%r13)
	.size sat_sefp_info, .-sat_sefp_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefp_info)+320
	.long	0
	.quad	1
	.quad	73014444049
sat_sefp_info:
_ceqx:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqy
_ceqz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.getModSummary_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqy:
	jmp *-16(%r13)
	.size sat_sefp_info, .-sat_sefp_info



==================== Optimised Cmm ====================
sat_sefI_entry() //  [R1]
        { [(ceqA,
            sat_sefI_info:
                const SehZ_srt-sat_sefI_info+288;
                const 1;
                const 2194728288273;)]
        }
    {offset
      ceqA:
          _sefI::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto ceqB; else goto ceqC;   // CmmCondBranch
      ceqC:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceqE; else goto ceqD;   // CmmCondBranch
      ceqE:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto ceqB;   // CmmBranch
      ceqB:
          R1 = _sefI::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqD:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefI::P64;   // CmmStore
          _sefk::P64 = P64[_sefI::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefH_info;   // CmmStore
          _ceoR::P64 = Hp - 31;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefp_info;   // CmmStore
          P64[Hp] = _sefk::P64;   // CmmStore
          _ceqt::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqt::P64;   // CmmStore
          P64[Sp - 24] = _ceoR::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefI_info)+288
	.long	0
	.quad	1
	.quad	2194728288273
sat_sefI_info:
_ceqA:
	movq %rbx,%vI_sefI
	leaq -40(%rbp),%vI_neug
	cmpq %r15,%vI_neug
	jb _ceqB
	jmp _ceqC
_ceqB:
	movq %vI_sefI,%rbx
	jmp *-16(%r13)
_ceqC:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqE
	jmp _ceqD
_ceqD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefI,-8(%rbp)
	movq 16(%vI_sefI),%vI_sefk
	movq $sat_sefH_info,-32(%r12)
	leaq -31(%r12),%vI_ceoR
	movq $sat_sefp_info,-16(%r12)
	movq %vI_sefk,(%r12)
	leaq -16(%r12),%vI_ceqt
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_ceqt,-32(%rbp)
	movq %vI_ceoR,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceqE:
	movq $40,904(%r13)
	jmp _ceqB
	.size sat_sefI_info, .-sat_sefI_info



==================== Liveness annotations added ====================
sat_sefI_entry() //  [R1]
        { [(ceqA,
            sat_sefI_info:
                const SehZ_srt-sat_sefI_info+288;
                const 1;
                const 2194728288273;)]
          # entryIds         = [ceqA]
          # liveVRegsOnEntry = Just [(ceqA, [R1 :-> %r1]),
                                     (ceqB, [sefI :-> %vI_sefI]), (ceqC, [sefI :-> %vI_sefI]),
                                     (ceqD, [sefI :-> %vI_sefI]), (ceqE, [sefI :-> %vI_sefI])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqA:
            	movq %rbx,%vI_sefI
                    # born:    %vI_sefI
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_neug
                    # born:    %vI_neug
                     
            	cmpq %r15,%vI_neug
                    # r_dying: %vI_neug
                     
            	jb _ceqB
                     
            	jmp _ceqC
                    # r_dying: %vI_sefI
                     ,
     NONREC
        ceqC:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceqE
                     
            	jmp _ceqD
                    # r_dying: %vI_sefI
                     ,
     NONREC
        ceqE:
            	movq $40,904(%r13)
                     
            	jmp _ceqB
                    # r_dying: %vI_sefI
                     ,
     NONREC
        ceqB:
            	movq %vI_sefI,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefI
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqD:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefI,-8(%rbp)
                     
            	movq 16(%vI_sefI),%vI_sefk
                    # born:    %vI_sefk
                    # r_dying: %vI_sefI
                     
            	movq $sat_sefH_info,-32(%r12)
                     
            	leaq -31(%r12),%vI_ceoR
                    # born:    %vI_ceoR
                     
            	movq $sat_sefp_info,-16(%r12)
                     
            	movq %vI_sefk,(%r12)
                    # r_dying: %vI_sefk
                     
            	leaq -16(%r12),%vI_ceqt
                    # born:    %vI_ceqt
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_ceqt,-32(%rbp)
                    # r_dying: %vI_ceqt
                     
            	movq %vI_ceoR,-24(%rbp)
                    # r_dying: %vI_ceoR
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefI_info)+288
	.long	0
	.quad	1
	.quad	2194728288273
sat_sefI_info:
_ceqA:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqB
	jmp _ceqC
_ceqC:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqE
	jmp _ceqD
_ceqE:
	movq $40,904(%r13)
	jmp _ceqB
_ceqB:
	jmp *-16(%r13)
_ceqD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefH_info,-32(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefp_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefI_info, .-sat_sefI_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefI_info)+288
	.long	0
	.quad	1
	.quad	2194728288273
sat_sefI_info:
_ceqA:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqB
_ceqC:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqE
_ceqD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefH_info,-32(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefp_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceqE:
	movq $40,904(%r13)
_ceqB:
	jmp *-16(%r13)
	.size sat_sefI_info, .-sat_sefI_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefI_info)+288
	.long	0
	.quad	1
	.quad	2194728288273
sat_sefI_info:
_ceqA:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqB
_ceqC:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqE
_ceqD:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefH_info,-32(%r12)
	leaq -31(%r12),%rbx
	movq $sat_sefp_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceqE:
	movq $40,904(%r13)
_ceqB:
	jmp *-16(%r13)
	.size sat_sefI_info, .-sat_sefI_info



==================== Optimised Cmm ====================
sat_sefo_entry() //  [R1]
        { [(ceqJ,
            sat_sefo_info:
                const SehZ_srt-sat_sefo_info+320;
                const 0;
                const 141733920784;)]
        }
    {offset
      ceqJ:
          _sefo::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceqK; else goto ceqL;   // CmmCondBranch
      ceqK:
          R1 = _sefo::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqL:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefo::P64;   // CmmStore
          R3 = GhcMake.LoadAllTargets_closure+1;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMake.load_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefo_info)+320
	.long	0
	.quad	0
	.quad	141733920784
sat_sefo_info:
_ceqJ:
	movq %rbx,%vI_sefo
	leaq -16(%rbp),%vI_neuj
	cmpq %r15,%vI_neuj
	jb _ceqK
	jmp _ceqL
_ceqK:
	movq %vI_sefo,%rbx
	jmp *-16(%r13)
_ceqL:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefo,-8(%rbp)
	movl $GhcMake.LoadAllTargets_closure+1,%esi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMake.load_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefo_info, .-sat_sefo_info



==================== Liveness annotations added ====================
sat_sefo_entry() //  [R1]
        { [(ceqJ,
            sat_sefo_info:
                const SehZ_srt-sat_sefo_info+320;
                const 0;
                const 141733920784;)]
          # entryIds         = [ceqJ]
          # liveVRegsOnEntry = Just [(ceqJ, [R1 :-> %r1]),
                                     (ceqK, [sefo :-> %vI_sefo]), (ceqL, [sefo :-> %vI_sefo])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqJ:
            	movq %rbx,%vI_sefo
                    # born:    %vI_sefo
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neuj
                    # born:    %vI_neuj
                     
            	cmpq %r15,%vI_neuj
                    # r_dying: %vI_neuj
                     
            	jb _ceqK
                     
            	jmp _ceqL
                    # r_dying: %vI_sefo
                     ,
     NONREC
        ceqK:
            	movq %vI_sefo,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefo
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqL:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefo,-8(%rbp)
                    # r_dying: %vI_sefo
                     
            	movl $GhcMake.LoadAllTargets_closure+1,%esi
                    # born:    %r4
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GhcMake.load_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefo_info)+320
	.long	0
	.quad	0
	.quad	141733920784
sat_sefo_info:
_ceqJ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqK
	jmp _ceqL
_ceqK:
	jmp *-16(%r13)
_ceqL:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMake.LoadAllTargets_closure+1,%esi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMake.load_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefo_info, .-sat_sefo_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefo_info)+320
	.long	0
	.quad	0
	.quad	141733920784
sat_sefo_info:
_ceqJ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqK
_ceqL:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMake.LoadAllTargets_closure+1,%esi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMake.load_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqK:
	jmp *-16(%r13)
	.size sat_sefo_info, .-sat_sefo_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefo_info)+320
	.long	0
	.quad	0
	.quad	141733920784
sat_sefo_info:
_ceqJ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqK
_ceqL:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMake.LoadAllTargets_closure+1,%esi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMake.load_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_ceqK:
	jmp *-16(%r13)
	.size sat_sefo_info, .-sat_sefo_info



==================== Optimised Cmm ====================
sat_sefJ_entry() //  [R1]
        { [(ceqM,
            sat_sefJ_info:
                const SehZ_srt-sat_sefJ_info+288;
                const 1;
                const 4393751543825;)]
        }
    {offset
      ceqM:
          _sefJ::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto ceqN; else goto ceqO;   // CmmCondBranch
      ceqO:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceqQ; else goto ceqP;   // CmmCondBranch
      ceqQ:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto ceqN;   // CmmBranch
      ceqN:
          R1 = _sefJ::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      ceqP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefJ::P64;   // CmmStore
          _sefk::P64 = P64[_sefJ::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefI_info;   // CmmStore
          P64[Hp - 16] = _sefk::P64;   // CmmStore
          _ceoN::P64 = Hp - 32;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefo_info;   // CmmStore
          _ceqF::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqF::P64;   // CmmStore
          P64[Sp - 24] = _ceoN::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefJ_info)+288
	.long	0
	.quad	1
	.quad	4393751543825
sat_sefJ_info:
_ceqM:
	movq %rbx,%vI_sefJ
	leaq -40(%rbp),%vI_neum
	cmpq %r15,%vI_neum
	jb _ceqN
	jmp _ceqO
_ceqN:
	movq %vI_sefJ,%rbx
	jmp *-16(%r13)
_ceqO:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqQ
	jmp _ceqP
_ceqP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefJ,-8(%rbp)
	movq 16(%vI_sefJ),%vI_sefk
	movq $sat_sefI_info,-32(%r12)
	movq %vI_sefk,-16(%r12)
	leaq -32(%r12),%vI_ceoN
	movq $sat_sefo_info,-8(%r12)
	leaq -8(%r12),%vI_ceqF
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_ceqF,-32(%rbp)
	movq %vI_ceoN,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_ceqQ:
	movq $40,904(%r13)
	jmp _ceqN
	.size sat_sefJ_info, .-sat_sefJ_info



==================== Liveness annotations added ====================
sat_sefJ_entry() //  [R1]
        { [(ceqM,
            sat_sefJ_info:
                const SehZ_srt-sat_sefJ_info+288;
                const 1;
                const 4393751543825;)]
          # entryIds         = [ceqM]
          # liveVRegsOnEntry = Just [(ceqM, [R1 :-> %r1]),
                                     (ceqN, [sefJ :-> %vI_sefJ]), (ceqO, [sefJ :-> %vI_sefJ]),
                                     (ceqP, [sefJ :-> %vI_sefJ]), (ceqQ, [sefJ :-> %vI_sefJ])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqM:
            	movq %rbx,%vI_sefJ
                    # born:    %vI_sefJ
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_neum
                    # born:    %vI_neum
                     
            	cmpq %r15,%vI_neum
                    # r_dying: %vI_neum
                     
            	jb _ceqN
                     
            	jmp _ceqO
                    # r_dying: %vI_sefJ
                     ,
     NONREC
        ceqO:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceqQ
                     
            	jmp _ceqP
                    # r_dying: %vI_sefJ
                     ,
     NONREC
        ceqQ:
            	movq $40,904(%r13)
                     
            	jmp _ceqN
                    # r_dying: %vI_sefJ
                     ,
     NONREC
        ceqN:
            	movq %vI_sefJ,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefJ
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        ceqP:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefJ,-8(%rbp)
                     
            	movq 16(%vI_sefJ),%vI_sefk
                    # born:    %vI_sefk
                    # r_dying: %vI_sefJ
                     
            	movq $sat_sefI_info,-32(%r12)
                     
            	movq %vI_sefk,-16(%r12)
                    # r_dying: %vI_sefk
                     
            	leaq -32(%r12),%vI_ceoN
                    # born:    %vI_ceoN
                     
            	movq $sat_sefo_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_ceqF
                    # born:    %vI_ceqF
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_ceqF,-32(%rbp)
                    # r_dying: %vI_ceqF
                     
            	movq %vI_ceoN,-24(%rbp)
                    # r_dying: %vI_ceoN
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefJ_info)+288
	.long	0
	.quad	1
	.quad	4393751543825
sat_sefJ_info:
_ceqM:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqN
	jmp _ceqO
_ceqO:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqQ
	jmp _ceqP
_ceqQ:
	movq $40,904(%r13)
	jmp _ceqN
_ceqN:
	jmp *-16(%r13)
_ceqP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefI_info,-32(%r12)
	movq %rax,-16(%r12)
	leaq -32(%r12),%rax
	movq $sat_sefo_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
	.size sat_sefJ_info, .-sat_sefJ_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefJ_info)+288
	.long	0
	.quad	1
	.quad	4393751543825
sat_sefJ_info:
_ceqM:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqN
_ceqO:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqQ
_ceqP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefI_info,-32(%r12)
	movq %rax,-16(%r12)
	leaq -32(%r12),%rax
	movq $sat_sefo_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_ceqQ:
	movq $40,904(%r13)
_ceqN:
	jmp *-16(%r13)
	.size sat_sefJ_info, .-sat_sefJ_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefJ_info)+288
	.long	0
	.quad	1
	.quad	4393751543825
sat_sefJ_info:
_ceqM:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqN
_ceqO:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _ceqQ
_ceqP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefI_info,-32(%r12)
	movq %rax,-16(%r12)
	leaq -32(%r12),%rax
	movq $sat_sefo_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_ceqQ:
	movq $40,904(%r13)
_ceqN:
	jmp *-16(%r13)
	.size sat_sefJ_info, .-sat_sefJ_info



==================== Optimised Cmm ====================
sat_sefn_entry() //  [R1]
        { [(ceqX,
            sat_sefn_info:
                const SehZ_srt-sat_sefn_info+320;
                const 1;
                const 279172874257;)]
        }
    {offset
      ceqX:
          _sefn::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceqY; else goto ceqZ;   // CmmCondBranch
      ceqZ:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cer1; else goto cer0;   // CmmCondBranch
      cer1:
          I64[BaseReg + 904] = 48;   // CmmStore
          goto ceqY;   // CmmBranch
      ceqY:
          R1 = _sefn::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer0:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefn::P64;   // CmmStore
          _sefk::P64 = P64[_sefn::P64 + 16];   // CmmAssign
          I64[Hp - 40] = HscTypes.TargetModule_con_info;   // CmmStore
          P64[Hp - 32] = _sefk::P64;   // CmmStore
          _ceqV::P64 = Hp - 39;   // CmmAssign
          I64[Hp - 24] = HscTypes.Target_con_info;   // CmmStore
          P64[Hp - 16] = _ceqV::P64;   // CmmStore
          P64[Hp - 8] = GHC.Types.True_closure+2;   // CmmStore
          P64[Hp] = GHC.Base.Nothing_closure+1;   // CmmStore
          _ceqW::P64 = Hp - 23;   // CmmAssign
          R3 = _ceqW::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.addTarget_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefn_info)+320
	.long	0
	.quad	1
	.quad	279172874257
sat_sefn_info:
_ceqX:
	movq %rbx,%vI_sefn
	leaq -16(%rbp),%vI_neup
	cmpq %r15,%vI_neup
	jb _ceqY
	jmp _ceqZ
_ceqY:
	movq %vI_sefn,%rbx
	jmp *-16(%r13)
_ceqZ:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cer1
	jmp _cer0
_cer0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefn,-8(%rbp)
	movq 16(%vI_sefn),%vI_sefk
	movq $HscTypes.TargetModule_con_info,-40(%r12)
	movq %vI_sefk,-32(%r12)
	leaq -39(%r12),%vI_ceqV
	movq $HscTypes.Target_con_info,-24(%r12)
	movq %vI_ceqV,-16(%r12)
	movq $GHC.Types.True_closure+2,-8(%r12)
	movq $GHC.Base.Nothing_closure+1,(%r12)
	leaq -23(%r12),%vI_ceqW
	movq %vI_ceqW,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.addTarget_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cer1:
	movq $48,904(%r13)
	jmp _ceqY
	.size sat_sefn_info, .-sat_sefn_info



==================== Liveness annotations added ====================
sat_sefn_entry() //  [R1]
        { [(ceqX,
            sat_sefn_info:
                const SehZ_srt-sat_sefn_info+320;
                const 1;
                const 279172874257;)]
          # entryIds         = [ceqX]
          # liveVRegsOnEntry = Just [(ceqX, [R1 :-> %r1]),
                                     (ceqY, [sefn :-> %vI_sefn]), (ceqZ, [sefn :-> %vI_sefn]),
                                     (cer0, [sefn :-> %vI_sefn]), (cer1, [sefn :-> %vI_sefn])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        ceqX:
            	movq %rbx,%vI_sefn
                    # born:    %vI_sefn
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neup
                    # born:    %vI_neup
                     
            	cmpq %r15,%vI_neup
                    # r_dying: %vI_neup
                     
            	jb _ceqY
                     
            	jmp _ceqZ
                    # r_dying: %vI_sefn
                     ,
     NONREC
        ceqZ:
            	addq $48,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cer1
                     
            	jmp _cer0
                    # r_dying: %vI_sefn
                     ,
     NONREC
        cer1:
            	movq $48,904(%r13)
                     
            	jmp _ceqY
                    # r_dying: %vI_sefn
                     ,
     NONREC
        ceqY:
            	movq %vI_sefn,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefn
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cer0:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefn,-8(%rbp)
                     
            	movq 16(%vI_sefn),%vI_sefk
                    # born:    %vI_sefk
                    # r_dying: %vI_sefn
                     
            	movq $HscTypes.TargetModule_con_info,-40(%r12)
                     
            	movq %vI_sefk,-32(%r12)
                    # r_dying: %vI_sefk
                     
            	leaq -39(%r12),%vI_ceqV
                    # born:    %vI_ceqV
                     
            	movq $HscTypes.Target_con_info,-24(%r12)
                     
            	movq %vI_ceqV,-16(%r12)
                    # r_dying: %vI_ceqV
                     
            	movq $GHC.Types.True_closure+2,-8(%r12)
                     
            	movq $GHC.Base.Nothing_closure+1,(%r12)
                     
            	leaq -23(%r12),%vI_ceqW
                    # born:    %vI_ceqW
                     
            	movq %vI_ceqW,%rsi
                    # born:    %r4
                    # r_dying: %vI_ceqW
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.addTarget_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefn_info)+320
	.long	0
	.quad	1
	.quad	279172874257
sat_sefn_info:
_ceqX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqY
	jmp _ceqZ
_ceqZ:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cer1
	jmp _cer0
_cer1:
	movq $48,904(%r13)
	jmp _ceqY
_ceqY:
	jmp *-16(%r13)
_cer0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $HscTypes.TargetModule_con_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $HscTypes.Target_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq $GHC.Types.True_closure+2,-8(%r12)
	movq $GHC.Base.Nothing_closure+1,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.addTarget_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefn_info, .-sat_sefn_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefn_info)+320
	.long	0
	.quad	1
	.quad	279172874257
sat_sefn_info:
_ceqX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqY
_ceqZ:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cer1
_cer0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $HscTypes.TargetModule_con_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $HscTypes.Target_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq $GHC.Types.True_closure+2,-8(%r12)
	movq $GHC.Base.Nothing_closure+1,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.addTarget_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cer1:
	movq $48,904(%r13)
_ceqY:
	jmp *-16(%r13)
	.size sat_sefn_info, .-sat_sefn_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefn_info)+320
	.long	0
	.quad	1
	.quad	279172874257
sat_sefn_info:
_ceqX:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceqY
_ceqZ:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cer1
_cer0:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $HscTypes.TargetModule_con_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $HscTypes.Target_con_info,-24(%r12)
	movq %rax,-16(%r12)
	movq $GHC.Types.True_closure+2,-8(%r12)
	movq $GHC.Base.Nothing_closure+1,(%r12)
	leaq -23(%r12),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.addTarget_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cer1:
	movq $48,904(%r13)
_ceqY:
	jmp *-16(%r13)
	.size sat_sefn_info, .-sat_sefn_info



==================== Optimised Cmm ====================
sat_sefK_entry() //  [R1]
        { [(cer2,
            sat_sefK_info:
                const SehZ_srt-sat_sefK_info+280;
                const 1;
                const 17587891077137;)]
        }
    {offset
      cer2:
          _sefK::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto cer3; else goto cer4;   // CmmCondBranch
      cer4:
          Hp = Hp + 72;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cer6; else goto cer5;   // CmmCondBranch
      cer6:
          I64[BaseReg + 904] = 72;   // CmmStore
          goto cer3;   // CmmBranch
      cer3:
          R1 = _sefK::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cer5:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefK::P64;   // CmmStore
          _seeY::P64 = P64[_sefK::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 64] = mn_sefk_info;   // CmmStore
          P64[Hp - 48] = _seeY::P64;   // CmmStore
          _ceoC::P64 = Hp - 64;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefJ_info;   // CmmStore
          P64[Hp - 24] = _ceoC::P64;   // CmmStore
          _ceoJ::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefn_info;   // CmmStore
          P64[Hp] = _ceoC::P64;   // CmmStore
          _ceqR::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _ceqR::P64;   // CmmStore
          P64[Sp - 24] = _ceoJ::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefK_info)+280
	.long	0
	.quad	1
	.quad	17587891077137
sat_sefK_info:
_cer2:
	movq %rbx,%vI_sefK
	leaq -40(%rbp),%vI_neus
	cmpq %r15,%vI_neus
	jb _cer3
	jmp _cer4
_cer3:
	movq %vI_sefK,%rbx
	jmp *-16(%r13)
_cer4:
	addq $72,%r12
	cmpq 856(%r13),%r12
	ja _cer6
	jmp _cer5
_cer5:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefK,-8(%rbp)
	movq 16(%vI_sefK),%vI_seeY
	movq $mn_sefk_info,-64(%r12)
	movq %vI_seeY,-48(%r12)
	leaq -64(%r12),%vI_ceoC
	movq $sat_sefJ_info,-40(%r12)
	movq %vI_ceoC,-24(%r12)
	leaq -40(%r12),%vI_ceoJ
	movq $sat_sefn_info,-16(%r12)
	movq %vI_ceoC,(%r12)
	leaq -16(%r12),%vI_ceqR
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_ceqR,-32(%rbp)
	movq %vI_ceoJ,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cer6:
	movq $72,904(%r13)
	jmp _cer3
	.size sat_sefK_info, .-sat_sefK_info



==================== Liveness annotations added ====================
sat_sefK_entry() //  [R1]
        { [(cer2,
            sat_sefK_info:
                const SehZ_srt-sat_sefK_info+280;
                const 1;
                const 17587891077137;)]
          # entryIds         = [cer2]
          # liveVRegsOnEntry = Just [(cer2, [R1 :-> %r1]),
                                     (cer3, [sefK :-> %vI_sefK]), (cer4, [sefK :-> %vI_sefK]),
                                     (cer5, [sefK :-> %vI_sefK]), (cer6, [sefK :-> %vI_sefK])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cer2:
            	movq %rbx,%vI_sefK
                    # born:    %vI_sefK
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_neus
                    # born:    %vI_neus
                     
            	cmpq %r15,%vI_neus
                    # r_dying: %vI_neus
                     
            	jb _cer3
                     
            	jmp _cer4
                    # r_dying: %vI_sefK
                     ,
     NONREC
        cer4:
            	addq $72,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cer6
                     
            	jmp _cer5
                    # r_dying: %vI_sefK
                     ,
     NONREC
        cer6:
            	movq $72,904(%r13)
                     
            	jmp _cer3
                    # r_dying: %vI_sefK
                     ,
     NONREC
        cer3:
            	movq %vI_sefK,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefK
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cer5:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefK,-8(%rbp)
                     
            	movq 16(%vI_sefK),%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %vI_sefK
                     
            	movq $mn_sefk_info,-64(%r12)
                     
            	movq %vI_seeY,-48(%r12)
                    # r_dying: %vI_seeY
                     
            	leaq -64(%r12),%vI_ceoC
                    # born:    %vI_ceoC
                     
            	movq $sat_sefJ_info,-40(%r12)
                     
            	movq %vI_ceoC,-24(%r12)
                     
            	leaq -40(%r12),%vI_ceoJ
                    # born:    %vI_ceoJ
                     
            	movq $sat_sefn_info,-16(%r12)
                     
            	movq %vI_ceoC,(%r12)
                    # r_dying: %vI_ceoC
                     
            	leaq -16(%r12),%vI_ceqR
                    # born:    %vI_ceqR
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_ceqR,-32(%rbp)
                    # r_dying: %vI_ceqR
                     
            	movq %vI_ceoJ,-24(%rbp)
                    # r_dying: %vI_ceoJ
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefK_info)+280
	.long	0
	.quad	1
	.quad	17587891077137
sat_sefK_info:
_cer2:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cer3
	jmp _cer4
_cer4:
	addq $72,%r12
	cmpq 856(%r13),%r12
	ja _cer6
	jmp _cer5
_cer6:
	movq $72,904(%r13)
	jmp _cer3
_cer3:
	jmp *-16(%r13)
_cer5:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $mn_sefk_info,-64(%r12)
	movq %rax,-48(%r12)
	leaq -64(%r12),%rax
	movq $sat_sefJ_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_sefn_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
	.size sat_sefK_info, .-sat_sefK_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefK_info)+280
	.long	0
	.quad	1
	.quad	17587891077137
sat_sefK_info:
_cer2:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cer3
_cer4:
	addq $72,%r12
	cmpq 856(%r13),%r12
	ja _cer6
_cer5:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $mn_sefk_info,-64(%r12)
	movq %rax,-48(%r12)
	leaq -64(%r12),%rax
	movq $sat_sefJ_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_sefn_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cer6:
	movq $72,904(%r13)
_cer3:
	jmp *-16(%r13)
	.size sat_sefK_info, .-sat_sefK_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefK_info)+280
	.long	0
	.quad	1
	.quad	17587891077137
sat_sefK_info:
_cer2:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cer3
_cer4:
	addq $72,%r12
	cmpq 856(%r13),%r12
	ja _cer6
_cer5:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $mn_sefk_info,-64(%r12)
	movq %rax,-48(%r12)
	leaq -64(%r12),%rax
	movq $sat_sefJ_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_sefn_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cer6:
	movq $72,904(%r13)
_cer3:
	jmp *-16(%r13)
	.size sat_sefK_info, .-sat_sefK_info



==================== Optimised Cmm ====================
sat_sefj_entry() //  [R1]
        { [(cerb,
            sat_sefj_info:
                const SehZ_srt-sat_sefj_info+320;
                const 1;
                const 554050781201;)]
        }
    {offset
      cerb:
          _sefj::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cerc; else goto cerd;   // CmmCondBranch
      cerc:
          R1 = _sefj::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerd:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefj::P64;   // CmmStore
          _sefi::P64 = P64[_sefj::P64 + 16];   // CmmAssign
          R3 = _sefi::P64;   // CmmAssign
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GHC.setSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefj_info)+320
	.long	0
	.quad	1
	.quad	554050781201
sat_sefj_info:
_cerb:
	movq %rbx,%vI_sefj
	leaq -16(%rbp),%vI_neuv
	cmpq %r15,%vI_neuv
	jb _cerc
	jmp _cerd
_cerc:
	movq %vI_sefj,%rbx
	jmp *-16(%r13)
_cerd:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefj,-8(%rbp)
	movq 16(%vI_sefj),%vI_sefi
	movq %vI_sefi,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.setSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefj_info, .-sat_sefj_info



==================== Liveness annotations added ====================
sat_sefj_entry() //  [R1]
        { [(cerb,
            sat_sefj_info:
                const SehZ_srt-sat_sefj_info+320;
                const 1;
                const 554050781201;)]
          # entryIds         = [cerb]
          # liveVRegsOnEntry = Just [(cerb, [R1 :-> %r1]),
                                     (cerc, [sefj :-> %vI_sefj]), (cerd, [sefj :-> %vI_sefj])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cerb:
            	movq %rbx,%vI_sefj
                    # born:    %vI_sefj
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neuv
                    # born:    %vI_neuv
                     
            	cmpq %r15,%vI_neuv
                    # r_dying: %vI_neuv
                     
            	jb _cerc
                     
            	jmp _cerd
                    # r_dying: %vI_sefj
                     ,
     NONREC
        cerc:
            	movq %vI_sefj,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefj
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cerd:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefj,-8(%rbp)
                     
            	movq 16(%vI_sefj),%vI_sefi
                    # born:    %vI_sefi
                    # r_dying: %vI_sefj
                     
            	movq %vI_sefi,%rsi
                    # born:    %r4
                    # r_dying: %vI_sefi
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.setSessionDynFlags_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefj_info)+320
	.long	0
	.quad	1
	.quad	554050781201
sat_sefj_info:
_cerb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerc
	jmp _cerd
_cerc:
	jmp *-16(%r13)
_cerd:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.setSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefj_info, .-sat_sefj_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefj_info)+320
	.long	0
	.quad	1
	.quad	554050781201
sat_sefj_info:
_cerb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerc
_cerd:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.setSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cerc:
	jmp *-16(%r13)
	.size sat_sefj_info, .-sat_sefj_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefj_info)+320
	.long	0
	.quad	1
	.quad	554050781201
sat_sefj_info:
_cerb:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerc
_cerd:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq %rax,%rsi
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GHC.setSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cerc:
	jmp *-16(%r13)
	.size sat_sefj_info, .-sat_sefj_info



==================== Optimised Cmm ====================
sat_sefL_entry() //  [R2, R1]
        { [(cere,
            sat_sefL_info:
                const SehZ_srt-sat_sefL_info+280;
                const 4294967301;
                const 1;
                const 35180077121546;)]
        }
    {offset
      cere:
          _sefi::P64 = R2;   // CmmAssign
          _sefL::P64 = R1;   // CmmAssign
          if ((Sp + -24) < SpLim) goto cerf; else goto cerg;   // CmmCondBranch
      cerg:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceri; else goto cerh;   // CmmCondBranch
      ceri:
          I64[BaseReg + 904] = 48;   // CmmStore
          goto cerf;   // CmmBranch
      cerf:
          R2 = _sefi::P64;   // CmmAssign
          R1 = _sefL::P64;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerh:
          _seeY::P64 = P64[_sefL::P64 + 7];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_sefK_info;   // CmmStore
          P64[Hp - 24] = _seeY::P64;   // CmmStore
          _ceoy::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_sefj_info;   // CmmStore
          P64[Hp] = _sefi::P64;   // CmmStore
          _cer7::P64 = Hp - 16;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _cer7::P64;   // CmmStore
          P64[Sp - 8] = _ceoy::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefL_info)+280
	.long	0
	.quad	4294967301
	.quad	1
	.quad	35180077121546
sat_sefL_info:
_cere:
	movq %r14,%vI_sefi
	movq %rbx,%vI_sefL
	leaq -24(%rbp),%vI_neuy
	cmpq %r15,%vI_neuy
	jb _cerf
	jmp _cerg
_cerf:
	movq %vI_sefi,%r14
	movq %vI_sefL,%rbx
	jmp *-8(%r13)
_cerg:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _ceri
	jmp _cerh
_cerh:
	movq 7(%vI_sefL),%vI_seeY
	movq $sat_sefK_info,-40(%r12)
	movq %vI_seeY,-24(%r12)
	leaq -40(%r12),%vI_ceoy
	movq $sat_sefj_info,-16(%r12)
	movq %vI_sefi,(%r12)
	leaq -16(%r12),%vI_cer7
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_cer7,-16(%rbp)
	movq %vI_ceoy,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>_info
_ceri:
	movq $48,904(%r13)
	jmp _cerf
	.size sat_sefL_info, .-sat_sefL_info



==================== Liveness annotations added ====================
sat_sefL_entry() //  [R2, R1]
        { [(cere,
            sat_sefL_info:
                const SehZ_srt-sat_sefL_info+280;
                const 4294967301;
                const 1;
                const 35180077121546;)]
          # entryIds         = [cere]
          # liveVRegsOnEntry = Just [(cere, [R1 :-> %r1, Re :-> %r14]),
                                     (cerf, [sefi :-> %vI_sefi, sefL :-> %vI_sefL]),
                                     (cerg, [sefi :-> %vI_sefi, sefL :-> %vI_sefL]),
                                     (cerh, [sefi :-> %vI_sefi, sefL :-> %vI_sefL]),
                                     (ceri, [sefi :-> %vI_sefi, sefL :-> %vI_sefL])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cere:
            	movq %r14,%vI_sefi
                    # born:    %vI_sefi
                    # r_dying: %r14
                     
            	movq %rbx,%vI_sefL
                    # born:    %vI_sefL
                    # r_dying: %r1
                     
            	leaq -24(%rbp),%vI_neuy
                    # born:    %vI_neuy
                     
            	cmpq %r15,%vI_neuy
                    # r_dying: %vI_neuy
                     
            	jb _cerf
                     
            	jmp _cerg
                    # r_dying: %vI_sefi %vI_sefL
                     ,
     NONREC
        cerg:
            	addq $48,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceri
                     
            	jmp _cerh
                    # r_dying: %vI_sefi %vI_sefL
                     ,
     NONREC
        ceri:
            	movq $48,904(%r13)
                     
            	jmp _cerf
                    # r_dying: %vI_sefi %vI_sefL
                     ,
     NONREC
        cerf:
            	movq %vI_sefi,%r14
                    # born:    %r14
                    # r_dying: %vI_sefi
                     
            	movq %vI_sefL,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefL
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cerh:
            	movq 7(%vI_sefL),%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %vI_sefL
                     
            	movq $sat_sefK_info,-40(%r12)
                     
            	movq %vI_seeY,-24(%r12)
                    # r_dying: %vI_seeY
                     
            	leaq -40(%r12),%vI_ceoy
                    # born:    %vI_ceoy
                     
            	movq $sat_sefj_info,-16(%r12)
                     
            	movq %vI_sefi,(%r12)
                    # r_dying: %vI_sefi
                     
            	leaq -16(%r12),%vI_cer7
                    # born:    %vI_cer7
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_cer7,-16(%rbp)
                    # r_dying: %vI_cer7
                     
            	movq %vI_ceoy,-8(%rbp)
                    # r_dying: %vI_ceoy
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefL_info)+280
	.long	0
	.quad	4294967301
	.quad	1
	.quad	35180077121546
sat_sefL_info:
_cere:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerf
	jmp _cerg
_cerg:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _ceri
	jmp _cerh
_ceri:
	movq $48,904(%r13)
	jmp _cerf
_cerf:
	jmp *-8(%r13)
_cerh:
	movq 7(%rbx),%rax
	movq $sat_sefK_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rax
	movq $sat_sefj_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>_info
	.size sat_sefL_info, .-sat_sefL_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefL_info)+280
	.long	0
	.quad	4294967301
	.quad	1
	.quad	35180077121546
sat_sefL_info:
_cere:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerf
_cerg:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _ceri
_cerh:
	movq 7(%rbx),%rax
	movq $sat_sefK_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rax
	movq $sat_sefj_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>_info
_ceri:
	movq $48,904(%r13)
_cerf:
	jmp *-8(%r13)
	.size sat_sefL_info, .-sat_sefL_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefL_info)+280
	.long	0
	.quad	4294967301
	.quad	1
	.quad	35180077121546
sat_sefL_info:
_cere:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerf
_cerg:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _ceri
_cerh:
	movq 7(%rbx),%rax
	movq $sat_sefK_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rax
	movq $sat_sefj_info,-16(%r12)
	movq %r14,(%r12)
	leaq -16(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>_info
_ceri:
	movq $48,904(%r13)
_cerf:
	jmp *-8(%r13)
	.size sat_sefL_info, .-sat_sefL_info



==================== Optimised Cmm ====================
sat_sefh_entry() //  [R1]
        { [(cern,
            sat_sefh_info:
                const SehZ_srt-sat_sefh_info+320;
                const 0;
                const 1103806595088;)]
        }
    {offset
      cern:
          _sefh::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cero; else goto cerp;   // CmmCondBranch
      cero:
          R1 = _sefh::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerp:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefh::P64;   // CmmStore
          R2 = GhcMonad.$fGhcMonadGhc_closure;   // CmmAssign
          R1 = GhcMonad.getSessionDynFlags_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefh_info)+320
	.long	0
	.quad	0
	.quad	1103806595088
sat_sefh_info:
_cern:
	movq %rbx,%vI_sefh
	leaq -16(%rbp),%vI_neuB
	cmpq %r15,%vI_neuB
	jb _cero
	jmp _cerp
_cero:
	movq %vI_sefh,%rbx
	jmp *-16(%r13)
_cerp:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefh,-8(%rbp)
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMonad.getSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefh_info, .-sat_sefh_info



==================== Liveness annotations added ====================
sat_sefh_entry() //  [R1]
        { [(cern,
            sat_sefh_info:
                const SehZ_srt-sat_sefh_info+320;
                const 0;
                const 1103806595088;)]
          # entryIds         = [cern]
          # liveVRegsOnEntry = Just [(cern, [R1 :-> %r1]),
                                     (cero, [sefh :-> %vI_sefh]), (cerp, [sefh :-> %vI_sefh])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cern:
            	movq %rbx,%vI_sefh
                    # born:    %vI_sefh
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neuB
                    # born:    %vI_neuB
                     
            	cmpq %r15,%vI_neuB
                    # r_dying: %vI_neuB
                     
            	jb _cero
                     
            	jmp _cerp
                    # r_dying: %vI_sefh
                     ,
     NONREC
        cero:
            	movq %vI_sefh,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefh
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cerp:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefh,-8(%rbp)
                    # r_dying: %vI_sefh
                     
            	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movl $GhcMonad.getSessionDynFlags_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefh_info)+320
	.long	0
	.quad	0
	.quad	1103806595088
sat_sefh_info:
_cern:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cero
	jmp _cerp
_cero:
	jmp *-16(%r13)
_cerp:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMonad.getSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
	.size sat_sefh_info, .-sat_sefh_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefh_info)+320
	.long	0
	.quad	0
	.quad	1103806595088
sat_sefh_info:
_cern:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cero
_cerp:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMonad.getSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cero:
	jmp *-16(%r13)
	.size sat_sefh_info, .-sat_sefh_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefh_info)+320
	.long	0
	.quad	0
	.quad	1103806595088
sat_sefh_info:
_cern:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cero
_cerp:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $GhcMonad.$fGhcMonadGhc_closure,%r14d
	movl $GhcMonad.getSessionDynFlags_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cero:
	jmp *-16(%r13)
	.size sat_sefh_info, .-sat_sefh_info



==================== Optimised Cmm ====================
sat_sefM_entry() //  [R1]
        { [(cerq,
            sat_sefM_info:
                const SehZ_srt-sat_sefM_info+280;
                const 1;
                const 70364449210385;)]
        }
    {offset
      cerq:
          _sefM::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto cerr; else goto cers;   // CmmCondBranch
      cers:
          Hp = Hp + 32;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto ceru; else goto cert;   // CmmCondBranch
      ceru:
          I64[BaseReg + 904] = 32;   // CmmStore
          goto cerr;   // CmmBranch
      cerr:
          R1 = _sefM::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cert:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefM::P64;   // CmmStore
          _seeY::P64 = P64[_sefM::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefL_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceot::P64 = Hp - 23;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_sefh_info;   // CmmStore
          _cerj::P64 = Hp - 8;   // CmmAssign
          R2 = GhcMonad.$fMonadGhc_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cerj::P64;   // CmmStore
          P64[Sp - 24] = _ceot::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefM_info)+280
	.long	0
	.quad	1
	.quad	70364449210385
sat_sefM_info:
_cerq:
	movq %rbx,%vI_sefM
	leaq -40(%rbp),%vI_neuE
	cmpq %r15,%vI_neuE
	jb _cerr
	jmp _cers
_cerr:
	movq %vI_sefM,%rbx
	jmp *-16(%r13)
_cers:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _ceru
	jmp _cert
_cert:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefM,-8(%rbp)
	movq 16(%vI_sefM),%vI_seeY
	movq $sat_sefL_info,-24(%r12)
	movq %vI_seeY,-16(%r12)
	leaq -23(%r12),%vI_ceot
	movq $sat_sefh_info,-8(%r12)
	leaq -8(%r12),%vI_cerj
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_cerj,-32(%rbp)
	movq %vI_ceot,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceru:
	movq $32,904(%r13)
	jmp _cerr
	.size sat_sefM_info, .-sat_sefM_info



==================== Liveness annotations added ====================
sat_sefM_entry() //  [R1]
        { [(cerq,
            sat_sefM_info:
                const SehZ_srt-sat_sefM_info+280;
                const 1;
                const 70364449210385;)]
          # entryIds         = [cerq]
          # liveVRegsOnEntry = Just [(cerq, [R1 :-> %r1]),
                                     (cerr, [sefM :-> %vI_sefM]), (cers, [sefM :-> %vI_sefM]),
                                     (cert, [sefM :-> %vI_sefM]), (ceru, [sefM :-> %vI_sefM])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cerq:
            	movq %rbx,%vI_sefM
                    # born:    %vI_sefM
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_neuE
                    # born:    %vI_neuE
                     
            	cmpq %r15,%vI_neuE
                    # r_dying: %vI_neuE
                     
            	jb _cerr
                     
            	jmp _cers
                    # r_dying: %vI_sefM
                     ,
     NONREC
        cers:
            	addq $32,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _ceru
                     
            	jmp _cert
                    # r_dying: %vI_sefM
                     ,
     NONREC
        ceru:
            	movq $32,904(%r13)
                     
            	jmp _cerr
                    # r_dying: %vI_sefM
                     ,
     NONREC
        cerr:
            	movq %vI_sefM,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefM
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cert:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefM,-8(%rbp)
                     
            	movq 16(%vI_sefM),%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %vI_sefM
                     
            	movq $sat_sefL_info,-24(%r12)
                     
            	movq %vI_seeY,-16(%r12)
                    # r_dying: %vI_seeY
                     
            	leaq -23(%r12),%vI_ceot
                    # born:    %vI_ceot
                     
            	movq $sat_sefh_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cerj
                    # born:    %vI_cerj
                     
            	movl $GhcMonad.$fMonadGhc_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_cerj,-32(%rbp)
                    # r_dying: %vI_cerj
                     
            	movq %vI_ceot,-24(%rbp)
                    # r_dying: %vI_ceot
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefM_info)+280
	.long	0
	.quad	1
	.quad	70364449210385
sat_sefM_info:
_cerq:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cerr
	jmp _cers
_cers:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _ceru
	jmp _cert
_ceru:
	movq $32,904(%r13)
	jmp _cerr
_cerr:
	jmp *-16(%r13)
_cert:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefL_info,-24(%r12)
	movq %rax,-16(%r12)
	leaq -23(%r12),%rax
	movq $sat_sefh_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
	.size sat_sefM_info, .-sat_sefM_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefM_info)+280
	.long	0
	.quad	1
	.quad	70364449210385
sat_sefM_info:
_cerq:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cerr
_cers:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _ceru
_cert:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefL_info,-24(%r12)
	movq %rax,-16(%r12)
	leaq -23(%r12),%rax
	movq $sat_sefh_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceru:
	movq $32,904(%r13)
_cerr:
	jmp *-16(%r13)
	.size sat_sefM_info, .-sat_sefM_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefM_info)+280
	.long	0
	.quad	1
	.quad	70364449210385
sat_sefM_info:
_cerq:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cerr
_cers:
	addq $32,%r12
	cmpq 856(%r13),%r12
	ja _ceru
_cert:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_sefL_info,-24(%r12)
	movq %rax,-16(%r12)
	leaq -23(%r12),%rax
	movq $sat_sefh_info,-8(%r12)
	leaq -8(%r12),%rbx
	movl $GhcMonad.$fMonadGhc_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rbx,-32(%rbp)
	movq %rax,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_ceru:
	movq $32,904(%r13)
_cerr:
	jmp *-16(%r13)
	.size sat_sefM_info, .-sat_sefM_info



==================== Optimised Cmm ====================
sat_sefN_entry() //  [R1]
        { [(cerw,
            sat_sefN_info:
                const SehZ_srt-sat_sefN_info+280;
                const 2;
                const 140733193388051;)]
        }
    {offset
      cerw:
          _sefN::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cerx; else goto cery;   // CmmCondBranch
      cery:
          Hp = Hp + 40;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cerA; else goto cerz;   // CmmCondBranch
      cerA:
          I64[BaseReg + 904] = 40;   // CmmStore
          goto cerx;   // CmmBranch
      cerx:
          R1 = _sefN::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerz:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _sefN::P64;   // CmmStore
          _seeX::P64 = P64[_sefN::P64 + 16];   // CmmAssign
          _seeY::P64 = P64[_sefN::P64 + 24];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 32] = sat_sefM_info;   // CmmStore
          P64[Hp - 16] = _seeY::P64;   // CmmStore
          _ceop::P64 = Hp - 32;   // CmmAssign
          I64[Hp - 8] = GHC.Base.Just_con_info;   // CmmStore
          P64[Hp] = _seeX::P64;   // CmmStore
          _cerv::P64 = Hp - 6;   // CmmAssign
          R3 = _ceop::P64;   // CmmAssign
          R2 = _cerv::P64;   // CmmAssign
          R1 = GHC.runGhc_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_pp_fast(R3,
                              R2,
                              R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefN_info)+280
	.long	0
	.quad	2
	.quad	140733193388051
sat_sefN_info:
_cerw:
	movq %rbx,%vI_sefN
	leaq -16(%rbp),%vI_neuH
	cmpq %r15,%vI_neuH
	jb _cerx
	jmp _cery
_cerx:
	movq %vI_sefN,%rbx
	jmp *-16(%r13)
_cery:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cerA
	jmp _cerz
_cerz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_sefN,-8(%rbp)
	movq 16(%vI_sefN),%vI_seeX
	movq 24(%vI_sefN),%vI_seeY
	movq $sat_sefM_info,-32(%r12)
	movq %vI_seeY,-16(%r12)
	leaq -32(%r12),%vI_ceop
	movq $GHC.Base.Just_con_info,-8(%r12)
	movq %vI_seeX,(%r12)
	leaq -6(%r12),%vI_cerv
	movq %vI_ceop,%rsi
	movq %vI_cerv,%r14
	movl $GHC.runGhc_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cerA:
	movq $40,904(%r13)
	jmp _cerx
	.size sat_sefN_info, .-sat_sefN_info



==================== Liveness annotations added ====================
sat_sefN_entry() //  [R1]
        { [(cerw,
            sat_sefN_info:
                const SehZ_srt-sat_sefN_info+280;
                const 2;
                const 140733193388051;)]
          # entryIds         = [cerw]
          # liveVRegsOnEntry = Just [(cerw, [R1 :-> %r1]),
                                     (cerx, [sefN :-> %vI_sefN]), (cery, [sefN :-> %vI_sefN]),
                                     (cerz, [sefN :-> %vI_sefN]), (cerA, [sefN :-> %vI_sefN])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cerw:
            	movq %rbx,%vI_sefN
                    # born:    %vI_sefN
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_neuH
                    # born:    %vI_neuH
                     
            	cmpq %r15,%vI_neuH
                    # r_dying: %vI_neuH
                     
            	jb _cerx
                     
            	jmp _cery
                    # r_dying: %vI_sefN
                     ,
     NONREC
        cery:
            	addq $40,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cerA
                     
            	jmp _cerz
                    # r_dying: %vI_sefN
                     ,
     NONREC
        cerA:
            	movq $40,904(%r13)
                     
            	jmp _cerx
                    # r_dying: %vI_sefN
                     ,
     NONREC
        cerx:
            	movq %vI_sefN,%rbx
                    # born:    %r1
                    # r_dying: %vI_sefN
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cerz:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_sefN,-8(%rbp)
                     
            	movq 16(%vI_sefN),%vI_seeX
                    # born:    %vI_seeX
                     
            	movq 24(%vI_sefN),%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %vI_sefN
                     
            	movq $sat_sefM_info,-32(%r12)
                     
            	movq %vI_seeY,-16(%r12)
                    # r_dying: %vI_seeY
                     
            	leaq -32(%r12),%vI_ceop
                    # born:    %vI_ceop
                     
            	movq $GHC.Base.Just_con_info,-8(%r12)
                     
            	movq %vI_seeX,(%r12)
                    # r_dying: %vI_seeX
                     
            	leaq -6(%r12),%vI_cerv
                    # born:    %vI_cerv
                     
            	movq %vI_ceop,%rsi
                    # born:    %r4
                    # r_dying: %vI_ceop
                     
            	movq %vI_cerv,%r14
                    # born:    %r14
                    # r_dying: %vI_cerv
                     
            	movl $GHC.runGhc_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_pp_fast
                    # r_dying: %r1 %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefN_info)+280
	.long	0
	.quad	2
	.quad	140733193388051
sat_sefN_info:
_cerw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerx
	jmp _cery
_cery:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cerA
	jmp _cerz
_cerA:
	movq $40,904(%r13)
	jmp _cerx
_cerx:
	jmp *-16(%r13)
_cerz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefM_info,-32(%r12)
	movq %rbx,-16(%r12)
	leaq -32(%r12),%rbx
	movq $GHC.Base.Just_con_info,-8(%r12)
	movq %rax,(%r12)
	leaq -6(%r12),%rax
	movq %rbx,%rsi
	movq %rax,%r14
	movl $GHC.runGhc_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
	.size sat_sefN_info, .-sat_sefN_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefN_info)+280
	.long	0
	.quad	2
	.quad	140733193388051
sat_sefN_info:
_cerw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerx
_cery:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cerA
_cerz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefM_info,-32(%r12)
	movq %rbx,-16(%r12)
	leaq -32(%r12),%rbx
	movq $GHC.Base.Just_con_info,-8(%r12)
	movq %rax,(%r12)
	leaq -6(%r12),%rax
	movq %rbx,%rsi
	movq %rax,%r14
	movl $GHC.runGhc_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cerA:
	movq $40,904(%r13)
_cerx:
	jmp *-16(%r13)
	.size sat_sefN_info, .-sat_sefN_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_sefN_info)+280
	.long	0
	.quad	2
	.quad	140733193388051
sat_sefN_info:
_cerw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cerx
_cery:
	addq $40,%r12
	cmpq 856(%r13),%r12
	ja _cerA
_cerz:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq 24(%rbx),%rbx
	movq $sat_sefM_info,-32(%r12)
	movq %rbx,-16(%r12)
	leaq -32(%r12),%rbx
	movq $GHC.Base.Just_con_info,-8(%r12)
	movq %rax,(%r12)
	leaq -6(%r12),%rax
	movq %rbx,%rsi
	movq %rax,%r14
	movl $GHC.runGhc_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_pp_fast
_cerA:
	movq $40,904(%r13)
_cerx:
	jmp *-16(%r13)
	.size sat_sefN_info, .-sat_sefN_info



==================== Optimised Cmm ====================
section ""relreadonly" . uerJ_srtd" {
    uerJ_srtd:
        const SehZ_srt;
        const 52;
        const 4503599627370445;
}



==================== Native code ====================
.section .data.rel.ro
.align 8
.align 1
uerJ_srtd:
	.quad	SehZ_srt
	.quad	52
	.quad	4503599627370445



==================== Liveness annotations added ====================
section ""relreadonly" . uerJ_srtd" {
    (1,
     uerJ_srtd:
         const SehZ_srt;
         const 52;
         const 4503599627370445;)
}



==================== Registers allocated ====================
.section .data.rel.ro
.align 8
.align 1
uerJ_srtd:
	.quad	SehZ_srt
	.quad	52
	.quad	4503599627370445



==================== Synthetic instructions expanded ====================
.section .data.rel.ro
.align 8
.align 1
uerJ_srtd:
	.quad	SehZ_srt
	.quad	52
	.quad	4503599627370445



==================== Asm code ====================
.section .data.rel.ro
.align 8
.align 1
uerJ_srtd:
	.quad	SehZ_srt
	.quad	52
	.quad	4503599627370445



==================== Optimised Cmm ====================
Main.testOneFile_entry() //  [R3, R2]
        { [(cerB,
            Main.testOneFile_info:
                const uerJ_srtd-Main.testOneFile_info;
                const 8589934607;
                const 0;
                const 18446744069414584335;)]
        }
    {offset
      cerB:
          _seeY::P64 = R3;   // CmmAssign
          _seeX::P64 = R2;   // CmmAssign
          if ((Sp + -24) < SpLim) goto cerC; else goto cerD;   // CmmCondBranch
      cerD:
          Hp = Hp + 64;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cerF; else goto cerE;   // CmmCondBranch
      cerF:
          I64[BaseReg + 904] = 64;   // CmmStore
          goto cerC;   // CmmBranch
      cerC:
          R3 = _seeY::P64;   // CmmAssign
          R2 = _seeX::P64;   // CmmAssign
          R1 = Main.testOneFile_closure;   // CmmAssign
          call (I64[BaseReg - 8])(R3,
                                  R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cerE:
          // calling allocDynClosure
          I64[Hp - 56] = gq_seeZ_info;   // CmmStore
          _ceiW::P64 = Hp - 54;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segp_info;   // CmmStore
          P64[Hp - 32] = _ceiW::P64;   // CmmStore
          _cekl::P64 = Hp - 39;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 24] = sat_sefN_info;   // CmmStore
          P64[Hp - 8] = _seeX::P64;   // CmmStore
          P64[Hp] = _seeY::P64;   // CmmStore
          _ceol::P64 = Hp - 24;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 24] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 16] = _ceol::P64;   // CmmStore
          P64[Sp - 8] = _cekl::P64;   // CmmStore
          Sp = Sp - 24;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	uerJ_srtd-(Main.testOneFile_info)+0
	.long	0
	.quad	8589934607
	.quad	0
	.quad	-4294967281
.globl Main.testOneFile_info
.type Main.testOneFile_info, @object
Main.testOneFile_info:
_cerB:
	movq %rsi,%vI_seeY
	movq %r14,%vI_seeX
	leaq -24(%rbp),%vI_neuL
	cmpq %r15,%vI_neuL
	jb _cerC
	jmp _cerD
_cerC:
	movq %vI_seeY,%rsi
	movq %vI_seeX,%r14
	movl $Main.testOneFile_closure,%ebx
	jmp *-8(%r13)
_cerD:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cerF
	jmp _cerE
_cerE:
	movq $gq_seeZ_info,-56(%r12)
	leaq -54(%r12),%vI_ceiW
	movq $sat_segp_info,-40(%r12)
	movq %vI_ceiW,-32(%r12)
	leaq -39(%r12),%vI_cekl
	movq $sat_sefN_info,-24(%r12)
	movq %vI_seeX,-8(%r12)
	movq %vI_seeY,(%r12)
	leaq -24(%r12),%vI_ceol
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %vI_ceol,-16(%rbp)
	movq %vI_cekl,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cerF:
	movq $64,904(%r13)
	jmp _cerC
	.size Main.testOneFile_info, .-Main.testOneFile_info



==================== Liveness annotations added ====================
Main.testOneFile_entry() //  [R3, R2]
        { [(cerB,
            Main.testOneFile_info:
                const uerJ_srtd-Main.testOneFile_info;
                const 8589934607;
                const 0;
                const 18446744069414584335;)]
          # entryIds         = [cerB]
          # liveVRegsOnEntry = Just [(cerB, [R4 :-> %r4, Re :-> %r14]),
                                     (cerC, [seeX :-> %vI_seeX, seeY :-> %vI_seeY]),
                                     (cerD, [seeX :-> %vI_seeX, seeY :-> %vI_seeY]),
                                     (cerE, [seeX :-> %vI_seeX, seeY :-> %vI_seeY]),
                                     (cerF, [seeX :-> %vI_seeX, seeY :-> %vI_seeY])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cerB:
            	movq %rsi,%vI_seeY
                    # born:    %vI_seeY
                    # r_dying: %r4
                     
            	movq %r14,%vI_seeX
                    # born:    %vI_seeX
                    # r_dying: %r14
                     
            	leaq -24(%rbp),%vI_neuL
                    # born:    %vI_neuL
                     
            	cmpq %r15,%vI_neuL
                    # r_dying: %vI_neuL
                     
            	jb _cerC
                     
            	jmp _cerD
                    # r_dying: %vI_seeX %vI_seeY
                     ,
     NONREC
        cerD:
            	addq $64,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cerF
                     
            	jmp _cerE
                    # r_dying: %vI_seeX %vI_seeY
                     ,
     NONREC
        cerF:
            	movq $64,904(%r13)
                     
            	jmp _cerC
                    # r_dying: %vI_seeX %vI_seeY
                     ,
     NONREC
        cerC:
            	movq %vI_seeY,%rsi
                    # born:    %r4
                    # r_dying: %vI_seeY
                     
            	movq %vI_seeX,%r14
                    # born:    %r14
                    # r_dying: %vI_seeX
                     
            	movl $Main.testOneFile_closure,%ebx
                    # born:    %r1
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r4 %r14
                     ,
     NONREC
        cerE:
            	movq $gq_seeZ_info,-56(%r12)
                     
            	leaq -54(%r12),%vI_ceiW
                    # born:    %vI_ceiW
                     
            	movq $sat_segp_info,-40(%r12)
                     
            	movq %vI_ceiW,-32(%r12)
                    # r_dying: %vI_ceiW
                     
            	leaq -39(%r12),%vI_cekl
                    # born:    %vI_cekl
                     
            	movq $sat_sefN_info,-24(%r12)
                     
            	movq %vI_seeX,-8(%r12)
                    # r_dying: %vI_seeX
                     
            	movq %vI_seeY,(%r12)
                    # r_dying: %vI_seeY
                     
            	leaq -24(%r12),%vI_ceol
                    # born:    %vI_ceol
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-24(%rbp)
                     
            	movq %vI_ceol,-16(%rbp)
                    # r_dying: %vI_ceol
                     
            	movq %vI_cekl,-8(%rbp)
                    # r_dying: %vI_cekl
                     
            	addq $-24,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	uerJ_srtd-(Main.testOneFile_info)+0
	.long	0
	.quad	8589934607
	.quad	0
	.quad	-4294967281
.globl Main.testOneFile_info
.type Main.testOneFile_info, @object
Main.testOneFile_info:
_cerB:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerC
	jmp _cerD
_cerD:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cerF
	jmp _cerE
_cerF:
	movq $64,904(%r13)
	jmp _cerC
_cerC:
	movl $Main.testOneFile_closure,%ebx
	jmp *-8(%r13)
_cerE:
	movq $gq_seeZ_info,-56(%r12)
	leaq -54(%r12),%rax
	movq $sat_segp_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $sat_sefN_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rbx
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
	.size Main.testOneFile_info, .-Main.testOneFile_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	uerJ_srtd-(Main.testOneFile_info)+0
	.long	0
	.quad	8589934607
	.quad	0
	.quad	-4294967281
.globl Main.testOneFile_info
.type Main.testOneFile_info, @object
Main.testOneFile_info:
_cerB:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerC
_cerD:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cerF
_cerE:
	movq $gq_seeZ_info,-56(%r12)
	leaq -54(%r12),%rax
	movq $sat_segp_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $sat_sefN_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rbx
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cerF:
	movq $64,904(%r13)
_cerC:
	movl $Main.testOneFile_closure,%ebx
	jmp *-8(%r13)
	.size Main.testOneFile_info, .-Main.testOneFile_info



==================== Asm code ====================
.section .text
.align 8
	.long	uerJ_srtd-(Main.testOneFile_info)+0
	.long	0
	.quad	8589934607
	.quad	0
	.quad	-4294967281
.globl Main.testOneFile_info
.type Main.testOneFile_info, @object
Main.testOneFile_info:
_cerB:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cerC
_cerD:
	addq $64,%r12
	cmpq 856(%r13),%r12
	ja _cerF
_cerE:
	movq $gq_seeZ_info,-56(%r12)
	leaq -54(%r12),%rax
	movq $sat_segp_info,-40(%r12)
	movq %rax,-32(%r12)
	leaq -39(%r12),%rax
	movq $sat_sefN_info,-24(%r12)
	movq %r14,-8(%r12)
	movq %rsi,(%r12)
	leaq -24(%r12),%rbx
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-24(%rbp)
	movq %rbx,-16(%rbp)
	movq %rax,-8(%rbp)
	addq $-24,%rbp
	jmp GHC.Base.>>=_info
_cerF:
	movq $64,904(%r13)
_cerC:
	movl $Main.testOneFile_closure,%ebx
	jmp *-8(%r13)
	.size Main.testOneFile_info, .-Main.testOneFile_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . sat_segK_closure" {
     sat_segK_closure:
         const sat_segK_info;
         const 0;
 },
 section ""readonly" . cev0_str" {
     cev0_str:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54]
 },
 sat_segt_entry() //  [R1]
         { info_tbl: [(cev1,
                       label: sat_segt_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cev1:
           _segt::P64 = R1;   // CmmAssign
           goto ceuY;   // CmmBranch
       ceuY:
           if ((old + 0) - <highSp> < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
       cev2:
           R1 = _segt::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cev3:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segt::P64;   // CmmStore
           R2 = cev0_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevv_str" {
     cevv_str:
         I8[] [77,105,110,101,84,121,112,101]
 },
 sat_segE_entry() //  [R1]
         { info_tbl: [(cevw,
                       label: sat_segE_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevw:
           _segE::P64 = R1;   // CmmAssign
           goto cevt;   // CmmBranch
       cevt:
           if ((old + 0) - <highSp> < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
       cevx:
           R1 = _segE::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevy:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segE::P64;   // CmmStore
           R2 = cevv_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segF_entry() //  [R1]
         { info_tbl: [(cevz,
                       label: sat_segF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevz:
           _segF::P64 = R1;   // CmmAssign
           goto cevp;   // CmmBranch
       cevp:
           if ((old + 0) - <highSp> < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
       cevB:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
       cevD:
           HpAlloc = 16;   // CmmAssign
           goto cevA;   // CmmBranch
       cevA:
           R1 = _segF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevC:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segF::P64;   // CmmStore
           _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segE_info;   // CmmStore
           _cevr::P64 = Hp - 8;   // CmmAssign
           R3 = _cevr::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevM_str" {
     cevM_str:
         I8[] [77,105,110,101,78,97,109,101,115]
 },
 sat_segC_entry() //  [R1]
         { info_tbl: [(cevN,
                       label: sat_segC_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevN:
           _segC::P64 = R1;   // CmmAssign
           goto cevK;   // CmmBranch
       cevK:
           if ((old + 0) - <highSp> < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
       cevO:
           R1 = _segC::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevP:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segC::P64;   // CmmStore
           R2 = cevM_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segD_entry() //  [R1]
         { info_tbl: [(cevQ,
                       label: sat_segD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevQ:
           _segD::P64 = R1;   // CmmAssign
           goto cevG;   // CmmBranch
       cevG:
           if ((old + 0) - <highSp> < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
       cevS:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
       cevU:
           HpAlloc = 16;   // CmmAssign
           goto cevR;   // CmmBranch
       cevR:
           R1 = _segD::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevT:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segD::P64;   // CmmStore
           _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segC_info;   // CmmStore
           _cevI::P64 = Hp - 8;   // CmmAssign
           R3 = _cevI::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segG_entry() //  [R1]
         { info_tbl: [(cevV,
                       label: sat_segG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevV:
           _segG::P64 = R1;   // CmmAssign
           goto cevl;   // CmmBranch
       cevl:
           if ((old + 0) - <highSp> < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
       cevX:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
       cevZ:
           HpAlloc = 48;   // CmmAssign
           goto cevW;   // CmmBranch
       cevW:
           R1 = _segG::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevY:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segG::P64;   // CmmStore
           _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segF_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevn::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segD_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cevE::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _cevE::P64;   // CmmStore
           P64[(old + 32)] = _cevn::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cew8_str" {
     cew8_str:
         I8[] [77,105,110,101,75,105,110,100]
 },
 sat_segA_entry() //  [R1]
         { info_tbl: [(cew9,
                       label: sat_segA_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cew9:
           _segA::P64 = R1;   // CmmAssign
           goto cew6;   // CmmBranch
       cew6:
           if ((old + 0) - <highSp> < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
       cewa:
           R1 = _segA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewb:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segA::P64;   // CmmStore
           R2 = cew8_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segB_entry() //  [R1]
         { info_tbl: [(cewc,
                       label: sat_segB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewc:
           _segB::P64 = R1;   // CmmAssign
           goto cew2;   // CmmBranch
       cew2:
           if ((old + 0) - <highSp> < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
       cewe:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
       cewg:
           HpAlloc = 16;   // CmmAssign
           goto cewd;   // CmmBranch
       cewd:
           R1 = _segB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewf:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segB::P64;   // CmmStore
           _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segA_info;   // CmmStore
           _cew4::P64 = Hp - 8;   // CmmAssign
           R3 = _cew4::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segH_entry() //  [R1]
         { info_tbl: [(cewh,
                       label: sat_segH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewh:
           _segH::P64 = R1;   // CmmAssign
           goto cevh;   // CmmBranch
       cevh:
           if ((old + 0) - <highSp> < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
       cewj:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
       cewl:
           HpAlloc = 48;   // CmmAssign
           goto cewi;   // CmmBranch
       cewi:
           R1 = _segH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewk:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segH::P64;   // CmmStore
           _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segG_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevj::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segB_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cew0::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = _cew0::P64;   // CmmStore
           P64[(old + 32)] = _cevj::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cewu_str" {
     cewu_str:
         I8[] [77,105,110,101,70,105,120,105,116,121]
 },
 sat_segy_entry() //  [R1]
         { info_tbl: [(cewv,
                       label: sat_segy_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewv:
           _segy::P64 = R1;   // CmmAssign
           goto cews;   // CmmBranch
       cews:
           if ((old + 0) - <highSp> < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
       ceww:
           R1 = _segy::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewx:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segy::P64;   // CmmStore
           R2 = cewu_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segz_entry() //  [R1]
         { info_tbl: [(cewy,
                       label: sat_segz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewy:
           _segz::P64 = R1;   // CmmAssign
           goto cewo;   // CmmBranch
       cewo:
           if ((old + 0) - <highSp> < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
       cewA:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
       cewC:
           HpAlloc = 16;   // CmmAssign
           goto cewz;   // CmmBranch
       cewz:
           R1 = _segz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewB:
           I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
           P64[(old + 16)] = _segz::P64;   // CmmStore
           _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segy_info;   // CmmStore
           _cewq::P64 = Hp - 8;   // CmmAssign
           R3 = _cewq::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segK_entry() //  [R2]
         { info_tbl: [(cewH,
                       label: sat_segK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewH:
           _segq::P64 = R2;   // CmmAssign
           goto ceuP;   // CmmBranch
       ceuP:
           if ((old + 0) - <highSp> < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
       cewI:
           R2 = _segq::P64;   // CmmAssign
           R1 = sat_segK_closure;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewJ:
           goto ceuO;   // CmmBranch
       ceuO:
           I64[(young<cev4> + 8)] = cev4;   // CmmStore
           R1 = _segq::P64;   // CmmAssign
           if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
       cev5:
           call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
       cev4:
           _segu::P64 = R1;   // CmmAssign
           _cewG::P64 = _segu::P64 & 7;   // CmmAssign
           switch [1 .. 2] _cewG::P64 {
               case 1 : goto cewE;
               case 2 : goto cewF;
           }   // CmmSwitch
       cewF:
           _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
           _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
           I64[(young<ceva> + 8)] = ceva;   // CmmStore
           R1 = _segw::P64;   // CmmAssign
           if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
       cevb:
           call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       ceva:
           _segx::P64 = R1;   // CmmAssign
           _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
           switch [1 .. 2] _cewZ::P64 {
               case 1 : goto cewR;
               case 2 : goto cewY;
           }   // CmmSwitch
       cewY:
           _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
           _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
           goto segr;   // CmmBranch
       cewR:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
       cewU:
           HpAlloc = 48;   // CmmAssign
           goto cewS;   // CmmBranch
       cewS:
           R1 = _segx::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       cewT:
           // calling allocDynClosure
           I64[Hp - 40] = sat_segH_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevf::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segz_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cewm::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 24)] = _cewm::P64;   // CmmStore
           P64[(old + 16)] = _cevf::P64;   // CmmStore
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
       cewE:
           goto segr;   // CmmBranch
       segr:
           goto ceuU;   // CmmBranch
       ceuU:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
       cewM:
           HpAlloc = 16;   // CmmAssign
           goto cewK;   // CmmBranch
       cewK:
           I64[(young<ceuT> + 8)] = ceuT;   // CmmStore
           call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
       ceuT:
           goto ceuU;   // CmmBranch
       cewL:
           // calling allocDynClosure
           I64[Hp - 8] = sat_segt_info;   // CmmStore
           _ceuW::P64 = Hp - 8;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 24)] = stg_ap_p_info;   // CmmStore
           P64[(old + 16)] = _ceuW::P64;   // CmmStore
           call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cev1:
      _segt::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
  cev2:
      R1 = _segt::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cev3:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segt::P64;   // CmmStore
      R2 = cev0_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cev1:
      _segt::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
  cev2:
      R1 = _segt::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cev3:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segt::P64;   // CmmStore
      R2 = cev0_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cev1:
      _segt::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
  cev2:
      R1 = _segt::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cev3:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segt::P64;   // CmmStore
      R2 = cev0_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cev1, {GHC.CString.unpackCString#_closure}), (cev2, {}),
 (cev3, {GHC.CString.unpackCString#_closure})]



==================== after setInfoTableStackMap ====================
sat_segt_entry() //  [R1]
        { info_tbl: [(cev1,
                      label: sat_segt_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cev1:
          _segt::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
      cev2:
          R1 = _segt::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cev3:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segt::P64;   // CmmStore
          R2 = cev0_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segt_entry() //  [R1]
        { info_tbl: [(cev1,
                      label: sat_segt_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cev1:
          _segt::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
      cev2:
          R1 = _segt::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cev3:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segt::P64;   // CmmStore
          R2 = cev0_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cevw:
      _segE::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
  cevx:
      R1 = _segE::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevy:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segE::P64;   // CmmStore
      R2 = cevv_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cevw:
      _segE::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
  cevx:
      R1 = _segE::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevy:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segE::P64;   // CmmStore
      R2 = cevv_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cevw:
      _segE::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
  cevx:
      R1 = _segE::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevy:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segE::P64;   // CmmStore
      R2 = cevv_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cevw, {GHC.CString.unpackCString#_closure}), (cevx, {}),
 (cevy, {GHC.CString.unpackCString#_closure})]



==================== after setInfoTableStackMap ====================
sat_segE_entry() //  [R1]
        { info_tbl: [(cevw,
                      label: sat_segE_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevw:
          _segE::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
      cevx:
          R1 = _segE::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segE::P64;   // CmmStore
          R2 = cevv_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segE_entry() //  [R1]
        { info_tbl: [(cevw,
                      label: sat_segE_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevw:
          _segE::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
      cevx:
          R1 = _segE::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segE::P64;   // CmmStore
          R2 = cevv_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cevz:
      _segF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
  cevB:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
  cevD:
      HpAlloc = 16;   // CmmAssign
      goto cevA;   // CmmBranch
  cevA:
      R1 = _segF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevC:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segF::P64;   // CmmStore
      _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segE_info;   // CmmStore
      _cevr::P64 = Hp - 8;   // CmmAssign
      R3 = _cevr::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cevz:
      _segF::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
  cevB:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
  cevD:
      HpAlloc = 16;   // CmmAssign
      goto cevA;   // CmmBranch
  cevA:
      R1 = _segF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevC:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segF::P64;   // CmmStore
      _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segE_info;   // CmmStore
      _cevr::P64 = Hp - 8;   // CmmAssign
      R3 = _cevr::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cevz:
      _segF::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
  cevB:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
  cevD:
      HpAlloc = 16;   // CmmAssign
      goto cevA;   // CmmBranch
  cevA:
      R1 = _segF::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevC:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segF::P64;   // CmmStore
      _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segE_info;   // CmmStore
      _cevr::P64 = Hp - 8;   // CmmAssign
      R3 = _cevr::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cevz, {Main.testOneFile_closure, sat_segE_closure}), (cevA, {}),
 (cevB, {Main.testOneFile_closure, sat_segE_closure}),
 (cevC, {Main.testOneFile_closure, sat_segE_closure}), (cevD, {})]



==================== after setInfoTableStackMap ====================
sat_segF_entry() //  [R1]
        { info_tbl: [(cevz,
                      label: sat_segF_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevz:
          _segF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
      cevB:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
      cevD:
          HpAlloc = 16;   // CmmAssign
          goto cevA;   // CmmBranch
      cevA:
          R1 = _segF::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevC:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segF::P64;   // CmmStore
          _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segE_info;   // CmmStore
          _cevr::P64 = Hp - 8;   // CmmAssign
          R3 = _cevr::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segF_entry() //  [R1]
        { info_tbl: [(cevz,
                      label: sat_segF_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevz:
          _segF::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
      cevB:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
      cevD:
          HpAlloc = 16;   // CmmAssign
          goto cevA;   // CmmBranch
      cevA:
          R1 = _segF::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevC:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segF::P64;   // CmmStore
          _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segE_info;   // CmmStore
          _cevr::P64 = Hp - 8;   // CmmAssign
          R3 = _cevr::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cevN:
      _segC::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
  cevO:
      R1 = _segC::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevP:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segC::P64;   // CmmStore
      R2 = cevM_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cevN:
      _segC::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
  cevO:
      R1 = _segC::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevP:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segC::P64;   // CmmStore
      R2 = cevM_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cevN:
      _segC::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
  cevO:
      R1 = _segC::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevP:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segC::P64;   // CmmStore
      R2 = cevM_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cevN, {GHC.CString.unpackCString#_closure}), (cevO, {}),
 (cevP, {GHC.CString.unpackCString#_closure})]



==================== after setInfoTableStackMap ====================
sat_segC_entry() //  [R1]
        { info_tbl: [(cevN,
                      label: sat_segC_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevN:
          _segC::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
      cevO:
          R1 = _segC::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segC::P64;   // CmmStore
          R2 = cevM_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segC_entry() //  [R1]
        { info_tbl: [(cevN,
                      label: sat_segC_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevN:
          _segC::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
      cevO:
          R1 = _segC::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segC::P64;   // CmmStore
          R2 = cevM_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cevQ:
      _segD::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
  cevS:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
  cevU:
      HpAlloc = 16;   // CmmAssign
      goto cevR;   // CmmBranch
  cevR:
      R1 = _segD::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevT:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segD::P64;   // CmmStore
      _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segC_info;   // CmmStore
      _cevI::P64 = Hp - 8;   // CmmAssign
      R3 = _cevI::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cevQ:
      _segD::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
  cevS:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
  cevU:
      HpAlloc = 16;   // CmmAssign
      goto cevR;   // CmmBranch
  cevR:
      R1 = _segD::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevT:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segD::P64;   // CmmStore
      _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segC_info;   // CmmStore
      _cevI::P64 = Hp - 8;   // CmmAssign
      R3 = _cevI::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cevQ:
      _segD::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
  cevS:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
  cevU:
      HpAlloc = 16;   // CmmAssign
      goto cevR;   // CmmBranch
  cevR:
      R1 = _segD::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevT:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segD::P64;   // CmmStore
      _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segC_info;   // CmmStore
      _cevI::P64 = Hp - 8;   // CmmAssign
      R3 = _cevI::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cevQ, {Main.testOneFile_closure, sat_segC_closure}), (cevR, {}),
 (cevS, {Main.testOneFile_closure, sat_segC_closure}),
 (cevT, {Main.testOneFile_closure, sat_segC_closure}), (cevU, {})]



==================== after setInfoTableStackMap ====================
sat_segD_entry() //  [R1]
        { info_tbl: [(cevQ,
                      label: sat_segD_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevQ:
          _segD::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
      cevS:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
      cevU:
          HpAlloc = 16;   // CmmAssign
          goto cevR;   // CmmBranch
      cevR:
          R1 = _segD::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segD::P64;   // CmmStore
          _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segC_info;   // CmmStore
          _cevI::P64 = Hp - 8;   // CmmAssign
          R3 = _cevI::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segD_entry() //  [R1]
        { info_tbl: [(cevQ,
                      label: sat_segD_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevQ:
          _segD::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
      cevS:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
      cevU:
          HpAlloc = 16;   // CmmAssign
          goto cevR;   // CmmBranch
      cevR:
          R1 = _segD::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segD::P64;   // CmmStore
          _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segC_info;   // CmmStore
          _cevI::P64 = Hp - 8;   // CmmAssign
          R3 = _cevI::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cevV:
      _segG::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
  cevX:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
  cevZ:
      HpAlloc = 48;   // CmmAssign
      goto cevW;   // CmmBranch
  cevW:
      R1 = _segG::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevY:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segG::P64;   // CmmStore
      _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segF_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevn::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segD_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cevE::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cevE::P64;   // CmmStore
      P64[(old + 32)] = _cevn::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cevV:
      _segG::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
  cevX:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
  cevZ:
      HpAlloc = 48;   // CmmAssign
      goto cevW;   // CmmBranch
  cevW:
      R1 = _segG::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevY:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segG::P64;   // CmmStore
      _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segF_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevn::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segD_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cevE::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cevE::P64;   // CmmStore
      P64[(old + 32)] = _cevn::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cevV:
      _segG::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
  cevX:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
  cevZ:
      HpAlloc = 48;   // CmmAssign
      goto cevW;   // CmmBranch
  cevW:
      R1 = _segG::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cevY:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segG::P64;   // CmmStore
      _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segF_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevn::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segD_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cevE::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _cevE::P64;   // CmmStore
      P64[Sp - 24] = _cevn::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cevV,
  {GHC.Base.$fMonadIO_closure, sat_segD_closure, sat_segF_closure}),
 (cevW, {}),
 (cevX,
  {GHC.Base.$fMonadIO_closure, sat_segD_closure, sat_segF_closure}),
 (cevY,
  {GHC.Base.$fMonadIO_closure, sat_segD_closure, sat_segF_closure}),
 (cevZ, {})]



==================== after setInfoTableStackMap ====================
sat_segG_entry() //  [R1]
        { info_tbl: [(cevV,
                      label: sat_segG_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevV:
          _segG::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
      cevX:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
      cevZ:
          HpAlloc = 48;   // CmmAssign
          goto cevW;   // CmmBranch
      cevW:
          R1 = _segG::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segG::P64;   // CmmStore
          _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segF_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevn::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segD_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cevE::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cevE::P64;   // CmmStore
          P64[Sp - 24] = _cevn::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segG_entry() //  [R1]
        { info_tbl: [(cevV,
                      label: sat_segG_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cevV:
          _segG::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
      cevX:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
      cevZ:
          HpAlloc = 48;   // CmmAssign
          goto cevW;   // CmmBranch
      cevW:
          R1 = _segG::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segG::P64;   // CmmStore
          _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segF_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevn::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segD_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cevE::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cevE::P64;   // CmmStore
          P64[Sp - 24] = _cevn::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cew9:
      _segA::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
  cewa:
      R1 = _segA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewb:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segA::P64;   // CmmStore
      R2 = cew8_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cew9:
      _segA::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
  cewa:
      R1 = _segA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewb:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segA::P64;   // CmmStore
      R2 = cew8_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cew9:
      _segA::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
  cewa:
      R1 = _segA::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewb:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segA::P64;   // CmmStore
      R2 = cew8_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cew9, {GHC.CString.unpackCString#_closure}), (cewa, {}),
 (cewb, {GHC.CString.unpackCString#_closure})]



==================== after setInfoTableStackMap ====================
sat_segA_entry() //  [R1]
        { info_tbl: [(cew9,
                      label: sat_segA_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cew9:
          _segA::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
      cewa:
          R1 = _segA::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segA::P64;   // CmmStore
          R2 = cew8_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segA_entry() //  [R1]
        { info_tbl: [(cew9,
                      label: sat_segA_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cew9:
          _segA::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
      cewa:
          R1 = _segA::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segA::P64;   // CmmStore
          R2 = cew8_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cewc:
      _segB::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
  cewe:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
  cewg:
      HpAlloc = 16;   // CmmAssign
      goto cewd;   // CmmBranch
  cewd:
      R1 = _segB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewf:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segB::P64;   // CmmStore
      _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segA_info;   // CmmStore
      _cew4::P64 = Hp - 8;   // CmmAssign
      R3 = _cew4::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cewc:
      _segB::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
  cewe:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
  cewg:
      HpAlloc = 16;   // CmmAssign
      goto cewd;   // CmmBranch
  cewd:
      R1 = _segB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewf:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segB::P64;   // CmmStore
      _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segA_info;   // CmmStore
      _cew4::P64 = Hp - 8;   // CmmAssign
      R3 = _cew4::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cewc:
      _segB::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
  cewe:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
  cewg:
      HpAlloc = 16;   // CmmAssign
      goto cewd;   // CmmBranch
  cewd:
      R1 = _segB::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewf:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segB::P64;   // CmmStore
      _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segA_info;   // CmmStore
      _cew4::P64 = Hp - 8;   // CmmAssign
      R3 = _cew4::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cewc, {Main.testOneFile_closure, sat_segA_closure}), (cewd, {}),
 (cewe, {Main.testOneFile_closure, sat_segA_closure}),
 (cewf, {Main.testOneFile_closure, sat_segA_closure}), (cewg, {})]



==================== after setInfoTableStackMap ====================
sat_segB_entry() //  [R1]
        { info_tbl: [(cewc,
                      label: sat_segB_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewc:
          _segB::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
      cewe:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
      cewg:
          HpAlloc = 16;   // CmmAssign
          goto cewd;   // CmmBranch
      cewd:
          R1 = _segB::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewf:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segB::P64;   // CmmStore
          _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segA_info;   // CmmStore
          _cew4::P64 = Hp - 8;   // CmmAssign
          R3 = _cew4::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segB_entry() //  [R1]
        { info_tbl: [(cewc,
                      label: sat_segB_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewc:
          _segB::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
      cewe:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
      cewg:
          HpAlloc = 16;   // CmmAssign
          goto cewd;   // CmmBranch
      cewd:
          R1 = _segB::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewf:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segB::P64;   // CmmStore
          _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segA_info;   // CmmStore
          _cew4::P64 = Hp - 8;   // CmmAssign
          R3 = _cew4::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cewh:
      _segH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
  cewj:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
  cewl:
      HpAlloc = 48;   // CmmAssign
      goto cewi;   // CmmBranch
  cewi:
      R1 = _segH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewk:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segH::P64;   // CmmStore
      _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segG_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevj::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segB_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cew0::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cew0::P64;   // CmmStore
      P64[(old + 32)] = _cevj::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cewh:
      _segH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
  cewj:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
  cewl:
      HpAlloc = 48;   // CmmAssign
      goto cewi;   // CmmBranch
  cewi:
      R1 = _segH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewk:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segH::P64;   // CmmStore
      _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segG_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevj::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segB_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cew0::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = _cew0::P64;   // CmmStore
      P64[(old + 32)] = _cevj::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cewh:
      _segH::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
  cewj:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
  cewl:
      HpAlloc = 48;   // CmmAssign
      goto cewi;   // CmmBranch
  cewi:
      R1 = _segH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewk:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segH::P64;   // CmmStore
      _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 40] = sat_segG_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevj::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segB_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cew0::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = _cew0::P64;   // CmmStore
      P64[Sp - 24] = _cevj::P64;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cewh,
  {GHC.Base.$fMonadIO_closure, sat_segB_closure, sat_segG_closure}),
 (cewi, {}),
 (cewj,
  {GHC.Base.$fMonadIO_closure, sat_segB_closure, sat_segG_closure}),
 (cewk,
  {GHC.Base.$fMonadIO_closure, sat_segB_closure, sat_segG_closure}),
 (cewl, {})]



==================== after setInfoTableStackMap ====================
sat_segH_entry() //  [R1]
        { info_tbl: [(cewh,
                      label: sat_segH_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewh:
          _segH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
      cewj:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
      cewl:
          HpAlloc = 48;   // CmmAssign
          goto cewi;   // CmmBranch
      cewi:
          R1 = _segH::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewk:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segH::P64;   // CmmStore
          _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segG_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevj::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segB_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cew0::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cew0::P64;   // CmmStore
          P64[Sp - 24] = _cevj::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segH_entry() //  [R1]
        { info_tbl: [(cewh,
                      label: sat_segH_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewh:
          _segH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
      cewj:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
      cewl:
          HpAlloc = 48;   // CmmAssign
          goto cewi;   // CmmBranch
      cewi:
          R1 = _segH::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewk:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segH::P64;   // CmmStore
          _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segG_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevj::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segB_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cew0::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cew0::P64;   // CmmStore
          P64[Sp - 24] = _cevj::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cewv:
      _segy::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
  ceww:
      R1 = _segy::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewx:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segy::P64;   // CmmStore
      R2 = cewu_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cewv:
      _segy::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
  ceww:
      R1 = _segy::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewx:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segy::P64;   // CmmStore
      R2 = cewu_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cewv:
      _segy::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
  ceww:
      R1 = _segy::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewx:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segy::P64;   // CmmStore
      R2 = cewu_str;   // CmmAssign
      R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cewv, {GHC.CString.unpackCString#_closure}), (ceww, {}),
 (cewx, {GHC.CString.unpackCString#_closure})]



==================== after setInfoTableStackMap ====================
sat_segy_entry() //  [R1]
        { info_tbl: [(cewv,
                      label: sat_segy_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewv:
          _segy::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
      ceww:
          R1 = _segy::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewx:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segy::P64;   // CmmStore
          R2 = cewu_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segy_entry() //  [R1]
        { info_tbl: [(cewv,
                      label: sat_segy_info
                      rep:HeapRep { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewv:
          _segy::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
      ceww:
          R1 = _segy::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewx:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segy::P64;   // CmmStore
          R2 = cewu_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cewy:
      _segz::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
  cewA:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
  cewC:
      HpAlloc = 16;   // CmmAssign
      goto cewz;   // CmmBranch
  cewz:
      R1 = _segz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewB:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segz::P64;   // CmmStore
      _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segy_info;   // CmmStore
      _cewq::P64 = Hp - 8;   // CmmAssign
      R3 = _cewq::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cewy:
      _segz::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
  cewA:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
  cewC:
      HpAlloc = 16;   // CmmAssign
      goto cewz;   // CmmBranch
  cewz:
      R1 = _segz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewB:
      I64[(old + 24)] = stg_upd_frame_info;   // CmmStore
      P64[(old + 16)] = _segz::P64;   // CmmStore
      _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segy_info;   // CmmStore
      _cewq::P64 = Hp - 8;   // CmmAssign
      R3 = _cewq::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cewy:
      _segz::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
  cewA:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
  cewC:
      HpAlloc = 16;   // CmmAssign
      goto cewz;   // CmmBranch
  cewz:
      R1 = _segz::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewB:
      I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
      P64[Sp - 8] = _segz::P64;   // CmmStore
      _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 8] = sat_segy_info;   // CmmStore
      _cewq::P64 = Hp - 8;   // CmmAssign
      R3 = _cewq::P64;   // CmmAssign
      R2 = _segv::P64;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call Main.testOneFile_info(R3,
                                 R2) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cewy, {Main.testOneFile_closure, sat_segy_closure}), (cewz, {}),
 (cewA, {Main.testOneFile_closure, sat_segy_closure}),
 (cewB, {Main.testOneFile_closure, sat_segy_closure}), (cewC, {})]



==================== after setInfoTableStackMap ====================
sat_segz_entry() //  [R1]
        { info_tbl: [(cewy,
                      label: sat_segz_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewy:
          _segz::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
      cewA:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
      cewC:
          HpAlloc = 16;   // CmmAssign
          goto cewz;   // CmmBranch
      cewz:
          R1 = _segz::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewB:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segz::P64;   // CmmStore
          _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segy_info;   // CmmStore
          _cewq::P64 = Hp - 8;   // CmmAssign
          R3 = _cewq::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segz_entry() //  [R1]
        { info_tbl: [(cewy,
                      label: sat_segz_info
                      rep:HeapRep 1 ptrs { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewy:
          _segz::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
      cewA:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
      cewC:
          HpAlloc = 16;   // CmmAssign
          goto cewz;   // CmmBranch
      cewz:
          R1 = _segz::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewB:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segz::P64;   // CmmStore
          _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segy_info;   // CmmStore
          _cewq::P64 = Hp - 8;   // CmmAssign
          R3 = _cewq::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
{offset
  cewH:
      _segq::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
  cewI:
      R2 = _segq::P64;   // CmmAssign
      R1 = sat_segK_closure;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewJ:
      I64[(young<cev4> + 8)] = cev4;   // CmmStore
      R1 = _segq::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
  cev5:
      call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
  cev4:
      _segu::P64 = R1;   // CmmAssign
      _cewG::P64 = _segu::P64 & 7;   // CmmAssign
      switch [1 .. 2] _cewG::P64 {
          case 1 : goto ceuU;
          case 2 : goto cewF;
      }   // CmmSwitch
  cewF:
      _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
      _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
      I64[(young<ceva> + 8)] = ceva;   // CmmStore
      R1 = _segw::P64;   // CmmAssign
      if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
  cevb:
      call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  ceva:
      _segx::P64 = R1;   // CmmAssign
      _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
      switch [1 .. 2] _cewZ::P64 {
          case 1 : goto cewR;
          case 2 : goto cewY;
      }   // CmmSwitch
  cewY:
      _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
      _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
      goto ceuU;   // CmmBranch
  cewR:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
  cewU:
      HpAlloc = 48;   // CmmAssign
      R1 = _segx::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  cewT:
      // calling allocDynClosure
      I64[Hp - 40] = sat_segH_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevf::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segz_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cewm::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cewm::P64;   // CmmStore
      P64[(old + 16)] = _cevf::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
  ceuU:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
  cewM:
      HpAlloc = 16;   // CmmAssign
      I64[(young<ceuT> + 8)] = ceuT;   // CmmStore
      call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
  ceuT:
      goto ceuU;   // CmmBranch
  cewL:
      // calling allocDynClosure
      I64[Hp - 8] = sat_segt_info;   // CmmStore
      _ceuW::P64 = Hp - 8;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _ceuW::P64;   // CmmStore
      call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cewH:
      _segq::P64 = R2;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
  cewI:
      R2 = _segq::P64;   // CmmAssign
      R1 = sat_segK_closure;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewJ:
      I64[(young<cev4> + 8)] = cev4;   // CmmStore
      R1 = _segq::P64;   // CmmAssign
      if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
  cev5:
      call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
  cev4:
      _segu::P64 = R1;   // CmmAssign
      _cewG::P64 = _segu::P64 & 7;   // CmmAssign
      if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
  cewF:
      _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
      _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
      I64[(young<ceva> + 8)] = ceva;   // CmmStore
      R1 = _segw::P64;   // CmmAssign
      if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
  cevb:
      call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  ceva:
      _segx::P64 = R1;   // CmmAssign
      _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
      if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
  cewY:
      _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
      _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
      goto ceuU;   // CmmBranch
  cewR:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
  cewU:
      HpAlloc = 48;   // CmmAssign
      R1 = _segx::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  cewT:
      // calling allocDynClosure
      I64[Hp - 40] = sat_segH_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevf::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segz_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cewm::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 32)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 24)] = _cewm::P64;   // CmmStore
      P64[(old + 16)] = _cevf::P64;   // CmmStore
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
  ceuU:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
  cewM:
      HpAlloc = 16;   // CmmAssign
      I64[(young<ceuT> + 8)] = ceuT;   // CmmStore
      call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
  ceuT:
      goto ceuU;   // CmmBranch
  cewL:
      // calling allocDynClosure
      I64[Hp - 8] = sat_segt_info;   // CmmStore
      _ceuW::P64 = Hp - 8;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 24)] = stg_ap_p_info;   // CmmStore
      P64[(old + 16)] = _ceuW::P64;   // CmmStore
      call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cewH:
      _segq::P64 = R2;   // CmmAssign
      if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
  cewI:
      R2 = _segq::P64;   // CmmAssign
      R1 = sat_segK_closure;   // CmmAssign
      call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
  cewJ:
      I64[Sp - 8] = cev4;   // CmmStore
      R1 = _segq::P64;   // CmmAssign
      Sp = Sp - 8;   // CmmAssign
      if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
  cev5:
      call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
  cev4:
      _segu::P64 = R1;   // CmmAssign
      _cewG::P64 = _segu::P64 & 7;   // CmmAssign
      if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
  cewF:
      _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
      _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
      I64[Sp - 8] = ceva;   // CmmStore
      R1 = _segw::P64;   // CmmAssign
      P64[Sp] = _segv::P64;   // CmmStore
      Sp = Sp - 8;   // CmmAssign
      if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
  cevb:
      call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  ceva:
      _segv::P64 = P64[Sp + 8];   // CmmAssign
      _segx::P64 = R1;   // CmmAssign
      _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
      if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
  cewY:
      _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
      _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
      goto uex0;   // CmmBranch
  uex0:
      Sp = Sp + 8;   // CmmAssign
      goto ceuU;   // CmmBranch
  cewR:
      Hp = Hp + 48;   // CmmAssign
      if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
  cewU:
      HpAlloc = 48;   // CmmAssign
      R1 = _segx::P64;   // CmmAssign
      call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
  cewT:
      // calling allocDynClosure
      I64[Hp - 40] = sat_segH_info;   // CmmStore
      P64[Hp - 24] = _segv::P64;   // CmmStore
      _cevf::P64 = Hp - 40;   // CmmAssign
      // calling allocDynClosure
      I64[Hp - 16] = sat_segz_info;   // CmmStore
      P64[Hp] = _segv::P64;   // CmmStore
      _cewm::P64 = Hp - 16;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
      P64[Sp] = _cewm::P64;   // CmmStore
      P64[Sp + 8] = _cevf::P64;   // CmmStore
      Sp = Sp - 8;   // CmmAssign
      call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
  ceuU:
      Hp = Hp + 16;   // CmmAssign
      if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
  cewM:
      HpAlloc = 16;   // CmmAssign
      I64[Sp] = ceuT;   // CmmStore
      call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
  ceuT:
      goto ceuU;   // CmmBranch
  cewL:
      // calling allocDynClosure
      I64[Hp - 8] = sat_segt_info;   // CmmStore
      _ceuW::P64 = Hp - 8;   // CmmAssign
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 8] = stg_ap_p_info;   // CmmStore
      P64[Sp] = _ceuW::P64;   // CmmStore
      Sp = Sp - 8;   // CmmAssign
      call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
}



==================== CAFEnv ====================
[(ceuT, {GHC.Base.$fMonadIO_closure, sat_segt_closure}),
 (ceuU, {GHC.Base.$fMonadIO_closure, sat_segt_closure}),
 (cev4,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cev5,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (ceva,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cevb,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cewF,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cewH,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure, sat_segK_closure}),
 (cewI, {sat_segK_closure}),
 (cewJ,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cewL, {GHC.Base.$fMonadIO_closure, sat_segt_closure}),
 (cewM, {GHC.Base.$fMonadIO_closure, sat_segt_closure}),
 (cewR,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cewT,
  {GHC.Base.$fMonadIO_closure, sat_segz_closure, sat_segH_closure}),
 (cewU,
  {GHC.Base.$fMonadIO_closure, sat_segt_closure, sat_segz_closure,
   sat_segH_closure}),
 (cewY, {GHC.Base.$fMonadIO_closure, sat_segt_closure}),
 (uex0, {GHC.Base.$fMonadIO_closure, sat_segt_closure})]



==================== after setInfoTableStackMap ====================
sat_segK_entry() //  [R2]
        { info_tbl: [(ceuT,
                      label: block_ceuT_info
                      rep:StackRep []),
                     (cev4,
                      label: block_cev4_info
                      rep:StackRep []),
                     (ceva,
                      label: block_ceva_info
                      rep:StackRep [False]),
                     (cewH,
                      label: sat_segK_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewH:
          _segq::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
      cewI:
          R2 = _segq::P64;   // CmmAssign
          R1 = sat_segK_closure;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewJ:
          I64[Sp - 8] = cev4;   // CmmStore
          R1 = _segq::P64;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
      cev5:
          call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
      cev4:
          _segu::P64 = R1;   // CmmAssign
          _cewG::P64 = _segu::P64 & 7;   // CmmAssign
          if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
      cewF:
          _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
          _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
          I64[Sp - 8] = ceva;   // CmmStore
          R1 = _segw::P64;   // CmmAssign
          P64[Sp] = _segv::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
      cevb:
          call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      ceva:
          _segv::P64 = P64[Sp + 8];   // CmmAssign
          _segx::P64 = R1;   // CmmAssign
          _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
          if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
      cewY:
          _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
          _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
          goto uex0;   // CmmBranch
      uex0:
          Sp = Sp + 8;   // CmmAssign
          goto ceuU;   // CmmBranch
      cewR:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
      cewU:
          HpAlloc = 48;   // CmmAssign
          R1 = _segx::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      cewT:
          // calling allocDynClosure
          I64[Hp - 40] = sat_segH_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevf::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segz_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cewm::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
          P64[Sp] = _cewm::P64;   // CmmStore
          P64[Sp + 8] = _cevf::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
      ceuU:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
      cewM:
          HpAlloc = 16;   // CmmAssign
          I64[Sp] = ceuT;   // CmmStore
          call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
      ceuT:
          goto ceuU;   // CmmBranch
      cewL:
          // calling allocDynClosure
          I64[Hp - 8] = sat_segt_info;   // CmmStore
          _ceuW::P64 = Hp - 8;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_p_info;   // CmmStore
          P64[Sp] = _ceuW::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
sat_segK_entry() //  [R2]
        { info_tbl: [(ceuT,
                      label: block_ceuT_info
                      rep:StackRep []),
                     (cev4,
                      label: block_cev4_info
                      rep:StackRep []),
                     (ceva,
                      label: block_ceva_info
                      rep:StackRep [False]),
                     (cewH,
                      label: sat_segK_info
                      rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cewH:
          _segq::P64 = R2;   // CmmAssign
          if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
      cewI:
          R2 = _segq::P64;   // CmmAssign
          R1 = sat_segK_closure;   // CmmAssign
          call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewJ:
          I64[Sp - 8] = cev4;   // CmmStore
          R1 = _segq::P64;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
      cev5:
          call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
      cev4:
          _segu::P64 = R1;   // CmmAssign
          _cewG::P64 = _segu::P64 & 7;   // CmmAssign
          if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
      cewF:
          _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
          _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
          I64[Sp - 8] = ceva;   // CmmStore
          R1 = _segw::P64;   // CmmAssign
          P64[Sp] = _segv::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
      cevb:
          call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      ceva:
          _segv::P64 = P64[Sp + 8];   // CmmAssign
          _segx::P64 = R1;   // CmmAssign
          _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
          if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
      cewY:
          _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
          _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
          goto uex0;   // CmmBranch
      uex0:
          Sp = Sp + 8;   // CmmAssign
          goto ceuU;   // CmmBranch
      cewR:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
      cewU:
          HpAlloc = 48;   // CmmAssign
          R1 = _segx::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      cewT:
          // calling allocDynClosure
          I64[Hp - 40] = sat_segH_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevf::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segz_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cewm::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
          P64[Sp] = _cewm::P64;   // CmmStore
          P64[Sp + 8] = _cevf::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
      ceuU:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
      cewM:
          HpAlloc = 16;   // CmmAssign
          I64[Sp] = ceuT;   // CmmStore
          call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
      ceuT:
          goto ceuU;   // CmmBranch
      cewL:
          // calling allocDynClosure
          I64[Hp - 8] = sat_segt_info;   // CmmStore
          _ceuW::P64 = Hp - 8;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_p_info;   // CmmStore
          P64[Sp] = _ceuW::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . sat_segK_closure" {
     sat_segK_closure:
         const sat_segK_info;
         const 0;
 },
 section ""readonly" . cev0_str" {
     cev0_str:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54]
 },
 sat_segt_entry() //  [R1]
         { info_tbl: [(cev1,
                       label: sat_segt_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cev1:
           _segt::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
       cev2:
           R1 = _segt::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cev3:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segt::P64;   // CmmStore
           R2 = cev0_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevv_str" {
     cevv_str:
         I8[] [77,105,110,101,84,121,112,101]
 },
 sat_segE_entry() //  [R1]
         { info_tbl: [(cevw,
                       label: sat_segE_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevw:
           _segE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
       cevx:
           R1 = _segE::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segE::P64;   // CmmStore
           R2 = cevv_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segF_entry() //  [R1]
         { info_tbl: [(cevz,
                       label: sat_segF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevz:
           _segF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
       cevB:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
       cevD:
           HpAlloc = 16;   // CmmAssign
           goto cevA;   // CmmBranch
       cevA:
           R1 = _segF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevC:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segF::P64;   // CmmStore
           _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segE_info;   // CmmStore
           _cevr::P64 = Hp - 8;   // CmmAssign
           R3 = _cevr::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevM_str" {
     cevM_str:
         I8[] [77,105,110,101,78,97,109,101,115]
 },
 sat_segC_entry() //  [R1]
         { info_tbl: [(cevN,
                       label: sat_segC_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevN:
           _segC::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
       cevO:
           R1 = _segC::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segC::P64;   // CmmStore
           R2 = cevM_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segD_entry() //  [R1]
         { info_tbl: [(cevQ,
                       label: sat_segD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevQ:
           _segD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
       cevS:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
       cevU:
           HpAlloc = 16;   // CmmAssign
           goto cevR;   // CmmBranch
       cevR:
           R1 = _segD::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segD::P64;   // CmmStore
           _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segC_info;   // CmmStore
           _cevI::P64 = Hp - 8;   // CmmAssign
           R3 = _cevI::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segG_entry() //  [R1]
         { info_tbl: [(cevV,
                       label: sat_segG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevV:
           _segG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
       cevX:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
       cevZ:
           HpAlloc = 48;   // CmmAssign
           goto cevW;   // CmmBranch
       cevW:
           R1 = _segG::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segG::P64;   // CmmStore
           _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segF_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevn::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segD_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cevE::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cevE::P64;   // CmmStore
           P64[Sp - 24] = _cevn::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cew8_str" {
     cew8_str:
         I8[] [77,105,110,101,75,105,110,100]
 },
 sat_segA_entry() //  [R1]
         { info_tbl: [(cew9,
                       label: sat_segA_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cew9:
           _segA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
       cewa:
           R1 = _segA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segA::P64;   // CmmStore
           R2 = cew8_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segB_entry() //  [R1]
         { info_tbl: [(cewc,
                       label: sat_segB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewc:
           _segB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
       cewe:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
       cewg:
           HpAlloc = 16;   // CmmAssign
           goto cewd;   // CmmBranch
       cewd:
           R1 = _segB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewf:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segB::P64;   // CmmStore
           _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segA_info;   // CmmStore
           _cew4::P64 = Hp - 8;   // CmmAssign
           R3 = _cew4::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segH_entry() //  [R1]
         { info_tbl: [(cewh,
                       label: sat_segH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewh:
           _segH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
       cewj:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
       cewl:
           HpAlloc = 48;   // CmmAssign
           goto cewi;   // CmmBranch
       cewi:
           R1 = _segH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewk:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segH::P64;   // CmmStore
           _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segG_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevj::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segB_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cew0::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cew0::P64;   // CmmStore
           P64[Sp - 24] = _cevj::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cewu_str" {
     cewu_str:
         I8[] [77,105,110,101,70,105,120,105,116,121]
 },
 sat_segy_entry() //  [R1]
         { info_tbl: [(cewv,
                       label: sat_segy_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewv:
           _segy::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
       ceww:
           R1 = _segy::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewx:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segy::P64;   // CmmStore
           R2 = cewu_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segz_entry() //  [R1]
         { info_tbl: [(cewy,
                       label: sat_segz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewy:
           _segz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
       cewA:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
       cewC:
           HpAlloc = 16;   // CmmAssign
           goto cewz;   // CmmBranch
       cewz:
           R1 = _segz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewB:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segz::P64;   // CmmStore
           _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segy_info;   // CmmStore
           _cewq::P64 = Hp - 8;   // CmmAssign
           R3 = _cewq::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segK_entry() //  [R2]
         { info_tbl: [(ceuT,
                       label: block_ceuT_info
                       rep:StackRep []),
                      (cev4,
                       label: block_cev4_info
                       rep:StackRep []),
                      (ceva,
                       label: block_ceva_info
                       rep:StackRep [False]),
                      (cewH,
                       label: sat_segK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewH:
           _segq::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
       cewI:
           R2 = _segq::P64;   // CmmAssign
           R1 = sat_segK_closure;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewJ:
           I64[Sp - 8] = cev4;   // CmmStore
           R1 = _segq::P64;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
       cev5:
           call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
       cev4:
           _segu::P64 = R1;   // CmmAssign
           _cewG::P64 = _segu::P64 & 7;   // CmmAssign
           if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
       cewF:
           _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
           _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
           I64[Sp - 8] = ceva;   // CmmStore
           R1 = _segw::P64;   // CmmAssign
           P64[Sp] = _segv::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
       cevb:
           call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       ceva:
           _segv::P64 = P64[Sp + 8];   // CmmAssign
           _segx::P64 = R1;   // CmmAssign
           _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
           if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
       cewY:
           _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
           _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
           goto uex0;   // CmmBranch
       uex0:
           Sp = Sp + 8;   // CmmAssign
           goto ceuU;   // CmmBranch
       cewR:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
       cewU:
           HpAlloc = 48;   // CmmAssign
           R1 = _segx::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       cewT:
           // calling allocDynClosure
           I64[Hp - 40] = sat_segH_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevf::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segz_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cewm::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
           P64[Sp] = _cewm::P64;   // CmmStore
           P64[Sp + 8] = _cevf::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
       ceuU:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
       cewM:
           HpAlloc = 16;   // CmmAssign
           I64[Sp] = ceuT;   // CmmStore
           call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
       ceuT:
           goto ceuU;   // CmmBranch
       cewL:
           // calling allocDynClosure
           I64[Hp - 8] = sat_segt_info;   // CmmStore
           _ceuW::P64 = Hp - 8;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_p_info;   // CmmStore
           P64[Sp] = _ceuW::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . sat_segK_closure" {
     sat_segK_closure:
         const sat_segK_info;
         const 0;
 },
 section ""readonly" . cev0_str" {
     cev0_str:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54]
 },
 sat_segt_entry() //  [R1]
         { info_tbl: [(cev1,
                       label: sat_segt_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cev1:
           _segt::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
       cev2:
           R1 = _segt::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cev3:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segt::P64;   // CmmStore
           R2 = cev0_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevv_str" {
     cevv_str:
         I8[] [77,105,110,101,84,121,112,101]
 },
 sat_segE_entry() //  [R1]
         { info_tbl: [(cevw,
                       label: sat_segE_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevw:
           _segE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
       cevx:
           R1 = _segE::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segE::P64;   // CmmStore
           R2 = cevv_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segF_entry() //  [R1]
         { info_tbl: [(cevz,
                       label: sat_segF_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevz:
           _segF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
       cevB:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
       cevD:
           HpAlloc = 16;   // CmmAssign
           goto cevA;   // CmmBranch
       cevA:
           R1 = _segF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevC:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segF::P64;   // CmmStore
           _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segE_info;   // CmmStore
           _cevr::P64 = Hp - 8;   // CmmAssign
           R3 = _cevr::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevM_str" {
     cevM_str:
         I8[] [77,105,110,101,78,97,109,101,115]
 },
 sat_segC_entry() //  [R1]
         { info_tbl: [(cevN,
                       label: sat_segC_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevN:
           _segC::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
       cevO:
           R1 = _segC::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segC::P64;   // CmmStore
           R2 = cevM_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segD_entry() //  [R1]
         { info_tbl: [(cevQ,
                       label: sat_segD_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevQ:
           _segD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
       cevS:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
       cevU:
           HpAlloc = 16;   // CmmAssign
           goto cevR;   // CmmBranch
       cevR:
           R1 = _segD::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segD::P64;   // CmmStore
           _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segC_info;   // CmmStore
           _cevI::P64 = Hp - 8;   // CmmAssign
           R3 = _cevI::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segG_entry() //  [R1]
         { info_tbl: [(cevV,
                       label: sat_segG_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cevV:
           _segG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
       cevX:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
       cevZ:
           HpAlloc = 48;   // CmmAssign
           goto cevW;   // CmmBranch
       cevW:
           R1 = _segG::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segG::P64;   // CmmStore
           _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segF_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevn::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segD_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cevE::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cevE::P64;   // CmmStore
           P64[Sp - 24] = _cevn::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cew8_str" {
     cew8_str:
         I8[] [77,105,110,101,75,105,110,100]
 },
 sat_segA_entry() //  [R1]
         { info_tbl: [(cew9,
                       label: sat_segA_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cew9:
           _segA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
       cewa:
           R1 = _segA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segA::P64;   // CmmStore
           R2 = cew8_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segB_entry() //  [R1]
         { info_tbl: [(cewc,
                       label: sat_segB_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewc:
           _segB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
       cewe:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
       cewg:
           HpAlloc = 16;   // CmmAssign
           goto cewd;   // CmmBranch
       cewd:
           R1 = _segB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewf:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segB::P64;   // CmmStore
           _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segA_info;   // CmmStore
           _cew4::P64 = Hp - 8;   // CmmAssign
           R3 = _cew4::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segH_entry() //  [R1]
         { info_tbl: [(cewh,
                       label: sat_segH_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewh:
           _segH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
       cewj:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
       cewl:
           HpAlloc = 48;   // CmmAssign
           goto cewi;   // CmmBranch
       cewi:
           R1 = _segH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewk:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segH::P64;   // CmmStore
           _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segG_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevj::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segB_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cew0::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cew0::P64;   // CmmStore
           P64[Sp - 24] = _cevj::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cewu_str" {
     cewu_str:
         I8[] [77,105,110,101,70,105,120,105,116,121]
 },
 sat_segy_entry() //  [R1]
         { info_tbl: [(cewv,
                       label: sat_segy_info
                       rep:HeapRep { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewv:
           _segy::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
       ceww:
           R1 = _segy::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewx:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segy::P64;   // CmmStore
           R2 = cewu_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segz_entry() //  [R1]
         { info_tbl: [(cewy,
                       label: sat_segz_info
                       rep:HeapRep 1 ptrs { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewy:
           _segz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
       cewA:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
       cewC:
           HpAlloc = 16;   // CmmAssign
           goto cewz;   // CmmBranch
       cewz:
           R1 = _segz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewB:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segz::P64;   // CmmStore
           _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segy_info;   // CmmStore
           _cewq::P64 = Hp - 8;   // CmmAssign
           R3 = _cewq::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segK_entry() //  [R2]
         { info_tbl: [(ceuT,
                       label: block_ceuT_info
                       rep:StackRep []),
                      (cev4,
                       label: block_cev4_info
                       rep:StackRep []),
                      (ceva,
                       label: block_ceva_info
                       rep:StackRep [False]),
                      (cewH,
                       label: sat_segK_info
                       rep:HeapRep static { Fun {arity: 1 fun_type: ArgSpec 5} })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cewH:
           _segq::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
       cewI:
           R2 = _segq::P64;   // CmmAssign
           R1 = sat_segK_closure;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewJ:
           I64[Sp - 8] = cev4;   // CmmStore
           R1 = _segq::P64;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
       cev5:
           call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
       cev4:
           _segu::P64 = R1;   // CmmAssign
           _cewG::P64 = _segu::P64 & 7;   // CmmAssign
           if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
       cewF:
           _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
           _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
           I64[Sp - 8] = ceva;   // CmmStore
           R1 = _segw::P64;   // CmmAssign
           P64[Sp] = _segv::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
       cevb:
           call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       ceva:
           _segv::P64 = P64[Sp + 8];   // CmmAssign
           _segx::P64 = R1;   // CmmAssign
           _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
           if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
       cewY:
           _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
           _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
           goto uex0;   // CmmBranch
       uex0:
           Sp = Sp + 8;   // CmmAssign
           goto ceuU;   // CmmBranch
       cewR:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
       cewU:
           HpAlloc = 48;   // CmmAssign
           R1 = _segx::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       cewT:
           // calling allocDynClosure
           I64[Hp - 40] = sat_segH_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevf::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segz_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cewm::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
           P64[Sp] = _cewm::P64;   // CmmStore
           P64[Sp + 8] = _cevf::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
       ceuU:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
       cewM:
           HpAlloc = 16;   // CmmAssign
           I64[Sp] = ceuT;   // CmmStore
           call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
       ceuT:
           goto ceuU;   // CmmBranch
       cewL:
           // calling allocDynClosure
           I64[Hp - 8] = sat_segt_info;   // CmmStore
           _ceuW::P64 = Hp - 8;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_p_info;   // CmmStore
           P64[Sp] = _ceuW::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . sat_segK_closure" {
     sat_segK_closure:
         const sat_segK_info;
         const 0;
 },
 section ""readonly" . cev0_str" {
     cev0_str:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54]
 },
 sat_segt_entry() //  [R1]
         { [(cev1,
             sat_segt_info:
                 const SehZ_srt-sat_segt_info+416;
                 const 0;
                 const 4294967312;)]
         }
     {offset
       cev1:
           _segt::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
       cev2:
           R1 = _segt::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cev3:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segt::P64;   // CmmStore
           R2 = cev0_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevv_str" {
     cevv_str:
         I8[] [77,105,110,101,84,121,112,101]
 },
 sat_segE_entry() //  [R1]
         { [(cevw,
             sat_segE_info:
                 const SehZ_srt-sat_segE_info+416;
                 const 0;
                 const 4294967312;)]
         }
     {offset
       cevw:
           _segE::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
       cevx:
           R1 = _segE::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevy:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segE::P64;   // CmmStore
           R2 = cevv_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segF_entry() //  [R1]
         { [(cevz,
             sat_segF_info:
                 const SehZ_srt-sat_segF_info+408;
                 const 1;
                 const 12884901905;)]
         }
     {offset
       cevz:
           _segF::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
       cevB:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevD; else goto cevC;   // CmmCondBranch
       cevD:
           HpAlloc = 16;   // CmmAssign
           goto cevA;   // CmmBranch
       cevA:
           R1 = _segF::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevC:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segF::P64;   // CmmStore
           _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segE_info;   // CmmStore
           _cevr::P64 = Hp - 8;   // CmmAssign
           R3 = _cevr::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cevM_str" {
     cevM_str:
         I8[] [77,105,110,101,78,97,109,101,115]
 },
 sat_segC_entry() //  [R1]
         { [(cevN,
             sat_segC_info:
                 const SehZ_srt-sat_segC_info+416;
                 const 0;
                 const 4294967312;)]
         }
     {offset
       cevN:
           _segC::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
       cevO:
           R1 = _segC::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevP:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segC::P64;   // CmmStore
           R2 = cevM_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segD_entry() //  [R1]
         { [(cevQ,
             sat_segD_info:
                 const SehZ_srt-sat_segD_info+408;
                 const 1;
                 const 12884901905;)]
         }
     {offset
       cevQ:
           _segD::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
       cevS:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cevU; else goto cevT;   // CmmCondBranch
       cevU:
           HpAlloc = 16;   // CmmAssign
           goto cevR;   // CmmBranch
       cevR:
           R1 = _segD::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevT:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segD::P64;   // CmmStore
           _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segC_info;   // CmmStore
           _cevI::P64 = Hp - 8;   // CmmAssign
           R3 = _cevI::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segG_entry() //  [R1]
         { [(cevV,
             sat_segG_info:
                 const SehZ_srt-sat_segG_info+400;
                 const 1;
                 const 30064771089;)]
         }
     {offset
       cevV:
           _segG::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
       cevX:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cevZ; else goto cevY;   // CmmCondBranch
       cevZ:
           HpAlloc = 48;   // CmmAssign
           goto cevW;   // CmmBranch
       cevW:
           R1 = _segG::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cevY:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segG::P64;   // CmmStore
           _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segF_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevn::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segD_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cevE::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cevE::P64;   // CmmStore
           P64[Sp - 24] = _cevn::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cew8_str" {
     cew8_str:
         I8[] [77,105,110,101,75,105,110,100]
 },
 sat_segA_entry() //  [R1]
         { [(cew9,
             sat_segA_info:
                 const SehZ_srt-sat_segA_info+416;
                 const 0;
                 const 4294967312;)]
         }
     {offset
       cew9:
           _segA::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
       cewa:
           R1 = _segA::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewb:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segA::P64;   // CmmStore
           R2 = cew8_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segB_entry() //  [R1]
         { [(cewc,
             sat_segB_info:
                 const SehZ_srt-sat_segB_info+408;
                 const 1;
                 const 12884901905;)]
         }
     {offset
       cewc:
           _segB::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
       cewe:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewg; else goto cewf;   // CmmCondBranch
       cewg:
           HpAlloc = 16;   // CmmAssign
           goto cewd;   // CmmBranch
       cewd:
           R1 = _segB::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewf:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segB::P64;   // CmmStore
           _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segA_info;   // CmmStore
           _cew4::P64 = Hp - 8;   // CmmAssign
           R3 = _cew4::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segH_entry() //  [R1]
         { [(cewh,
             sat_segH_info:
                 const SehZ_srt-sat_segH_info+400;
                 const 1;
                 const 30064771089;)]
         }
     {offset
       cewh:
           _segH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
       cewj:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewl; else goto cewk;   // CmmCondBranch
       cewl:
           HpAlloc = 48;   // CmmAssign
           goto cewi;   // CmmBranch
       cewi:
           R1 = _segH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewk:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segH::P64;   // CmmStore
           _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 40] = sat_segG_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevj::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segB_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cew0::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = _cew0::P64;   // CmmStore
           P64[Sp - 24] = _cevj::P64;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 },
 section ""readonly" . cewu_str" {
     cewu_str:
         I8[] [77,105,110,101,70,105,120,105,116,121]
 },
 sat_segy_entry() //  [R1]
         { [(cewv,
             sat_segy_info:
                 const SehZ_srt-sat_segy_info+416;
                 const 0;
                 const 4294967312;)]
         }
     {offset
       cewv:
           _segy::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
       ceww:
           R1 = _segy::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewx:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segy::P64;   // CmmStore
           R2 = cewu_str;   // CmmAssign
           R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segz_entry() //  [R1]
         { [(cewy,
             sat_segz_info:
                 const SehZ_srt-sat_segz_info+408;
                 const 1;
                 const 12884901905;)]
         }
     {offset
       cewy:
           _segz::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
       cewA:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewC; else goto cewB;   // CmmCondBranch
       cewC:
           HpAlloc = 16;   // CmmAssign
           goto cewz;   // CmmBranch
       cewz:
           R1 = _segz::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewB:
           I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
           P64[Sp - 8] = _segz::P64;   // CmmStore
           _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 8] = sat_segy_info;   // CmmStore
           _cewq::P64 = Hp - 8;   // CmmAssign
           R3 = _cewq::P64;   // CmmAssign
           R2 = _segv::P64;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call Main.testOneFile_info(R3,
                                      R2) args: 24, res: 0, upd: 24;   // CmmCall
     }
 },
 sat_segK_entry() //  [R2]
         { [(ceuT,
             block_ceuT_info:
                 const SehZ_srt-block_ceuT_info+400;
                 const 0;
                 const 21474836512;),
            (cev4,
             block_cev4_info:
                 const SehZ_srt-block_cev4_info+400;
                 const 0;
                 const 30064771104;),
            (ceva,
             block_ceva_info:
                 const SehZ_srt-block_ceva_info+400;
                 const 1;
                 const 30064771104;),
            (cewH,
             sat_segK_info:
                 const SehZ_srt-sat_segK_info+400;
                 const 4294967301;
                 const 0;
                 const 64424509455;)]
         }
     {offset
       cewH:
           _segq::P64 = R2;   // CmmAssign
           if ((Sp + 8) - 32 < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
       cewI:
           R2 = _segq::P64;   // CmmAssign
           R1 = sat_segK_closure;   // CmmAssign
           call (stg_gc_fun)(R2, R1) args: 8, res: 0, upd: 8;   // CmmCall
       cewJ:
           I64[Sp - 8] = cev4;   // CmmStore
           R1 = _segq::P64;   // CmmAssign
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
       cev5:
           call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
       cev4:
           _segu::P64 = R1;   // CmmAssign
           _cewG::P64 = _segu::P64 & 7;   // CmmAssign
           if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
       cewF:
           _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
           _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
           I64[Sp - 8] = ceva;   // CmmStore
           R1 = _segw::P64;   // CmmAssign
           P64[Sp] = _segv::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
       cevb:
           call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       ceva:
           _segv::P64 = P64[Sp + 8];   // CmmAssign
           _segx::P64 = R1;   // CmmAssign
           _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
           if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
       cewY:
           _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
           _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
           goto uex0;   // CmmBranch
       uex0:
           Sp = Sp + 8;   // CmmAssign
           goto ceuU;   // CmmBranch
       cewR:
           Hp = Hp + 48;   // CmmAssign
           if (Hp > HpLim) goto cewU; else goto cewT;   // CmmCondBranch
       cewU:
           HpAlloc = 48;   // CmmAssign
           R1 = _segx::P64;   // CmmAssign
           call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
       cewT:
           // calling allocDynClosure
           I64[Hp - 40] = sat_segH_info;   // CmmStore
           P64[Hp - 24] = _segv::P64;   // CmmStore
           _cevf::P64 = Hp - 40;   // CmmAssign
           // calling allocDynClosure
           I64[Hp - 16] = sat_segz_info;   // CmmStore
           P64[Hp] = _segv::P64;   // CmmStore
           _cewm::P64 = Hp - 16;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
           P64[Sp] = _cewm::P64;   // CmmStore
           P64[Sp + 8] = _cevf::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
       ceuU:
           Hp = Hp + 16;   // CmmAssign
           if (Hp > HpLim) goto cewM; else goto cewL;   // CmmCondBranch
       cewM:
           HpAlloc = 16;   // CmmAssign
           I64[Sp] = ceuT;   // CmmStore
           call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
       ceuT:
           goto ceuU;   // CmmBranch
       cewL:
           // calling allocDynClosure
           I64[Hp - 8] = sat_segt_info;   // CmmStore
           _ceuW::P64 = Hp - 8;   // CmmAssign
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 8] = stg_ap_p_info;   // CmmStore
           P64[Sp] = _ceuW::P64;   // CmmStore
           Sp = Sp - 8;   // CmmAssign
           call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . sat_segK_closure" {
    sat_segK_closure:
        const sat_segK_info;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
sat_segK_closure:
	.quad	sat_segK_info
	.quad	0



==================== Liveness annotations added ====================
section ""data" . sat_segK_closure" {
    (1,
     sat_segK_closure:
         const sat_segK_info;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
sat_segK_closure:
	.quad	sat_segK_info
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
sat_segK_closure:
	.quad	sat_segK_info
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
sat_segK_closure:
	.quad	sat_segK_info
	.quad	0



==================== Optimised Cmm ====================
section ""readonly" . cev0_str" {
    cev0_str:
        I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cev0_str:
	.byte	80
	.byte	97
	.byte	116
	.byte	116
	.byte	101
	.byte	114
	.byte	110
	.byte	32
	.byte	109
	.byte	97
	.byte	116
	.byte	99
	.byte	104
	.byte	32
	.byte	102
	.byte	97
	.byte	105
	.byte	108
	.byte	117
	.byte	114
	.byte	101
	.byte	32
	.byte	105
	.byte	110
	.byte	32
	.byte	100
	.byte	111
	.byte	32
	.byte	101
	.byte	120
	.byte	112
	.byte	114
	.byte	101
	.byte	115
	.byte	115
	.byte	105
	.byte	111
	.byte	110
	.byte	32
	.byte	97
	.byte	116
	.byte	32
	.byte	108
	.byte	97
	.byte	110
	.byte	100
	.byte	109
	.byte	105
	.byte	110
	.byte	101
	.byte	115
	.byte	46
	.byte	104
	.byte	115
	.byte	58
	.byte	49
	.byte	57
	.byte	58
	.byte	57
	.byte	45
	.byte	49
	.byte	54
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cev0_str" {
    (1,
     cev0_str:
         I8[] [80,97,116,116,101,114,110,32,109,97,116,99,104,32,102,97,105,108,117,114,101,32,105,110,32,100,111,32,101,120,112,114,101,115,115,105,111,110,32,97,116,32,108,97,110,100,109,105,110,101,115,46,104,115,58,49,57,58,57,45,49,54])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cev0_str:
	.byte	80
	.byte	97
	.byte	116
	.byte	116
	.byte	101
	.byte	114
	.byte	110
	.byte	32
	.byte	109
	.byte	97
	.byte	116
	.byte	99
	.byte	104
	.byte	32
	.byte	102
	.byte	97
	.byte	105
	.byte	108
	.byte	117
	.byte	114
	.byte	101
	.byte	32
	.byte	105
	.byte	110
	.byte	32
	.byte	100
	.byte	111
	.byte	32
	.byte	101
	.byte	120
	.byte	112
	.byte	114
	.byte	101
	.byte	115
	.byte	115
	.byte	105
	.byte	111
	.byte	110
	.byte	32
	.byte	97
	.byte	116
	.byte	32
	.byte	108
	.byte	97
	.byte	110
	.byte	100
	.byte	109
	.byte	105
	.byte	110
	.byte	101
	.byte	115
	.byte	46
	.byte	104
	.byte	115
	.byte	58
	.byte	49
	.byte	57
	.byte	58
	.byte	57
	.byte	45
	.byte	49
	.byte	54
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cev0_str:
	.byte	80
	.byte	97
	.byte	116
	.byte	116
	.byte	101
	.byte	114
	.byte	110
	.byte	32
	.byte	109
	.byte	97
	.byte	116
	.byte	99
	.byte	104
	.byte	32
	.byte	102
	.byte	97
	.byte	105
	.byte	108
	.byte	117
	.byte	114
	.byte	101
	.byte	32
	.byte	105
	.byte	110
	.byte	32
	.byte	100
	.byte	111
	.byte	32
	.byte	101
	.byte	120
	.byte	112
	.byte	114
	.byte	101
	.byte	115
	.byte	115
	.byte	105
	.byte	111
	.byte	110
	.byte	32
	.byte	97
	.byte	116
	.byte	32
	.byte	108
	.byte	97
	.byte	110
	.byte	100
	.byte	109
	.byte	105
	.byte	110
	.byte	101
	.byte	115
	.byte	46
	.byte	104
	.byte	115
	.byte	58
	.byte	49
	.byte	57
	.byte	58
	.byte	57
	.byte	45
	.byte	49
	.byte	54
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cev0_str:
	.byte	80
	.byte	97
	.byte	116
	.byte	116
	.byte	101
	.byte	114
	.byte	110
	.byte	32
	.byte	109
	.byte	97
	.byte	116
	.byte	99
	.byte	104
	.byte	32
	.byte	102
	.byte	97
	.byte	105
	.byte	108
	.byte	117
	.byte	114
	.byte	101
	.byte	32
	.byte	105
	.byte	110
	.byte	32
	.byte	100
	.byte	111
	.byte	32
	.byte	101
	.byte	120
	.byte	112
	.byte	114
	.byte	101
	.byte	115
	.byte	115
	.byte	105
	.byte	111
	.byte	110
	.byte	32
	.byte	97
	.byte	116
	.byte	32
	.byte	108
	.byte	97
	.byte	110
	.byte	100
	.byte	109
	.byte	105
	.byte	110
	.byte	101
	.byte	115
	.byte	46
	.byte	104
	.byte	115
	.byte	58
	.byte	49
	.byte	57
	.byte	58
	.byte	57
	.byte	45
	.byte	49
	.byte	54
	.byte	0



==================== Optimised Cmm ====================
sat_segt_entry() //  [R1]
        { [(cev1,
            sat_segt_info:
                const SehZ_srt-sat_segt_info+416;
                const 0;
                const 4294967312;)]
        }
    {offset
      cev1:
          _segt::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cev2; else goto cev3;   // CmmCondBranch
      cev2:
          R1 = _segt::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cev3:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segt::P64;   // CmmStore
          R2 = cev0_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segt_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segt_info:
_cev1:
	movq %rbx,%vI_segt
	leaq -16(%rbp),%vI_nex4
	cmpq %r15,%vI_nex4
	jb _cev2
	jmp _cev3
_cev2:
	movq %vI_segt,%rbx
	jmp *-16(%r13)
_cev3:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segt,-8(%rbp)
	movl $cev0_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segt_info, .-sat_segt_info



==================== Liveness annotations added ====================
sat_segt_entry() //  [R1]
        { [(cev1,
            sat_segt_info:
                const SehZ_srt-sat_segt_info+416;
                const 0;
                const 4294967312;)]
          # entryIds         = [cev1]
          # liveVRegsOnEntry = Just [(cev1, [R1 :-> %r1]),
                                     (cev2, [segt :-> %vI_segt]), (cev3, [segt :-> %vI_segt])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cev1:
            	movq %rbx,%vI_segt
                    # born:    %vI_segt
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nex4
                    # born:    %vI_nex4
                     
            	cmpq %r15,%vI_nex4
                    # r_dying: %vI_nex4
                     
            	jb _cev2
                     
            	jmp _cev3
                    # r_dying: %vI_segt
                     ,
     NONREC
        cev2:
            	movq %vI_segt,%rbx
                    # born:    %r1
                    # r_dying: %vI_segt
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cev3:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segt,-8(%rbp)
                    # r_dying: %vI_segt
                     
            	movl $cev0_str,%r14d
                    # born:    %r14
                     
            	movl $GHC.CString.unpackCString#_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_n_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segt_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segt_info:
_cev1:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cev2
	jmp _cev3
_cev2:
	jmp *-16(%r13)
_cev3:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cev0_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segt_info, .-sat_segt_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segt_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segt_info:
_cev1:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cev2
_cev3:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cev0_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cev2:
	jmp *-16(%r13)
	.size sat_segt_info, .-sat_segt_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segt_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segt_info:
_cev1:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cev2
_cev3:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cev0_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cev2:
	jmp *-16(%r13)
	.size sat_segt_info, .-sat_segt_info



==================== Optimised Cmm ====================
section ""readonly" . cevv_str" {
    cevv_str:
        I8[] [77,105,110,101,84,121,112,101]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cevv_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	84
	.byte	121
	.byte	112
	.byte	101
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cevv_str" {
    (1,
     cevv_str:
         I8[] [77,105,110,101,84,121,112,101])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cevv_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	84
	.byte	121
	.byte	112
	.byte	101
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cevv_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	84
	.byte	121
	.byte	112
	.byte	101
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cevv_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	84
	.byte	121
	.byte	112
	.byte	101
	.byte	0



==================== Optimised Cmm ====================
sat_segE_entry() //  [R1]
        { [(cevw,
            sat_segE_info:
                const SehZ_srt-sat_segE_info+416;
                const 0;
                const 4294967312;)]
        }
    {offset
      cevw:
          _segE::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cevx; else goto cevy;   // CmmCondBranch
      cevx:
          R1 = _segE::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevy:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segE::P64;   // CmmStore
          R2 = cevv_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segE_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segE_info:
_cevw:
	movq %rbx,%vI_segE
	leaq -16(%rbp),%vI_nex8
	cmpq %r15,%vI_nex8
	jb _cevx
	jmp _cevy
_cevx:
	movq %vI_segE,%rbx
	jmp *-16(%r13)
_cevy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segE,-8(%rbp)
	movl $cevv_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segE_info, .-sat_segE_info



==================== Liveness annotations added ====================
sat_segE_entry() //  [R1]
        { [(cevw,
            sat_segE_info:
                const SehZ_srt-sat_segE_info+416;
                const 0;
                const 4294967312;)]
          # entryIds         = [cevw]
          # liveVRegsOnEntry = Just [(cevw, [R1 :-> %r1]),
                                     (cevx, [segE :-> %vI_segE]), (cevy, [segE :-> %vI_segE])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cevw:
            	movq %rbx,%vI_segE
                    # born:    %vI_segE
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nex8
                    # born:    %vI_nex8
                     
            	cmpq %r15,%vI_nex8
                    # r_dying: %vI_nex8
                     
            	jb _cevx
                     
            	jmp _cevy
                    # r_dying: %vI_segE
                     ,
     NONREC
        cevx:
            	movq %vI_segE,%rbx
                    # born:    %r1
                    # r_dying: %vI_segE
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cevy:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segE,-8(%rbp)
                    # r_dying: %vI_segE
                     
            	movl $cevv_str,%r14d
                    # born:    %r14
                     
            	movl $GHC.CString.unpackCString#_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_n_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segE_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segE_info:
_cevw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevx
	jmp _cevy
_cevx:
	jmp *-16(%r13)
_cevy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevv_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segE_info, .-sat_segE_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segE_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segE_info:
_cevw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevx
_cevy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevv_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cevx:
	jmp *-16(%r13)
	.size sat_segE_info, .-sat_segE_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segE_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segE_info:
_cevw:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevx
_cevy:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevv_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cevx:
	jmp *-16(%r13)
	.size sat_segE_info, .-sat_segE_info



==================== Optimised Cmm ====================
sat_segF_entry() //  [R1]
        { [(cevz,
            sat_segF_info:
                const SehZ_srt-sat_segF_info+408;
                const 1;
                const 12884901905;)]
        }
    {offset
      cevz:
          _segF::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cevA; else goto cevB;   // CmmCondBranch
      cevB:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cevD; else goto cevC;   // CmmCondBranch
      cevD:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cevA;   // CmmBranch
      cevA:
          R1 = _segF::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevC:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segF::P64;   // CmmStore
          _segv::P64 = P64[_segF::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segE_info;   // CmmStore
          _cevr::P64 = Hp - 8;   // CmmAssign
          R3 = _cevr::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segF_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segF_info:
_cevz:
	movq %rbx,%vI_segF
	leaq -16(%rbp),%vI_nexb
	cmpq %r15,%vI_nexb
	jb _cevA
	jmp _cevB
_cevA:
	movq %vI_segF,%rbx
	jmp *-16(%r13)
_cevB:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevD
	jmp _cevC
_cevC:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segF,-8(%rbp)
	movq 16(%vI_segF),%vI_segv
	movq $sat_segE_info,-8(%r12)
	leaq -8(%r12),%vI_cevr
	movq %vI_cevr,%rsi
	movq %vI_segv,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevD:
	movq $16,904(%r13)
	jmp _cevA
	.size sat_segF_info, .-sat_segF_info



==================== Liveness annotations added ====================
sat_segF_entry() //  [R1]
        { [(cevz,
            sat_segF_info:
                const SehZ_srt-sat_segF_info+408;
                const 1;
                const 12884901905;)]
          # entryIds         = [cevz]
          # liveVRegsOnEntry = Just [(cevz, [R1 :-> %r1]),
                                     (cevA, [segF :-> %vI_segF]), (cevB, [segF :-> %vI_segF]),
                                     (cevC, [segF :-> %vI_segF]), (cevD, [segF :-> %vI_segF])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cevz:
            	movq %rbx,%vI_segF
                    # born:    %vI_segF
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexb
                    # born:    %vI_nexb
                     
            	cmpq %r15,%vI_nexb
                    # r_dying: %vI_nexb
                     
            	jb _cevA
                     
            	jmp _cevB
                    # r_dying: %vI_segF
                     ,
     NONREC
        cevB:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cevD
                     
            	jmp _cevC
                    # r_dying: %vI_segF
                     ,
     NONREC
        cevD:
            	movq $16,904(%r13)
                     
            	jmp _cevA
                    # r_dying: %vI_segF
                     ,
     NONREC
        cevA:
            	movq %vI_segF,%rbx
                    # born:    %r1
                    # r_dying: %vI_segF
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cevC:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segF,-8(%rbp)
                     
            	movq 16(%vI_segF),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segF
                     
            	movq $sat_segE_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cevr
                    # born:    %vI_cevr
                     
            	movq %vI_cevr,%rsi
                    # born:    %r4
                    # r_dying: %vI_cevr
                     
            	movq %vI_segv,%r14
                    # born:    %r14
                    # r_dying: %vI_segv
                     
            	addq $-16,%rbp
                     
            	jmp Main.testOneFile_info
                    # r_dying: %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segF_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segF_info:
_cevz:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevA
	jmp _cevB
_cevB:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevD
	jmp _cevC
_cevD:
	movq $16,904(%r13)
	jmp _cevA
_cevA:
	jmp *-16(%r13)
_cevC:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segE_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
	.size sat_segF_info, .-sat_segF_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segF_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segF_info:
_cevz:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevA
_cevB:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevD
_cevC:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segE_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevD:
	movq $16,904(%r13)
_cevA:
	jmp *-16(%r13)
	.size sat_segF_info, .-sat_segF_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segF_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segF_info:
_cevz:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevA
_cevB:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevD
_cevC:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segE_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevD:
	movq $16,904(%r13)
_cevA:
	jmp *-16(%r13)
	.size sat_segF_info, .-sat_segF_info



==================== Optimised Cmm ====================
section ""readonly" . cevM_str" {
    cevM_str:
        I8[] [77,105,110,101,78,97,109,101,115]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cevM_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	78
	.byte	97
	.byte	109
	.byte	101
	.byte	115
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cevM_str" {
    (1,
     cevM_str:
         I8[] [77,105,110,101,78,97,109,101,115])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cevM_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	78
	.byte	97
	.byte	109
	.byte	101
	.byte	115
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cevM_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	78
	.byte	97
	.byte	109
	.byte	101
	.byte	115
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cevM_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	78
	.byte	97
	.byte	109
	.byte	101
	.byte	115
	.byte	0



==================== Optimised Cmm ====================
sat_segC_entry() //  [R1]
        { [(cevN,
            sat_segC_info:
                const SehZ_srt-sat_segC_info+416;
                const 0;
                const 4294967312;)]
        }
    {offset
      cevN:
          _segC::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cevO; else goto cevP;   // CmmCondBranch
      cevO:
          R1 = _segC::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevP:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segC::P64;   // CmmStore
          R2 = cevM_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segC_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segC_info:
_cevN:
	movq %rbx,%vI_segC
	leaq -16(%rbp),%vI_nexf
	cmpq %r15,%vI_nexf
	jb _cevO
	jmp _cevP
_cevO:
	movq %vI_segC,%rbx
	jmp *-16(%r13)
_cevP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segC,-8(%rbp)
	movl $cevM_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segC_info, .-sat_segC_info



==================== Liveness annotations added ====================
sat_segC_entry() //  [R1]
        { [(cevN,
            sat_segC_info:
                const SehZ_srt-sat_segC_info+416;
                const 0;
                const 4294967312;)]
          # entryIds         = [cevN]
          # liveVRegsOnEntry = Just [(cevN, [R1 :-> %r1]),
                                     (cevO, [segC :-> %vI_segC]), (cevP, [segC :-> %vI_segC])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cevN:
            	movq %rbx,%vI_segC
                    # born:    %vI_segC
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexf
                    # born:    %vI_nexf
                     
            	cmpq %r15,%vI_nexf
                    # r_dying: %vI_nexf
                     
            	jb _cevO
                     
            	jmp _cevP
                    # r_dying: %vI_segC
                     ,
     NONREC
        cevO:
            	movq %vI_segC,%rbx
                    # born:    %r1
                    # r_dying: %vI_segC
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cevP:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segC,-8(%rbp)
                    # r_dying: %vI_segC
                     
            	movl $cevM_str,%r14d
                    # born:    %r14
                     
            	movl $GHC.CString.unpackCString#_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_n_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segC_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segC_info:
_cevN:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevO
	jmp _cevP
_cevO:
	jmp *-16(%r13)
_cevP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevM_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segC_info, .-sat_segC_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segC_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segC_info:
_cevN:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevO
_cevP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevM_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cevO:
	jmp *-16(%r13)
	.size sat_segC_info, .-sat_segC_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segC_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segC_info:
_cevN:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevO
_cevP:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cevM_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cevO:
	jmp *-16(%r13)
	.size sat_segC_info, .-sat_segC_info



==================== Optimised Cmm ====================
sat_segD_entry() //  [R1]
        { [(cevQ,
            sat_segD_info:
                const SehZ_srt-sat_segD_info+408;
                const 1;
                const 12884901905;)]
        }
    {offset
      cevQ:
          _segD::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cevR; else goto cevS;   // CmmCondBranch
      cevS:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cevU; else goto cevT;   // CmmCondBranch
      cevU:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cevR;   // CmmBranch
      cevR:
          R1 = _segD::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevT:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segD::P64;   // CmmStore
          _segv::P64 = P64[_segD::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segC_info;   // CmmStore
          _cevI::P64 = Hp - 8;   // CmmAssign
          R3 = _cevI::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segD_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segD_info:
_cevQ:
	movq %rbx,%vI_segD
	leaq -16(%rbp),%vI_nexi
	cmpq %r15,%vI_nexi
	jb _cevR
	jmp _cevS
_cevR:
	movq %vI_segD,%rbx
	jmp *-16(%r13)
_cevS:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevU
	jmp _cevT
_cevT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segD,-8(%rbp)
	movq 16(%vI_segD),%vI_segv
	movq $sat_segC_info,-8(%r12)
	leaq -8(%r12),%vI_cevI
	movq %vI_cevI,%rsi
	movq %vI_segv,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevU:
	movq $16,904(%r13)
	jmp _cevR
	.size sat_segD_info, .-sat_segD_info



==================== Liveness annotations added ====================
sat_segD_entry() //  [R1]
        { [(cevQ,
            sat_segD_info:
                const SehZ_srt-sat_segD_info+408;
                const 1;
                const 12884901905;)]
          # entryIds         = [cevQ]
          # liveVRegsOnEntry = Just [(cevQ, [R1 :-> %r1]),
                                     (cevR, [segD :-> %vI_segD]), (cevS, [segD :-> %vI_segD]),
                                     (cevT, [segD :-> %vI_segD]), (cevU, [segD :-> %vI_segD])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cevQ:
            	movq %rbx,%vI_segD
                    # born:    %vI_segD
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexi
                    # born:    %vI_nexi
                     
            	cmpq %r15,%vI_nexi
                    # r_dying: %vI_nexi
                     
            	jb _cevR
                     
            	jmp _cevS
                    # r_dying: %vI_segD
                     ,
     NONREC
        cevS:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cevU
                     
            	jmp _cevT
                    # r_dying: %vI_segD
                     ,
     NONREC
        cevU:
            	movq $16,904(%r13)
                     
            	jmp _cevR
                    # r_dying: %vI_segD
                     ,
     NONREC
        cevR:
            	movq %vI_segD,%rbx
                    # born:    %r1
                    # r_dying: %vI_segD
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cevT:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segD,-8(%rbp)
                     
            	movq 16(%vI_segD),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segD
                     
            	movq $sat_segC_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cevI
                    # born:    %vI_cevI
                     
            	movq %vI_cevI,%rsi
                    # born:    %r4
                    # r_dying: %vI_cevI
                     
            	movq %vI_segv,%r14
                    # born:    %r14
                    # r_dying: %vI_segv
                     
            	addq $-16,%rbp
                     
            	jmp Main.testOneFile_info
                    # r_dying: %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segD_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segD_info:
_cevQ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevR
	jmp _cevS
_cevS:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevU
	jmp _cevT
_cevU:
	movq $16,904(%r13)
	jmp _cevR
_cevR:
	jmp *-16(%r13)
_cevT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segC_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
	.size sat_segD_info, .-sat_segD_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segD_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segD_info:
_cevQ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevR
_cevS:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevU
_cevT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segC_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevU:
	movq $16,904(%r13)
_cevR:
	jmp *-16(%r13)
	.size sat_segD_info, .-sat_segD_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segD_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segD_info:
_cevQ:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cevR
_cevS:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cevU
_cevT:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segC_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cevU:
	movq $16,904(%r13)
_cevR:
	jmp *-16(%r13)
	.size sat_segD_info, .-sat_segD_info



==================== Optimised Cmm ====================
sat_segG_entry() //  [R1]
        { [(cevV,
            sat_segG_info:
                const SehZ_srt-sat_segG_info+400;
                const 1;
                const 30064771089;)]
        }
    {offset
      cevV:
          _segG::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto cevW; else goto cevX;   // CmmCondBranch
      cevX:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cevZ; else goto cevY;   // CmmCondBranch
      cevZ:
          I64[BaseReg + 904] = 48;   // CmmStore
          goto cevW;   // CmmBranch
      cevW:
          R1 = _segG::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cevY:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segG::P64;   // CmmStore
          _segv::P64 = P64[_segG::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segF_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevn::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segD_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cevE::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cevE::P64;   // CmmStore
          P64[Sp - 24] = _cevn::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segG_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segG_info:
_cevV:
	movq %rbx,%vI_segG
	leaq -40(%rbp),%vI_nexl
	cmpq %r15,%vI_nexl
	jb _cevW
	jmp _cevX
_cevW:
	movq %vI_segG,%rbx
	jmp *-16(%r13)
_cevX:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cevZ
	jmp _cevY
_cevY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segG,-8(%rbp)
	movq 16(%vI_segG),%vI_segv
	movq $sat_segF_info,-40(%r12)
	movq %vI_segv,-24(%r12)
	leaq -40(%r12),%vI_cevn
	movq $sat_segD_info,-16(%r12)
	movq %vI_segv,(%r12)
	leaq -16(%r12),%vI_cevE
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_cevE,-32(%rbp)
	movq %vI_cevn,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cevZ:
	movq $48,904(%r13)
	jmp _cevW
	.size sat_segG_info, .-sat_segG_info



==================== Liveness annotations added ====================
sat_segG_entry() //  [R1]
        { [(cevV,
            sat_segG_info:
                const SehZ_srt-sat_segG_info+400;
                const 1;
                const 30064771089;)]
          # entryIds         = [cevV]
          # liveVRegsOnEntry = Just [(cevV, [R1 :-> %r1]),
                                     (cevW, [segG :-> %vI_segG]), (cevX, [segG :-> %vI_segG]),
                                     (cevY, [segG :-> %vI_segG]), (cevZ, [segG :-> %vI_segG])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cevV:
            	movq %rbx,%vI_segG
                    # born:    %vI_segG
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_nexl
                    # born:    %vI_nexl
                     
            	cmpq %r15,%vI_nexl
                    # r_dying: %vI_nexl
                     
            	jb _cevW
                     
            	jmp _cevX
                    # r_dying: %vI_segG
                     ,
     NONREC
        cevX:
            	addq $48,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cevZ
                     
            	jmp _cevY
                    # r_dying: %vI_segG
                     ,
     NONREC
        cevZ:
            	movq $48,904(%r13)
                     
            	jmp _cevW
                    # r_dying: %vI_segG
                     ,
     NONREC
        cevW:
            	movq %vI_segG,%rbx
                    # born:    %r1
                    # r_dying: %vI_segG
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cevY:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segG,-8(%rbp)
                     
            	movq 16(%vI_segG),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segG
                     
            	movq $sat_segF_info,-40(%r12)
                     
            	movq %vI_segv,-24(%r12)
                     
            	leaq -40(%r12),%vI_cevn
                    # born:    %vI_cevn
                     
            	movq $sat_segD_info,-16(%r12)
                     
            	movq %vI_segv,(%r12)
                    # r_dying: %vI_segv
                     
            	leaq -16(%r12),%vI_cevE
                    # born:    %vI_cevE
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_cevE,-32(%rbp)
                    # r_dying: %vI_cevE
                     
            	movq %vI_cevn,-24(%rbp)
                    # r_dying: %vI_cevn
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segG_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segG_info:
_cevV:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cevW
	jmp _cevX
_cevX:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cevZ
	jmp _cevY
_cevZ:
	movq $48,904(%r13)
	jmp _cevW
_cevW:
	jmp *-16(%r13)
_cevY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segF_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segD_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
	.size sat_segG_info, .-sat_segG_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segG_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segG_info:
_cevV:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cevW
_cevX:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cevZ
_cevY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segF_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segD_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cevZ:
	movq $48,904(%r13)
_cevW:
	jmp *-16(%r13)
	.size sat_segG_info, .-sat_segG_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segG_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segG_info:
_cevV:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cevW
_cevX:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cevZ
_cevY:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segF_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segD_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cevZ:
	movq $48,904(%r13)
_cevW:
	jmp *-16(%r13)
	.size sat_segG_info, .-sat_segG_info



==================== Optimised Cmm ====================
section ""readonly" . cew8_str" {
    cew8_str:
        I8[] [77,105,110,101,75,105,110,100]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cew8_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	75
	.byte	105
	.byte	110
	.byte	100
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cew8_str" {
    (1,
     cew8_str:
         I8[] [77,105,110,101,75,105,110,100])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cew8_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	75
	.byte	105
	.byte	110
	.byte	100
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cew8_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	75
	.byte	105
	.byte	110
	.byte	100
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cew8_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	75
	.byte	105
	.byte	110
	.byte	100
	.byte	0



==================== Optimised Cmm ====================
sat_segA_entry() //  [R1]
        { [(cew9,
            sat_segA_info:
                const SehZ_srt-sat_segA_info+416;
                const 0;
                const 4294967312;)]
        }
    {offset
      cew9:
          _segA::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cewa; else goto cewb;   // CmmCondBranch
      cewa:
          R1 = _segA::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewb:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segA::P64;   // CmmStore
          R2 = cew8_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segA_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segA_info:
_cew9:
	movq %rbx,%vI_segA
	leaq -16(%rbp),%vI_nexp
	cmpq %r15,%vI_nexp
	jb _cewa
	jmp _cewb
_cewa:
	movq %vI_segA,%rbx
	jmp *-16(%r13)
_cewb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segA,-8(%rbp)
	movl $cew8_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segA_info, .-sat_segA_info



==================== Liveness annotations added ====================
sat_segA_entry() //  [R1]
        { [(cew9,
            sat_segA_info:
                const SehZ_srt-sat_segA_info+416;
                const 0;
                const 4294967312;)]
          # entryIds         = [cew9]
          # liveVRegsOnEntry = Just [(cew9, [R1 :-> %r1]),
                                     (cewa, [segA :-> %vI_segA]), (cewb, [segA :-> %vI_segA])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cew9:
            	movq %rbx,%vI_segA
                    # born:    %vI_segA
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexp
                    # born:    %vI_nexp
                     
            	cmpq %r15,%vI_nexp
                    # r_dying: %vI_nexp
                     
            	jb _cewa
                     
            	jmp _cewb
                    # r_dying: %vI_segA
                     ,
     NONREC
        cewa:
            	movq %vI_segA,%rbx
                    # born:    %r1
                    # r_dying: %vI_segA
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cewb:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segA,-8(%rbp)
                    # r_dying: %vI_segA
                     
            	movl $cew8_str,%r14d
                    # born:    %r14
                     
            	movl $GHC.CString.unpackCString#_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_n_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segA_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segA_info:
_cew9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewa
	jmp _cewb
_cewa:
	jmp *-16(%r13)
_cewb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cew8_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segA_info, .-sat_segA_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segA_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segA_info:
_cew9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewa
_cewb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cew8_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cewa:
	jmp *-16(%r13)
	.size sat_segA_info, .-sat_segA_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segA_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segA_info:
_cew9:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewa
_cewb:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cew8_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_cewa:
	jmp *-16(%r13)
	.size sat_segA_info, .-sat_segA_info



==================== Optimised Cmm ====================
sat_segB_entry() //  [R1]
        { [(cewc,
            sat_segB_info:
                const SehZ_srt-sat_segB_info+408;
                const 1;
                const 12884901905;)]
        }
    {offset
      cewc:
          _segB::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cewd; else goto cewe;   // CmmCondBranch
      cewe:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cewg; else goto cewf;   // CmmCondBranch
      cewg:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cewd;   // CmmBranch
      cewd:
          R1 = _segB::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewf:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segB::P64;   // CmmStore
          _segv::P64 = P64[_segB::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segA_info;   // CmmStore
          _cew4::P64 = Hp - 8;   // CmmAssign
          R3 = _cew4::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segB_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segB_info:
_cewc:
	movq %rbx,%vI_segB
	leaq -16(%rbp),%vI_nexs
	cmpq %r15,%vI_nexs
	jb _cewd
	jmp _cewe
_cewd:
	movq %vI_segB,%rbx
	jmp *-16(%r13)
_cewe:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewg
	jmp _cewf
_cewf:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segB,-8(%rbp)
	movq 16(%vI_segB),%vI_segv
	movq $sat_segA_info,-8(%r12)
	leaq -8(%r12),%vI_cew4
	movq %vI_cew4,%rsi
	movq %vI_segv,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewg:
	movq $16,904(%r13)
	jmp _cewd
	.size sat_segB_info, .-sat_segB_info



==================== Liveness annotations added ====================
sat_segB_entry() //  [R1]
        { [(cewc,
            sat_segB_info:
                const SehZ_srt-sat_segB_info+408;
                const 1;
                const 12884901905;)]
          # entryIds         = [cewc]
          # liveVRegsOnEntry = Just [(cewc, [R1 :-> %r1]),
                                     (cewd, [segB :-> %vI_segB]), (cewe, [segB :-> %vI_segB]),
                                     (cewf, [segB :-> %vI_segB]), (cewg, [segB :-> %vI_segB])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cewc:
            	movq %rbx,%vI_segB
                    # born:    %vI_segB
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexs
                    # born:    %vI_nexs
                     
            	cmpq %r15,%vI_nexs
                    # r_dying: %vI_nexs
                     
            	jb _cewd
                     
            	jmp _cewe
                    # r_dying: %vI_segB
                     ,
     NONREC
        cewe:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cewg
                     
            	jmp _cewf
                    # r_dying: %vI_segB
                     ,
     NONREC
        cewg:
            	movq $16,904(%r13)
                     
            	jmp _cewd
                    # r_dying: %vI_segB
                     ,
     NONREC
        cewd:
            	movq %vI_segB,%rbx
                    # born:    %r1
                    # r_dying: %vI_segB
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cewf:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segB,-8(%rbp)
                     
            	movq 16(%vI_segB),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segB
                     
            	movq $sat_segA_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cew4
                    # born:    %vI_cew4
                     
            	movq %vI_cew4,%rsi
                    # born:    %r4
                    # r_dying: %vI_cew4
                     
            	movq %vI_segv,%r14
                    # born:    %r14
                    # r_dying: %vI_segv
                     
            	addq $-16,%rbp
                     
            	jmp Main.testOneFile_info
                    # r_dying: %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segB_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segB_info:
_cewc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewd
	jmp _cewe
_cewe:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewg
	jmp _cewf
_cewg:
	movq $16,904(%r13)
	jmp _cewd
_cewd:
	jmp *-16(%r13)
_cewf:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segA_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
	.size sat_segB_info, .-sat_segB_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segB_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segB_info:
_cewc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewd
_cewe:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewg
_cewf:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segA_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewg:
	movq $16,904(%r13)
_cewd:
	jmp *-16(%r13)
	.size sat_segB_info, .-sat_segB_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segB_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segB_info:
_cewc:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewd
_cewe:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewg
_cewf:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segA_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewg:
	movq $16,904(%r13)
_cewd:
	jmp *-16(%r13)
	.size sat_segB_info, .-sat_segB_info



==================== Optimised Cmm ====================
sat_segH_entry() //  [R1]
        { [(cewh,
            sat_segH_info:
                const SehZ_srt-sat_segH_info+400;
                const 1;
                const 30064771089;)]
        }
    {offset
      cewh:
          _segH::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto cewi; else goto cewj;   // CmmCondBranch
      cewj:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cewl; else goto cewk;   // CmmCondBranch
      cewl:
          I64[BaseReg + 904] = 48;   // CmmStore
          goto cewi;   // CmmBranch
      cewi:
          R1 = _segH::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewk:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segH::P64;   // CmmStore
          _segv::P64 = P64[_segH::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 40] = sat_segG_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevj::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segB_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cew0::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = _cew0::P64;   // CmmStore
          P64[Sp - 24] = _cevj::P64;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segH_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segH_info:
_cewh:
	movq %rbx,%vI_segH
	leaq -40(%rbp),%vI_nexv
	cmpq %r15,%vI_nexv
	jb _cewi
	jmp _cewj
_cewi:
	movq %vI_segH,%rbx
	jmp *-16(%r13)
_cewj:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewl
	jmp _cewk
_cewk:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segH,-8(%rbp)
	movq 16(%vI_segH),%vI_segv
	movq $sat_segG_info,-40(%r12)
	movq %vI_segv,-24(%r12)
	leaq -40(%r12),%vI_cevj
	movq $sat_segB_info,-16(%r12)
	movq %vI_segv,(%r12)
	leaq -16(%r12),%vI_cew0
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %vI_cew0,-32(%rbp)
	movq %vI_cevj,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cewl:
	movq $48,904(%r13)
	jmp _cewi
	.size sat_segH_info, .-sat_segH_info



==================== Liveness annotations added ====================
sat_segH_entry() //  [R1]
        { [(cewh,
            sat_segH_info:
                const SehZ_srt-sat_segH_info+400;
                const 1;
                const 30064771089;)]
          # entryIds         = [cewh]
          # liveVRegsOnEntry = Just [(cewh, [R1 :-> %r1]),
                                     (cewi, [segH :-> %vI_segH]), (cewj, [segH :-> %vI_segH]),
                                     (cewk, [segH :-> %vI_segH]), (cewl, [segH :-> %vI_segH])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cewh:
            	movq %rbx,%vI_segH
                    # born:    %vI_segH
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_nexv
                    # born:    %vI_nexv
                     
            	cmpq %r15,%vI_nexv
                    # r_dying: %vI_nexv
                     
            	jb _cewi
                     
            	jmp _cewj
                    # r_dying: %vI_segH
                     ,
     NONREC
        cewj:
            	addq $48,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cewl
                     
            	jmp _cewk
                    # r_dying: %vI_segH
                     ,
     NONREC
        cewl:
            	movq $48,904(%r13)
                     
            	jmp _cewi
                    # r_dying: %vI_segH
                     ,
     NONREC
        cewi:
            	movq %vI_segH,%rbx
                    # born:    %r1
                    # r_dying: %vI_segH
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cewk:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segH,-8(%rbp)
                     
            	movq 16(%vI_segH),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segH
                     
            	movq $sat_segG_info,-40(%r12)
                     
            	movq %vI_segv,-24(%r12)
                     
            	leaq -40(%r12),%vI_cevj
                    # born:    %vI_cevj
                     
            	movq $sat_segB_info,-16(%r12)
                     
            	movq %vI_segv,(%r12)
                    # r_dying: %vI_segv
                     
            	leaq -16(%r12),%vI_cew0
                    # born:    %vI_cew0
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq %vI_cew0,-32(%rbp)
                    # r_dying: %vI_cew0
                     
            	movq %vI_cevj,-24(%rbp)
                    # r_dying: %vI_cevj
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segH_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segH_info:
_cewh:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cewi
	jmp _cewj
_cewj:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewl
	jmp _cewk
_cewl:
	movq $48,904(%r13)
	jmp _cewi
_cewi:
	jmp *-16(%r13)
_cewk:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segG_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segB_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
	.size sat_segH_info, .-sat_segH_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segH_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segH_info:
_cewh:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cewi
_cewj:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewl
_cewk:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segG_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segB_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cewl:
	movq $48,904(%r13)
_cewi:
	jmp *-16(%r13)
	.size sat_segH_info, .-sat_segH_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segH_info)+400
	.long	0
	.quad	1
	.quad	30064771089
sat_segH_info:
_cewh:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cewi
_cewj:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewl
_cewk:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segG_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segB_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq %rax,-32(%rbp)
	movq %rbx,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>_info
_cewl:
	movq $48,904(%r13)
_cewi:
	jmp *-16(%r13)
	.size sat_segH_info, .-sat_segH_info



==================== Optimised Cmm ====================
section ""readonly" . cewu_str" {
    cewu_str:
        I8[] [77,105,110,101,70,105,120,105,116,121]
}



==================== Native code ====================
.section .rodata
.align 8
.align 1
cewu_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	70
	.byte	105
	.byte	120
	.byte	105
	.byte	116
	.byte	121
	.byte	0



==================== Liveness annotations added ====================
section ""readonly" . cewu_str" {
    (1,
     cewu_str:
         I8[] [77,105,110,101,70,105,120,105,116,121])
}



==================== Registers allocated ====================
.section .rodata
.align 8
.align 1
cewu_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	70
	.byte	105
	.byte	120
	.byte	105
	.byte	116
	.byte	121
	.byte	0



==================== Synthetic instructions expanded ====================
.section .rodata
.align 8
.align 1
cewu_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	70
	.byte	105
	.byte	120
	.byte	105
	.byte	116
	.byte	121
	.byte	0



==================== Asm code ====================
.section .rodata
.align 8
.align 1
cewu_str:
	.byte	77
	.byte	105
	.byte	110
	.byte	101
	.byte	70
	.byte	105
	.byte	120
	.byte	105
	.byte	116
	.byte	121
	.byte	0



==================== Optimised Cmm ====================
sat_segy_entry() //  [R1]
        { [(cewv,
            sat_segy_info:
                const SehZ_srt-sat_segy_info+416;
                const 0;
                const 4294967312;)]
        }
    {offset
      cewv:
          _segy::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto ceww; else goto cewx;   // CmmCondBranch
      ceww:
          R1 = _segy::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewx:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segy::P64;   // CmmStore
          R2 = cewu_str;   // CmmAssign
          R1 = GHC.CString.unpackCString#_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_n_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segy_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segy_info:
_cewv:
	movq %rbx,%vI_segy
	leaq -16(%rbp),%vI_nexz
	cmpq %r15,%vI_nexz
	jb _ceww
	jmp _cewx
_ceww:
	movq %vI_segy,%rbx
	jmp *-16(%r13)
_cewx:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segy,-8(%rbp)
	movl $cewu_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segy_info, .-sat_segy_info



==================== Liveness annotations added ====================
sat_segy_entry() //  [R1]
        { [(cewv,
            sat_segy_info:
                const SehZ_srt-sat_segy_info+416;
                const 0;
                const 4294967312;)]
          # entryIds         = [cewv]
          # liveVRegsOnEntry = Just [(cewv, [R1 :-> %r1]),
                                     (ceww, [segy :-> %vI_segy]), (cewx, [segy :-> %vI_segy])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cewv:
            	movq %rbx,%vI_segy
                    # born:    %vI_segy
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexz
                    # born:    %vI_nexz
                     
            	cmpq %r15,%vI_nexz
                    # r_dying: %vI_nexz
                     
            	jb _ceww
                     
            	jmp _cewx
                    # r_dying: %vI_segy
                     ,
     NONREC
        ceww:
            	movq %vI_segy,%rbx
                    # born:    %r1
                    # r_dying: %vI_segy
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cewx:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segy,-8(%rbp)
                    # r_dying: %vI_segy
                     
            	movl $cewu_str,%r14d
                    # born:    %r14
                     
            	movl $GHC.CString.unpackCString#_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_n_fast
                    # r_dying: %r1 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segy_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segy_info:
_cewv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceww
	jmp _cewx
_ceww:
	jmp *-16(%r13)
_cewx:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cewu_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
	.size sat_segy_info, .-sat_segy_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segy_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segy_info:
_cewv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceww
_cewx:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cewu_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_ceww:
	jmp *-16(%r13)
	.size sat_segy_info, .-sat_segy_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segy_info)+416
	.long	0
	.quad	0
	.quad	4294967312
sat_segy_info:
_cewv:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _ceww
_cewx:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movl $cewu_str,%r14d
	movl $GHC.CString.unpackCString#_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_n_fast
_ceww:
	jmp *-16(%r13)
	.size sat_segy_info, .-sat_segy_info



==================== Optimised Cmm ====================
sat_segz_entry() //  [R1]
        { [(cewy,
            sat_segz_info:
                const SehZ_srt-sat_segz_info+408;
                const 1;
                const 12884901905;)]
        }
    {offset
      cewy:
          _segz::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cewz; else goto cewA;   // CmmCondBranch
      cewA:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cewC; else goto cewB;   // CmmCondBranch
      cewC:
          I64[BaseReg + 904] = 16;   // CmmStore
          goto cewz;   // CmmBranch
      cewz:
          R1 = _segz::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewB:
          I64[Sp - 16] = stg_upd_frame_info;   // CmmStore
          P64[Sp - 8] = _segz::P64;   // CmmStore
          _segv::P64 = P64[_segz::P64 + 16];   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 8] = sat_segy_info;   // CmmStore
          _cewq::P64 = Hp - 8;   // CmmAssign
          R3 = _cewq::P64;   // CmmAssign
          R2 = _segv::P64;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call Main.testOneFile_info(R3,
                                     R2) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segz_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segz_info:
_cewy:
	movq %rbx,%vI_segz
	leaq -16(%rbp),%vI_nexC
	cmpq %r15,%vI_nexC
	jb _cewz
	jmp _cewA
_cewz:
	movq %vI_segz,%rbx
	jmp *-16(%r13)
_cewA:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewC
	jmp _cewB
_cewB:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %vI_segz,-8(%rbp)
	movq 16(%vI_segz),%vI_segv
	movq $sat_segy_info,-8(%r12)
	leaq -8(%r12),%vI_cewq
	movq %vI_cewq,%rsi
	movq %vI_segv,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewC:
	movq $16,904(%r13)
	jmp _cewz
	.size sat_segz_info, .-sat_segz_info



==================== Liveness annotations added ====================
sat_segz_entry() //  [R1]
        { [(cewy,
            sat_segz_info:
                const SehZ_srt-sat_segz_info+408;
                const 1;
                const 12884901905;)]
          # entryIds         = [cewy]
          # liveVRegsOnEntry = Just [(cewy, [R1 :-> %r1]),
                                     (cewz, [segz :-> %vI_segz]), (cewA, [segz :-> %vI_segz]),
                                     (cewB, [segz :-> %vI_segz]), (cewC, [segz :-> %vI_segz])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cewy:
            	movq %rbx,%vI_segz
                    # born:    %vI_segz
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_nexC
                    # born:    %vI_nexC
                     
            	cmpq %r15,%vI_nexC
                    # r_dying: %vI_nexC
                     
            	jb _cewz
                     
            	jmp _cewA
                    # r_dying: %vI_segz
                     ,
     NONREC
        cewA:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cewC
                     
            	jmp _cewB
                    # r_dying: %vI_segz
                     ,
     NONREC
        cewC:
            	movq $16,904(%r13)
                     
            	jmp _cewz
                    # r_dying: %vI_segz
                     ,
     NONREC
        cewz:
            	movq %vI_segz,%rbx
                    # born:    %r1
                    # r_dying: %vI_segz
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ,
     NONREC
        cewB:
            	movq $stg_upd_frame_info,-16(%rbp)
                     
            	movq %vI_segz,-8(%rbp)
                     
            	movq 16(%vI_segz),%vI_segv
                    # born:    %vI_segv
                    # r_dying: %vI_segz
                     
            	movq $sat_segy_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_cewq
                    # born:    %vI_cewq
                     
            	movq %vI_cewq,%rsi
                    # born:    %r4
                    # r_dying: %vI_cewq
                     
            	movq %vI_segv,%r14
                    # born:    %r14
                    # r_dying: %vI_segv
                     
            	addq $-16,%rbp
                     
            	jmp Main.testOneFile_info
                    # r_dying: %r4 %r14
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segz_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segz_info:
_cewy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewz
	jmp _cewA
_cewA:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewC
	jmp _cewB
_cewC:
	movq $16,904(%r13)
	jmp _cewz
_cewz:
	jmp *-16(%r13)
_cewB:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segy_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
	.size sat_segz_info, .-sat_segz_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segz_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segz_info:
_cewy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewz
_cewA:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewC
_cewB:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segy_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewC:
	movq $16,904(%r13)
_cewz:
	jmp *-16(%r13)
	.size sat_segz_info, .-sat_segz_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segz_info)+408
	.long	0
	.quad	1
	.quad	12884901905
sat_segz_info:
_cewy:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cewz
_cewA:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewC
_cewB:
	movq $stg_upd_frame_info,-16(%rbp)
	movq %rbx,-8(%rbp)
	movq 16(%rbx),%rax
	movq $sat_segy_info,-8(%r12)
	leaq -8(%r12),%rbx
	movq %rbx,%rsi
	movq %rax,%r14
	addq $-16,%rbp
	jmp Main.testOneFile_info
_cewC:
	movq $16,904(%r13)
_cewz:
	jmp *-16(%r13)
	.size sat_segz_info, .-sat_segz_info



==================== Optimised Cmm ====================
sat_segK_entry() //  [R2]
        { [(ceuT,
            block_ceuT_info:
                const SehZ_srt-block_ceuT_info+400;
                const 0;
                const 21474836512;),
           (cev4,
            block_cev4_info:
                const SehZ_srt-block_cev4_info+400;
                const 0;
                const 30064771104;),
           (ceva,
            block_ceva_info:
                const SehZ_srt-block_ceva_info+400;
                const 1;
                const 30064771104;),
           (cewH,
            sat_segK_info:
                const SehZ_srt-sat_segK_info+400;
                const 4294967301;
                const 0;
                const 64424509455;)]
        }
    {offset
      cewH:
          _segq::P64 = R2;   // CmmAssign
          if ((Sp + -24) < SpLim) goto cewI; else goto cewJ;   // CmmCondBranch
      cewI:
          R2 = _segq::P64;   // CmmAssign
          R1 = sat_segK_closure;   // CmmAssign
          call (I64[BaseReg - 8])(R2,
                                  R1) args: 8, res: 0, upd: 8;   // CmmCall
      cewJ:
          I64[Sp - 8] = block_cev4_info;   // CmmStore
          R1 = _segq::P64;   // CmmAssign
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto cev4; else goto cev5;   // CmmCondBranch
      cev5:
          call (I64[R1])(R1) returns to cev4, args: 8, res: 8, upd: 8;   // CmmCall
      cev4:
          _segu::P64 = R1;   // CmmAssign
          _cewG::P64 = _segu::P64 & 7;   // CmmAssign
          if (_cewG::P64 != 1) goto cewF; else goto ceuU;   // CmmCondBranch
      cewF:
          _segv::P64 = P64[_segu::P64 + 6];   // CmmAssign
          _segw::P64 = P64[_segu::P64 + 14];   // CmmAssign
          I64[Sp - 8] = block_ceva_info;   // CmmStore
          R1 = _segw::P64;   // CmmAssign
          P64[Sp] = _segv::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          if (R1 & 7 != 0) goto ceva; else goto cevb;   // CmmCondBranch
      cevb:
          call (I64[R1])(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      ceva:
          _segv::P64 = P64[Sp + 8];   // CmmAssign
          _segx::P64 = R1;   // CmmAssign
          _cewZ::P64 = _segx::P64 & 7;   // CmmAssign
          if (_cewZ::P64 != 1) goto cewY; else goto cewR;   // CmmCondBranch
      cewY:
          _segI::P64 = P64[_segx::P64 + 6];   // CmmAssign
          _segJ::P64 = P64[_segx::P64 + 14];   // CmmAssign
          goto uex0;   // CmmBranch
      uex0:
          Sp = Sp + 8;   // CmmAssign
          goto ceuU;   // CmmBranch
      cewR:
          Hp = Hp + 48;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cewU; else goto cewT;   // CmmCondBranch
      cewU:
          I64[BaseReg + 904] = 48;   // CmmStore
          R1 = _segx::P64;   // CmmAssign
          call stg_gc_unpt_r1(R1) returns to ceva, args: 8, res: 8, upd: 8;   // CmmCall
      cewT:
          // calling allocDynClosure
          I64[Hp - 40] = sat_segH_info;   // CmmStore
          P64[Hp - 24] = _segv::P64;   // CmmStore
          _cevf::P64 = Hp - 40;   // CmmAssign
          // calling allocDynClosure
          I64[Hp - 16] = sat_segz_info;   // CmmStore
          P64[Hp] = _segv::P64;   // CmmStore
          _cewm::P64 = Hp - 16;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_pp_info;   // CmmStore
          P64[Sp] = _cewm::P64;   // CmmStore
          P64[Sp + 8] = _cevf::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.>>_info(R2) args: 32, res: 0, upd: 8;   // CmmCall
      ceuU:
          Hp = Hp + 16;   // CmmAssign
          if (Hp > I64[BaseReg + 856]) goto cewM; else goto cewL;   // CmmCondBranch
      cewM:
          I64[BaseReg + 904] = 16;   // CmmStore
          I64[Sp] = block_ceuT_info;   // CmmStore
          call stg_gc_noregs() returns to ceuT, args: 8, res: 8, upd: 8;   // CmmCall
      ceuT:
          goto ceuU;   // CmmBranch
      cewL:
          // calling allocDynClosure
          I64[Hp - 8] = sat_segt_info;   // CmmStore
          _ceuW::P64 = Hp - 8;   // CmmAssign
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 8] = stg_ap_p_info;   // CmmStore
          P64[Sp] = _ceuW::P64;   // CmmStore
          Sp = Sp - 8;   // CmmAssign
          call GHC.Base.fail_info(R2) args: 24, res: 0, upd: 8;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segK_info)+400
	.long	0
	.quad	4294967301
	.quad	0
	.quad	64424509455
sat_segK_info:
_cewH:
	movq %r14,%vI_segq
	leaq -24(%rbp),%vI_nexF
	cmpq %r15,%vI_nexF
	jb _cewI
	jmp _cewJ
	.long	SehZ_srt-(block_ceuT_info)+400
	.long	0
	.quad	0
	.quad	21474836512
block_ceuT_info:
_ceuT:
	jmp _ceuU
_ceuU:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewM
	jmp _cewL
	.long	SehZ_srt-(block_cev4_info)+400
	.long	0
	.quad	0
	.quad	30064771104
block_cev4_info:
_cev4:
	movq %rbx,%vI_segu
	movq %vI_segu,%vI_cewG
	andl $7,%vI_cewG
	cmpq $1,%vI_cewG
	jne _cewF
	jmp _ceuU
_cev5:
	jmp *(%rbx)
	.long	SehZ_srt-(block_ceva_info)+400
	.long	0
	.quad	1
	.quad	30064771104
block_ceva_info:
_ceva:
	movq 8(%rbp),%vI_segv
	movq %rbx,%vI_segx
	movq %vI_segx,%vI_cewZ
	andl $7,%vI_cewZ
	cmpq $1,%vI_cewZ
	jne _cewY
	jmp _cewR
_cevb:
	jmp *(%rbx)
_cewF:
	movq 6(%vI_segu),%vI_segv
	movq 14(%vI_segu),%vI_segw
	movq $block_ceva_info,-8(%rbp)
	movq %vI_segw,%rbx
	movq %vI_segv,(%rbp)
	addq $-8,%rbp
	testb $7,%bl
	jne _ceva
	jmp _cevb
_cewI:
	movq %vI_segq,%r14
	movl $sat_segK_closure,%ebx
	jmp *-8(%r13)
_cewJ:
	movq $block_cev4_info,-8(%rbp)
	movq %vI_segq,%rbx
	addq $-8,%rbp
	testb $7,%bl
	jne _cev4
	jmp _cev5
_cewL:
	movq $sat_segt_info,-8(%r12)
	leaq -8(%r12),%vI_ceuW
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_p_info,-8(%rbp)
	movq %vI_ceuW,(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.fail_info
_cewM:
	movq $16,904(%r13)
	movq $block_ceuT_info,(%rbp)
	jmp stg_gc_noregs
_cewR:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewU
	jmp _cewT
_cewT:
	movq $sat_segH_info,-40(%r12)
	movq %vI_segv,-24(%r12)
	leaq -40(%r12),%vI_cevf
	movq $sat_segz_info,-16(%r12)
	movq %vI_segv,(%r12)
	leaq -16(%r12),%vI_cewm
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-8(%rbp)
	movq %vI_cewm,(%rbp)
	movq %vI_cevf,8(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.>>_info
_cewU:
	movq $48,904(%r13)
	movq %vI_segx,%rbx
	jmp stg_gc_unpt_r1
_cewY:
	movq 6(%vI_segx),%vI_segI
	movq 14(%vI_segx),%vI_segJ
	jmp _uex0
_uex0:
	addq $8,%rbp
	jmp _ceuU
	.size sat_segK_info, .-sat_segK_info



==================== Liveness annotations added ====================
sat_segK_entry() //  [R2]
        { [(ceuT,
            block_ceuT_info:
                const SehZ_srt-block_ceuT_info+400;
                const 0;
                const 21474836512;),
           (cev4,
            block_cev4_info:
                const SehZ_srt-block_cev4_info+400;
                const 0;
                const 30064771104;),
           (ceva,
            block_ceva_info:
                const SehZ_srt-block_ceva_info+400;
                const 1;
                const 30064771104;),
           (cewH,
            sat_segK_info:
                const SehZ_srt-sat_segK_info+400;
                const 4294967301;
                const 0;
                const 64424509455;)]
          # entryIds         = [cewH, ceuT, cev4, ceva]
          # liveVRegsOnEntry = Just [(ceuT, []), (ceuU, []),
                                     (cev4, [R1 :-> %r1]), (cev5, [R1 :-> %r1]),
                                     (ceva, [R1 :-> %r1]), (cevb, [R1 :-> %r1]),
                                     (cewF, [segu :-> %vI_segu]), (cewH, [Re :-> %r14]),
                                     (cewI, [segq :-> %vI_segq]), (cewJ, [segq :-> %vI_segq]),
                                     (cewL, []), (cewM, []),
                                     (cewR, [segv :-> %vI_segv, segx :-> %vI_segx]),
                                     (cewT, [segv :-> %vI_segv]), (cewU, [segx :-> %vI_segx]),
                                     (cewY, [segx :-> %vI_segx]), (uex0, [])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cewH:
            	movq %r14,%vI_segq
                    # born:    %vI_segq
                    # r_dying: %r14
                     
            	leaq -24(%rbp),%vI_nexF
                    # born:    %vI_nexF
                     
            	cmpq %r15,%vI_nexF
                    # r_dying: %vI_nexF
                     
            	jb _cewI
                     
            	jmp _cewJ
                    # r_dying: %vI_segq
                     ,
     NONREC
        ceuT:
            	jmp _ceuU
                     ,
     NONREC
        cewJ:
            	movq $block_cev4_info,-8(%rbp)
                     
            	movq %vI_segq,%rbx
                    # born:    %r1
                    # r_dying: %vI_segq
                     
            	addq $-8,%rbp
                     
            	testb $7,%bl
                     
            	jne _cev4
                     
            	jmp _cev5
                    # r_dying: %r1
                     ,
     NONREC
        cev4:
            	movq %rbx,%vI_segu
                    # born:    %vI_segu
                    # r_dying: %r1
                     
            	movq %vI_segu,%vI_cewG
                    # born:    %vI_cewG
                     
            	andl $7,%vI_cewG
                     
            	cmpq $1,%vI_cewG
                    # r_dying: %vI_cewG
                     
            	jne _cewF
                    # r_dying: %vI_segu
                     
            	jmp _ceuU
                     ,
     NONREC
        cewF:
            	movq 6(%vI_segu),%vI_segv
                    # born:    %vI_segv
                     
            	movq 14(%vI_segu),%vI_segw
                    # born:    %vI_segw
                    # r_dying: %vI_segu
                     
            	movq $block_ceva_info,-8(%rbp)
                     
            	movq %vI_segw,%rbx
                    # born:    %r1
                    # r_dying: %vI_segw
                     
            	movq %vI_segv,(%rbp)
                    # r_dying: %vI_segv
                     
            	addq $-8,%rbp
                     
            	testb $7,%bl
                     
            	jne _ceva
                     
            	jmp _cevb
                    # r_dying: %r1
                     ,
     NONREC
        ceva:
            	movq 8(%rbp),%vI_segv
                    # born:    %vI_segv
                     
            	movq %rbx,%vI_segx
                    # born:    %vI_segx
                    # r_dying: %r1
                     
            	movq %vI_segx,%vI_cewZ
                    # born:    %vI_cewZ
                     
            	andl $7,%vI_cewZ
                     
            	cmpq $1,%vI_cewZ
                    # r_dying: %vI_cewZ
                     
            	jne _cewY
                     
            	jmp _cewR
                    # r_dying: %vI_segv %vI_segx
                     ,
     NONREC
        cewY:
            	movq 6(%vI_segx),%vI_segI
                    # born:    %vI_segI
                    # w_dying: %vI_segI
                     
            	movq 14(%vI_segx),%vI_segJ
                    # born:    %vI_segJ
                    # r_dying: %vI_segx
                    # w_dying: %vI_segJ
                     
            	jmp _uex0
                     ,
     NONREC
        uex0:
            	addq $8,%rbp
                     
            	jmp _ceuU
                     ,
     NONREC
        ceuU:
            	addq $16,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cewM
                     
            	jmp _cewL
                     ,
     NONREC
        cev5:
            	jmp *(%rbx)
                    # r_dying: %r1
                     ,
     NONREC
        cevb:
            	jmp *(%rbx)
                    # r_dying: %r1
                     ,
     NONREC
        cewI:
            	movq %vI_segq,%r14
                    # born:    %r14
                    # r_dying: %vI_segq
                     
            	movl $sat_segK_closure,%ebx
                    # born:    %r1
                     
            	jmp *-8(%r13)
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cewL:
            	movq $sat_segt_info,-8(%r12)
                     
            	leaq -8(%r12),%vI_ceuW
                    # born:    %vI_ceuW
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_p_info,-8(%rbp)
                     
            	movq %vI_ceuW,(%rbp)
                    # r_dying: %vI_ceuW
                     
            	addq $-8,%rbp
                     
            	jmp GHC.Base.fail_info
                    # r_dying: %r14
                     ,
     NONREC
        cewM:
            	movq $16,904(%r13)
                     
            	movq $block_ceuT_info,(%rbp)
                     
            	jmp stg_gc_noregs
                     ,
     NONREC
        cewR:
            	addq $48,%r12
                     
            	cmpq 856(%r13),%r12
                     
            	ja _cewU
                    # r_dying: %vI_segx
                     
            	jmp _cewT
                    # r_dying: %vI_segv
                     ,
     NONREC
        cewT:
            	movq $sat_segH_info,-40(%r12)
                     
            	movq %vI_segv,-24(%r12)
                     
            	leaq -40(%r12),%vI_cevf
                    # born:    %vI_cevf
                     
            	movq $sat_segz_info,-16(%r12)
                     
            	movq %vI_segv,(%r12)
                    # r_dying: %vI_segv
                     
            	leaq -16(%r12),%vI_cewm
                    # born:    %vI_cewm
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-8(%rbp)
                     
            	movq %vI_cewm,(%rbp)
                    # r_dying: %vI_cewm
                     
            	movq %vI_cevf,8(%rbp)
                    # r_dying: %vI_cevf
                     
            	addq $-8,%rbp
                     
            	jmp GHC.Base.>>_info
                    # r_dying: %r14
                     ,
     NONREC
        cewU:
            	movq $48,904(%r13)
                     
            	movq %vI_segx,%rbx
                    # born:    %r1
                    # r_dying: %vI_segx
                     
            	jmp stg_gc_unpt_r1
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segK_info)+400
	.long	0
	.quad	4294967301
	.quad	0
	.quad	64424509455
sat_segK_info:
_cewH:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cewI
	jmp _cewJ
	.long	SehZ_srt-(block_ceuT_info)+400
	.long	0
	.quad	0
	.quad	21474836512
block_ceuT_info:
_ceuT:
	jmp _ceuU
_cewJ:
	movq $block_cev4_info,-8(%rbp)
	movq %r14,%rbx
	addq $-8,%rbp
	testb $7,%bl
	jne _cev4
	jmp _cev5
	.long	SehZ_srt-(block_cev4_info)+400
	.long	0
	.quad	0
	.quad	30064771104
block_cev4_info:
_cev4:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cewF
	jmp _ceuU
_cewF:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq $block_ceva_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	testb $7,%bl
	jne _ceva
	jmp _cevb
	.long	SehZ_srt-(block_ceva_info)+400
	.long	0
	.quad	1
	.quad	30064771104
block_ceva_info:
_ceva:
	movq 8(%rbp),%rax
	movq %rbx,%rcx
	andl $7,%ecx
	cmpq $1,%rcx
	jne _cewY
	jmp _cewR
_cewY:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rax
	jmp _uex0
_uex0:
	addq $8,%rbp
	jmp _ceuU
_ceuU:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewM
	jmp _cewL
_cev5:
	jmp *(%rbx)
_cevb:
	jmp *(%rbx)
_cewI:
	movl $sat_segK_closure,%ebx
	jmp *-8(%r13)
_cewL:
	movq $sat_segt_info,-8(%r12)
	leaq -8(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_p_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.fail_info
_cewM:
	movq $16,904(%r13)
	movq $block_ceuT_info,(%rbp)
	jmp stg_gc_noregs
_cewR:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewU
	jmp _cewT
_cewT:
	movq $sat_segH_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segz_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-8(%rbp)
	movq %rax,(%rbp)
	movq %rbx,8(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.>>_info
_cewU:
	movq $48,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segK_info, .-sat_segK_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segK_info)+400
	.long	0
	.quad	4294967301
	.quad	0
	.quad	64424509455
sat_segK_info:
_cewH:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cewI
_cewJ:
	movq $block_cev4_info,-8(%rbp)
	movq %r14,%rbx
	addq $-8,%rbp
	testb $7,%bl
	jne _cev4
_cev5:
	jmp *(%rbx)
	.long	SehZ_srt-(block_ceuT_info)+400
	.long	0
	.quad	0
	.quad	21474836512
block_ceuT_info:
_ceuT:
_ceuU:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewM
_cewL:
	movq $sat_segt_info,-8(%r12)
	leaq -8(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_p_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.fail_info
	.long	SehZ_srt-(block_cev4_info)+400
	.long	0
	.quad	0
	.quad	30064771104
block_cev4_info:
_cev4:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cewF
	jmp _ceuU
_cewF:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq $block_ceva_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	testb $7,%bl
	jne _ceva
_cevb:
	jmp *(%rbx)
	.long	SehZ_srt-(block_ceva_info)+400
	.long	0
	.quad	1
	.quad	30064771104
block_ceva_info:
_ceva:
	movq 8(%rbp),%rax
	movq %rbx,%rcx
	andl $7,%ecx
	cmpq $1,%rcx
	jne _cewY
_cewR:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewU
_cewT:
	movq $sat_segH_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segz_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-8(%rbp)
	movq %rax,(%rbp)
	movq %rbx,8(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.>>_info
_cewY:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rax
_uex0:
	addq $8,%rbp
	jmp _ceuU
_cewI:
	movl $sat_segK_closure,%ebx
	jmp *-8(%r13)
_cewM:
	movq $16,904(%r13)
	movq $block_ceuT_info,(%rbp)
	jmp stg_gc_noregs
_cewU:
	movq $48,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segK_info, .-sat_segK_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(sat_segK_info)+400
	.long	0
	.quad	4294967301
	.quad	0
	.quad	64424509455
sat_segK_info:
_cewH:
	leaq -24(%rbp),%rax
	cmpq %r15,%rax
	jb _cewI
_cewJ:
	movq $block_cev4_info,-8(%rbp)
	movq %r14,%rbx
	addq $-8,%rbp
	testb $7,%bl
	jne _cev4
_cev5:
	jmp *(%rbx)
	.long	SehZ_srt-(block_ceuT_info)+400
	.long	0
	.quad	0
	.quad	21474836512
block_ceuT_info:
_ceuT:
_ceuU:
	addq $16,%r12
	cmpq 856(%r13),%r12
	ja _cewM
_cewL:
	movq $sat_segt_info,-8(%r12)
	leaq -8(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_p_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.fail_info
	.long	SehZ_srt-(block_cev4_info)+400
	.long	0
	.quad	0
	.quad	30064771104
block_cev4_info:
_cev4:
	movq %rbx,%rax
	andl $7,%eax
	cmpq $1,%rax
	jne _cewF
	jmp _ceuU
_cewF:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rbx
	movq $block_ceva_info,-8(%rbp)
	movq %rax,(%rbp)
	addq $-8,%rbp
	testb $7,%bl
	jne _ceva
_cevb:
	jmp *(%rbx)
	.long	SehZ_srt-(block_ceva_info)+400
	.long	0
	.quad	1
	.quad	30064771104
block_ceva_info:
_ceva:
	movq 8(%rbp),%rax
	movq %rbx,%rcx
	andl $7,%ecx
	cmpq $1,%rcx
	jne _cewY
_cewR:
	addq $48,%r12
	cmpq 856(%r13),%r12
	ja _cewU
_cewT:
	movq $sat_segH_info,-40(%r12)
	movq %rax,-24(%r12)
	leaq -40(%r12),%rbx
	movq $sat_segz_info,-16(%r12)
	movq %rax,(%r12)
	leaq -16(%r12),%rax
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-8(%rbp)
	movq %rax,(%rbp)
	movq %rbx,8(%rbp)
	addq $-8,%rbp
	jmp GHC.Base.>>_info
_cewY:
	movq 6(%rbx),%rax
	movq 14(%rbx),%rax
_uex0:
	addq $8,%rbp
	jmp _ceuU
_cewI:
	movl $sat_segK_closure,%ebx
	jmp *-8(%r13)
_cewM:
	movq $16,904(%r13)
	movq $block_ceuT_info,(%rbp)
	jmp stg_gc_noregs
_cewU:
	movq $48,904(%r13)
	jmp stg_gc_unpt_r1
	.size sat_segK_info, .-sat_segK_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . Main.main_closure" {
     Main.main_closure:
         const Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main_entry() //  [R1]
         { info_tbl: [(cexP,
                       label: Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cexP:
           _r3PH::P64 = R1;   // CmmAssign
           goto cexK;   // CmmBranch
       cexK:
           if ((old + 0) - <highSp> < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
       cexQ:
           R1 = _r3PH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cexR:
           (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
           if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
       cexO:
           call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cexN:
           I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
           I64[(old + 16)] = _cexM::I64;   // CmmStore
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
           P64[(old + 40)] = System.Environment.getArgs_closure;   // CmmStore
           P64[(old + 32)] = sat_segK_closure+1;   // CmmStore
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cexP:
      _r3PH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
  cexQ:
      R1 = _r3PH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cexR:
      (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
      if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
  cexO:
      call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cexN:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _cexM::I64;   // CmmStore
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = System.Environment.getArgs_closure;   // CmmStore
      P64[(old + 32)] = sat_segK_closure+1;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cexP:
      _r3PH::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
  cexQ:
      R1 = _r3PH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cexR:
      (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
      if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
  cexO:
      call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cexN:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _cexM::I64;   // CmmStore
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[(old + 48)] = stg_ap_pp_info;   // CmmStore
      P64[(old + 40)] = System.Environment.getArgs_closure;   // CmmStore
      P64[(old + 32)] = sat_segK_closure+1;   // CmmStore
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cexP:
      _r3PH::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
  cexQ:
      R1 = _r3PH::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cexR:
      (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
      if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
  cexO:
      call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cexN:
      I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
      I64[Sp - 8] = _cexM::I64;   // CmmStore
      R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
      I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
      P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
      P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
      Sp = Sp - 40;   // CmmAssign
      call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cexN,
  {System.Environment.getArgs_closure, GHC.Base.$fMonadIO_closure,
   sat_segK_closure}),
 (cexO, {}),
 (cexP,
  {System.Environment.getArgs_closure, GHC.Base.$fMonadIO_closure,
   sat_segK_closure}),
 (cexQ, {}),
 (cexR,
  {System.Environment.getArgs_closure, GHC.Base.$fMonadIO_closure,
   sat_segK_closure})]



==================== after setInfoTableStackMap ====================
Main.main_entry() //  [R1]
        { info_tbl: [(cexP,
                      label: Main.main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cexP:
          _r3PH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
      cexQ:
          R1 = _r3PH::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cexR:
          (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
          if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
      cexO:
          call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cexN:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexM::I64;   // CmmStore
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
          P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
Main.main_entry() //  [R1]
        { info_tbl: [(cexP,
                      label: Main.main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cexP:
          _r3PH::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
      cexQ:
          R1 = _r3PH::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cexR:
          (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
          if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
      cexO:
          call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cexN:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexM::I64;   // CmmStore
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
          P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . Main.main_closure" {
     Main.main_closure:
         const Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main_entry() //  [R1]
         { info_tbl: [(cexP,
                       label: Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cexP:
           _r3PH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
       cexQ:
           R1 = _r3PH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cexR:
           (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
           if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
       cexO:
           call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cexN:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexM::I64;   // CmmStore
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
           P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . Main.main_closure" {
     Main.main_closure:
         const Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main_entry() //  [R1]
         { info_tbl: [(cexP,
                       label: Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cexP:
           _r3PH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
       cexQ:
           R1 = _r3PH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cexR:
           (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
           if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
       cexO:
           call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cexN:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexM::I64;   // CmmStore
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
           P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . Main.main_closure" {
     Main.main_closure:
         const Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 Main.main_entry() //  [R1]
         { [(cexP,
             Main.main_info:
                 const SehZ_srt-Main.main_info+400;
                 const 0;
                 const 107374182422;)]
         }
     {offset
       cexP:
           _r3PH::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 48 < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
       cexQ:
           R1 = _r3PH::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cexR:
           (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
           if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
       cexO:
           call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cexN:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexM::I64;   // CmmStore
           R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
           I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
           P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
           P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
           Sp = Sp - 40;   // CmmAssign
           call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . Main.main_closure" {
    Main.main_closure:
        const Main.main_info;
        const 0;
        const 0;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl Main.main_closure
.type Main.main_closure, @object
Main.main_closure:
	.quad	Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Liveness annotations added ====================
section ""data" . Main.main_closure" {
    (1,
     Main.main_closure:
         const Main.main_info;
         const 0;
         const 0;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl Main.main_closure
.type Main.main_closure, @object
Main.main_closure:
	.quad	Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl Main.main_closure
.type Main.main_closure, @object
Main.main_closure:
	.quad	Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl Main.main_closure
.type Main.main_closure, @object
Main.main_closure:
	.quad	Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Optimised Cmm ====================
Main.main_entry() //  [R1]
        { [(cexP,
            Main.main_info:
                const SehZ_srt-Main.main_info+400;
                const 0;
                const 107374182422;)]
        }
    {offset
      cexP:
          _r3PH::P64 = R1;   // CmmAssign
          if ((Sp + -40) < SpLim) goto cexQ; else goto cexR;   // CmmCondBranch
      cexQ:
          R1 = _r3PH::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cexR:
          (_cexM::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _r3PH::P64);   // CmmUnsafeForeignCall
          if (_cexM::I64 == 0) goto cexO; else goto cexN;   // CmmCondBranch
      cexO:
          call (I64[_r3PH::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cexN:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexM::I64;   // CmmStore
          R2 = GHC.Base.$fMonadIO_closure;   // CmmAssign
          I64[Sp - 40] = stg_ap_pp_info;   // CmmStore
          P64[Sp - 32] = System.Environment.getArgs_closure;   // CmmStore
          P64[Sp - 24] = sat_segK_closure+1;   // CmmStore
          Sp = Sp - 40;   // CmmAssign
          call GHC.Base.>>=_info(R2) args: 48, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.main_info)+400
	.long	0
	.quad	0
	.quad	107374182422
.globl Main.main_info
.type Main.main_info, @object
Main.main_info:
_cexP:
	movq %rbx,%vI_r3PH
	leaq -40(%rbp),%vI_nexU
	cmpq %r15,%vI_nexU
	jb _cexQ
	jmp _cexR
_cexN:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %vI_cexM,-8(%rbp)
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq $System.Environment.getArgs_closure,-32(%rbp)
	movq $sat_segK_closure+1,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_cexO:
	jmp *(%vI_r3PH)
_cexQ:
	movq %vI_r3PH,%rbx
	jmp *-16(%r13)
_cexR:
	movq %r13,%rdi
	movq %vI_r3PH,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	movq %rax,%vI_cexM
	testq %vI_cexM,%vI_cexM
	je _cexO
	jmp _cexN
	.size Main.main_info, .-Main.main_info



==================== Liveness annotations added ====================
Main.main_entry() //  [R1]
        { [(cexP,
            Main.main_info:
                const SehZ_srt-Main.main_info+400;
                const 0;
                const 107374182422;)]
          # entryIds         = [cexP]
          # liveVRegsOnEntry = Just [(cexN, [cexM :-> %vI_cexM]),
                                     (cexO, [r3PH :-> %vI_r3PH]), (cexP, [R1 :-> %r1]),
                                     (cexQ, [r3PH :-> %vI_r3PH]), (cexR, [r3PH :-> %vI_r3PH])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cexP:
            	movq %rbx,%vI_r3PH
                    # born:    %vI_r3PH
                    # r_dying: %r1
                     
            	leaq -40(%rbp),%vI_nexU
                    # born:    %vI_nexU
                     
            	cmpq %r15,%vI_nexU
                    # r_dying: %vI_nexU
                     
            	jb _cexQ
                     
            	jmp _cexR
                    # r_dying: %vI_r3PH
                     ,
     NONREC
        cexR:
            	movq %r13,%rdi
                    # born:    %r5
                     
            	movq %vI_r3PH,%rsi
                    # born:    %r4
                     
            	subq $8,%rsp
                     
            	xorl %eax,%eax
                    # born:    %r0
                     
            	call newCAF
                    # born:    %r2 %r3 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                    # w_dying: %r2 %r3 %r4 %r5 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                     
            	addq $8,%rsp
                     
            	movq %rax,%vI_cexM
                    # born:    %vI_cexM
                    # r_dying: %r0
                     
            	testq %vI_cexM,%vI_cexM
                     
            	je _cexO
                    # r_dying: %vI_r3PH
                     
            	jmp _cexN
                    # r_dying: %vI_cexM
                     ,
     NONREC
        cexN:
            	movq $stg_bh_upd_frame_info,-16(%rbp)
                     
            	movq %vI_cexM,-8(%rbp)
                    # r_dying: %vI_cexM
                     
            	movl $GHC.Base.$fMonadIO_closure,%r14d
                    # born:    %r14
                     
            	movq $stg_ap_pp_info,-40(%rbp)
                     
            	movq $System.Environment.getArgs_closure,-32(%rbp)
                     
            	movq $sat_segK_closure+1,-24(%rbp)
                     
            	addq $-40,%rbp
                     
            	jmp GHC.Base.>>=_info
                    # r_dying: %r14
                     ,
     NONREC
        cexO:
            	jmp *(%vI_r3PH)
                    # r_dying: %vI_r3PH
                     ,
     NONREC
        cexQ:
            	movq %vI_r3PH,%rbx
                    # born:    %r1
                    # r_dying: %vI_r3PH
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.main_info)+400
	.long	0
	.quad	0
	.quad	107374182422
.globl Main.main_info
.type Main.main_info, @object
Main.main_info:
_cexP:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cexQ
	jmp _cexR
_cexR:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cexO
	jmp _cexN
_cexN:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq $System.Environment.getArgs_closure,-32(%rbp)
	movq $sat_segK_closure+1,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_cexO:
	jmp *(%rbx)
_cexQ:
	jmp *-16(%r13)
	.size Main.main_info, .-Main.main_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.main_info)+400
	.long	0
	.quad	0
	.quad	107374182422
.globl Main.main_info
.type Main.main_info, @object
Main.main_info:
_cexP:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cexQ
_cexR:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cexO
_cexN:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq $System.Environment.getArgs_closure,-32(%rbp)
	movq $sat_segK_closure+1,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_cexO:
	jmp *(%rbx)
_cexQ:
	jmp *-16(%r13)
	.size Main.main_info, .-Main.main_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(Main.main_info)+400
	.long	0
	.quad	0
	.quad	107374182422
.globl Main.main_info
.type Main.main_info, @object
Main.main_info:
_cexP:
	leaq -40(%rbp),%rax
	cmpq %r15,%rax
	jb _cexQ
_cexR:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cexO
_cexN:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $GHC.Base.$fMonadIO_closure,%r14d
	movq $stg_ap_pp_info,-40(%rbp)
	movq $System.Environment.getArgs_closure,-32(%rbp)
	movq $sat_segK_closure+1,-24(%rbp)
	addq $-40,%rbp
	jmp GHC.Base.>>=_info
_cexO:
	jmp *(%rbx)
_cexQ:
	jmp *-16(%r13)
	.size Main.main_info, .-Main.main_info



==================== Debug Infos ====================



==================== Cmm produced by new codegen ====================
[section ""data" . :Main.main_closure" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 :Main.main_entry() //  [R1]
         { info_tbl: [(cey2,
                       label: :Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cey2:
           _01D::P64 = R1;   // CmmAssign
           goto cexX;   // CmmBranch
       cexX:
           if ((old + 0) - <highSp> < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
       cey3:
           R1 = _01D::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cey4:
           (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
           if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
       cey1:
           call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cey0:
           I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
           I64[(old + 16)] = _cexZ::I64;   // CmmStore
           R2 = Main.main_closure;   // CmmAssign
           R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Post control-flow optimisations ====================
{offset
  cey2:
      _01D::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
  cey3:
      R1 = _01D::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cey4:
      (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
      if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
  cey1:
      call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cey0:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _cexZ::I64;   // CmmStore
      R2 = Main.main_closure;   // CmmAssign
      R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Post switch plan ====================
{offset
  cey2:
      _01D::P64 = R1;   // CmmAssign
      if ((old + 0) - <highSp> < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
  cey3:
      R1 = _01D::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cey4:
      (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
      if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
  cey1:
      call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cey0:
      I64[(old + 24)] = stg_bh_upd_frame_info;   // CmmStore
      I64[(old + 16)] = _cexZ::I64;   // CmmStore
      R2 = Main.main_closure;   // CmmAssign
      R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== Layout Stack ====================
{offset
  cey2:
      _01D::P64 = R1;   // CmmAssign
      if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
  cey3:
      R1 = _01D::P64;   // CmmAssign
      call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
  cey4:
      (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                               PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
      if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
  cey1:
      call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
  cey0:
      I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
      I64[Sp - 8] = _cexZ::I64;   // CmmStore
      R2 = Main.main_closure;   // CmmAssign
      R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
      Sp = Sp - 16;   // CmmAssign
      call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
}



==================== CAFEnv ====================
[(cey0, {GHC.TopHandler.runMainIO_closure, Main.main_closure}),
 (cey1, {}),
 (cey2, {GHC.TopHandler.runMainIO_closure, Main.main_closure}),
 (cey3, {}),
 (cey4, {GHC.TopHandler.runMainIO_closure, Main.main_closure})]



==================== after setInfoTableStackMap ====================
:Main.main_entry() //  [R1]
        { info_tbl: [(cey2,
                      label: :Main.main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cey2:
          _01D::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
      cey3:
          R1 = _01D::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cey4:
          (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
          if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
      cey1:
          call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cey0:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexZ::I64;   // CmmStore
          R2 = Main.main_closure;   // CmmAssign
          R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post control-flow optimisations ====================
:Main.main_entry() //  [R1]
        { info_tbl: [(cey2,
                      label: :Main.main_info
                      rep:HeapRep static { Thunk })]
          stack_info: arg_space: 8 updfr_space: Just 8
        }
    {offset
      cey2:
          _01D::P64 = R1;   // CmmAssign
          if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
      cey3:
          R1 = _01D::P64;   // CmmAssign
          call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cey4:
          (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
          if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
      cey1:
          call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cey0:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexZ::I64;   // CmmStore
          R2 = Main.main_closure;   // CmmAssign
          R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Post CPS Cmm ====================
[section ""data" . :Main.main_closure" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 :Main.main_entry() //  [R1]
         { info_tbl: [(cey2,
                       label: :Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cey2:
           _01D::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
       cey3:
           R1 = _01D::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cey4:
           (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
           if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
       cey1:
           call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cey0:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexZ::I64;   // CmmStore
           R2 = Main.main_closure;   // CmmAssign
           R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Output Cmm ====================
[section ""data" . :Main.main_closure" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 :Main.main_entry() //  [R1]
         { info_tbl: [(cey2,
                       label: :Main.main_info
                       rep:HeapRep static { Thunk })]
           stack_info: arg_space: 8 updfr_space: Just 8
         }
     {offset
       cey2:
           _01D::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
       cey3:
           R1 = _01D::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cey4:
           (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
           if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
       cey1:
           call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cey0:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexZ::I64;   // CmmStore
           R2 = Main.main_closure;   // CmmAssign
           R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Raw Cmm ====================
[section ""data" . :Main.main_closure" {
     :Main.main_closure:
         const :Main.main_info;
         const 0;
         const 0;
         const 0;
 },
 :Main.main_entry() //  [R1]
         { [(cey2,
             :Main.main_info:
                 const SehZ_srt-:Main.main_info+440;
                 const 0;
                 const 12884901910;)]
         }
     {offset
       cey2:
           _01D::P64 = R1;   // CmmAssign
           if ((Sp + 8) - 24 < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
       cey3:
           R1 = _01D::P64;   // CmmAssign
           call (stg_gc_enter_1)(R1) args: 8, res: 0, upd: 8;   // CmmCall
       cey4:
           (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                    PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
           if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
       cey1:
           call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
       cey0:
           I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
           I64[Sp - 8] = _cexZ::I64;   // CmmStore
           R2 = Main.main_closure;   // CmmAssign
           R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
           Sp = Sp - 16;   // CmmAssign
           call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
     }
 }]



==================== Optimised Cmm ====================
section ""data" . :Main.main_closure" {
    :Main.main_closure:
        const :Main.main_info;
        const 0;
        const 0;
        const 0;
}



==================== Native code ====================
.section .data
.align 8
.align 1
.globl :Main.main_closure
.type :Main.main_closure, @object
:Main.main_closure:
	.quad	:Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Liveness annotations added ====================
section ""data" . :Main.main_closure" {
    (1,
     :Main.main_closure:
         const :Main.main_info;
         const 0;
         const 0;
         const 0;)
}



==================== Registers allocated ====================
.section .data
.align 8
.align 1
.globl :Main.main_closure
.type :Main.main_closure, @object
:Main.main_closure:
	.quad	:Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Synthetic instructions expanded ====================
.section .data
.align 8
.align 1
.globl :Main.main_closure
.type :Main.main_closure, @object
:Main.main_closure:
	.quad	:Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Asm code ====================
.section .data
.align 8
.align 1
.globl :Main.main_closure
.type :Main.main_closure, @object
:Main.main_closure:
	.quad	:Main.main_info
	.quad	0
	.quad	0
	.quad	0



==================== Optimised Cmm ====================
:Main.main_entry() //  [R1]
        { [(cey2,
            :Main.main_info:
                const SehZ_srt-:Main.main_info+440;
                const 0;
                const 12884901910;)]
        }
    {offset
      cey2:
          _01D::P64 = R1;   // CmmAssign
          if ((Sp + -16) < SpLim) goto cey3; else goto cey4;   // CmmCondBranch
      cey3:
          R1 = _01D::P64;   // CmmAssign
          call (I64[BaseReg - 16])(R1) args: 8, res: 0, upd: 8;   // CmmCall
      cey4:
          (_cexZ::I64) = call "ccall" arg hints:  [PtrHint,
                                                   PtrHint]  result hints:  [PtrHint] newCAF(BaseReg, _01D::P64);   // CmmUnsafeForeignCall
          if (_cexZ::I64 == 0) goto cey1; else goto cey0;   // CmmCondBranch
      cey1:
          call (I64[_01D::P64])() args: 8, res: 0, upd: 8;   // CmmCall
      cey0:
          I64[Sp - 16] = stg_bh_upd_frame_info;   // CmmStore
          I64[Sp - 8] = _cexZ::I64;   // CmmStore
          R2 = Main.main_closure;   // CmmAssign
          R1 = GHC.TopHandler.runMainIO_closure;   // CmmAssign
          Sp = Sp - 16;   // CmmAssign
          call stg_ap_p_fast(R2, R1) args: 24, res: 0, upd: 24;   // CmmCall
    }
}



==================== Native code ====================
.section .text
.align 8
	.long	SehZ_srt-(:Main.main_info)+440
	.long	0
	.quad	0
	.quad	12884901910
.globl :Main.main_info
.type :Main.main_info, @object
:Main.main_info:
_cey2:
	movq %rbx,%vI_01D
	leaq -16(%rbp),%vI_ney7
	cmpq %r15,%vI_ney7
	jb _cey3
	jmp _cey4
_cey0:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %vI_cexZ,-8(%rbp)
	movl $Main.main_closure,%r14d
	movl $GHC.TopHandler.runMainIO_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cey1:
	jmp *(%vI_01D)
_cey3:
	movq %vI_01D,%rbx
	jmp *-16(%r13)
_cey4:
	movq %r13,%rdi
	movq %vI_01D,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	movq %rax,%vI_cexZ
	testq %vI_cexZ,%vI_cexZ
	je _cey1
	jmp _cey0
	.size :Main.main_info, .-:Main.main_info



==================== Liveness annotations added ====================
:Main.main_entry() //  [R1]
        { [(cey2,
            :Main.main_info:
                const SehZ_srt-:Main.main_info+440;
                const 0;
                const 12884901910;)]
          # entryIds         = [cey2]
          # liveVRegsOnEntry = Just [(cey0, [cexZ :-> %vI_cexZ]),
                                     (cey1, [01D :-> %vI_01D]), (cey2, [R1 :-> %r1]),
                                     (cey3, [01D :-> %vI_01D]), (cey4, [01D :-> %vI_01D])]
          # liveSlotsOnEntry = fromList []
        }
    [NONREC
        cey2:
            	movq %rbx,%vI_01D
                    # born:    %vI_01D
                    # r_dying: %r1
                     
            	leaq -16(%rbp),%vI_ney7
                    # born:    %vI_ney7
                     
            	cmpq %r15,%vI_ney7
                    # r_dying: %vI_ney7
                     
            	jb _cey3
                     
            	jmp _cey4
                    # r_dying: %vI_01D
                     ,
     NONREC
        cey4:
            	movq %r13,%rdi
                    # born:    %r5
                     
            	movq %vI_01D,%rsi
                    # born:    %r4
                     
            	subq $8,%rsp
                     
            	xorl %eax,%eax
                    # born:    %r0
                     
            	call newCAF
                    # born:    %r2 %r3 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                    # w_dying: %r2 %r3 %r4 %r5 %r8 %r9 %r10 %r11 %r16 %r17 %r18 %r19 %r20 %r21 %r24 %r25 %r26 %r27 %r28 %r29 %r30 %r31 %r32 %r33 %r34 %r35 %r36 %r37 %r38 %r39
                     
            	addq $8,%rsp
                     
            	movq %rax,%vI_cexZ
                    # born:    %vI_cexZ
                    # r_dying: %r0
                     
            	testq %vI_cexZ,%vI_cexZ
                     
            	je _cey1
                    # r_dying: %vI_01D
                     
            	jmp _cey0
                    # r_dying: %vI_cexZ
                     ,
     NONREC
        cey0:
            	movq $stg_bh_upd_frame_info,-16(%rbp)
                     
            	movq %vI_cexZ,-8(%rbp)
                    # r_dying: %vI_cexZ
                     
            	movl $Main.main_closure,%r14d
                    # born:    %r14
                     
            	movl $GHC.TopHandler.runMainIO_closure,%ebx
                    # born:    %r1
                     
            	addq $-16,%rbp
                     
            	jmp stg_ap_p_fast
                    # r_dying: %r1 %r14
                     ,
     NONREC
        cey1:
            	jmp *(%vI_01D)
                    # r_dying: %vI_01D
                     ,
     NONREC
        cey3:
            	movq %vI_01D,%rbx
                    # born:    %r1
                    # r_dying: %vI_01D
                     
            	jmp *-16(%r13)
                    # r_dying: %r1
                     ]
}



==================== Registers allocated ====================
.section .text
.align 8
	.long	SehZ_srt-(:Main.main_info)+440
	.long	0
	.quad	0
	.quad	12884901910
.globl :Main.main_info
.type :Main.main_info, @object
:Main.main_info:
_cey2:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cey3
	jmp _cey4
_cey4:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cey1
	jmp _cey0
_cey0:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $Main.main_closure,%r14d
	movl $GHC.TopHandler.runMainIO_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cey1:
	jmp *(%rbx)
_cey3:
	jmp *-16(%r13)
	.size :Main.main_info, .-:Main.main_info



==================== Synthetic instructions expanded ====================
.section .text
.align 8
	.long	SehZ_srt-(:Main.main_info)+440
	.long	0
	.quad	0
	.quad	12884901910
.globl :Main.main_info
.type :Main.main_info, @object
:Main.main_info:
_cey2:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cey3
_cey4:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cey1
_cey0:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $Main.main_closure,%r14d
	movl $GHC.TopHandler.runMainIO_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cey1:
	jmp *(%rbx)
_cey3:
	jmp *-16(%r13)
	.size :Main.main_info, .-:Main.main_info



==================== Asm code ====================
.section .text
.align 8
	.long	SehZ_srt-(:Main.main_info)+440
	.long	0
	.quad	0
	.quad	12884901910
.globl :Main.main_info
.type :Main.main_info, @object
:Main.main_info:
_cey2:
	leaq -16(%rbp),%rax
	cmpq %r15,%rax
	jb _cey3
_cey4:
	movq %r13,%rdi
	movq %rbx,%rsi
	subq $8,%rsp
	xorl %eax,%eax
	call newCAF
	addq $8,%rsp
	testq %rax,%rax
	je _cey1
_cey0:
	movq $stg_bh_upd_frame_info,-16(%rbp)
	movq %rax,-8(%rbp)
	movl $Main.main_closure,%r14d
	movl $GHC.TopHandler.runMainIO_closure,%ebx
	addq $-16,%rbp
	jmp stg_ap_p_fast
_cey1:
	jmp *(%rbx)
_cey3:
	jmp *-16(%r13)
	.size :Main.main_info, .-:Main.main_info



==================== Debug Infos ====================



==================== Output Cmm ====================
[section ""relreadonly" . SehZ_srt" {
     SehZ_srt:
         const Data.Typeable.cast_closure;
         const Main.mkQ_closure;
         const Main.everything_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const GHC.Show.$fShowInt_closure;
         const GHC.Show.$fShow(,,)_closure;
         const Data.Typeable.Internal.mkPolyTyConApp_closure;
         const SrcLoc.$tcSrcSpan_closure;
         const GHC.Base.++_closure;
         const Data.Data.$fData[]_closure;
         const ConLike.$fDataConLike_closure;
         const TypeRep.$fDataType_closure;
         const Name.$fDataName_closure;
         const FieldLabel.$fDataFieldLbl_closure;
         const UniqFM.$fDataUniqFM_closure;
         const HsBinds.$fDataHsBindLR_closure;
         const SrcLoc.$fDataSrcSpan_closure;
         const SrcLoc.$fDataGenLocated_closure;
         const Bag.$fDataBag_closure;
         const Data.Data.$fDataBool_closure;
         const BasicTypes.$fDataFixity_closure;
         const Var.$fDataVar_closure;
         const TcEvidence.$fDataHsWrapper_closure;
         const Coercion.$fDataCoercion_closure;
         const HsDoc.$fDataHsDocString_closure;
         const Data.Data.$fDataMaybe_closure;
         const HsImpExp.$fDataIE_closure;
         const HsImpExp.$fDataImportDecl_closure;
         const HsDecls.$fDataHsGroup_closure;
         const PlaceHolder.$fDataPlaceHolder_closure;
         const Data.Data.$fData(,,,)_closure;
         const HsSyn.$fDataHsModule_closure;
         const RdrName.$fDataRdrName_closure;
         const System.IO.print_closure;
         const $dShow_reeF_closure;
         const Module.mkModuleName_closure;
         const GHC.$fTypecheckedModDesugaredModule_closure;
         const GHC.pm_parsed_source_closure;
         const GhcMonad.$fMonadGhc_closure;
         const GHC.loadModule_closure;
         const GhcMonad.$fGhcMonadGhc_closure;
         const GHC.desugarModule_closure;
         const GHC.typecheckModule_closure;
         const GHC.parseModule_closure;
         const GHC.getModSummary_closure;
         const GhcMake.load_closure;
         const GHC.addTarget_closure;
         const GHC.setSessionDynFlags_closure;
         const GhcMonad.getSessionDynFlags_closure;
         const GHC.runGhc_closure;
         const GHC.Base.$fMonadIO_closure;
         const Main.testOneFile_closure;
         const GHC.CString.unpackCString#_closure;
         const sat_segK_closure;
         const System.Environment.getArgs_closure;
         const GHC.TopHandler.runMainIO_closure;
         const Main.main_closure;
 }]



==================== Raw Cmm ====================
[section ""relreadonly" . SehZ_srt" {
     SehZ_srt:
         const Data.Typeable.cast_closure;
         const Main.mkQ_closure;
         const Main.everything_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const GHC.Show.$fShowInt_closure;
         const GHC.Show.$fShow(,,)_closure;
         const Data.Typeable.Internal.mkPolyTyConApp_closure;
         const SrcLoc.$tcSrcSpan_closure;
         const GHC.Base.++_closure;
         const Data.Data.$fData[]_closure;
         const ConLike.$fDataConLike_closure;
         const TypeRep.$fDataType_closure;
         const Name.$fDataName_closure;
         const FieldLabel.$fDataFieldLbl_closure;
         const UniqFM.$fDataUniqFM_closure;
         const HsBinds.$fDataHsBindLR_closure;
         const SrcLoc.$fDataSrcSpan_closure;
         const SrcLoc.$fDataGenLocated_closure;
         const Bag.$fDataBag_closure;
         const Data.Data.$fDataBool_closure;
         const BasicTypes.$fDataFixity_closure;
         const Var.$fDataVar_closure;
         const TcEvidence.$fDataHsWrapper_closure;
         const Coercion.$fDataCoercion_closure;
         const HsDoc.$fDataHsDocString_closure;
         const Data.Data.$fDataMaybe_closure;
         const HsImpExp.$fDataIE_closure;
         const HsImpExp.$fDataImportDecl_closure;
         const HsDecls.$fDataHsGroup_closure;
         const PlaceHolder.$fDataPlaceHolder_closure;
         const Data.Data.$fData(,,,)_closure;
         const HsSyn.$fDataHsModule_closure;
         const RdrName.$fDataRdrName_closure;
         const System.IO.print_closure;
         const $dShow_reeF_closure;
         const Module.mkModuleName_closure;
         const GHC.$fTypecheckedModDesugaredModule_closure;
         const GHC.pm_parsed_source_closure;
         const GhcMonad.$fMonadGhc_closure;
         const GHC.loadModule_closure;
         const GhcMonad.$fGhcMonadGhc_closure;
         const GHC.desugarModule_closure;
         const GHC.typecheckModule_closure;
         const GHC.parseModule_closure;
         const GHC.getModSummary_closure;
         const GhcMake.load_closure;
         const GHC.addTarget_closure;
         const GHC.setSessionDynFlags_closure;
         const GhcMonad.getSessionDynFlags_closure;
         const GHC.runGhc_closure;
         const GHC.Base.$fMonadIO_closure;
         const Main.testOneFile_closure;
         const GHC.CString.unpackCString#_closure;
         const sat_segK_closure;
         const System.Environment.getArgs_closure;
         const GHC.TopHandler.runMainIO_closure;
         const Main.main_closure;
 }]



==================== Optimised Cmm ====================
section ""relreadonly" . SehZ_srt" {
    SehZ_srt:
        const Data.Typeable.cast_closure;
        const Main.mkQ_closure;
        const Main.everything_closure;
        const Data.Foldable.$fFoldable[]_closure;
        const GHC.Show.$fShowInt_closure;
        const GHC.Show.$fShow(,,)_closure;
        const Data.Typeable.Internal.mkPolyTyConApp_closure;
        const SrcLoc.$tcSrcSpan_closure;
        const GHC.Base.++_closure;
        const Data.Data.$fData[]_closure;
        const ConLike.$fDataConLike_closure;
        const TypeRep.$fDataType_closure;
        const Name.$fDataName_closure;
        const FieldLabel.$fDataFieldLbl_closure;
        const UniqFM.$fDataUniqFM_closure;
        const HsBinds.$fDataHsBindLR_closure;
        const SrcLoc.$fDataSrcSpan_closure;
        const SrcLoc.$fDataGenLocated_closure;
        const Bag.$fDataBag_closure;
        const Data.Data.$fDataBool_closure;
        const BasicTypes.$fDataFixity_closure;
        const Var.$fDataVar_closure;
        const TcEvidence.$fDataHsWrapper_closure;
        const Coercion.$fDataCoercion_closure;
        const HsDoc.$fDataHsDocString_closure;
        const Data.Data.$fDataMaybe_closure;
        const HsImpExp.$fDataIE_closure;
        const HsImpExp.$fDataImportDecl_closure;
        const HsDecls.$fDataHsGroup_closure;
        const PlaceHolder.$fDataPlaceHolder_closure;
        const Data.Data.$fData(,,,)_closure;
        const HsSyn.$fDataHsModule_closure;
        const RdrName.$fDataRdrName_closure;
        const System.IO.print_closure;
        const $dShow_reeF_closure;
        const Module.mkModuleName_closure;
        const GHC.$fTypecheckedModDesugaredModule_closure;
        const GHC.pm_parsed_source_closure;
        const GhcMonad.$fMonadGhc_closure;
        const GHC.loadModule_closure;
        const GhcMonad.$fGhcMonadGhc_closure;
        const GHC.desugarModule_closure;
        const GHC.typecheckModule_closure;
        const GHC.parseModule_closure;
        const GHC.getModSummary_closure;
        const GhcMake.load_closure;
        const GHC.addTarget_closure;
        const GHC.setSessionDynFlags_closure;
        const GhcMonad.getSessionDynFlags_closure;
        const GHC.runGhc_closure;
        const GHC.Base.$fMonadIO_closure;
        const Main.testOneFile_closure;
        const GHC.CString.unpackCString#_closure;
        const sat_segK_closure;
        const System.Environment.getArgs_closure;
        const GHC.TopHandler.runMainIO_closure;
        const Main.main_closure;
}



==================== Native code ====================
.section .data.rel.ro
.align 8
.align 1
SehZ_srt:
	.quad	Data.Typeable.cast_closure
	.quad	Main.mkQ_closure
	.quad	Main.everything_closure
	.quad	Data.Foldable.$fFoldable[]_closure
	.quad	GHC.Show.$fShowInt_closure
	.quad	GHC.Show.$fShow(,,)_closure
	.quad	Data.Typeable.Internal.mkPolyTyConApp_closure
	.quad	SrcLoc.$tcSrcSpan_closure
	.quad	GHC.Base.++_closure
	.quad	Data.Data.$fData[]_closure
	.quad	ConLike.$fDataConLike_closure
	.quad	TypeRep.$fDataType_closure
	.quad	Name.$fDataName_closure
	.quad	FieldLabel.$fDataFieldLbl_closure
	.quad	UniqFM.$fDataUniqFM_closure
	.quad	HsBinds.$fDataHsBindLR_closure
	.quad	SrcLoc.$fDataSrcSpan_closure
	.quad	SrcLoc.$fDataGenLocated_closure
	.quad	Bag.$fDataBag_closure
	.quad	Data.Data.$fDataBool_closure
	.quad	BasicTypes.$fDataFixity_closure
	.quad	Var.$fDataVar_closure
	.quad	TcEvidence.$fDataHsWrapper_closure
	.quad	Coercion.$fDataCoercion_closure
	.quad	HsDoc.$fDataHsDocString_closure
	.quad	Data.Data.$fDataMaybe_closure
	.quad	HsImpExp.$fDataIE_closure
	.quad	HsImpExp.$fDataImportDecl_closure
	.quad	HsDecls.$fDataHsGroup_closure
	.quad	PlaceHolder.$fDataPlaceHolder_closure
	.quad	Data.Data.$fData(,,,)_closure
	.quad	HsSyn.$fDataHsModule_closure
	.quad	RdrName.$fDataRdrName_closure
	.quad	System.IO.print_closure
	.quad	$dShow_reeF_closure
	.quad	Module.mkModuleName_closure
	.quad	GHC.$fTypecheckedModDesugaredModule_closure
	.quad	GHC.pm_parsed_source_closure
	.quad	GhcMonad.$fMonadGhc_closure
	.quad	GHC.loadModule_closure
	.quad	GhcMonad.$fGhcMonadGhc_closure
	.quad	GHC.desugarModule_closure
	.quad	GHC.typecheckModule_closure
	.quad	GHC.parseModule_closure
	.quad	GHC.getModSummary_closure
	.quad	GhcMake.load_closure
	.quad	GHC.addTarget_closure
	.quad	GHC.setSessionDynFlags_closure
	.quad	GhcMonad.getSessionDynFlags_closure
	.quad	GHC.runGhc_closure
	.quad	GHC.Base.$fMonadIO_closure
	.quad	Main.testOneFile_closure
	.quad	GHC.CString.unpackCString#_closure
	.quad	sat_segK_closure
	.quad	System.Environment.getArgs_closure
	.quad	GHC.TopHandler.runMainIO_closure
	.quad	Main.main_closure



==================== Liveness annotations added ====================
section ""relreadonly" . SehZ_srt" {
    (1,
     SehZ_srt:
         const Data.Typeable.cast_closure;
         const Main.mkQ_closure;
         const Main.everything_closure;
         const Data.Foldable.$fFoldable[]_closure;
         const GHC.Show.$fShowInt_closure;
         const GHC.Show.$fShow(,,)_closure;
         const Data.Typeable.Internal.mkPolyTyConApp_closure;
         const SrcLoc.$tcSrcSpan_closure;
         const GHC.Base.++_closure;
         const Data.Data.$fData[]_closure;
         const ConLike.$fDataConLike_closure;
         const TypeRep.$fDataType_closure;
         const Name.$fDataName_closure;
         const FieldLabel.$fDataFieldLbl_closure;
         const UniqFM.$fDataUniqFM_closure;
         const HsBinds.$fDataHsBindLR_closure;
         const SrcLoc.$fDataSrcSpan_closure;
         const SrcLoc.$fDataGenLocated_closure;
         const Bag.$fDataBag_closure;
         const Data.Data.$fDataBool_closure;
         const BasicTypes.$fDataFixity_closure;
         const Var.$fDataVar_closure;
         const TcEvidence.$fDataHsWrapper_closure;
         const Coercion.$fDataCoercion_closure;
         const HsDoc.$fDataHsDocString_closure;
         const Data.Data.$fDataMaybe_closure;
         const HsImpExp.$fDataIE_closure;
         const HsImpExp.$fDataImportDecl_closure;
         const HsDecls.$fDataHsGroup_closure;
         const PlaceHolder.$fDataPlaceHolder_closure;
         const Data.Data.$fData(,,,)_closure;
         const HsSyn.$fDataHsModule_closure;
         const RdrName.$fDataRdrName_closure;
         const System.IO.print_closure;
         const $dShow_reeF_closure;
         const Module.mkModuleName_closure;
         const GHC.$fTypecheckedModDesugaredModule_closure;
         const GHC.pm_parsed_source_closure;
         const GhcMonad.$fMonadGhc_closure;
         const GHC.loadModule_closure;
         const GhcMonad.$fGhcMonadGhc_closure;
         const GHC.desugarModule_closure;
         const GHC.typecheckModule_closure;
         const GHC.parseModule_closure;
         const GHC.getModSummary_closure;
         const GhcMake.load_closure;
         const GHC.addTarget_closure;
         const GHC.setSessionDynFlags_closure;
         const GhcMonad.getSessionDynFlags_closure;
         const GHC.runGhc_closure;
         const GHC.Base.$fMonadIO_closure;
         const Main.testOneFile_closure;
         const GHC.CString.unpackCString#_closure;
         const sat_segK_closure;
         const System.Environment.getArgs_closure;
         const GHC.TopHandler.runMainIO_closure;
         const Main.main_closure;)
}



==================== Registers allocated ====================
.section .data.rel.ro
.align 8
.align 1
SehZ_srt:
	.quad	Data.Typeable.cast_closure
	.quad	Main.mkQ_closure
	.quad	Main.everything_closure
	.quad	Data.Foldable.$fFoldable[]_closure
	.quad	GHC.Show.$fShowInt_closure
	.quad	GHC.Show.$fShow(,,)_closure
	.quad	Data.Typeable.Internal.mkPolyTyConApp_closure
	.quad	SrcLoc.$tcSrcSpan_closure
	.quad	GHC.Base.++_closure
	.quad	Data.Data.$fData[]_closure
	.quad	ConLike.$fDataConLike_closure
	.quad	TypeRep.$fDataType_closure
	.quad	Name.$fDataName_closure
	.quad	FieldLabel.$fDataFieldLbl_closure
	.quad	UniqFM.$fDataUniqFM_closure
	.quad	HsBinds.$fDataHsBindLR_closure
	.quad	SrcLoc.$fDataSrcSpan_closure
	.quad	SrcLoc.$fDataGenLocated_closure
	.quad	Bag.$fDataBag_closure
	.quad	Data.Data.$fDataBool_closure
	.quad	BasicTypes.$fDataFixity_closure
	.quad	Var.$fDataVar_closure
	.quad	TcEvidence.$fDataHsWrapper_closure
	.quad	Coercion.$fDataCoercion_closure
	.quad	HsDoc.$fDataHsDocString_closure
	.quad	Data.Data.$fDataMaybe_closure
	.quad	HsImpExp.$fDataIE_closure
	.quad	HsImpExp.$fDataImportDecl_closure
	.quad	HsDecls.$fDataHsGroup_closure
	.quad	PlaceHolder.$fDataPlaceHolder_closure
	.quad	Data.Data.$fData(,,,)_closure
	.quad	HsSyn.$fDataHsModule_closure
	.quad	RdrName.$fDataRdrName_closure
	.quad	System.IO.print_closure
	.quad	$dShow_reeF_closure
	.quad	Module.mkModuleName_closure
	.quad	GHC.$fTypecheckedModDesugaredModule_closure
	.quad	GHC.pm_parsed_source_closure
	.quad	GhcMonad.$fMonadGhc_closure
	.quad	GHC.loadModule_closure
	.quad	GhcMonad.$fGhcMonadGhc_closure
	.quad	GHC.desugarModule_closure
	.quad	GHC.typecheckModule_closure
	.quad	GHC.parseModule_closure
	.quad	GHC.getModSummary_closure
	.quad	GhcMake.load_closure
	.quad	GHC.addTarget_closure
	.quad	GHC.setSessionDynFlags_closure
	.quad	GhcMonad.getSessionDynFlags_closure
	.quad	GHC.runGhc_closure
	.quad	GHC.Base.$fMonadIO_closure
	.quad	Main.testOneFile_closure
	.quad	GHC.CString.unpackCString#_closure
	.quad	sat_segK_closure
	.quad	System.Environment.getArgs_closure
	.quad	GHC.TopHandler.runMainIO_closure
	.quad	Main.main_closure



==================== Synthetic instructions expanded ====================
.section .data.rel.ro
.align 8
.align 1
SehZ_srt:
	.quad	Data.Typeable.cast_closure
	.quad	Main.mkQ_closure
	.quad	Main.everything_closure
	.quad	Data.Foldable.$fFoldable[]_closure
	.quad	GHC.Show.$fShowInt_closure
	.quad	GHC.Show.$fShow(,,)_closure
	.quad	Data.Typeable.Internal.mkPolyTyConApp_closure
	.quad	SrcLoc.$tcSrcSpan_closure
	.quad	GHC.Base.++_closure
	.quad	Data.Data.$fData[]_closure
	.quad	ConLike.$fDataConLike_closure
	.quad	TypeRep.$fDataType_closure
	.quad	Name.$fDataName_closure
	.quad	FieldLabel.$fDataFieldLbl_closure
	.quad	UniqFM.$fDataUniqFM_closure
	.quad	HsBinds.$fDataHsBindLR_closure
	.quad	SrcLoc.$fDataSrcSpan_closure
	.quad	SrcLoc.$fDataGenLocated_closure
	.quad	Bag.$fDataBag_closure
	.quad	Data.Data.$fDataBool_closure
	.quad	BasicTypes.$fDataFixity_closure
	.quad	Var.$fDataVar_closure
	.quad	TcEvidence.$fDataHsWrapper_closure
	.quad	Coercion.$fDataCoercion_closure
	.quad	HsDoc.$fDataHsDocString_closure
	.quad	Data.Data.$fDataMaybe_closure
	.quad	HsImpExp.$fDataIE_closure
	.quad	HsImpExp.$fDataImportDecl_closure
	.quad	HsDecls.$fDataHsGroup_closure
	.quad	PlaceHolder.$fDataPlaceHolder_closure
	.quad	Data.Data.$fData(,,,)_closure
	.quad	HsSyn.$fDataHsModule_closure
	.quad	RdrName.$fDataRdrName_closure
	.quad	System.IO.print_closure
	.quad	$dShow_reeF_closure
	.quad	Module.mkModuleName_closure
	.quad	GHC.$fTypecheckedModDesugaredModule_closure
	.quad	GHC.pm_parsed_source_closure
	.quad	GhcMonad.$fMonadGhc_closure
	.quad	GHC.loadModule_closure
	.quad	GhcMonad.$fGhcMonadGhc_closure
	.quad	GHC.desugarModule_closure
	.quad	GHC.typecheckModule_closure
	.quad	GHC.parseModule_closure
	.quad	GHC.getModSummary_closure
	.quad	GhcMake.load_closure
	.quad	GHC.addTarget_closure
	.quad	GHC.setSessionDynFlags_closure
	.quad	GhcMonad.getSessionDynFlags_closure
	.quad	GHC.runGhc_closure
	.quad	GHC.Base.$fMonadIO_closure
	.quad	Main.testOneFile_closure
	.quad	GHC.CString.unpackCString#_closure
	.quad	sat_segK_closure
	.quad	System.Environment.getArgs_closure
	.quad	GHC.TopHandler.runMainIO_closure
	.quad	Main.main_closure



==================== Asm code ====================
.section .data.rel.ro
.align 8
.align 1
SehZ_srt:
	.quad	Data.Typeable.cast_closure
	.quad	Main.mkQ_closure
	.quad	Main.everything_closure
	.quad	Data.Foldable.$fFoldable[]_closure
	.quad	GHC.Show.$fShowInt_closure
	.quad	GHC.Show.$fShow(,,)_closure
	.quad	Data.Typeable.Internal.mkPolyTyConApp_closure
	.quad	SrcLoc.$tcSrcSpan_closure
	.quad	GHC.Base.++_closure
	.quad	Data.Data.$fData[]_closure
	.quad	ConLike.$fDataConLike_closure
	.quad	TypeRep.$fDataType_closure
	.quad	Name.$fDataName_closure
	.quad	FieldLabel.$fDataFieldLbl_closure
	.quad	UniqFM.$fDataUniqFM_closure
	.quad	HsBinds.$fDataHsBindLR_closure
	.quad	SrcLoc.$fDataSrcSpan_closure
	.quad	SrcLoc.$fDataGenLocated_closure
	.quad	Bag.$fDataBag_closure
	.quad	Data.Data.$fDataBool_closure
	.quad	BasicTypes.$fDataFixity_closure
	.quad	Var.$fDataVar_closure
	.quad	TcEvidence.$fDataHsWrapper_closure
	.quad	Coercion.$fDataCoercion_closure
	.quad	HsDoc.$fDataHsDocString_closure
	.quad	Data.Data.$fDataMaybe_closure
	.quad	HsImpExp.$fDataIE_closure
	.quad	HsImpExp.$fDataImportDecl_closure
	.quad	HsDecls.$fDataHsGroup_closure
	.quad	PlaceHolder.$fDataPlaceHolder_closure
	.quad	Data.Data.$fData(,,,)_closure
	.quad	HsSyn.$fDataHsModule_closure
	.quad	RdrName.$fDataRdrName_closure
	.quad	System.IO.print_closure
	.quad	$dShow_reeF_closure
	.quad	Module.mkModuleName_closure
	.quad	GHC.$fTypecheckedModDesugaredModule_closure
	.quad	GHC.pm_parsed_source_closure
	.quad	GhcMonad.$fMonadGhc_closure
	.quad	GHC.loadModule_closure
	.quad	GhcMonad.$fGhcMonadGhc_closure
	.quad	GHC.desugarModule_closure
	.quad	GHC.typecheckModule_closure
	.quad	GHC.parseModule_closure
	.quad	GHC.getModSummary_closure
	.quad	GhcMake.load_closure
	.quad	GHC.addTarget_closure
	.quad	GHC.setSessionDynFlags_closure
	.quad	GhcMonad.getSessionDynFlags_closure
	.quad	GHC.runGhc_closure
	.quad	GHC.Base.$fMonadIO_closure
	.quad	Main.testOneFile_closure
	.quad	GHC.CString.unpackCString#_closure
	.quad	sat_segK_closure
	.quad	System.Environment.getArgs_closure
	.quad	GHC.TopHandler.runMainIO_closure
	.quad	Main.main_closure



==================== Debug Infos ====================


Linking landmines ...
(11,11,7)
(49,45,0)
(12,12,7)
(9,9,7)
