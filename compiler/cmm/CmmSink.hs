{-# LANGUAGE GADTs #-}
module CmmSink (
     cmmSink
  ) where

import Cmm
import BlockId
import CmmLive
import CmmUtils
import Hoopl

import UniqFM
-- import Outputable

import Data.List (partition)
import qualified Data.Set as Set

-- -----------------------------------------------------------------------------
-- Sinking

-- This is an optimisation pass that
--  (a) moves assignments closer to their uses, to reduce register pressure
--  (b) pushes assignments into a single branch of a conditional if possible

-- It is particularly helpful in the Cmm generated by the Stg->Cmm
-- code generator, in which every function starts with a copyIn
-- sequence like:
--
--    x1 = R1
--    x2 = Sp[8]
--    x3 = Sp[16]
--    if (Sp - 32 < SpLim) then L1 else L2
--
-- we really want to push the x1..x3 assignments into the L2 branch.
--
-- Algorithm:
--
--  * Start by doing liveness analysis.
--  * Keep a list of assignments; earlier ones may refer to later ones
--  * Walk forwards through the graph;
--    * At an assignment:
--      * pick up the assignment and add it to the list
--    * At a store:
--      * drop any assignments that the store refers to
--      * drop any assignments that refer to memory that may be written
--        by the store
--      * do this recursively, dropping dependent assignments
--    * At a multi-way branch:
--      * drop any assignments that are live on more than one branch
--      * if any successor has more than one predecessor, drop everything
--        live in that successor
-- 
-- As a side-effect we'll delete some dead assignments (transitively,
-- even).  Maybe we could do without removeDeadAssignments?

-- If we do this *before* stack layout, we might be able to avoid
-- saving some things across calls/procpoints.
--
-- *but*, that will invalidate the liveness analysis, and we'll have
-- to re-do it.

type Assignment = (LocalReg, CmmExpr, AbsAddr)

cmmSink :: CmmGraph -> CmmGraph
cmmSink graph = ofBlockList (g_entry graph) $ sink mapEmpty $ blocks
  where

  liveness = cmmLiveness graph
  getLive l = mapFindWithDefault Set.empty l liveness

  blocks = postorderDfs graph

  all_succs = concatMap successors blocks
  succ_counts :: BlockEnv Int
  succ_counts = foldr (\l -> mapInsertWith (+) l 1) mapEmpty all_succs
  join_pts = mapFilter (>1) succ_counts


  sink :: BlockEnv [Assignment] -> [CmmBlock] -> [CmmBlock]
  sink _ [] = []
  sink sunk (b:bs) =
    -- pprTrace "sink" (ppr lbl) $
    blockJoin first final_middle last : sink sunk' bs
    where
      lbl = entryLabel b
      (first, middle, last) = blockSplit b
      (middle', assigs) = walk ann_middles emptyBlock
                               (mapFindWithDefault [] lbl sunk)

      succs = successors last

      -- Annotate the middle nodes with the registers live *after*
      -- the node.  This will help us decide whether we can inline
      -- an assignment in the current node or not.
      live = Set.unions (map getLive succs)
      live_middle = gen_kill last live
      ann_middles = annotate live_middle (blockToList middle)

      -- We cannot sink into join points (successors with more than
      -- one predecessor), so identify the join points and the set
      -- of registers live in them.
      (joins, nonjoins) = partition (`mapMember` join_pts) succs
      live_in_joins = Set.unions (map getLive joins)

      -- We do not want to sink an assignment into multiple branches,
      -- so identify the set of registers live in multiple successors.
      -- This is made more complicated because when we sink an assignment
      -- into one branch, this might change the set of registers that are
      -- now live in multiple branches.
      init_live_sets = map getLive nonjoins
      live_in_multi live_sets r =
         case filter (Set.member r) live_sets of
           (_one:_two:_) -> True
           _ -> False

      -- Now, drop any assignments that we will not sink any further.
      (dropped_last, assigs') = dropAssignments drop_if init_live_sets assigs

      drop_if a@(r,rhs,_) live_sets = (should_drop, live_sets')
          where
            should_drop =  a `conflicts` last
                        || {- not (isTiny rhs) && -} live_in_multi live_sets r
                        || r `Set.member` live_in_joins

            live_sets' | should_drop = live_sets
                       | otherwise   = map upd live_sets

            upd set | r `Set.member` set = set `Set.union` live_rhs
                    | otherwise          = set

            live_rhs = foldRegsUsed extendRegSet emptyRegSet rhs

      final_middle = foldl blockSnoc middle' dropped_last

      sunk' = mapUnion sunk $
                 mapFromList [ (l, filterAssignments (getLive l) assigs')
                             | l <- succs ]

{-
-- tiny: an expression we don't mind duplicating
isTiny :: CmmExpr -> Bool
isTiny (CmmReg _) = True
isTiny (CmmLit _) = True
isTiny _other     = False
-}

-- annotate each node with the set of registers live *after* the node
annotate :: RegSet -> [CmmNode O O] -> [(RegSet, CmmNode O O)]
annotate live nodes = snd $ foldr (\n (live,nodes) -> (gen_kill n live, (live,n) : nodes)) (live,[]) nodes

filterAssignments :: RegSet -> [Assignment] -> [Assignment]
filterAssignments live assigs = reverse (go assigs [])
  where go []           kept = kept
        go (a@(r,_,_):as) kept | needed    = go as (a:kept)
                               | otherwise = go as kept
           where
              needed = r `Set.member` live || any (a `conflicts`) (map toNode kept)


walk :: [(RegSet, CmmNode O O)] -> Block CmmNode O O -> [Assignment]
     -> (Block CmmNode O O, [Assignment])

walk []               block as = (block, as)
walk ((live,node):ns) block as
  | Just a <- shouldSink node1 = walk ns block (a : as1)
  | otherwise                  = walk ns block' as'
  where
    (node1, as1) = tryToInline live usages node as
       where usages :: UniqFM Int
             usages = foldRegsUsed addUsage emptyUFM node

    (dropped, as') = dropAssignmentsSimple (`conflicts` node1) as1
    block' = foldl blockSnoc block dropped `blockSnoc` node1

tryToInline :: RegSet -> UniqFM Int -> CmmNode O x -> [Assignment]
            -> (CmmNode O x, [Assignment])
tryToInline _live _usages node []
  = (node, [])
tryToInline live usages node (a@(l,rhs,_) : rest)
  | occurs_once_in_this_node  = inline_and_discard
  | False {- isTiny rhs -}    = inline_and_keep
    -- ^^ seems to make things slightly worse
  where
        inline_and_discard = tryToInline live' usages' node' rest

        inline_and_keep = (node'', a : rest')
          where (node'',rest') = inline_and_discard

        occurs_once_in_this_node =
         not (l `elemRegSet` live) &&  lookupUFM usages l == Just 1

        live'   = foldRegsUsed extendRegSet live rhs
        usages' = foldRegsUsed addUsage usages rhs

        node' = mapExpDeep inline node
           where inline (CmmReg    (CmmLocal l'))     | l == l' = rhs
                 inline (CmmRegOff (CmmLocal l') off) | l == l' = cmmOffset rhs off
                 inline other = other
tryToInline live usages node (assig@(_,rhs,_) : rest)
  = (node', assig : rest')
  where (node', rest') = tryToInline live usages' node rest
        usages' = foldRegsUsed addUsage usages rhs

addUsage :: UniqFM Int -> LocalReg -> UniqFM Int
addUsage m r = addToUFM_C (+) m r 1

shouldSink :: CmmNode e x -> Maybe Assignment
shouldSink (CmmAssign (CmmLocal r) e) | no_local_regs = Just (r, e, exprAddr e)
  where no_local_regs = True -- foldRegsUsed (\_ _ -> False) True e
shouldSink _other = Nothing

toNode :: Assignment -> CmmNode O O
toNode (r,rhs,_) = CmmAssign (CmmLocal r) rhs

dropAssignmentsSimple :: (Assignment -> Bool) -> [Assignment] -> ([CmmNode O O], [Assignment])
dropAssignmentsSimple f = dropAssignments (\a _ -> (f a, ())) ()

dropAssignments :: (Assignment -> s -> (Bool, s)) -> s -> [Assignment] -> ([CmmNode O O], [Assignment])
dropAssignments should_drop state assigs
 = (dropped, reverse kept)
 where
   (dropped,kept) = go state assigs [] []

   go _ []             dropped kept = (dropped, kept)
   go state (assig : rest) dropped kept
      | conflict  = go state' rest (toNode assig : dropped) kept
      | otherwise = go state' rest dropped (assig:kept)
      where
        (dropit, state') = should_drop assig state
        conflict = dropit || any (assig `conflicts`) dropped

-- -----------------------------------------------------------------------------

-- | @conflicts (r,e) stmt@ is @False@ if and only if the assignment
-- @r = e@ can be safely commuted past @stmt@.
--
-- We only sink "r = G" assignments right now, so conflicts is very simple:
--
conflicts :: Assignment -> CmmNode O x -> Bool
(_, rhs, _   ) `conflicts` CmmAssign reg  _ | reg `regUsedIn` rhs = True
(_, _,   addr) `conflicts` CmmStore addr' _ | addrConflicts addr (loadAddr addr') = True
(r, _,   _)    `conflicts` node
  = foldRegsUsed (\b r' -> r == r' || b) False node

-- An abstraction of the addresses read or written.
data AbsAddr = NoAddr | HeapAddr | StackAddr | AnyAddr

bothAddrs :: AbsAddr -> AbsAddr -> AbsAddr
bothAddrs NoAddr    x         = x
bothAddrs x         NoAddr    = x
bothAddrs HeapAddr  HeapAddr  = HeapAddr
bothAddrs StackAddr StackAddr = StackAddr
bothAddrs _         _         = AnyAddr

addrConflicts :: AbsAddr -> AbsAddr -> Bool
addrConflicts NoAddr    _         = False
addrConflicts _         NoAddr    = False
addrConflicts HeapAddr  StackAddr = False
addrConflicts StackAddr HeapAddr  = False
addrConflicts _         _         = True

exprAddr :: CmmExpr -> AbsAddr -- here NoAddr means "no reads"
exprAddr (CmmLoad addr _)  = loadAddr addr
exprAddr (CmmMachOp _ es)  = foldr bothAddrs NoAddr (map exprAddr es)
exprAddr _                 = NoAddr

absAddr :: CmmExpr -> AbsAddr -- here NoAddr means "don't know"
absAddr (CmmLoad addr _)  = bothAddrs HeapAddr (loadAddr addr) -- (1)
absAddr (CmmMachOp _ es)  = foldr bothAddrs NoAddr (map absAddr es)
absAddr (CmmReg r)        = regAddr r
absAddr (CmmRegOff r _)   = regAddr r
absAddr _ = NoAddr

loadAddr :: CmmExpr -> AbsAddr
loadAddr e = case absAddr e of
               NoAddr -> HeapAddr -- (2)
               a      -> a

-- (1) we assume that an address read from memory is a heap address.
-- We never read a stack address from memory.
--
-- (2) loading from an unknown address is assumed to be a heap load.

regAddr :: CmmReg -> AbsAddr
regAddr (CmmGlobal Sp) = StackAddr
regAddr (CmmGlobal Hp) = HeapAddr
regAddr _              = NoAddr
