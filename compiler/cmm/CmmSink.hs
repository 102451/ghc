{-# LANGUAGE GADTs #-}
module CmmSink (
     cmmSink
  ) where

import Cmm
import BlockId
import CmmLive
import CmmUtils
import Hoopl

import UniqFM
import Unique
import Outputable

import Data.List (partition)
import qualified Data.Set as Set

-- -----------------------------------------------------------------------------
-- Sinking

-- This is an optimisation pass that
--  (a) moves assignments closer to their uses, to reduce register pressure
--  (b) pushes assignments into a single branch of a conditional if possible

-- It is particularly helpful in the Cmm generated by the Stg->Cmm
-- code generator, in which every function starts with a copyIn
-- sequence like:
--
--    x1 = R1
--    x2 = Sp[8]
--    x3 = Sp[16]
--    if (Sp - 32 < SpLim) then L1 else L2
--
-- we really want to push the x1..x3 assignments into the L2 branch.
--
-- Algorithm:
--
--  * Start by doing liveness analysis.
--  * Keep a list of assignments; earlier ones may refer to later ones
--  * Walk forwards through the graph;
--    * At an assignment:
--      * pick up the assignment and add it to the list
--    * At a store:
--      * drop any assignments that the store refers to
--      * drop any assignments that refer to memory that may be written
--        by the store
--      * do this recursively, dropping dependent assignments
--    * At a multi-way branch:
--      * drop any assignments that are live on more than one branch
--      * if any successor has more than one predecessor, drop everything
--        live in that successor
-- 
-- As a side-effect we'll delete some dead assignments (transitively,
-- even).  Maybe we could do without removeDeadAssignments?

-- If we do this *before* stack layout, we might be able to avoid
-- saving some things across calls/procpoints.
--
-- *but*, that will invalidate the liveness analysis, and we'll have
-- to re-do it.

type Assignment = (LocalReg, CmmExpr, AbsAddr)

cmmSink :: CmmGraph -> CmmGraph
cmmSink graph = ofBlockList (g_entry graph) $ sink mapEmpty $ blocks
  where

  liveness = cmmLiveness graph

  blocks = postorderDfs graph

  all_succs = concatMap successors blocks
  succ_counts :: BlockEnv Int
  succ_counts = foldr (\l -> mapInsertWith (+) l 1) mapEmpty all_succs
  join_pts = mapFilter (>1) succ_counts

  sink :: BlockEnv [Assignment] -> [CmmBlock] -> [CmmBlock]
  sink _ [] = []
  sink sunk (b:bs) =
    pprTrace "sink" (ppr lbl) $
    blockJoin first final_middle last : sink sunk' bs
    where
      lbl = entryLabel b
      (first, middle, last) = blockSplit b
      (middle', assigs) = walk ann_middles emptyBlock
                               (mapFindWithDefault [] lbl sunk)

      live = Set.unions [ mapFindWithDefault Set.empty l liveness | l <- succs ]
      live_middle = gen_kill last live

      ann_middles = annotate live_middle (blockToList middle)

      getLive l = mapFindWithDefault Set.empty l liveness
      succs = successors last
      (joins, nonjoins) = partition (`mapMember` join_pts) succs
      live_in_nonjoins = concatMap (Set.toList . getLive) nonjoins
      live_in_joins :: [LocalReg]
      live_in_joins    = concatMap (Set.toList . getLive) joins

      -- multilive is a list of registers that are live in more than
      -- one successor branch, and we should therefore drop them here.
      multilive = [ r | (r,n) <- ufmToList livemap, n > 1 ]
         where livemap = foldr (\r m -> addToUFM_C (+) m r (1::Int))
                            emptyUFM live_in_nonjoins

      (dropped_last, assigs') = dropAssignments drop_if assigs

      drop_if a@(r,_,_)
           =  a `conflicts` last
           || (getUnique r `elem` multilive)
           || (r `elem` live_in_joins)

      final_middle = foldl blockSnoc middle' dropped_last

      sunk' = mapUnion sunk $
                 mapFromList [ (l, filterAssignments (getLive l) assigs')
                             | l <- succs ]


-- annotate each node with the set of registers live *after* the node
annotate :: RegSet -> [CmmNode O O] -> [(RegSet, CmmNode O O)]
annotate live nodes = snd $ foldr (\n (live,nodes) -> (gen_kill n live, (live,n) : nodes)) (live,[]) nodes

filterAssignments :: RegSet -> [Assignment] -> [Assignment]
filterAssignments live assigs = reverse (go assigs [])
  where go []           kept = kept
        go (a@(r,_,_):as) kept | needed    = go as (a:kept)
                               | otherwise = go as kept
           where
              needed = r `Set.member` live || any (a `conflicts`) (map toNode kept)


walk :: [(RegSet, CmmNode O O)] -> Block CmmNode O O -> [Assignment]
     -> (Block CmmNode O O, [Assignment])

walk []               block as = (block, as)
walk ((live,node):ns) block as
  | Just a <- shouldSink node1 = walk ns block (a : as1)
  | otherwise                  = walk ns block' as'
  where
    (node1, as1) = tryToInline live usages node as
       where usages :: UniqFM Int
             usages = foldRegsUsed addUsage emptyUFM node

    (dropped, as') = dropAssignments (`conflicts` node1) as1
    block' = foldl blockSnoc block dropped `blockSnoc` node1

tryToInline :: RegSet -> UniqFM Int -> CmmNode O x -> [Assignment]
            -> (CmmNode O x, [Assignment])
tryToInline live usages node []
  = (node, [])
tryToInline live usages node ((l,rhs,_) : rest)
  | not (l `elemRegSet` live),
    Just 1 <- lookupUFM usages l
  = tryToInline live' usages' node' rest
  where
        live'   = foldRegsUsed extendRegSet live rhs
        usages' = foldRegsUsed addUsage usages rhs

        node' = mapExpDeep inline node
           where inline (CmmReg    (CmmLocal l'))     | l == l' = rhs
                 inline (CmmRegOff (CmmLocal l') off) | l == l' = cmmOffset rhs off
                 inline other = other
tryToInline live usages node (assig : rest)
  = (node', assig : rest')
  where (node', rest') = tryToInline live usages node rest

addUsage :: UniqFM Int -> LocalReg -> UniqFM Int
addUsage m r = addToUFM_C (+) m r 1

shouldSink :: CmmNode e x -> Maybe Assignment
shouldSink (CmmAssign (CmmLocal r) e) | no_local_regs = Just (r, e, exprAddr e)
  where no_local_regs = foldRegsUsed (\_ _ -> False) True e
shouldSink _other = Nothing

toNode :: Assignment -> CmmNode O O
toNode (r,rhs,_) = CmmAssign (CmmLocal r) rhs

dropAssignments :: (Assignment -> Bool) -> [Assignment] -> ([CmmNode O O], [Assignment])
dropAssignments should_drop assigs
 = (dropped, reverse kept)
 where
   (dropped,kept) = go assigs [] []

   go []             dropped kept = (dropped, kept)
   go (assig : rest) dropped kept
      | conflict  = go rest (toNode assig : dropped) kept
      | otherwise = go rest dropped (assig:kept)
      where
        conflict = should_drop assig || any (assig `conflicts`) dropped

-- | @conflicts (r,e) stmt@ is @False@ if and only if the assignment
-- @r = e@ can be safely commuted past @stmt@.
--
-- We only sink "r = G" assignments right now, so conflicts is very simple:
--
conflicts :: Assignment -> CmmNode O x -> Bool
(_, rhs, _   ) `conflicts` CmmAssign reg  _ | reg `regUsedIn` rhs = True
(_, _,   addr) `conflicts` CmmStore addr' _ | addrConflicts addr (loadAddr addr') = True
(r, _,   _)    `conflicts` node
  = foldRegsUsed (\b r' -> r == r' || b) False node

-- An abstraction of the addresses read or written.
data AbsAddr = NoAddr | HeapAddr | StackAddr | AnyAddr

bothAddrs :: AbsAddr -> AbsAddr -> AbsAddr
bothAddrs NoAddr    x         = x
bothAddrs x         NoAddr    = x
bothAddrs HeapAddr  HeapAddr  = HeapAddr
bothAddrs StackAddr StackAddr = StackAddr
bothAddrs _         _         = AnyAddr

addrConflicts :: AbsAddr -> AbsAddr -> Bool
addrConflicts NoAddr    _         = False
addrConflicts _         NoAddr    = False
addrConflicts HeapAddr  StackAddr = False
addrConflicts StackAddr HeapAddr  = False
addrConflicts _         _         = True

exprAddr :: CmmExpr -> AbsAddr -- here NoAddr means "no reads"
exprAddr (CmmLoad addr _)  = loadAddr addr
exprAddr (CmmMachOp _ es)  = foldr bothAddrs NoAddr (map exprAddr es)
exprAddr _                 = NoAddr

absAddr :: CmmExpr -> AbsAddr -- here NoAddr means "don't know"
absAddr (CmmLoad addr _)  = bothAddrs HeapAddr (loadAddr addr) -- (1)
absAddr (CmmMachOp _ es)  = foldr bothAddrs NoAddr (map absAddr es)
absAddr (CmmReg r)        = regAddr r
absAddr (CmmRegOff r _)   = regAddr r
absAddr _ = NoAddr

loadAddr :: CmmExpr -> AbsAddr
loadAddr e = case absAddr e of
               NoAddr -> HeapAddr -- (2)
               a      -> a

-- (1) we assume that an address read from memory is a heap address.
-- We never read a stack address from memory.
--
-- (2) loading from an unknown address is assumed to be a heap load.

regAddr :: CmmReg -> AbsAddr
regAddr (CmmGlobal Sp) = StackAddr
regAddr (CmmGlobal Hp) = HeapAddr
regAddr _              = NoAddr
