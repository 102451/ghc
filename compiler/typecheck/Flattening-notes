ToDo:

* Float only CTyEqCans.   kind-incompatible things should be CNonCanonical,
  so they won't float and generate a duplicate kind-unify message

  Then we can stop disabling floating when there are insolubles,
  and that will improve mc21 etc

* Note [Do not add duplicate derived isols]
  This mostly doesn't apply now, except for the fundeps

* TcCanonical re-orients, so TcInteract should
  not do so.  (TwoWay, OneWay)
* Check orientation (isFlattenTyVar) in canEqTyVarTyVar


* No need to zonk now we are unflattening

* TcInteract, Note [Efficient orientation]?

* inert_funeqs, inert_eqs: keep only the CtEvidence. 
   They are all CFunEqCans, CTyEqCans

* Update Note [Preparing inert set for implications]
* remove/rewrite TcMType Note [Unflattening while zonking]

* Consider individual data tpyes for CFunEqCan etc

----------------------
Outer given is rewritten by an inner given, then there must have been an inner given equality, hence the “given-eq” flag will be true anyway.

Inner given rewritten by outer, retains its level (ie. The inner one)

--------------------
Try: rewrite wanted with wanted only for fuvs (not all meta-tyvars)

But:   fuv ~ alpha[0]
       alpha[0] ~ fuv’
Now we don’t see that fuv ~ fuv’, which is a problem for injectivity detection.

Conclusion: rewrite watneds with wanted for all untouchables.

skol ~ untch, must re-orieint to untch ~ skol, so that we can use it to rewrite.


--------------
f :: [a] -> [b] -> blah
f (e1 :: F Int) (e2 :: F Int)

we get
   F Int ~ fuv
   fuv ~ [alpha]
   fuv ~ [beta]

We want: alpha := beta (which might unlock something else).  So rewriting wanted with wanted helps here.



----------------------------------------
indexed-types/should_failt/T4179

after solving
  [W] fuv_1 ~ fuv_2
  [W] A3 (FCon x)           ~ fuv_1    (CFunEqCan)
  [W] A3 (x (aoa -> fuv_2)) ~ fuv_2    (CFunEqCan)

----------------------------------------
indexed-types/should_fail/T7729a

a)  [W]   BasePrimMonad (Rand m) ~ m1
b)  [W]   tt m1 ~ BasePrimMonad (Rand m)

--->  process (b) first
    BasePrimMonad (Ramd m) ~ fuv_atH
    fuv_atH ~ tt m1
  
--->  now process (a)
    m1 ~ s_atH ~ tt m1    -- An obscure occurs check


----------------------------------------
typecheck/TcTypeNatSimple

Original constraint
  [W] x + y ~ x + alpha  (non-canonical)
==>
  [W] x + y     ~ fuv1   (CFunEqCan)
  [W] x + alpha ~ fuv2   (CFuneqCan)
  [W] fuv1 ~ fuv2        (CTyEqCan)

(sigh)

----------------------------------------
indexed-types/should_fail/GADTwrong1

  [G] Const a ~ ()
==> flatten
  [G] fsk ~ ()
  work item: Const a ~ fsk
==> fire top rule
  [G] fsk ~ ()
  work item fsk ~ ()

Surely the work item should rewrite to () ~ ()?  Well, maybe not;
it'a very special case.  More generally, our givens look like 
F a ~ Int, where (F a) is not reducible.

----------------------------------------
indexed_types/should_fail/T7786

  BuriedUnder sub k Empty ~ fsk _ajP
  Intersect fsk_ajP inv ~ s_aJM
  xxx[1] ~ s_aJM
  forall . (xxx ~ Empty 
         => Intersect (BuriedUnder sub k Empty) inv ~ Empty

Conclusion: unflatten before solving nested implications

----------------------------------------
indexed_types/should_fail/T8227:

   Inert: [W] fsk_aBh ~ fuv_aBk -> fuv_aBk
          [W] fuv_aBk ~ fsk_aBh

          [G] Scalar fsk_aBg ~ fsk_aBh
          [G] V a ~ f_aBg

   Worklist includes  [W] Scalar fuv_aBi ~ fuv_aBk
   fuv_aBi, fuv_aBk are flatten unificaiton variables

   Work item: [W] V fsk_aBh ~ fuv_aBi

Note that the inert wanteds are cyclic, because we do not rewrite
wanteds with wanteds.


Then we go into a loop when normalise the work-item, because we
use rewriteOrSame on the argument of V.

Conclusion: Don't make canRewrite context specific; instead use 
[W] a ~ ty to rewrite a wanted iff 'a' is a unification variable.


----------------------------------------
IndTypesPerfMerge is interesting

      [G] F a ~ a
      [W] F alpha ~ alpha, alpha ~ a

    From Givens we get
      [G] F a ~ fsk, fsk ~ a

    Now if we flatten we get
      [W] alpha ~ fuv, F alpha ~ fuv, alpha ~ a

    Now, processing the first one first, choosing alpha := fuv
      [W] F fuv ~ fuv, fuv ~ a

    And now we are stuck.  We must either *unify* fuv := a, or
    use the fuv ~ a to rewrite F fuv ~ fuv, so we can make it
    meet up with the given F a ~ blah.

Here is a somewhat similar case:

   type family G a :: *

   blah :: (G a ~ Bool, Eq (G a)) => a -> a
   blah = error "urk"

   foo x = blah x

For foo we get
   [W] Eq (G a), G a ~ Bool
Flattening
   [W] G a ~ fuv, Eq fuv, fuv ~ Bool
We can't simplify away the Eq Bool unless we substitute for 

The new flattening story
~~~~~~~~~~~~~~~~~~~~~~~~
* A "flatten-skolem", fsk, is a *unification* variable
  (ie with an IORef inside it)

* A CFunEqCan is either of form
     [G] <F xis> : F xis ~ fsk   -- fsk is a FlatSkol
     [W]       x : F xis ~ usk   -- usk is a unification variable,
                                 -- but untouchable
  where
     x is the witness variable
     fsk is a flatten skolem
     xis are function-free
  CFunEqCans are always [Wanted], or [Given]

  usk untouchable just means that in a CTyVarEq, say,
       usk ~ Int
  we do NOT unify usk.

* KEY INSIGHTS:

   - A given flatten-skolem, fsk, is known a-priori to be equal to
     F xis (the LHS), with <F xis> evidence

   - A unification flatten-skolem, usk, stands for the as-yet-unknown 
     type to which (F xis) will eventually reduce


* Inert set invariant: if F xis1 ~ fsk1, F xis2 ~ fsk2
                       then xis1 /= xis2 
  i.e. at most one CFunEqCan with a particular LHS

* Each canonical CFunEqCan x : F xis ~ fsk/usk has its own
  distinct evidence variable x and flatten-skolem fsk/usk.
  Why? We make a fresh fsk/usk when the constraint is born;
  and we never rewrite the RHS of a CFunEqCan.

* CFunEqCans are the *only* way that function applications appear in
  canonical constraints.  Function applications in any other
  constraint must be gotten rid of by flattening, thereby generating
  fresh CFunEqCans.

* Flattening a type (F xis):
    - If any member of fvs(xis) is a touchable unification variable
                                or a unification flatten-skolem usk
      then create new [W] x : F xis ~ usk
      else create new [G] x : F xis ~ fsk
      with fresh evidence variable x and flatten-skolem fsk/usk

      NB: givens never contain touchable unification variables

    - Add it to the work list

    - Replace (F xis) with fsk/usk in the type you are flattening

    - You can also add the CFunEqCan to the "flat cache", which
      simply keeps track of all the function applications you
      have flattened. 

    - If (F xis) is in the cache already, just
      use its fsk/usk and evidence x, and emit nothing.

    - No need to substitute in the flat-cache. It's not the end
      of the world if we start with, say (F alpha ~ usk1) and
      (F Int ~ usk2) and then find alpha := Int.  Athat will
      simply give rise to usk1 := usk2 via [Interacting rule] below

* Canonicalising a CFunEqan [G/W] x : F xis ~ fks/usk
    - Flatten xis (to substitute any tyvars; there are already no functions)
                  cos :: xis ~ flat_xis
    - New wanted  x2 :: F flat_xis ~ fsk/usk
    - Add new wanted to flat cache
    - Discharge x = F cos ; x2

* Unification flatten-skolems, usk, ONLY get unified when either
    a) The CFunEqCan takes a step, using an axiom
    b) During un-flattening at the very, very end
  They are never unified in any other form of equality.
  For example [W] fsk ~ Int  is stuck; it does not unify with fsk.

* We *never* substitute in the RHS (i.e. the fsk) of a CFunEqCan.
  That would destroy the invariant about the shape of a CFunEqCan,
  and it would risk wanted/wanted interactions. The only way we
  learn information about fsk is when the CFunEqCan takes a step.

  However we *do* substitute in the LHS of a CFunEqCan (else it
  would never get to fire!)

* [Interacting rule]
    (inert)     [W] x1 : F tys ~ usk1
    (work item) [W] x2 : F tys ~ usk2
  Just solve one from the other:
    x2 := x1
    usk2 := usk1
  This just unites the two fsks into one.
  Always solve given from wanted if poss.

* [Firing rule: wanteds]
    (work item) [W] x : F tys ~ fuv
    instantiate axiom: ax_co : F tys ~ rhs

   Dischard fuv:
      fuv := alpha
      x := ax_co ; sym x2
      [W] x2 : alpha ~ rhs  (Non-canonical)
   discharging the work item. This is the way that usk's get
   unified; even though they are "untouchable".

   NB: this deals with the case where fuv appears in xi, which can
   happen; it just happens through the non-canonical stuff

   Possible short cut if rhs = G rhs_tys, 
   where G is a type function.  Then
      - Flatten rhs_tys (cos : rhs_tys ~ rhs_xis)
      - Add G rhs_xis ~ fuv to flat cache
      - New wanted [W] x2 : G rhs_xis ~ fuv
      - Discharge x := co ; G cos ; x2

* [Firing rule: givens]
    (work item) [G] g : F tys ~ fsk
    instantiate axiom: co : F tys ~ rhs

   Now add non-canonical (since rhs is not flat)
      [G] (sym g ; co) : fsk ~ rhs

   Short cut for when rhs = G rhs_tys and G is a type function
      [G] (co ; g) : G tys ~ fsk
   But need to flatten tys:  flat_cos : tys ~ flat_tys
      [G] (sym (G flat_cos) ; co ; g) : G flat_tys ~ fsk

Floating
~~~~~~~~
Principle 1: do floating as if you un-flattened first

For example:
   [2] forall s.  () => (F alpha[1] s ~ fuv, alpha[1] ~ Maybe fuv)
   and axiom F (Maybe _) x = x

Here we obviously cannot float (F alpha s ~ fuv) since it mentions s,
*and hence* cannot float alpha ~ Maybe fuv

BUT consider this:
   [2] forall s.  () => (F alpha[1] t ~ fuv, alpha[1] ~ Maybe fuv)
   and axiom F (Maybe _) x = x

Here we really *should* float both constraints, since they are
equivalent to this (un-flattened) constraint
   [2] forall s.  alpha[1] ~ Maybe (F alpha[1] t)
which is clearly floatable.

Principle 2: start the quest for floating with (a[n] ~ xi), where
a is an untouchable unification variable.  Reason: the whole point
of floating is to make thse

Algorithm.  Start with ([W] a[n] ~ xi)
            Look at free vars of xi
               - unification variable: promote if necessary
               - fuv: float if its CFunEqCan is floatable
               - skolem bound at this level: do not float
               - fsk: look at the free vars of its value
                      (in that case maybe promote a ~ F Int,
                      rather than a ~ fsk, perhaps)
            (see Principle 1)

---------------
----------------
Preparing the inert set for implications

   type instance F True a b = a
   type instance F False a b = b

   [W] x : F c a b ~ fsk
   [G] gamma ~ fsk
   (c ~ True)  => a ~ gamma
   (c ~ False) => b ~ gamma
--> (c ~ True branch)  Push in as given non-canonical
   [G] g : (c ~ True)
   [G] x : F c a b ~ fsk  (nc)
   [W] a ~ fsk,
--> flatten
   [G] g : (c ~ True)
   [G] sym x1 ; x : fsk1 ~ fsk
   [W] x1 : F c a b ~ fsk1 (canon)
  [W] a ~ fsk,
---> subst c
   [G] g : (c ~ True)
   [G] sym x1 ; x : fsk1 ~ fsk
   [W] x2 : F True a b ~ fsk1 (canon)
   x1 = F g a b ; x2
   [W] a ~ fsk,
---> step  ax : F True a b ~ a
   [G] g : (c ~ True)
   [G] sym x1 ; x : fsk1 ~ fsk
   [W] x2 : F True a b ~ fsk1 (canon)
   [G] <a> : fsk1 := a
   x2 = ax

   [W] a ~ fsk,

--------------------------
Simple20
~~~~~~~~
axiom F [a] = [F a]

 [G] F [a] ~ a
-->
 [G] fsk ~ a
 [G] [F a] ~ fsk  (nc)
-->
 [G] F a ~ fsk2
 [G] fsk ~ [fsk2] 
 [G] fsk ~ a
-->
 [G] F a ~ fsk2
 [G] a ~ [fsk2]
 [G] fsk ~ a


-------------------------------------------
Simple13  with unification-fsks only
~~~~~~~~  (This is why unif-fsks-only doesn't work)

  [G] g : a ~ [F a]

---> Flatten given
  g' = g;[x]
  [G] g'  : a ~ [usk]
  [W] x : F a ~ usk

--> subst a in x
       x = F g' ; x2
   [W] x2 : F [usk] ~ usk

And now we have an evidence cycle between g' and x.

If we used a given instead (ie current story)

  [G] g : a ~ [F a]

---> Flatten given
  g' = g;[x]
  [G] g'  : a ~ [fsk]
  [G] <F a> : F a ~ fsk

---> Substitute for a
  [G] g'  : a ~ [fsk]
  [G] F (sym g'); <F a> : F [fsk] ~ fsk



-------------------------------------------
Why given-fsks, alone, doesn't work
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [W] w : alpha ~ [F alpha Int]

---> flatten
  w = ...w'...
  [W] w' : alpha ~ [fsk]
  [G] <F alpha Int> : F alpha Int ~ fsk

--> unify (no occurs check)
  alpha := [fsk]

But since fsk = F alpha Int, this is really an occurs check error.  If
that is all we know about alpha, we will succeed in constraint
solving, producing a program with an infinite type.

Even if we did finally get (g : fsk ~ Boo)l by solving (F alpha Int ~ fsk)
using axiom, zonking would not see it, so (x::alpha) sitting in the
tree will get zonked to an infinite type.  (Zonking always only does
refl stuff.)




