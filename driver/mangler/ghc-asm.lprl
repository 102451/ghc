%************************************************************************
%*									*
\section[Driver-asm-fiddling]{Fiddling with assembler files}
%*									*
%************************************************************************

Tasks:
\begin{itemize}
\item
Utterly stomp out C functions' prologues and epilogues; i.e., the
stuff to do with the C stack.
\item
Any other required tidying up.
\end{itemize}

General note [chak]: Many regexps are very fragile because they rely on white
space being in the right place.  This caused trouble with gcc 2.95 (at least
on Linux), where the use of white space in .s files generated by gcc suddenly 
changed.  To guarantee compatibility across different versions of gcc, make
sure (at least on i386-.*-linux) that regexps tolerate varying amounts of white
space between an assembler statement and its arguments as well as after a the
comma separating multiple arguments.  

\emph{For the time being, I have corrected the regexps for i386-.*-linux.  I
didn't touch all the regexps for other i386 platforms, as I don't have
a box to test these changes.}

HPPA specific notes:
\begin{itemize}
\item
The HP linker is very picky about symbols being in the appropriate
space (code vs. data).  When we mangle the threaded code to put the
info tables just prior to the code, they wind up in code space
rather than data space.  This means that references to *_info from
un-mangled parts of the RTS (e.g. unthreaded GC code) get
unresolved symbols.  Solution:  mini-mangler for .c files on HP.  I
think this should really be triggered in the driver by a new -rts
option, so that user code doesn't get mangled inappropriately.
\item
With reversed tables, jumps are to the _info label rather than to
the _entry label.  The _info label is just an address in code
space, rather than an entry point with the descriptive blob we
talked about yesterday.  As a result, you can't use the call-style
JMP_ macro.  However, some JMP_ macros take _info labels as targets
and some take code entry points within the RTS.  The latter won't
work with the goto-style JMP_ macro.  Sigh.  Solution: Use the goto
style JMP_ macro, and mangle some more assembly, changing all
"RP'literal" and "LP'literal" references to "R'literal" and
"L'literal," so that you get the real address of the code, rather
than the descriptive blob.  Also change all ".word P%literal"
entries in info tables and vector tables to just ".word literal,"
for the same reason.  Advantage: No more ridiculous call sequences.
\end{itemize}

%************************************************************************
%*									*
\subsection{Top-level code}
%*									*
%************************************************************************

\begin{code}
$TargetPlatform = $TARGETPLATFORM;

($Pgm = $0) =~ s|.*/||;
$ifile = $ARGV[0];
$ofile = $ARGV[1];

if ( $TargetPlatform =~ /^i386-/ ) {
    if ($ARGV[2] eq '') {
	$StolenX86Regs = 4;
    } else {
        $StolenX86Regs = $ARGV[2];
    }
}

&mangle_asm($ifile,$ofile);

exit(0);
\end{code}

%************************************************************************
%*									*
\subsection{Constants for various architectures}
%*									*
%************************************************************************

\begin{code}
sub init_TARGET_STUFF {

    #--------------------------------------------------------#
    if ( $TargetPlatform =~ /^alpha-.*-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$L?C(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\$.*\.\.ng:|\.align\s+\d+|\.(globl|ent)\s+\S+|\#.*|\.(file|loc)\s+\S+\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '^\s*(\$.*\.\.ng:|\#|\.(file|globl|ent|loc))';

    $T_DOT_WORD	    = '\.(long|quad|byte|word)';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\.rdata\n\t\.align 3\n";
    $T_HDR_misc	    = "\.text\n\t\.align 3\n";
    $T_HDR_data	    = "\.data\n\t\.align 3\n";
    $T_HDR_rodata   = "\.rdata\n\t\.align 3\n";
    $T_HDR_closure  = "\.data\n\t\.align 3\n";
    $T_HDR_info	    = "\.text\n\t\.align 3\n";
    $T_HDR_entry    = "\.text\n\t\.align 3\n";
    $T_HDR_vector   = "\.text\n\t\.align 3\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^hppa/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DONT THINK THIS APPLIES'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^L\$C(\d+)$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = '';

    $T_MOVE_DIRVS   = '^((\s+\.(IMPORT|EXPORT|PARAM).*|\s+\.align\s+\d+|\s+\.(SPACE|SUBSPA)\s+\S+|\s*)\n)';
    $T_COPY_DIRVS   = '^\s+\.(IMPORT|EXPORT)';

    $T_DOT_WORD	    = '\.(blockz|word|half|byte)';
    $T_DOT_GLOBAL   = '^\s+\.EXPORT';
    $T_HDR_literal  = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$LIT\$\n";
    $T_HDR_misc	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_data	    = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_rodata   = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_closure  = "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$DATA\$\n\t\.align 4\n";
    $T_HDR_info	    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_entry    = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";
    $T_HDR_vector   = "\t.SPACE \$TEXT\$\n\t.SUBSPA \$CODE\$\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(linuxaout|freebsd2|nextstep3|cygwin32|mingw32)$/ ) {
				# NeXT added but not tested. CaS

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = 'L';
    $T_X86_PRE_LLBL	    = 'L';
    $T_X86_BADJMP   = '^\tjmp [^L\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s.*|\.globl\s+\S+|\.text|\.data|\.stab[^n].*|\.type\s+.*|\.size\s+.*|\.lcomm.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|stab|lcomm)';
    $T_DOT_WORD	    = '\.(long|word|value|byte|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.align 2\n";
    $T_HDR_misc	    = "\.text\n\t\.align 2,0x90\n";
    $T_HDR_data	    = "\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\.text\n\t\.align 2\n";
    $T_HDR_closure  = "\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\.text\n\t\.align 2\n"; # NB: requires padding
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_vector   = "\.text\n\t\.align 2\n"; # NB: requires padding

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-.*-(solaris2|linux|gnu|freebsd|netbsd|openbsd|kfreebsdgnu)$/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = # regexp that says what comes before APP/NO_APP
		      ($TargetPlatform =~ /-(linux|gnu|freebsd|netbsd|openbsd)$/) ? '#' : '/' ;
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = '\.L';
    $T_X86_PRE_LLBL	    = '.L';
    $T_X86_BADJMP   = '^\tjmp\s+[^\.\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s.*|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
    $T_COPY_DIRVS   = '^\s*\.(globl|type|size|local)';

    $T_DOT_WORD	    = '\.(long|value|word|byte|zero)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.section\t\.rodata\n"; # or just use .text??? (WDP 95/11)
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 4\n";
    $T_HDR_rodata   = "\.section\t\.rodata\n\t\.align 4\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n"; # no .align so we're right next to _info (arguably wrong...?)
    $T_HDR_vector   = "\.text\n\t\.align 4\n"; # NB: requires padding

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^ia64-.*-linux$/ ) {

    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#';
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^(\s*\.(global|proc|pred\.safe_across_calls|text|data|section|subsection|align|size|type|ident)\s+.*\n)';
    $T_COPY_DIRVS   = '\.(global|proc)';

    $T_DOT_WORD     = '\.(long|value|byte|zero)';
    $T_DOT_GLOBAL   = '\.global';
    $T_HDR_literal  = "\.section\t\.rodata\n";
    $T_HDR_misc     = "\.text\n\t\.align 16\n"; # May contain code; align like 'entry'
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_rodata   = "\.section\t\.rodata\n\t\.align 8\n";
    $T_HDR_closure  = "\.data\n\t\.align 8\n";
    $T_HDR_info     = "\.text\n\t\.align 8\n";
    $T_HDR_entry    = "\.text\n\t\.align 16\n";
    $T_HDR_vector   = "\.text\n\t\.align 8\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^x86_64-.*-(linux|openbsd)$/ ) {

    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#';
    $T_CONST_LBL    = '^\.LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^(\s*\.(globl|text|data|section|align|size|type|ident|local)\s+.*\n)';
    $T_COPY_DIRVS   = '\.(globl|type|size|local)';

    $T_DOT_WORD     = '\.(quad|long|value|byte|zero)';
    $T_DOT_GLOBAL   = '\.global';

    $T_HDR_literal16 = "\.section\t\.rodata.cst16\n\t.align 16\n";
    $T_HDR_literal  = "\.section\t\.rodata\n";

    $T_HDR_misc     = "\.text\n\t\.align 8\n";
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_rodata   = "\.section\t\.rodata\n\t\.align 8\n";

	# the assembler on x86_64/Linux refuses to generate code for
	#   .quad  x - y
	# where x is in the text section and y in the rodata section.
	# It works if y is in the text section, though.  This is probably
	# going to cause difficulties for PIC, I imagine.
    $T_HDR_relrodata= "\.text\n\t\.align 8\n";

    $T_HDR_closure  = "\.data\n\t\.align 8\n";
    $T_HDR_info     = "\.text\n\t\.align 8\n";
    $T_HDR_entry    = "\.text\n\t\.align 8\n";
    $T_HDR_vector   = "\.text\n\t\.align 8\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^m68k-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# MAY NOT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.proc\s+\d+|\.const|\.cstring|\.globl\s+\S+|\.text|\.data|\.even|\.stab[^n].*)\n)';
    $T_COPY_DIRVS   = '\.(globl|proc|stab)';

    $T_DOT_WORD	    = '\.long';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_literal  = "\.text\n\t\.even\n";
    $T_HDR_misc	    = "\.text\n\t\.even\n";
    $T_HDR_data	    = "\.data\n\t\.even\n";
    $T_HDR_rodata   = "\.text\n\t\.even\n";
    $T_HDR_closure  = "\.data\n\t\.even\n";
    $T_HDR_info	    = "\.text\n\t\.even\n";
    $T_HDR_entry    = "\.text\n\t\.even\n";
    $T_HDR_vector   = "\.text\n\t\.even\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^mips-.*/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^\s*#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\$LC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align\s+\d+|\.(globl|ent)\s+\S+|\.text|\.r?data)\n)';
    $T_COPY_DIRVS   = '\.(globl|ent)';

    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.globl';
    $T_HDR_literal  = "\t\.rdata\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.rdata\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc-apple-darwin.*/ ) {
				# Apple PowerPC Darwin/MacOS X.
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOESNT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s.*|\.text|\.data|\.const_data|\.cstring|\.non_lazy_symbol_pointer|\.const|\.static_const|\.literal4|\.literal8|\.static_data|\.globl \S+|\.section .*|\.lcomm.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|lcomm)';

    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\t\.const\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.const\n\t\.align 2\n";
    $T_HDR_relrodata= "\t\.const_data\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^i386-apple-darwin.*/ ) {
				# Apple PowerPC Darwin/MacOS X.
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOESNT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';
    $T_X86_PRE_LLBL_PAT = 'L';
    $T_X86_PRE_LLBL	    = 'L';
    $T_X86_BADJMP   = '^\tjmp [^L\*]';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s.*|\.text|\.data|\.const_data|\.cstring|\.non_lazy_symbol_pointer|\.const|\.static_const|\.literal4|\.literal8|\.static_data|\.globl \S+|\.section .*|\.lcomm.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|lcomm)';

    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal16= "\t\.literal8\n\t\.align 4\n";
    $T_HDR_literal  = "\t\.const\n\t\.align 4\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.const\n\t\.align 2\n";
    $T_HDR_relrodata= "\t\.const_data\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^x86_64-apple-darwin.*/ ) {
				# Apple PowerPC Darwin/MacOS X.
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOESNT APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.align \d+|\.text|\.data|\.const_data|\.cstring|\.non_lazy_symbol_pointer|\.const|\.static_const|\.literal4|\.literal8|\.static_data|\.globl \S+|\.section .*|\.lcomm.*)\n)';
    $T_COPY_DIRVS   = '\.(globl|lcomm)';

    $T_DOT_WORD	    = '\.(quad|long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal16= "\t\.literal8\n\t\.align 4\n";
    $T_HDR_literal  = "\t\.const\n\t\.align 4\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.const\n\t\.align 2\n";
    $T_HDR_relrodata= "\t\.const_data\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc-.*-linux/ ) {
				# PowerPC Linux
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,\s*0x90)?|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
    $T_COPY_DIRVS   = '^\s*\.(globl|type|size|local)';

    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\t\.section\t.rodata\n\t\.align 2\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.section\t.rodata\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^powerpc64-.*-linux/ ) {
				# PowerPC 64 Linux
    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '\.'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^#'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LC\d+:'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^(\s*(\.(p2)?align\s+\d+(,\s*0x90)?|\.globl\s+\S+|\.text|\.data|\.section\s+.*|\.type\s+.*|\.size\s+\S+\s*,\s*\d+|\.ident.*|\.local.*)\n)';
    $T_COPY_DIRVS   = '^\s*\.(globl|type|size|local)';

    $T_DOT_WORD	    = '\.(long|short|byte|fill|space)';
    $T_DOT_GLOBAL   = '\.globl';
    $T_HDR_toc      = "\.toc\n";
    $T_HDR_literal  = "\t\.section\t\".toc\",\"aw\"\n";
    $T_HDR_misc	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_data	    = "\t\.data\n\t\.align 2\n";
    $T_HDR_rodata   = "\t\.section\t.rodata\n\t\.align 2\n";
    $T_HDR_closure  = "\t\.data\n\t\.align 2\n";
    $T_HDR_info	    = "\t\.text\n\t\.align 2\n";
    $T_HDR_entry    = "\t\.text\n\t\.align 2\n";
    $T_HDR_vector   = "\t\.text\n\t\.align 2\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-(solaris2|openbsd)/ ) {

    $T_STABBY	    = 0; # 1 iff .stab things (usually if a.out format)
    $T_US	    = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = 'DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^\.LLC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   =  '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\s+\.local\s+\S+|\.text|\.data|\.stab.*|\s*\.section.*|\s+\.type.*|\s+\.size.*)\n)';
    $T_COPY_DIRVS   = '\.(global|local|proc|stab)';

    $T_DOT_WORD	    = '\.(long|word|byte|half|skip|uahalf|uaword)';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_rodata   = "\.text\n\t\.align 4\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_info     = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-sunos4/ ) {

    $T_STABBY	    = 1; # 1 iff .stab things (usually if a.out format)
    $T_US	    = '_'; # _ if symbols have an underscore on the front
    $T_PRE_APP	    = '^# DOES NOT SEEM TO APPLY'; # regexp that says what comes before APP/NO_APP
    $T_CONST_LBL    = '^LC(\d+):$';
    $T_POST_LBL	    = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\.text|\.data|\.stab.*)\n)';
    $T_COPY_DIRVS   = '\.(global|proc|stab)';

    $T_DOT_WORD	    = '\.word';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc	    = "\.text\n\t\.align 4\n";
    $T_HDR_data	    = "\.data\n\t\.align 8\n";
    $T_HDR_rodata   = "\.text\n\t\.align 4\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_info	    = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } elsif ( $TargetPlatform =~ /^sparc-.*-linux/ ) {
    $T_STABBY       = 0; # 1 iff .stab things (usually if a.out format)
    $T_US           = ''; # _ if symbols have an underscore on the front
    $T_PRE_APP      = '#'; # regexp that says what comes before APP/NO_APP
                           # Probably doesn't apply anyway
    $T_CONST_LBL    = '^\.LLC(\d+):$'; # regexp for what such a lbl looks like
    $T_POST_LBL     = ':';

    $T_MOVE_DIRVS   = '^((\s+\.align\s+\d+|\s+\.proc\s+\d+|\s+\.global\s+\S+|\s+\.local\s+\S+|\.text|\.data|\.seg|\.stab.*|\s+?\.section.*|\s+\.type.*|\s+\.size.*)\n)';
    $T_COPY_DIRVS   = '\.(global|local|globl|proc|stab)';

    $T_DOT_WORD     = '\.(long|word|nword|xword|byte|half|short|skip|uahalf|uaword)';
    $T_DOT_GLOBAL   = '^\t\.global';
    $T_HDR_literal  = "\.text\n\t\.align 8\n";
    $T_HDR_misc     = "\.text\n\t\.align 4\n";
    $T_HDR_data     = "\.data\n\t\.align 8\n";
    $T_HDR_rodata   = "\.text\n\t\.align 4\n";
    $T_HDR_closure  = "\.data\n\t\.align 4\n";
    $T_HDR_info     = "\.text\n\t\.align 4\n";
    $T_HDR_entry    = "\.text\n\t\.align 4\n";
    $T_HDR_vector   = "\.text\n\t\.align 4\n";

    #--------------------------------------------------------#
    } else {
	print STDERR "$Pgm: don't know how to mangle assembly language for: $TargetPlatform\n";
	exit 1;
    }

    if($T_HDR_relrodata eq "") {
            # default values:
            # relrodata defaults to rodata.
        $T_HDR_relrodata = $T_HDR_rodata;
    }

if ( 0 ) {
print STDERR "T_STABBY: $T_STABBY\n";
print STDERR "T_US: $T_US\n";
print STDERR "T_PRE_APP: $T_PRE_APP\n";
print STDERR "T_CONST_LBL: $T_CONST_LBL\n";
print STDERR "T_POST_LBL: $T_POST_LBL\n";
if ( $TargetPlatform =~ /^i386-/ ) {
    print STDERR "T_X86_PRE_LLBL_PAT: $T_X86_PRE_LLBL_PAT\n";
    print STDERR "T_X86_PRE_LLBL: $T_X86_PRE_LLBL\n";
    print STDERR "T_X86_BADJMP: $T_X86_BADJMP\n";
}
print STDERR "T_MOVE_DIRVS: $T_MOVE_DIRVS\n";
print STDERR "T_COPY_DIRVS: $T_COPY_DIRVS\n";
print STDERR "T_DOT_WORD: $T_DOT_WORD\n";
print STDERR "T_HDR_literal: $T_HDR_literal\n";
print STDERR "T_HDR_misc: $T_HDR_misc\n";
print STDERR "T_HDR_data: $T_HDR_data\n";
print STDERR "T_HDR_rodata: $T_HDR_rodata\n";
print STDERR "T_HDR_closure: $T_HDR_closure\n";
print STDERR "T_HDR_info: $T_HDR_info\n";
print STDERR "T_HDR_entry: $T_HDR_entry\n";
print STDERR "T_HDR_vector: $T_HDR_vector\n";
}

}
\end{code}

%************************************************************************
%*									*
\subsection{Mangle away}
%*									*
%************************************************************************

\begin{code}
sub mangle_asm {
    local($in_asmf, $out_asmf) = @_;

    # multi-line regexp matching:
    local($*) = 1;
    local($i, $c);

    # ia64-specific information for code chunks
    my $ia64_locnum;
    my $ia64_outnum;

    &init_TARGET_STUFF();
    &init_FUNNY_THINGS();

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    # read whole file, divide into "chunks":
    #	record some info about what we've found...

    @chk = ();		# contents of the chunk
    $numchks = 0;	# number of them
    @chkcat = ();	# what category of thing in each chunk
    @chksymb = ();	# what symbol(base) is defined in this chunk
    %entrychk = ();	# ditto, its entry code
    %closurechk = ();	# ditto, the (static) closure
    %srtchk = ();	# ditto, its SRT (for top-level things)
    %infochk = (); 	# given a symbol base, say what chunk its info tbl is in
    %vectorchk = ();    # ditto, return vector table
    $EXTERN_DECLS = '';	# .globl <foo> .text (MIPS only)

    $i = 0; $chkcat[0] = 'misc'; $chk[0] = '';

    while (<INASM>) {
	tr/\r//d if $TargetPlatform =~ /-mingw32$/; # In case Perl doesn't convert line endings
	next if $T_STABBY && /^\.stab.*${T_US}__stg_split_marker/o;
	next if $T_STABBY && /^\.stab.*ghc.*c_ID/;
	next if /^\t\.def.*endef$/;
	next if /${T_PRE_APP}(NO_)?APP/o; 
    	next if /^;/ && $TargetPlatform =~ /^hppa/;

	next if /(^$|^\t\.file\t|^ # )/ && $TargetPlatform =~ /^(mips|ia64)-/;

	if ( $TargetPlatform =~ /^mips-/ 
	  && /^\t\.(globl\S+\.text|comm\t)/ ) {
	    $EXTERN_DECLS .= $_ unless /(__DISCARD__|\b(PK_|ASSIGN_)(FLT|DBL)\b)/;
	# Treat .comm variables as data.  These show up in two (known) places:
	#
	#    - the module_registered variable used in the __stginit fragment.
	#      even though these are declared static and initialised, gcc 3.3
	#      likes to make them .comm, presumably to save space in the
	#      object file.
	#
	#    - global variables used to pass arguments from C to STG in
	#      a foreign export.  (is this still true? --SDM)
	# 
	} elsif ( /^\t\.comm.*$/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	# Labels ending "_str": these are literal strings.
	} elsif ( /^${T_US}([A-Za-z0-9_]+)_str${T_POST_LBL}$/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'rodata';
	    $chksymb[$i] = '';
        } elsif ( $TargetPlatform =~ /-darwin/
                && (/^\s*\.subsections_via_symbols/
                  ||/^\s*\.no_dead_strip.*/)) {
            # Don't allow Apple's linker to do any dead-stripping of symbols
            # in this file, because it will mess up info-tables in mangled
            # code.
            # The .no_dead_strip directives are actually put there by
            # the gcc3 "used" attribute on entry points.
        
        } elsif ( $TargetPlatform =~ /^.*-apple-darwin.*/ && ( 
		   /^\s*\.picsymbol_stub/
		|| /^\s*\.section __TEXT,__picsymbol_stub\d,.*/
		|| /^\s*\.section __TEXT,__picsymbolstub\d,.*/
		|| /^\s*\.symbol_stub/
		|| /^\s*\.section __TEXT,__symbol_stub\d,.*/
		|| /^\s*\.section __TEXT,__symbolstub\d,.*/
		|| /^\s*\.lazy_symbol_pointer/
		|| /^\s*\.non_lazy_symbol_pointer/
		|| /^\s*\.section __IMPORT.*/))
	{
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'dyld';
	    $chksymb[$i] = '';
	    $dyld_section = $_;

	} elsif ( $TargetPlatform =~ /^.*-apple-darwin.*/ && $chkcat[$i] eq 'dyld' && /^\s*\.data/)
	{	# non_lazy_symbol_ptrs that point to local symbols
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'dyld';
	    $chksymb[$i] = '';
	    $dyld_section = $_;
	} elsif ( $TargetPlatform =~ /^.*-apple-darwin.*/ && $chkcat[$i] eq 'dyld' && /^\s*\.align/)
	{	# non_lazy_symbol_ptrs that point to local symbols
	    $dyld_section .= $_;
	} elsif ( $TargetPlatform =~ /^.*-apple-darwin.*/ && $chkcat[$i] eq 'dyld' && /^L_.*:$/)
	{	# non_lazy_symbol_ptrs that point to local symbols
	    $chk[++$i]   = $dyld_section . $_;
	    $chkcat[$i]  = 'dyld';
	    $chksymb[$i] = '';

	} elsif ( /^\s+/ ) { # most common case first -- a simple line!
	    # duplicated from the bottom

	    $chk[$i] .= $_;

	} elsif ( /\.\.ng:$/ && $TargetPlatform =~ /^alpha-/ ) {
	    # Alphas: Local labels not to be confused with new chunks
	    $chk[$i] .= $_;
	# NB: all the rest start with a non-space

	} elsif ( $TargetPlatform =~ /^mips-/
	       && /^\d+:/ ) { # a funny-looking very-local label
	    $chk[$i] .= $_;

	} elsif ( /$T_CONST_LBL/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'literal';
	    $chksymb[$i] = $1;

	} elsif ( /^${T_US}__stg_split_marker(\d*)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'splitmarker';
	    $chksymb[$i] = $1;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_info${T_POST_LBL}$/o ) {
	    $symb = $1;
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'infotbl';
	    $chksymb[$i] = $symb;

	    die "Info table already? $symb; $i\n" if defined($infochk{$symb});

	    $infochk{$symb} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_(entry|ret)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'entry';
	    $chksymb[$i] = $1;

	    $entrychk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_closure${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'closure';
	    $chksymb[$i] = $1;

	    $closurechk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_srt${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'srt';
	    $chksymb[$i] = $1;

	    $srtchk{$1} = $i;

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_ct${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^${T_US}(stg_ap_stack_entries|stg_stack_save_entries|stg_arg_bitmaps)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^(${T_US}__gnu_compiled_c|gcc2_compiled\.)${T_POST_LBL}/o ) {
	    ; # toss it

	} elsif ( /^${T_US}[A-Za-z0-9_]+\.\d+${T_POST_LBL}$/o
	       || /^${T_US}.*_CAT${T_POST_LBL}$/o 		# PROF: _entryname_CAT
	       || /^${T_US}.*_done${T_POST_LBL}$/o		# PROF: _module_done
	       || /^${T_US}_module_registered${T_POST_LBL}$/o	# PROF: _module_registered
	       ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

	} elsif ( /^([A-Za-z0-9_]+)\s+\.comm/ && $TargetPlatform =~ /^hppa/ ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'bss';
  	    $chksymb[$i] = '';

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_cc(s)?${T_POST_LBL}$/o ) {
            # all CC_ symbols go in the data section...
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'data';
	    $chksymb[$i] = '';

        } elsif ( /^${T_US}([A-Za-z0-9_]+)_hpc${T_POST_LBL}$/o ) {
           # hpc shares tick boxes across modules
           $chk[++$i]   = $_;
           $chkcat[$i]  = 'data';
           $chksymb[$i] = '';

	} elsif ( /^${T_US}([A-Za-z0-9_]+)_(alt|dflt)${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = '';
	} elsif ( /^${T_US}([A-Za-z0-9_]+)_vtbl${T_POST_LBL}$/o ) {
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'vector';
	    $chksymb[$i] = $1;

	    $vectorchk{$1} = $i;

	} elsif ( $TargetPlatform =~ /^i386-.*-solaris2/
	     &&   /^[A-Za-z0-9][A-Za-z0-9_]*:/ ) {
            # Some Solaris system headers contain function definitions (as
	    # opposed to mere prototypes), which end up in the .hc file when
	    # a Haskell module foreign imports the corresponding system 
	    # functions (most notably stat()).  We put them into the text 
            # segment.  Note that this currently does not extend to function
	    # names starting with an underscore. 
	    # - chak 7/2001
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'misc';
	    $chksymb[$i] = $1;

        } elsif ( $TargetPlatform =~ /^i386-apple-darwin/ && /^(___i686\.get_pc_thunk\.[abcd]x):/o) {
                # To handle PIC on Darwin/x86, we need to appropriately pass through
                # the get_pc_thunk functions. The need to be put into a special section
                # marked as coalesced (otherwise the .weak_definition doesn't work
                # on Darwin).
            $chk[++$i]   = $_;
            $chkcat[$i]  = 'get_pc_thunk';
            $chksymb[$i] = $1;

	} elsif ( /^${T_US}[A-Za-z0-9_]/o
		&& ( $TargetPlatform !~ /^hppa/ # need to avoid local labels in this case
		   || ! /^L\$\d+$/ ) 
		&& ( $TargetPlatform !~ /^powerpc64/ # we need to avoid local labels in this case
		   || ! /^\.L\d+:$/ ) ) {
	    local($thing);
	    chop($thing = $_);
	    $thing =~ s/:$//;
	    $chk[++$i]   = $_;
	    $chksymb[$i] = '';
	    if (
		       /^${T_US}stg_.*${T_POST_LBL}$/o          # RTS internals
		    || /^${T_US}__stg_.*${T_POST_LBL}$/o        # more RTS internals
		    || /^${T_US}__fexp_.*${T_POST_LBL}$/o       # foreign export
		    || /^${T_US}.*_slow${T_POST_LBL}$/o         # slow entry
		    || /^${T_US}__stginit.*${T_POST_LBL}$/o     # __stginit<module>
		    || /^${T_US}.*_btm${T_POST_LBL}$/o          # large bitmaps
		    || /^${T_US}.*_fast${T_POST_LBL}$/o         # primops
                    || /^_uname:/o			        # x86/Solaris2
		)
            {
	    	$chkcat[$i]  = 'misc';
            } elsif (
		       /^${T_US}.*_srtd${T_POST_LBL}$/o          # large bitmaps
		    || /^${T_US}.*_closure_tbl${T_POST_LBL}$/o  # closure tables
                )
            {
                $chkcat[$i] = 'relrodata';
            } else
            {
	        print STDERR "Warning: retaining unknown function \`$thing' in output from C compiler\n";
	    	$chkcat[$i]  = 'unknown';
	    }

	} elsif ( $TargetPlatform =~ /^powerpc-.*-linux/ && /^\.LCTOC1 = /o ) {
		# PowerPC Linux's large-model PIC (-fPIC) generates a gobal offset
		# table "by hand". Be sure to copy it over.
		# Note that this label and all entries in the table should actually
		# go into the .got2 section, but it isn't easy to distinguish them
		# from other constant literals (.LC\d+), so we just put everything
		# in .rodata.
	    $chk[++$i]   = $_;
	    $chkcat[$i]  = 'literal';
	    $chksymb[$i] = 'LCTOC1';
	} else { # simple line (duplicated at the top)

	    $chk[$i] .= $_;
	}
    }
    $numchks = $#chk + 1;
    $chk[$numchks] = ''; # We might push .note.GNU-stack into this
    $chkcat[$numchks] = 'verbatim'; # If we do, write it straight back out

    # open CHUNKS, ">/tmp/chunks1" or die "Cannot open /tmp/chunks1: $!\n";
    # for (my $i = 0; $i < @chk; ++$i) { print CHUNKS "======= $i =======\n", $chk[$i] }
    # close CHUNKS;

    # the division into chunks is imperfect;
    # we throw some things over the fence into the next
    # chunk.
    #
    # also, there are things we would like to know
    # about the whole module before we start spitting
    # output.

    local($FIRST_MANGLABLE) = ($TargetPlatform =~ /^(alpha-|hppa|mips-)/) ? 1 : 0;
    local($FIRST_TOSSABLE ) = ($TargetPlatform =~ /^(hppa|mips-)/) ? 1 : 0;

#   print STDERR "first chunk to mangle: $FIRST_MANGLABLE\n";

    # Alphas: NB: we start meddling at chunk 1, not chunk 0
    # The first ".rdata" is quite magical; as of GCC 2.7.x, it
    # spits a ".quad 0" in after the very first ".rdata"; we
    # detect this special case (tossing the ".quad 0")!
    local($magic_rdata_seen) = 0;
  
    # HPPAs, MIPSen: also start medding at chunk 1

    for ($i = $FIRST_TOSSABLE; $i < $numchks; $i++) {
	$c = $chk[$i]; # convenience copy

#	print STDERR "\nCHK $i (BEFORE) (",$chkcat[$i],"):\n", $c;

	# toss all prologue stuff; HPPA is pretty weird
	# (see elsewhere)
	$c = &hppa_mash_prologue($c) if $TargetPlatform =~ /^hppa-/;

	undef $ia64_locnum;
	undef $ia64_outnum;

	# be slightly paranoid to make sure there's
	# nothing surprising in there
	if ( $c =~ /--- BEGIN ---/ ) {
	    if (($p, $r) = split(/--- BEGIN ---/, $c)) {

		# remove junk whitespace around the split point
		$p =~ s/\t+$//;
		$r =~ s/^\s*\n//;

		if ($TargetPlatform =~ /^i386-/) {
		    if ($p =~ /^\tsubl\s+\$(\d+),\s*\%esp\n/) {
			if ($1 >= 8192) {
			    die "Error: reserved stack space exceeded!\n  Possible workarounds: compile with -fasm, or try another version of gcc.\n"
			}
		    }

		# gcc 3.4.3 puts this kind of stuff in the prologue, eg.
		# when compiling PrimOps.cmm with -optc-O2:
		#        xorl    %ecx, %ecx
		#        xorl    %edx, %edx
		#        movl    %ecx, 16(%esp)
		#        movl    %edx, 20(%esp)
		# but then the code of the function doesn't assume
		# anything about the contnets of these stack locations.
		# I think it's to do with the use of inline functions for
		# PK_Word64() and friends, where gcc is initialising the
		# contents of the struct to zero, and failing to optimise
		# away the initialisation.  Let's live dangerously and
		# discard these initalisations.

		    $p =~ s/^\tpushl\s+\%e(di|si|bx)\n//g;
		    $p =~ s/^\txorl\s+\%e(ax|cx|dx),\s*\%e(ax|cx|dx)\n//g;
		    $p =~ s/^\tmovl\s+\%e(ax|cx|dx|si|di),\s*\d*\(\%esp\)\n//g;
		    $p =~ s/^\tmovl\s+\$\d+,\s*\d*\(\%esp\)\n//g;
		    $p =~ s/^\tsubl\s+\$\d+,\s*\%esp\n//;
                    $p =~ s/^\tmovl\s+\$\d+,\s*\%eax\n\tcall\s+__alloca\n// if ($TargetPlatform =~ /^.*-(cygwin32|mingw32)/);

                    if ($TargetPlatform =~ /^i386-apple-darwin/) {
                        $pcrel_label = $p;
                        $pcrel_label =~ s/(.|\n)*^(\"?L\d+\$pb\"?):\n(.|\n)*/$2/ or $pcrel_label = "";
                        $pcrel_reg = $p;
                        $pcrel_reg =~ s/(.|\n)*.*___i686\.get_pc_thunk\.([abcd]x)\n(.|\n)*/$2/ or $pcrel_reg = "";
                        $p =~ s/^\s+call\s+___i686\.get_pc_thunk\..x//;
                        $p =~ s/^\"?L\d+\$pb\"?:\n//;

                        if ($pcrel_reg eq "bx") {
                            # Bad gcc. Goes and uses %ebx, our BaseReg, for PIC. Bad gcc.
                            die "Darwin/x86: -fPIC -via-C doesn't work yet, use -fasm. Aborting."
                        }
                    }

		} elsif ($TargetPlatform =~ /^x86_64-/) {
		    $p =~ s/^\tpushq\s+\%r(bx|bp|12|13|14)\n//g;
		    $p =~ s/^\tmovq\s+\%r(bx|bp|12|13|14),\s*\d*\(\%rsp\)\n//g;
		    $p =~ s/^\tsubq\s+\$\d+,\s*\%rsp\n//;

		} elsif ($TargetPlatform =~ /^ia64-/) {
		    $p =~ s/^\t\.prologue .*\n//;

		    # Record the number of local and out registers for register relocation later
		    $p =~ s/^\t\.save ar\.pfs, r\d+\n\talloc r\d+ = ar\.pfs, 0, (\d+), (\d+), 0\n//;
		    $ia64_locnum = $1;
		    $ia64_outnum = $2;

		    $p =~ s/^\t\.fframe \d+\n\tadds r12 = -\d+, r12\n//;
		    $p =~ s/^\t\.save rp, r\d+\n\tmov r\d+ = b0\n//;

		    # Ignore save/restore of these registers; they're taken
		    # care of in StgRun()
		    $p =~ s/^\t\.save ar\.lc, r\d+\n//;
		    $p =~ s/^\t\.save pr, r\d+\n//;
		    $p =~ s/^\tmov r\d+ = ar\.lc\n//;
		    $p =~ s/^\tmov r\d+ = pr\n//;

		    # Remove .proc and .body directives
		    $p =~ s/^\t\.proc [a-zA-Z0-9_.]+#\n//;
            	    $p =~ s/^\t\.body\n//;

            	    # If there's a label, move it to the body
            	    if ($p =~ /^[a-zA-Z0-9.]+:\n/) {
            	        $p = $` . $';
            	        $r = $& . $r;
            	      }

            	    # Remove floating-point spill instructions.
            	    # Only fp registers 2-5 and 16-21 are saved by the runtime.
            	    if ($p =~ s/^\tstf\.spill \[r1[4-9]\] = f([2-5]|1[6-9]|20|21)(, [0-9]+)?\n//g) {
            	        # Being paranoid, only try to remove these if we saw a
			# spill operation.
                        $p =~ s/^\tmov r1[4-9] = r12\n//;
                        $p =~ s/^\tadds r1[4-9] = -[0-9]+, r12\n//g;
                        $p =~ s/^\t\.save\.f 0x[0-9a-fA-F]\n//g;
            	    }

            	    $p =~ s/^\tnop(?:\.[mifb])?\s+\d+\n//g; # remove nop instructions
            	    $p =~ s/^\t\.(mii|mmi|mfi)\n//g;    # bundling is no longer sensible
		    $p =~ s/^\t;;\n//g;		# discard stops
		    $p =~ s/^\t\/\/.*\n//g;	# gcc inserts timings in // comments

               	    # GCC 3.3 saves r1 in the prologue, move this to the body
		    # (Does this register get restored anywhere?)
               	    if ($p =~ /^\tmov r\d+ = r1\n/) {
               	      $p = $` . $';
               	      $r = $& . $r;
               	    }
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $p =~ s/^\tlink a6,#-?\d.*\n//;
 		    $p =~ s/^\tpea a6@\n\tmovel sp,a6\n//;    
 				# The above showed up in the asm code,
 				# so I added it here.
 				# I hope it's correct.
 				# CaS
		    $p =~ s/^\tmovel d2,sp\@-\n//;
		    $p =~ s/^\tmovel d5,sp\@-\n//; # SMmark.* only?
		    $p =~ s/^\tmoveml \#0x[0-9a-f]+,sp\@-\n//; # SMmark.* only?
		} elsif ($TargetPlatform =~ /^mips-/) {
		    # the .frame/.mask/.fmask that we use is the same
		    # as that produced by GCC for miniInterpret; this
		    # gives GDB some chance of figuring out what happened
		    $FRAME = "\t.frame\t\$sp,2168,\$31\n\t.mask\t0x90000000,-4\n\t.fmask\t0x00000000,0\n";
		    $p =~ s/^\t\.(frame).*\n/__FRAME__/g;
		    $p =~ s/^\t\.(mask|fmask).*\n//g;
		    $p =~ s/^\t\.cprestore.*\n/\t\.cprestore 416\n/; # 16 + 100 4-byte args
		    $p =~ s/^\tsubu\t\$sp,\$sp,\d+\n//;
		    $p =~ s/^\tsw\t\$31,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$fp,\d+\(\$sp\)\n//;
		    $p =~ s/^\tsw\t\$28,\d+\(\$sp\)\n//;
		    $p =~ s/__FRAME__/$FRAME/;
		} elsif ($TargetPlatform =~ /^powerpc-apple-darwin.*/) {
		    $pcrel_label = $p;
		    $pcrel_label =~ s/(.|\n)*^(\"?L\d+\$pb\"?):\n(.|\n)*/$2/ or $pcrel_label = "";

		    $p =~ s/^\tmflr r0\n//;
 		    $p =~ s/^\tbl saveFP # f\d+\n//;
 		    $p =~ s/^\tbl saveFP ; save f\d+-f\d+\n//;
		    $p =~ s/^\"?L\d+\$pb\"?:\n//;
 		    $p =~ s/^\tstmw r\d+,-\d+\(r1\)\n//;
   		    $p =~ s/^\tstfd f\d+,-\d+\(r1\)\n//g;
 		    $p =~ s/^\tstw r0,\d+\(r1\)\n//g;
  		    $p =~ s/^\tstwu r1,-\d+\(r1\)\n//; 
  		    $p =~ s/^\tstw r\d+,-\d+\(r1\)\n//g; 
  		    $p =~ s/^\tbcl 20,31,\"?L\d+\$pb\"?\n//;
  		    $p =~ s/^\"?L\d+\$pb\"?:\n//;
  		    $p =~ s/^\tmflr r31\n//;

		    # This is bad: GCC 3 seems to zero-fill some local variables in the prologue
		    # under some circumstances, only when generating position dependent code.
		    # I have no idea why, and I don't think it is necessary, so let's toss it.
		    $p =~ s/^\tli r\d+,0\n//g;
		    $p =~ s/^\tstw r\d+,\d+\(r1\)\n//g;
		} elsif ($TargetPlatform =~ /^powerpc-.*-linux/) {
		    $p =~ s/^\tmflr 0\n//;
		    $p =~ s/^\tstmw \d+,\d+\(1\)\n//;
   		    $p =~ s/^\tstfd \d+,\d+\(1\)\n//g;
 		    $p =~ s/^\tstw r0,8\(1\)\n//;
  		    $p =~ s/^\tstwu 1,-\d+\(1\)\n//; 
  		    $p =~ s/^\tstw \d+,\d+\(1\)\n//g; 
                    
                        # GCC's "large-model" PIC (-fPIC)
		    $pcrel_label = $p;
		    $pcrel_label =~ s/(.|\n)*^.LCF(\d+):\n(.|\n)*/$2/ or $pcrel_label = "";

                    $p =~ s/^\tbcl 20,31,.LCF\d+\n//;
                    $p =~ s/^.LCF\d+:\n//;
                    $p =~ s/^\tmflr 30\n//;
                    $p =~ s/^\tlwz 0,\.LCL\d+-\.LCF\d+\(30\)\n//;
                    $p =~ s/^\tadd 30,0,30\n//;

		    # This is bad: GCC 3 seems to zero-fill some local variables in the prologue
		    # under some circumstances, only when generating position dependent code.
		    # I have no idea why, and I don't think it is necessary, so let's toss it.
		    $p =~ s/^\tli \d+,0\n//g;
		    $p =~ s/^\tstw \d+,\d+\(1\)\n//g;
		} elsif ($TargetPlatform =~ /^powerpc64-.*-linux/) {
		    $p =~ s/^\tmr 31,1\n//;
		    $p =~ s/^\tmflr 0\n//;
		    $p =~ s/^\tstmw \d+,\d+\(1\)\n//;
   		    $p =~ s/^\tstfd \d+,-?\d+\(1\)\n//g;
 		    $p =~ s/^\tstd r0,8\(1\)\n//;
  		    $p =~ s/^\tstdu 1,-\d+\(1\)\n//; 
  		    $p =~ s/^\tstd \d+,-?\d+\(1\)\n//g; 
                    
		    # This is bad: GCC 3 seems to zero-fill some local variables in the prologue
		    # under some circumstances, only when generating position dependent code.
		    # I have no idea why, and I don't think it is necessary, so let's toss it.
		    $p =~ s/^\tli \d+,0\n//g;
		    $p =~ s/^\tstd \d+,\d+\(1\)\n//g;
		} else {
		    print STDERR "$Pgm: unknown prologue mangling? $TargetPlatform\n";
		}
		
		# HWL HACK: dont die, just print a warning
		#print stderr  "HWL: this should die! Prologue junk?: $p\n" if $p =~ /^\t[^\.]/;
		die "Prologue junk?: $p\n" if $p =~ /^\s+[^\s\.]/;
		
                # For PIC, we want to keep part of the prologue
		if ($TargetPlatform =~ /^powerpc-apple-darwin.*/ && $pcrel_label ne "") {
		    # Darwin: load the current instruction pointer into register r31
		    $p .= "bcl 20,31,$pcrel_label\n";
		    $p .= "$pcrel_label:\n";
		    $p .= "\tmflr r31\n";
		} elsif ($TargetPlatform =~ /^powerpc-.*-linux/ && $pcrel_label ne "") {
                    # Linux: load the GOT pointer into register 30
                    $p .= "\tbcl 20,31,.LCF$pcrel_label\n";
                    $p .= ".LCF$pcrel_label:\n";
                    $p .= "\tmflr 30\n";
                    $p .= "\tlwz 0,.LCL$pcrel_label-.LCF$pcrel_label(30)\n";
                    $p .= "\tadd 30,0,30\n";
                } elsif ($TargetPlatform =~ /^i386-apple-darwin.*/ && $pcrel_label ne "") {
                    $p .= "\tcall ___i686.get_pc_thunk.$pcrel_reg\n";
                    $p .= "$pcrel_label:\n";
                }
		
		# glue together what's left
		$c = $p . $r;
	    }
	}

	if ( $TargetPlatform =~ /^mips-/ ) {
	    # MIPS: first, this basic sequence may occur "--- END ---" or not
	    $c =~ s/^\tlw\t\$31,\d+\(\$sp\)\n\taddu\t\$sp,\$sp,\d+\n\tj\t\$31\n\t\.end/\t\.end/;
	}

	# toss all epilogue stuff; again, paranoidly
	if ( $c =~ /--- END ---/ ) {
	    # Gcc may decide to replicate the function epilogue.  We want
	    # to process all epilogues, so we split the function and then
	    # loop here.
	    @fragments = split(/--- END ---/, $c);
	    $r = shift(@fragments);

	    # Rebuild `c'; processed fragments will be appended to `c'
	    $c = $r;

	    foreach $e (@fragments) {
                # etail holds code that is after the epilogue in the assembly-code
                # layout and should not be filtered as part of the epilogue.
                $etail = "";
		if ($TargetPlatform =~ /^i386-/) {
		    $e =~ s/^\tret\n//;
		    $e =~ s/^\tpopl\s+\%edi\n//;
		    $e =~ s/^\tpopl\s+\%esi\n//;
		    $e =~ s/^\tpopl\s+\%edx\n//;
		    $e =~ s/^\tpopl\s+\%ecx\n//;
		    $e =~ s/^\taddl\s+\$\d+,\s*\%esp\n//;
		    $e =~ s/^\tsubl\s+\$-\d+,\s*\%esp\n//;
		} elsif ($TargetPlatform =~ /^ia64-/) {
            	    # The epilogue is first split into:
            	    #     $e,    the epilogue code (up to the return instruction)
            	    #     $etail, non-epilogue code (after the return instruction)
            	    # The return instruction is stripped in the process.
            	    if (!(($e, $etail) = split(/^\tbr\.ret\.sptk\.many b0\n/, $e))) {
            	        die "Epilogue doesn't seem to have one return instruction: $e\n";
            	    }
		    # Remove 'endp' directive from the tail
            	    $etail =~ s/^\t\.endp [a-zA-Z0-9_.]+#\n//;

            	    # If a return value is saved here, discard it
 		    $e =~ s/^\tmov r8 = r14\n//;

            	    # Remove floating-point fill instructions.
            	    # Only fp registers 2-5 and 16-21 are saved by the runtime.
            	    if ($e =~ s/^\tldf\.fill f([2-5]|1[6-9]|20|21) = \[r1[4-9]\](, [0-9]+)?\n//g) {
            	        # Being paranoid, only try to remove this if we saw a fill
            	        # operation.
            	        $e =~ s/^\tadds r1[4-9] = [0-9]+, r12//g;
            	    }

            	    $e =~ s/^\tnop(?:\.[mifb])?\s+\d+\n//g; # remove nop instructions
	    	    $e =~ s/^\tmov ar\.pfs = r\d+\n//;
	    	    $e =~ s/^\tmov ar\.lc = r\d+\n//;
		    $e =~ s/^\tmov pr = r\d+, -1\n//;
	    	    $e =~ s/^\tmov b0 = r\d+\n//;
	    	    $e =~ s/^\t\.restore sp\n\tadds r12 = \d+, r12\n//;
	    	    #$e =~ s/^\tbr\.ret\.sptk\.many b0\n//; # already removed
	    	    $e =~ s/^\t\.(mii|mmi|mfi|mib)\n//g; # bundling is no longer sensible
	    	    $e =~ s/^\t;;\n//g; # discard stops - stop at end of body is sufficient
	    	    $e =~ s/^\t\/\/.*\n//g; # gcc inserts timings in // comments
		} elsif ($TargetPlatform =~ /^m68k-/) {
		    $e =~ s/^\tunlk a6\n//;
		    $e =~ s/^\trts\n//;
		} elsif ($TargetPlatform =~ /^mips-/) {
		    $e =~ s/^\tlw\t\$31,\d+\(\$sp\)\n//;
		    $e =~ s/^\tlw\t\$fp,\d+\(\$sp\)\n//;
		    $e =~ s/^\taddu\t\$sp,\$sp,\d+\n//;
		    $e =~ s/^\tj\t\$31\n//;
 		} elsif ($TargetPlatform =~ /^powerpc-apple-darwin.*/) {
  		    $e =~ s/^\taddi r1,r1,\d+\n//;
  		    $e =~ s/^\tlwz r\d+,\d+\(r1\)\n//; 
  		    $e =~ s/^\tlmw r\d+,-\d+\(r1\)\n//;
 		    $e =~ s/^\tmtlr r0\n//;
  		    $e =~ s/^\tblr\n//;
  		    $e =~ s/^\tb restFP ;.*\n//;
 		} elsif ($TargetPlatform =~ /^powerpc64-.*-linux/) {
		    $e =~ s/^\tmr 3,0\n//;
		    $e =~ s/^\taddi 1,1,\d+\n//;
		    $e =~ s/^\tld 0,16\(1\)\n//;
		    $e =~ s/^\tmtlr 0\n//;

		    # callee-save registers
		    $e =~ s/^\tld \d+,-?\d+\(1\)\n//g;
		    $e =~ s/^\tlfd \d+,-?\d+\(1\)\n//g;

		    # get rid of the debug junk along with the blr
		    $e =~ s/^\tblr\n\t.long .*\n\t.byte .*\n//;

		    # incase we missed it with the last one get the blr alone
		    $e =~ s/^\tblr\n//;
		} else {
		    print STDERR "$Pgm: unknown epilogue mangling? $TargetPlatform\n";
		}

		print STDERR "WARNING: Epilogue junk?: $e\n" if $e =~ /^\t\s*[^\.\s\n]/;

		# glue together what's left
		$c .= $e . $etail;
	    }
	    $c =~ s/\n\t\n/\n/; # junk blank line
	}
 	else {
 	    if ($TargetPlatform =~ /^ia64-/) {
 	        # On IA64, remove an .endp directive even if no epilogue was found.
 	        # Code optimizations may have removed the "--- END ---" token.
 	        $c =~ s/^\t\.endp [a-zA-Z0-9_.]+#\n//;
 	    }
 	}

	# On SPARCs, we don't do --- BEGIN/END ---, we just
	# toss the register-windowing save/restore/ret* instructions
	# directly unless they've been generated by function definitions in header
	# files on Solaris:
	if ( $TargetPlatform =~ /^sparc-/ ) {
	    if ( ! ( $TargetPlatform =~ /solaris2$/ && $chkcat[$i] eq 'unknown' )) {
	    	$c =~ s/^\t(save.*|restore.*|ret|retl)\n//g;
	    }
	    # throw away PROLOGUE comments
	    $c =~ s/^\t!#PROLOGUE# 0\n\t!#PROLOGUE# 1\n//;
	}

	# On Alphas, the prologue mangling is done a little later (below)

    	# toss all calls to __DISCARD__
	$c =~ s/^\t(call|jbsr|jal)\s+${T_US}__DISCARD__\n//go;
	$c =~ s/^\tjsr\s+\$26\s*,\s*${T_US}__DISCARD__\n//go if $TargetPlatform =~ /^alpha-/;
	$c =~ s/^\tbl\s+L___DISCARD__\$stub\n//go if $TargetPlatform =~ /^powerpc-apple-darwin.*/;
	$c =~ s/^\tbl\s+__DISCARD__(\@plt)?\n//go if $TargetPlatform =~ /^powerpc-.*-linux/;
	$c =~ s/^\tbl\s+\.__DISCARD__\n\s+nop\n//go if $TargetPlatform =~ /^powerpc64-.*-linux/;
	$c =~ s/^\tcall\s+L___DISCARD__\$stub\n//go if $TargetPlatform =~ /i386-apple-darwin.*/;

	# IA64: fix register allocation; mangle tailcalls into jumps
 	if ($TargetPlatform =~ /^ia64-/) {
	    ia64_rename_registers($ia64_locnum, $ia64_outnum) if (defined($ia64_locnum));
	    ia64_mangle_tailcalls();
	}

	# MIPS: that may leave some gratuitous asm macros around
	# (no harm done; but we get rid of them to be tidier)
	$c =~ s/^\t\.set\tnoreorder\n\t\.set\tnomacro\n\taddu\t(\S+)\n\t\.set\tmacro\n\t\.set\treorder\n/\taddu\t$1\n/
	    if $TargetPlatform =~ /^mips-/;

    	# toss stack adjustment after DoSparks
    	$c =~ s/^(\tjbsr _DoSparks\n)\taddqw #8,sp/$1/g
		if $TargetPlatform =~ /^m68k-/; # this looks old...

	if ( $TargetPlatform =~ /^alpha-/ &&
	   ! $magic_rdata_seen &&
	   $c =~ /^\s*\.rdata\n\t\.quad 0\n\t\.align \d\n/ ) {
	    $c =~ s/^\s*\.rdata\n\t\.quad 0\n\t\.align (\d)\n/\.rdata\n\t\.align $1\n/;
	    $magic_rdata_seen = 1;
	}

	# pick some end-things and move them to the next chunk

	# pin a funny end-thing on (for easier matching):
	$c .= 'FUNNY#END#THING';

	while ( $c =~ /${T_MOVE_DIRVS}FUNNY#END#THING/o ) {

	    $to_move = $1;

	    # on x86 we try not to copy any directives into a literal
	    # chunk, rather we keep looking for the next real chunk.  This
	    # is because we get things like
	    #
	    #    .globl blah_closure
	    #    .LC32
	    #    	.string "..."
	    #    blah_closure:
	    #		...
            #
	    if ( $TargetPlatform =~ /^(i386|sparc|powerpc)/ && $to_move =~ /${T_COPY_DIRVS}/ ) {
		$j = $i + 1;
		while ( $j < $numchks  && $chk[$j] =~ /$T_CONST_LBL/) {
			$j++;
		}
		if ( $j < $numchks ) {
			$chk[$j] = $to_move . $chk[$j];
	        }
	    }

            elsif (   (    $i < ($numchks - 1)
                       && ( $to_move =~ /${T_COPY_DIRVS}/
                           || (   $TargetPlatform =~ /^hppa/
                               && $to_move =~ /align/
                               && $chkcat[$i+1] eq 'literal')
                          )
                      )
                   || ($to_move =~ /^[ \t]*\.section[ \t]+\.note\.GNU-stack,/)
                  ) {
                $chk[$i + 1] = $to_move . $chk[$i + 1];
                # otherwise they're tossed
            }

	    $c =~ s/${T_MOVE_DIRVS}FUNNY#END#THING/FUNNY#END#THING/o;
	}

    	if ( $TargetPlatform =~ /^alpha-/ && $c =~ /^\t\.ent\s+(\S+)/ ) {
    	    $ent = $1;
	    # toss all prologue stuff, except for loading gp, and the ..ng address
	    unless ($c =~ /\.ent.*\n\$.*\.\.ng:/) {
		if (($p, $r) = split(/^\t\.prologue/, $c)) {
		    if (($keep, $junk) = split(/\.\.ng:/, $p)) {
			$keep =~ s/^\t\.frame.*\n/\t.frame \$30,0,\$26,0\n/;
			$keep =~ s/^\t\.(mask|fmask).*\n//g;
			$c = $keep . "..ng:\n";
		    } else {
			print STDERR "malformed code block ($ent)?\n"
		    }
		}
		$c .= "\t.prologue" . $r;
	    }
    	}
  
	$c =~ s/FUNNY#END#THING//;

#	print STDERR "\nCHK $i (AFTER) (",$chkcat[$i],"):\n", $c;

	$chk[$i] = $c; # update w/ convenience copy
    }

    # open CHUNKS, ">/tmp/chunks2" or die "Cannot open /tmp/chunks2: $!\n";
    # for (my $i = 0; $i < @chk; ++$i) { print CHUNKS "======= $i =======\n", $chk[$i] }
    # close CHUNKS;

    if ( $TargetPlatform =~ /^alpha-/ ) {
	# print out the header stuff first
	$chk[0] =~ s/^(\t\.file.*)"(ghc\d+\.c)"/$1"$ifile_root.hc"/;
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^hppa/ ) {
	print OUTASM $chk[0];

    } elsif ( $TargetPlatform =~ /^mips-/ ) {
	$chk[0] = "\t\.file\t1 \"$ifile_root.hc\"\n" . $chk[0];

	# get rid of horrible "<dollar>Revision: .*$" strings
	local(@lines0) = split(/\n/, $chk[0]);
	local($z) = 0;
	while ( $z <= $#lines0 ) {
	    if ( $lines0[$z] =~ /^\t\.byte\t0x24,0x52,0x65,0x76,0x69,0x73,0x69,0x6f$/ ) {
		undef($lines0[$z]);
		$z++;
		while ( $z <= $#lines0 ) {
		    undef($lines0[$z]);
		    last if $lines0[$z] =~ /[,\t]0x0$/;
		    $z++;
		}
	    }
	    $z++;
	}
	$chk[0] = join("\n", @lines0);
	$chk[0] =~ s/\n\n+/\n/;
	print OUTASM $chk[0];
    }

    # print out all the literal strings next
    for ($i = 0; $i < $numchks; $i++) {
	if ( $chkcat[$i] eq 'literal' ) {

	    # HACK: try to detect 16-byte constants and align them
	    # on a 16-byte boundary.  x86_64 sometimes needs 128-bit
	    # aligned constants, and so does Darwin/x86.
	    if ( $TargetPlatform =~ /^x86_64/
                || $TargetPlatform =~ /^i386-apple-darwin/ ) { 
		$z = $chk[$i];
 		if ($z =~ /(\.long.*\n.*\.long.*\n.*\.long.*\n.*\.long|\.quad.*\n.*\.quad)/) {
		    print OUTASM $T_HDR_literal16;
		} else {
		    print OUTASM $T_HDR_literal;
		}
 	    } else {
		print OUTASM $T_HDR_literal;
	    }

	    print OUTASM $chk[$i];
	    print OUTASM "; end literal\n" if $TargetPlatform =~ /^hppa/; # for the splitter

	    $chkcat[$i] = 'DONE ALREADY';
	}
    }

    # on the HPPA, print out all the bss next
    if ( $TargetPlatform =~ /^hppa/ ) {
	for ($i = 1; $i < $numchks; $i++) {
	    if ( $chkcat[$i] eq 'bss' ) {
		print OUTASM "\t.SPACE \$PRIVATE\$\n\t.SUBSPA \$BSS\$\n\t.align 4\n";
		print OUTASM $chk[$i];

		$chkcat[$i] = 'DONE ALREADY';
	    }
	}
    }

    # $numchks + 1 as we have the extra one for .note.GNU-stack
    for ($i = $FIRST_MANGLABLE; $i < $numchks + 1; $i++) {
#	print STDERR "$i: cat $chkcat[$i], symb $chksymb[$i]\n";

	next if $chkcat[$i] eq 'DONE ALREADY';

	if ( $chkcat[$i] eq 'misc' || $chkcat[$i] eq 'unknown' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_misc;
 		&print_doctored($chk[$i], 0);
	    }

	} elsif ( $chkcat[$i] eq 'verbatim' ) {
	    print OUTASM $chk[$i];

	} elsif ( $chkcat[$i] eq 'toss' ) {
	    print STDERR "*** NB: TOSSING code for $chksymb[$i] !!! ***\n";

	} elsif ( $chkcat[$i] eq 'data' ) {
	    if ($chk[$i] ne '') {
		print OUTASM $T_HDR_data;
		print OUTASM $chk[$i];
	    }

	} elsif ( $chkcat[$i] eq 'splitmarker' ) {
	    # we can just re-constitute this one...
	    # NB: we emit _three_ underscores no matter what,
	    # so ghc-split doesn't have to care.
	    print OUTASM "___stg_split_marker",$chksymb[$i],"${T_POST_LBL}\n";

	} elsif ( $chkcat[$i] eq 'closure'
	       || $chkcat[$i] eq 'srt'
	       || $chkcat[$i] eq 'infotbl'
	       || $chkcat[$i] eq 'entry') { # do them in that order
	    $symb = $chksymb[$i];

	    # CLOSURE
	    if ( defined($closurechk{$symb}) ) {
		print OUTASM $T_HDR_closure;
		print OUTASM $chk[$closurechk{$symb}];
		$chkcat[$closurechk{$symb}] = 'DONE ALREADY';
	    }

	    # SRT
	    if ( defined($srtchk{$symb}) ) {
		print OUTASM $T_HDR_relrodata;
		print OUTASM $chk[$srtchk{$symb}];
		$chkcat[$srtchk{$symb}] = 'DONE ALREADY';
	    }

	    # INFO TABLE
	    if ( defined($infochk{$symb}) ) {

		print OUTASM $T_HDR_info;
                print OUTASM &rev_tbl($symb, $chk[$infochk{$symb}], 1);
                
		# entry code will be put here!

		$chkcat[$infochk{$symb}] = 'DONE ALREADY';
	    }

	    # ENTRY POINT
	    if ( defined($entrychk{$symb}) ) {

		$c = $chk[$entrychk{$symb}];

		# If this is an entry point with an info table,
                # eliminate the entry symbol and all directives involving it.
		if (defined($infochk{$symb}) && $TargetPlatform !~ /^ia64-/) {
			@o = ();
			foreach $l (split(/\n/,$c)) {
			    next if $l =~ /^.*$symb_(entry|ret)${T_POST_LBL}/;

			    # If we have .type/.size direrctives involving foo_entry,
			    # then make them refer to foo_info instead.  The information
			    # in these directives is used by the cachegrind annotator,
			    # so it is worthwhile keeping.
			    if ($l =~ /^\s*\.(type|size).*$symb_(entry|ret)/) {
				$l =~ s/$symb(_entry|_ret)/${symb}_info/g;
				push(@o,$l);
				next;
			    }
                            next if $l =~ /^\s*\..*$symb.*\n?/;
			    push(@o,$l);
			}
			$c = join("\n",@o) . "\n";
		}

		print OUTASM $T_HDR_entry;

		&print_doctored($c, 1); # NB: the 1!!!

		$chkcat[$entrychk{$symb}] = 'DONE ALREADY';
	    }
	    
	} elsif ( $chkcat[$i] eq 'vector' ) {
	    $symb = $chksymb[$i];

	    # VECTOR TABLE
	    if ( defined($vectorchk{$symb}) ) {
		print OUTASM $T_HDR_vector;
		print OUTASM &rev_tbl($symb, $chk[$vectorchk{$symb}], 0);

		# direct return code will be put here!
		$chkcat[$vectorchk{$symb}] = 'DONE ALREADY';

	    } elsif ( $TargetPlatform =~ /^alpha-/ ) {
		# Alphas: the commented nop is for the splitter, to ensure
		# that no module ends with a label as the very last
		# thing.  (The linker will adjust the label to point
		# to the first code word of the next module linked in,
		# even if alignment constraints cause the label to move!)

		print OUTASM "\t# nop\n";
	    }
	    
 	} elsif ( $chkcat[$i] eq 'rodata' ) {
		print OUTASM $T_HDR_rodata;
		print OUTASM $chk[$i];
		$chkcat[$i] = 'DONE ALREADY';
 	} elsif ( $chkcat[$i] eq 'relrodata' ) {
		print OUTASM $T_HDR_relrodata;
		print OUTASM $chk[$i];
		$chkcat[$i] = 'DONE ALREADY';
 	} elsif ( $chkcat[$i] eq 'toc' ) {
            # silly optimisation to print tocs, since they come in groups...
 	    print OUTASM $T_HDR_toc;
            local($j)	= $i;
            while ($chkcat[$j] eq 'toc')
              { if (   $chk[$j] !~ /\.tc UpdatePAP\[TC\]/ # not needed: always turned into a jump.
                   ) 
                {
                  print OUTASM $chk[$j];
                }
                $chkcat[$j] = 'DONE ALREADY';
                $j++;
 	    }
 	    
 	} elsif ( $TargetPlatform =~ /^.*-apple-darwin.*/ && $chkcat[$i] eq 'dyld' ) {
	    # apple-darwin: dynamic linker stubs
	    if($chk[$i] !~ /\.indirect_symbol ___DISCARD__/)
	    {	# print them out unchanged, but remove the stubs for __DISCARD__
		print OUTASM $chk[$i];
	    }
        } elsif ( $TargetPlatform =~ /^i386-apple-darwin.*/ && $chkcat[$i] eq 'get_pc_thunk' ) {
            # i386-apple-darwin: __i686.get_pc_thunk.[abcd]x
            print OUTASM ".section __TEXT,__textcoal_nt,coalesced,no_toc\n";
            print OUTASM $chk[$i];
	} else {
	    &tidy_up_and_die(1,"$Pgm: unknown chkcat (ghc-asm: $TargetPlatform)\n$chkcat[$i]\n$chk[$i]\n");
	}
    }

    print OUTASM $EXTERN_DECLS if $TargetPlatform =~ /^mips-/;

    # finished
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}
\end{code}

On IA64, tail calls are converted to branches at this point.  The mangler
searches for function calls immediately followed by a '--- TAILCALL ---'
token.  Since the compiler can put various combinations of labels, bundling
directives, nop instructions, stops, and a move of the return value
between the branch and the tail call, proper matching of the tail call
gets a little hairy.  This subroutine does the mangling.

Here is an example of a tail call before mangling:

\begin{verbatim}
	br.call.sptk.many b0 = b6
.L211
	;;
	.mmi
	mov r1 = r32
	;;
	nop.m 0
	nop.i 0
	;;
	--- TAILCALL --
	;;
.L123
\end{verbatim}

\begin{code}
sub ia64_mangle_tailcalls {
    # Function input and output are in $c

    # Construct the tailcall-mangling expression the first time this function
    # is called.
    if (!defined($IA64_MATCH_TAILCALL)) {
        # One-line pattern matching constructs.  None of these
        # should bind references; all parenthesized terms
        # should be (?:) terms.
	my $stop       = q/(?:\t;;\n)/;
	my $bundle     = q/(?:\t\.(?:mii|mib|mmi|mmb|mfi|mfb|mbb|bbb)\n)/;
	my $nop        = q/(?:\tnop(?:\.[mifb])?\s+\d+\n)/;
	my $movgp      = q/(?:\tmov r1 = r\d+\n)/;
	my $postbr     = q/(?:\tbr \.L\d+\n)/;

	my $noeffect   = "(?:$stop$bundle?|$nop)*";
	my $postbundle = "(?:$bundle?$nop?$nop?$postbr)?";

	# Important parts of the pattern match.  The branch target
	# and subsequent jump label are bound to $1 and $2
	# respectively.  Sometimes there is no label.
	my $callbr    = q/^\tbr\.call\.sptk\.many b0 = (.*)\n/;
	my $label     = q/(?:^\.L([0-9]*):\n)/;
	my $tailcall  = q/\t--- TAILCALL ---\n/;

	$IA64_MATCH_TAILCALL =
	  $callbr . $label . '?' . $noeffect . $movgp . '?' . $noeffect .
	  $tailcall . $stop . '?' . '(?:' . $postbundle . ')?';
    }

    # Find and mangle tailcalls
    while ($c =~ s/$IA64_MATCH_TAILCALL/\tbr\.few $1\n/o) {
        # Eek, the gcc optimiser is getting smarter... if we see a jump to the
        # --- TAILCALL --- marker then we reapply the substitution at the source sites
        $c =~ s/^\tbr \.L$2\n/\t--- TAILCALL ---\n/g if ($2);
    }

    # Verify that all instances of TAILCALL were processed
    if ($c =~ /^\t--- TAILCALL ---\n/) {
        die "Unmangled TAILCALL tokens remain after mangling"
    }
}
\end{code}

The number of registers allocated on the IA64 register stack is set
upon entry to the runtime with an `alloc' instruction at the entry
point of \verb+StgRun()+.  Gcc uses its own `alloc' to allocate
however many registers it likes in each function.  When we discard
gcc's alloc, we have to reconcile its register assignment with what
the STG uses.

There are three stack areas: fixed registers, input/local registers,
and output registers.  We move the output registers to the output
register space and leave the other registers where they are.

\begin{code}
sub ia64_rename_registers() {
    # The text to be mangled is in $c
    # Find number of registers in each stack area
    my ($loc, $out) = @_;
    my $cout;
    my $first_out_reg;
    my $regnum;
    my $fragment;

    # These are the register numbers used in the STG runtime
    my $STG_FIRST_OUT_REG = 32 + 34;
    my $STG_LAST_OUT_REG = $STG_FIRST_OUT_REG + 7;

    $first_out_reg = 32 + $loc;

    if ($first_out_reg > $STG_FIRST_OUT_REG) {
        die "Too many local registers allocated by gcc";
    }

    # Split the string into fragments containing one register name each.
    # Rename the register in each fragment and concatenate.
    $cout = "";
    foreach $fragment (split(/(?=r\d+[^a-zA-Z0-9_.])/s, $c)) {
        if ($fragment =~ /^r(\d+)((?:[^a-zA-Z0-9_.].*)?)$/s) {
	    $regnum = $1;

	    if ($regnum < $first_out_reg) {
	        # This is a local or fixed register

		# Local registers 32 and 33 (r64 and r65) are
	        # used to hold saved state; they shouldn't be touched
		if ($regnum == 64 || $regnum == 65) {
		   die "Reserved register $regnum is in use";
		}
	    }
	    else {
	        # This is an output register
	        $regnum = $regnum - $first_out_reg + $STG_FIRST_OUT_REG;
		if ($regnum > $STG_LAST_OUT_REG) {
		    die "Register number ($regnum) is out of expected range";
		}
	    }

	    # Update this fragment
	    $fragment = "r" . $regnum . $2;
	}
	$cout .= $fragment;
    }

    $c = $cout;
}

\end{code}

\begin{code}
sub hppa_mash_prologue { # OK, epilogue, too
    local($_) = @_;

    # toss all prologue stuff
    s/^\s+\.ENTRY[^\0]*--- BEGIN ---/\t.ENTRY/;

    # Lie about our .CALLINFO
    s/^\s+\.CALLINFO.*$/\t.CALLINFO NO_CALLS,NO_UNWIND/;

    # Get rid of P'

    s/LP'/L'/g;
    s/RP'/R'/g;

    # toss all epilogue stuff
    s/^\s+--- END ---[^\0]*\.EXIT/\t.EXIT/;

    # Sorry; we moved the _info stuff to the code segment.
    s/_info,DATA/_info,CODE/g;

    return($_);
}
\end{code}

\begin{code}
sub print_doctored {
    local($_, $need_fallthru_patch) = @_;

    if ( $TargetPlatform =~ /^x86_64-/ ) {
	    # Catch things like
	    #	
	    #    movq -4(%ebp), %rax
	    #    jmp  *%rax
	    # 
	    # and optimise:
	    #
	    s/^\tmovq\s+(-?\d*\(\%r(bx|bp|13)\)),\s*(\%r(ax|cx|dx|10|11))\n\tjmp\s+\*\3/\tjmp\t\*$1/g;
	    s/^\tmovl\s+\$${T_US}(.*),\s*(\%e(ax|cx|si|di))\n\tjmp\s+\*\%r\3/\tjmp\t$T_US$1/g;
    }

    if ( $TargetPlatform !~ /^i386-/ 
      || ! /^\t[a-z]/  # no instructions in here, apparently
      || /^${T_US}__stginit_[A-Za-z0-9_]+${T_POST_LBL}/) {
	print OUTASM $_;
	return;
    }

    # OK, must do some x86 **HACKING**

    local($entry_patch)	= '';
    local($exit_patch)	= '';

    # gotta watch out for weird instructions that
    # invisibly smash various regs:
    #   rep*	%ecx used for counting
    #   scas*	%edi used for destination index
    #   cmps*	%e[sd]i used for indices
    #   loop*	%ecx used for counting
    #
    # SIGH.

    # We cater for:
    #  * use of STG reg [ nn(%ebx) ] where no machine reg avail
    #
    #  * GCC used an "STG reg" for its own purposes
    #
    #  * some secret uses of machine reg, requiring STG reg
    #    to be saved/restored

    # The most dangerous "GCC uses" of an "STG reg" are when
    # the reg holds the target of a jmp -- it's tricky to
    # insert the patch-up code before we get to the target!
    # So here we change the jmps:

    # --------------------------------------------------------
    # it can happen that we have jumps of the form...
    #   jmp *<something involving %esp>
    # or
    #   jmp <something involving another naughty register...>
    #
    # a reasonably-common case is:
    #
    #   movl $_blah,<bad-reg>
    #   jmp  *<bad-reg>
    #
    s/^\tmovl\s+\$${T_US}(.*),\s*(\%e[acd]x)\n\tjmp\s+\*\2/\tjmp $T_US$1/g;

    # Catch things like
    #
    #    movl -4(%ebx), %eax
    #    jmp  *%eax
    # 
    # and optimise:
    #
    s/^\tmovl\s+(-?\d*\(\%e(bx|si)\)),\s*(\%e[acd]x)\n\tjmp\s+\*\3/\tjmp\t\*$1/g;

    if ($StolenX86Regs <= 2 ) { # YURGH! spurious uses of esi?
	s/^\tmovl\s+(.*),\s*\%esi\n\tjmp\s+\*%esi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(.*\(.*\%esi.*\))\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*\%esi\n/\tmovl \%esi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%esi!\n$_"
	    if /(jmp|call)\s+.*\%esi/;
    }
    if ($StolenX86Regs <= 3 ) { # spurious uses of edi?
	s/^\tmovl\s+(.*),\s*\%edi\n\tjmp\s+\*%edi\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*(.*\(.*\%edi.*\))\n/\tmovl $1,\%eax\n\tjmp \*\%eax\n/g;
	s/^\tjmp\s+\*\%edi\n/\tmovl \%edi,\%eax\n\tjmp \*\%eax\n/g;
	die "$Pgm: (mangler) still have jump involving \%edi!\n$_"
	    if /(jmp|call)\s+.*\%edi/;
    }

    # OK, now we can decide what our patch-up code is going to
    # be:

    # Offsets into register table - you'd better update these magic
    # numbers should you change its contents!
    # local($OFFSET_R1)=0;  No offset for R1 in new RTS.
    local($OFFSET_Hp)=88;

	# Note funky ".=" stuff; we're *adding* to these _patch guys
    if ( $StolenX86Regs <= 2
	 && ( /[^0-9]\(\%ebx\)/ || /\%esi/ || /^\tcmps/ ) ) { # R1 (esi)
	$entry_patch .= "\tmovl \%esi,(\%ebx)\n";
	$exit_patch  .= "\tmovl (\%ebx),\%esi\n";

	# nothing for call_{entry,exit} because %esi is callee-save
    }
    if ( $StolenX86Regs <= 3
	 && ( /${OFFSET_Hp}\(\%ebx\)/ || /\%edi/ || /^\t(scas|cmps)/ ) ) { # Hp (edi)
	$entry_patch .= "\tmovl \%edi,${OFFSET_Hp}(\%ebx)\n";
	$exit_patch  .= "\tmovl ${OFFSET_Hp}(\%ebx),\%edi\n";

	# nothing for call_{entry,exit} because %edi is callee-save
    }

    # --------------------------------------------------------
    # next, here we go with non-%esp patching!
    #
    s/^(\t[a-z])/$entry_patch$1/; # before first instruction

# Before calling GC we must set up the exit condition before the call
# and entry condition when we come back

    # fix _all_ non-local jumps:

    if ( $TargetPlatform =~ /^.*-apple-darwin.*/ ) {
        # On Darwin, we've got local-looking jumps that are
        # actually global (i.e. jumps to Lfoo$stub or via
        # Lfoo$non_lazy_ptr), so we fix those first.
        # In fact, we just fix everything that contains a dollar
        # because false positives don't hurt here.

        s/^(\tjmp\s+\*?L.*\$.*\n)/$exit_patch$1/g;
    }

    s/^\tjmp\s+\*${T_X86_PRE_LLBL_PAT}/\tJMP___SL/go;
    s/^\tjmp\s+${T_X86_PRE_LLBL_PAT}/\tJMP___L/go;

    s/^(\tjmp\s+.*\n)/$exit_patch$1/g; # here's the fix...

    s/^\tJMP___SL/\tjmp \*${T_X86_PRE_LLBL}/go;
    s/^\tJMP___L/\tjmp ${T_X86_PRE_LLBL}/go;

    if ($StolenX86Regs == 2 ) {
	die "ARGH! Jump uses \%esi or \%edi with -monly-2-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%e(si|di)/;
    } elsif ($StolenX86Regs == 3 ) {
	die "ARGH! Jump uses \%edi with -monly-3-regs:\n$_" 
	    if /^\t(jmp|call)\s+.*\%edi/;
    }

    # --------------------------------------------------------
    # that's it -- print it
    #
    #die "Funny jumps?\n$_" if /${T_X86_BADJMP}/o; # paranoia

    print OUTASM $_;

    if ( $need_fallthru_patch ) { # exit patch for end of slow entry code
	print OUTASM $exit_patch;
	# ToDo: make it not print if there is a "jmp" at the end
    }
}
\end{code}

\begin{code}
sub init_FUNNY_THINGS {
    %KNOWN_FUNNY_THING = (
	# example
	# "${T_US}stg_.*{T_POST_LBL}", 1,  
    );
}
\end{code}

The following table reversal is used for both info tables and return
vectors.  In both cases, we remove the first entry from the table,
reverse the table, put the label at the end, and paste some code
(that which is normally referred to by the first entry in the table)
right after the table itself.  (The code pasting is done elsewhere.)

\begin{code}
sub rev_tbl {
    local($symb, $tbl, $discard1) = @_;

    return ($tbl) if ($TargetPlatform =~ /^ia64-/);

    local($before) = '';
    local($label) = '';
    local(@imports) = (); # hppa only
    local(@words) = ();
    local($after) = '';
    local(@lines) = split(/\n/, $tbl);
    local($i, $j);

    # Deal with the header...
    for ($i = 0; $i <= $#lines && $lines[$i] !~ /^\t?${T_DOT_WORD}\s+/o; $i++) {
	$label .= $lines[$i] . "\n",
	    next if $lines[$i] =~ /^[A-Za-z0-9_]+_info${T_POST_LBL}$/o
		 || $lines[$i] =~ /${T_DOT_GLOBAL}/o
		 || $lines[$i] =~ /^${T_US}\S+_vtbl${T_POST_LBL}$/o;

	$before .= $lines[$i] . "\n"; # otherwise...
    }

    $infoname = $label;
    $infoname =~ s/(.|\n)*^([A-Za-z0-9_]+_info)${T_POST_LBL}$(.|\n)*/\2/;
    
    # Grab the table data...
    if ( $TargetPlatform !~ /^hppa/ ) {
	for ( ; $i <= $#lines && $lines[$i] =~ /^\t?${T_DOT_WORD}\s+/o; $i++) {
	    $line = $lines[$i];
	    # Convert addresses of SRTs, slow entrypoints and large bitmaps
	    # to offsets (relative to the info label),
	    # in order to support position independent code.
            $line =~ s/$infoname/0/
            || $line =~ s/([A-Za-z0-9_]+_srtd)$/\1 - $infoname/
            || $line =~ s/([A-Za-z0-9_]+_srt(\+\d+)?)$/\1 - $infoname/
            || $line =~ s/([A-Za-z0-9_]+_str)$/\1 - $infoname/
	    || $line =~ s/([A-Za-z0-9_]+_slow)$/\1 - $infoname/
	    || $line =~ s/([A-Za-z0-9_]+_btm)$/\1 - $infoname/
            || $line =~ s/([A-Za-z0-9_]+_alt)$/\1 - $infoname/
            || $line =~ s/([A-Za-z0-9_]+_dflt)$/\1 - $infoname/
            || $line =~ s/([A-Za-z0-9_]+_ret)$/\1 - $infoname/;
	    push(@words, $line);
	}
    } else { # hppa weirdness
	for ( ; $i <= $#lines && $lines[$i] =~ /^\s+(${T_DOT_WORD}|\.IMPORT)/; $i++) {
            # FIXME: the RTS now expects offsets instead of addresses
            # for all labels in info tables.
	    if ($lines[$i] =~ /^\s+\.IMPORT/) {
		push(@imports, $lines[$i]);
	    } else {
		# We don't use HP's ``function pointers''
		# We just use labels in code space, like normal people
		$lines[$i] =~ s/P%//;
		push(@words, $lines[$i]);
	    }
	}
    }

    # Now throw away any initial zero word from the table.  This is a hack
    # that lets us reduce the size of info tables when the SRT field is not
    # needed: see comments StgFunInfoTable in InfoTables.h.
    #
    # The .zero business is for Linux/ELF.
    # The .skip business is for Sparc/Solaris/ELF.
    # The .blockz business is for HPPA.
#    if ($discard1) {
#	if ($words[0] =~ /^\t?(${T_DOT_WORD}\s+0|\.zero\s+4|\.skip\s+4|\.blockz\s+4)/) {
#		shift(@words);
#    	}
#    }

    for (; $i <= $#lines; $i++) {
	$after .= $lines[$i] . "\n";
    }

    # Alphas: If we have anonymous text (not part of a procedure), the
    # linker may complain about missing exception information.  Bleh.
    # To suppress this, we place a .ent/.end pair around the code.
    # At the same time, we have to be careful and not enclose any leading
    # .file/.loc directives.
    if ( $TargetPlatform =~ /^alpha-/ && $label =~ /^([A-Za-z0-9_]+):$/) {
        local ($ident) = $1;
        $before =~ s/^((\s*\.(file|loc)\s+[^\n]*\n)*)/$1\t.ent $ident\n/;
    	$after .= "\t.end $ident\n";
    }

    # Alphas: The heroic Simon Marlow found a bug in the Digital UNIX
    # assembler (!) wherein .quad constants inside .text sections are
    # first narrowed to 32 bits then sign-extended back to 64 bits.
    # This obviously screws up our 64-bit bitmaps, so we work around
    # the bug by replacing .quad with .align 3 + .long + .long [ccshan]
    if ( $TargetPlatform =~ /^alpha-/ ) {
	foreach (@words) {
	    if (/^\s*\.quad\s+([-+0-9].*\S)\s*$/ && length $1 >= 10) {
		local ($number) = $1;
		if ($number =~ /^([-+])?(0x?)?([0-9]+)$/) {
		    local ($sign, $base, $digits) = ($1, $2, $3);
		    $base = (10, 8, 16)[length $base];
		    local ($hi, $lo) = (0, 0);
		    foreach $i (split(//, $digits)) {
			$j = $lo * $base + $i;
			$lo = $j % 4294967296;
			$hi = $hi * $base + ($j - $lo) / 4294967296;
		    }
		    ($hi, $lo) = (4294967295 - $hi, 4294967296 - $lo)
			if $sign eq "-";
		    $_ = "\t.align 3\n\t.long $lo\n\t.long $hi\n";
		    # printf STDERR "TURNING %s into 0x %08x %08x\n", $number, $hi, $lo;
		} else {
		    print STDERR "Cannot handle \".quad $number\" in info table\n";
		    exit 1;
		}
	    }
	}
    }

    if ( $TargetPlatform =~ /x86_64-apple-darwin/ ) {
        # Tack a label to the front of the info table, too.
        # For now, this just serves to work around a crash in Apple's new
        # 64-bit linker (it seems to assume that there is no data before the
        # first label in a section).
        
        # The plan for the future is to do this on all Darwin platforms, and
        # to add a reference to this label after the entry code, just as the
        # NCG does, so we can enable dead-code-stripping in the linker without
        # losing our info tables. (Hence the name _dsp, for dead-strip preventer)
        
        $before .= "\n${infoname}_dsp:\n";    
    }

    $tbl = $before
	 . (($TargetPlatform !~ /^hppa/) ? '' : join("\n", @imports) . "\n")
	 . join("\n", @words) . "\n"
	 . $label . $after;

#   print STDERR "before=$before\n";
#   print STDERR "label=$label\n";
#   print STDERR "words=",(reverse @words),"\n";
#   print STDERR "after=$after\n";

    $tbl;
}
\end{code}

The HP is a major nuisance.  The threaded code mangler moved info
tables from data space to code space, but unthreaded code in the RTS
still has references to info tables in data space.  Since the HP
linker is very precise about where symbols live, we need to patch the
references in the unthreaded RTS as well.

\begin{code}
sub mini_mangle_asm_hppa {
    local($in_asmf, $out_asmf) = @_;

    open(INASM, "< $in_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$in_asmf' (to read)\n");
    open(OUTASM,"> $out_asmf")
	|| &tidy_up_and_die(1,"$Pgm: failed to open `$out_asmf' (to write)\n");

    while (<INASM>) {
	s/_info,DATA/_info,CODE/;   # Move _info references to code space
	s/P%_PR/_PR/;
	print OUTASM;
    }

    # finished:
    close(OUTASM) || &tidy_up_and_die(1,"Failed writing to $out_asmf\n");
    close(INASM)  || &tidy_up_and_die(1,"Failed reading from $in_asmf\n");
}

\end{code}

\begin{code}
sub tidy_up_and_die {
    local($return_val, $msg) = @_;
    print STDERR $msg;
    exit (($return_val == 0) ? 0 : 1);
}
\end{code}
