#!/usr/bin/perl -w

use strict;

# Usage:
#
# ./darcs-all [-q] [-s] [--dph] [--nofib] [--testsuite] get [darcs get flags]
#   This gets the GHC core repos, if they do not already exist.
#   -q says to be quite, and -s to be silent.
#   --dph, --nofib, --testsuite also get the dph library, nofib and
#                               testsuite repos respectively
#   The darcs get flag you are most likely to want is --complete. By
#   default we pass darcs the --partial flag.
#
# ./darcs-all [-q] [-s] cmd [darcs cmd flags]
#   This runs the darcs "cmd" command, with any flags you give, in all
#   of the repos you have checked out. e.g.
#       ./darcs-all pull
#       ./darcs-all -q send --dry-run
#   -q says to be quite, and -s to be silent.

$| = 1; # autoflush stdout after each print, to avoid output after die

# Figure out where to get the other repositories from,
# based on where this GHC repo came from.
my $defaultrepo = `cat _darcs/prefs/defaultrepo`;
chomp $defaultrepo;
my $defaultrepo_base;
my $checked_out_tree;

if ($defaultrepo =~ /^...*:/) {
    # HTTP or SSH
    # Above regex says "at least two chars before the :", to avoid
    # catching Win32 drives ("C:\").
    $defaultrepo_base = $defaultrepo;
    $defaultrepo_base =~ s#/[^/]+/?$##;
    $checked_out_tree = 0;
}
elsif ($defaultrepo =~ /^\/|\.\.\/|.:(\/|\\)/) {
    # Local filesystem, either absolute or relative path
    # (assumes a checked-out tree):
    $defaultrepo_base = $defaultrepo;
    $checked_out_tree = 1;
}
else {
    die "Couldn't work out defaultrepo";
}

my $verbose = 2;
my $ignore_failure = 0;

my %tags;

sub message {
    if ($verbose >= 2) {
        print "@_\n";
    }
}

sub warning {
    if ($verbose >= 1) {
        print "warning: @_\n";
    }
}

sub darcs {
    message "== running darcs @_";
    system ("darcs", @_) == 0
        or $ignore_failure
        or die "darcs failed: $?";
}

sub darcsall {
    my $localpath;
    my $path;
    my $tag;
    my @repos;

    open IN, "< packages" or die "Can't open packages file";
    @repos = <IN>;
    close IN;

    foreach (@repos) {
        chomp;
        if (/^([^# ]+) +(?:([^ ]+) +)?([^ ]+) +([^ ]+)$/) {
            $localpath = $1;
            $tag = defined($2) ? $2 : "";

            if (-d "$localpath/_darcs") {
                darcs (@_, "--repodir", $localpath);
            }
            elsif ($tag eq "") {
                message "== Required repo $localpath is missing! Skipping";
            }
            else {
                message "== $localpath repo not present; skipping";
            }
        }
        elsif (! /^(#.*)?$/) {
            die "Bad line: $_";
        }
    }
}

sub darcsget {
    my $r_flags;
    my $localpath;
    my $remotepath;
    my $path;
    my $tag;
    my @repos;

    if (! grep /(?:--complete|--partial)/, @_) {
        warning("adding --partial, to override use --complete");
        $r_flags = [@_, "--partial"];
    }
    else {
        $r_flags = \@_;
    }

    open IN, "< packages" or die "Can't open packages file";
    @repos = <IN>;
    close IN;

    foreach (@repos) {
        chomp;
        if (/^([^ ]+) +(?:([^ ]+) +)?([^ ]+) +([^ ]+)$/) {
            $localpath = $1;
            $tag = defined($2) ? $2 : "";
            $remotepath = $3;

            if ($checked_out_tree) {
                $path = "$defaultrepo_base/$localpath";
            }
            else {
                if ($remotepath =~ /^http:/) {
                    $path = $remotepath;
                }
                else {
                    $path = "$defaultrepo_base/$remotepath";
                }
            }

            if (($tag eq "") || defined($tags{$tag})) {
                if (-d $localpath) {
                    warning("$localpath already present; omitting");
                }
                else {
                    darcs (@$r_flags, $path, $localpath);
                }
            }
        }
        elsif (! /^(#.*)?$/) {
            die "Bad line: $_";
        }
    }
}

sub main {
    if (! -d "_darcs" || ! -d "compiler") {
        die "error: darcs-all must be run from the top level of the ghc tree."
    }

    while ($#_ ne -1) {
        my $arg = shift;
        # We handle -q here as well as lower down as we need to skip over it
        # if it comes before the darcs command
        if ($arg eq "-q") {
            $verbose = 1;
        }
        elsif ($arg eq "-s") {
            $verbose = 0;
        }
        # --dph says we grab the dph libs with 'get'.
        # It has no effect on the other commands.
        elsif ($arg eq "--dph") {
            $tags{"dph"} = 1;
        }
        # --nofib tells get to also grab the nofib repo.
        # It has no effect on the other commands.
        elsif ($arg eq "--nofib") {
            $tags{"nofib"} = 1;
        }
        # --testsuite tells get to also grab the testsuite repo.
        # It has no effect on the other commands.
        elsif ($arg eq "--testsuite") {
            $tags{"testsuite"} = 1;
        }
        else {
            unshift @_, $arg;
            if (grep /^-q$/, @_) {
                $verbose = 1;
            }
            last;
        }
    }

    if ($#_ eq -1) {
        die "What do you want to do?";
    }
    my $command = $_[0];
    if ($command eq "get") {
        darcsget @_;
    }
    else {
        if ($command =~ /^(?:w|wh|wha|what|whats|whatsn|whatsne|whatsnew)$/) {
            # Hack around whatsnew failing if there are no changes
            $ignore_failure = 1;
        }
        darcsall @_;
    }
}

main(@ARGV);

