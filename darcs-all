#!/usr/bin/perl -w

use strict;

# Usage:
#
# ./darcs-all [-q] [-s] [-i] [-r repo] [--nofib] [--testsuite] get [darcs get flags]
#   This gets the GHC core repos, if they do not already exist.
#   -q says to be quite, and -s to be silent.
#   -i says to ignore darcs errors and move on to the next repository
#   -r repo says to use repo as the location of package repositories
#   --nofib, --testsuite also get the nofib and testsuite repos respectively
#   The darcs get flag you are most likely to want is --complete. By
#   default we pass darcs the --partial flag.
#
# ./darcs-all [-q] [-s] [-i] [-r repo] cmd [darcs cmd flags]
#   This runs the darcs "cmd" command, with any flags you give, in all
#   of the repos you have checked out. e.g.
#       ./darcs-all pull
#       ./darcs-all -q send --dry-run
#   -q says to be quite, and -s to be silent.

$| = 1; # autoflush stdout after each print, to avoid output after die

my $defaultrepo;

my $verbose = 2;
my $ignore_failure = 0;
my $want_remote_repo = 0;

my %tags;

# Figure out where to get the other repositories from.
sub getrepo {
    my $basedir = ".";
    my $repo = $defaultrepo || `cat $basedir/_darcs/prefs/defaultrepo`;
    chomp $repo;

    my $repo_base;
    my $checked_out_tree;

    if ($repo =~ /^...*:/) {
        # HTTP or SSH
        # Above regex says "at least two chars before the :", to avoid
        # catching Win32 drives ("C:\").
        $repo_base = $repo;
        $checked_out_tree = 0;

        # Don't drop the last part of the path if specified with -r, as
        # it expects repos of the form:
        #
        #   http://darcs.haskell.org
        #
        # rather than
        #   
        #   http://darcs.haskell.org/ghc
        #
        if (!$defaultrepo) {
            $repo_base =~ s#/[^/]+/?$##;
        }
    }
    elsif ($repo =~ /^\/|\.\.\/|.:(\/|\\)/) {
        # Local filesystem, either absolute or relative path
        # (assumes a checked-out tree):
        $repo_base = $repo;
        $checked_out_tree = 1;
    }
    else {
        die "Couldn't work out repo";
    }

    return $repo_base, $checked_out_tree;
}

sub message {
    if ($verbose >= 2) {
        print "@_\n";
    }
}

sub warning {
    if ($verbose >= 1) {
        print "warning: @_\n";
    }
}

sub darcs {
    message "== running darcs @_";
    system ("darcs", @_) == 0
       or $ignore_failure
       or die "darcs failed: $?";
}

sub darcsall {
    my $localpath;
    my $remotepath;
    my $path;
    my $tag;
    my @repos;

    my ($repo_base, $checked_out_tree) = getrepo();

    open IN, "< packages" or die "Can't open packages file";
    @repos = <IN>;
    close IN;

    REPO: foreach (@repos) {
        chomp;
        if (/^([^# ]+) +(?:([^ ]+) +)?([^ ]+) +([^ ]+)$/) {
            $localpath = $1;
            $tag = defined($2) ? $2 : "";
            $remotepath = $3;

            if ($checked_out_tree) {
                $path = "$repo_base/$localpath";
            }
            else {
                $path = "$repo_base/$remotepath";
            }

            if (-d "$localpath/_darcs") {
                if ($want_remote_repo) {
                    darcs (@_, "--repodir", $localpath, $path);
                } else {
                    darcs (@_, "--repodir", $localpath);
                }
            }
            elsif ($tag eq "") {
                message "== Required repo $localpath is missing! Skipping";
            }
            else {
                message "== $localpath repo not present; skipping";
            }
        }
        elsif (! /^(#.*)?$/) {
            die "Bad line: $_";
        }
    }
}

sub darcsget {
    my $r_flags;
    my $localpath;
    my $remotepath;
    my $path;
    my $tag;
    my @repos;

    my ($repo_base, $checked_out_tree) = getrepo();

    if (! grep /(?:--complete|--partial)/, @_) {
        warning("adding --partial, to override use --complete");
        $r_flags = [@_, "--partial"];
    }
    else {
        $r_flags = \@_;
    }

    open IN, "< packages" or die "Can't open packages file";
    @repos = <IN>;
    close IN;

    foreach (@repos) {
        chomp;
        if (/^([^ ]+) +(?:([^ ]+) +)?([^ ]+) +([^ ]+)$/) {
            $localpath = $1;
            $tag = defined($2) ? $2 : "";
            $remotepath = $3;

            if ($checked_out_tree) {
                $path = "$repo_base/$localpath";
            }
            else {
                $path = "$repo_base/$remotepath";
            }

            if (($tag eq "") || defined($tags{$tag})) {
                if (-d $localpath) {
                    warning("$localpath already present; omitting");
                }
                else {
                    darcs (@$r_flags, $path, $localpath);
                }
            }
        }
        elsif (! /^(#.*)?$/) {
            die "Bad line: $_";
        }
    }
}

sub main {
    if (! -d "compiler") {
        die "error: darcs-all must be run from the top level of the ghc tree."
    }

    while ($#_ ne -1) {
        my $arg = shift;
        # We handle -q here as well as lower down as we need to skip over it
        # if it comes before the darcs command
        if ($arg eq "-q") {
            $verbose = 1;
        }
        elsif ($arg eq "-s") {
            $verbose = 0;
        }
        elsif ($arg eq "-r") {
            $defaultrepo = shift;
        }
        elsif ($arg eq "-i") {
            $ignore_failure = 1;
        }
        # --nofib tells get to also grab the nofib repo.
        # It has no effect on the other commands.
        elsif ($arg eq "--nofib") {
            $tags{"nofib"} = 1;
        }
        # --testsuite tells get to also grab the testsuite repo.
        # It has no effect on the other commands.
        elsif ($arg eq "--testsuite") {
            $tags{"testsuite"} = 1;
        }
        else {
            unshift @_, $arg;
            if (grep /^-q$/, @_) {
                $verbose = 1;
            }
            last;
        }
    }

    if ($#_ eq -1) {
        die "What do you want to do?";
    }
    my $command = $_[0];
    if ($command eq "get") {
        darcsget @_;
    }
    else {
        if ($command =~ /^(?:w|wh|wha|what|whats|whatsn|whatsne|whatsnew)$/) {
            # Hack around whatsnew failing if there are no changes
            $ignore_failure = 1;
        }
        if ($command =~ /^(pul|pus|sen|put)/) {
            $want_remote_repo = 1;
        }
        darcsall @_;
    }
}

main(@ARGV);

