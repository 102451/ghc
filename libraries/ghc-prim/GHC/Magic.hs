{-# LANGUAGE Trustworthy #-}
{-# LANGUAGE NoImplicitPrelude #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE MagicHash #-}
{-# LANGUAGE UnboxedTuples #-}

-----------------------------------------------------------------------------
-- |
-- Module      :  GHC.Magic
-- Copyright   :  (c) The University of Glasgow 2009
-- License     :  see libraries/ghc-prim/LICENSE
--
-- Maintainer  :  cvs-ghc@haskell.org
-- Stability   :  internal
-- Portability :  non-portable (GHC Extensions)
--
-- GHC magic.
--
-- Use GHC.Exts from the base package instead of importing this
-- module directly.
--
-----------------------------------------------------------------------------

module GHC.Magic
    ( -- * Control over inlining
      inline, noinline,
      -- * Forcing lazy evaluation
      lazy,
      -- * Hinting one-shot application
      oneShot,
      -- * Applying 'realWorld#'
      runRW#
      -- * Control over object lifetime
      -- | The @keepAlive@ family of functions are intended to be used in
      -- FFI scenarios where an object on the Haskell heap may have no inbound
      -- references yet still must be considered to be in use (e.g. by a
      -- foreign function).
      --
      -- Prior to GHC 9.0 the 'GHC.Prim.touch#' primitive was
      -- the recommended tool for ensuring liveness in this situation. However, as
      -- improvements in the simplifier have rendered 'GHC.Prim.touch#' fragile
      -- (e.g. see issue #17760), 'keepAliveLifted#' and 'keepAliveUnlifted#'
      -- now fill this need.
    , keepAliveLifted#, keepAliveUnlifted#
    ) where

--------------------------------------------------
--        See Note [magicIds] in GHC.Types.Id.Make
--------------------------------------------------

-- Here import TYPE explicitly from GHC.Types and not from GHC.Prim. This is
-- because TYPE is not exported by the source Haskell module generated by
-- genprimops which Haddock will typecheck (#15935).
import GHC.Prim (State#, realWorld#, RealWorld, touch#)
import GHC.Types (RuntimeRep(..), TYPE)

-- | The call @inline f@ arranges that @f@ is inlined, regardless of
-- its size. More precisely, the call @inline f@ rewrites to the
-- right-hand side of @f@'s definition. This allows the programmer to
-- control inlining from a particular call site rather than the
-- definition site of the function (c.f. @INLINE@ pragmas).
--
-- This inlining occurs regardless of the argument to the call or the
-- size of @f@'s definition; it is unconditional. The main caveat is
-- that @f@'s definition must be visible to the compiler; it is
-- therefore recommended to mark the function with an @INLINABLE@
-- pragma at its definition so that GHC guarantees to record its
-- unfolding regardless of size.
--
-- If no inlining takes place, the 'inline' function expands to the
-- identity function in Phase zero, so its use imposes no overhead.
{-# NOINLINE[0] inline #-}
inline :: a -> a
inline x = x

-- | The call @noinline f@ arranges that @f@ will not be inlined.
-- It is removed during CorePrep so that its use imposes no overhead
-- (besides the fact that it blocks inlining.)
{-# NOINLINE noinline #-}
noinline :: a -> a
noinline x = x

-- | The 'lazy' function restrains strictness analysis a little. The
-- call @lazy e@ means the same as @e@, but 'lazy' has a magical
-- property so far as strictness analysis is concerned: it is lazy in
-- its first argument, even though its semantics is strict. After
-- strictness analysis has run, calls to 'lazy' are inlined to be the
-- identity function.
--
-- This behaviour is occasionally useful when controlling evaluation
-- order. Notably, 'lazy' is used in the library definition of
-- 'Control.Parallel.par':
--
-- > par :: a -> b -> b
-- > par x y = case (par# x) of _ -> lazy y
--
-- If 'lazy' were not lazy, 'Control.Parallel.par' would look strict in
-- @y@ which would defeat the whole purpose of 'Control.Parallel.par'.
lazy :: a -> a
lazy x = x
-- Implementation note: its strictness and unfolding are over-ridden
-- by the definition in GHC.Types.Id.Make; in both cases to nothing at all.
-- That way, 'lazy' does not get inlined, and the strictness analyser
-- sees it as lazy.  Then the worker/wrapper phase inlines it.
-- Result: happiness


-- | The 'oneShot' function can be used to give a hint to the compiler that its
-- argument will be called at most once, which may (or may not) enable certain
-- optimizations. It can be useful to improve the performance of code in continuation
-- passing style.
--
-- If 'oneShot' is used wrongly, then it may be that computations whose result
-- that would otherwise be shared are re-evaluated every time they are used. Otherwise,
-- the use of `oneShot` is safe.
--
-- 'oneShot' is representation polymorphic: the type variables may refer to lifted
-- or unlifted types.
oneShot :: forall (q :: RuntimeRep) (r :: RuntimeRep)
                  (a :: TYPE q) (b :: TYPE r).
           (a -> b) -> a -> b
oneShot f = f
-- Implementation note: This is wired in in GHC.Types.Id.Make, so the code here is
-- mostly there to have a place for the documentation.

-- | Apply a function to a @'State#' 'RealWorld'@ token. When manually applying
-- a function to `realWorld#`, it is necessary to use @NOINLINE@ to prevent
-- semantically undesirable floating. `runRW#` is inlined, but only very late
-- in compilation after all floating is complete.

-- 'runRW#' is representation polymorphic: the result may have a lifted or
-- unlifted type.

runRW# :: forall (r :: RuntimeRep) (o :: TYPE r).
          (State# RealWorld -> o) -> o
-- See Note [runRW magic] in GHC.CoreToStg.Prep.
{-# NOINLINE runRW# #-}  -- runRW# is inlined manually in CorePrep
runRW# m = m realWorld#


{-
Note [The keepAlive# story]
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The keepAlive# family of functions were introduced to avoid the tendency for
the simplifier to render applications using touch# unsound by dropping
touch#-containing continuations. Specifically, consider the program:

    case go s0 of
      (# s1, r #) -> touch# s1 something

where `go` is known to diverge. In this case the simplifier's case-of-bottom
transformation (see Note [Case-of-bottom transformation] in
GHC.Core.Opt.Simplify will rewrite this to:

    case go s0 of {}

Note that `something` is now no longer live across the `case`. This means that
`something` may be reclaimed by the garbage collector at any point during the
execution of `go`, breaking the intent expressed by the user's use of `touch#`.

To avoid this we have introduced the keepAlive# family. These are normal
Haskell functions written in terms of `touch#` but with an inlining which is
phased to take advantage of the fact that case-of-bottom is disabled in the
final phase of simplification.

The inlining of keepAlive# is quite important for runtime efficiency since
it often appears in "computationally light" settings. For instance,
`GHC.IO.Buffer.readWord8Buf` is essentially:

    readWord8Buf :: ForeignPtr Word8 -> Int -> IO Word8
    readWord8Buf fptr n = IO $ keepAliveLifted# fptr
      (\s1 -> case readWord8OffAddr# (foreignPtrToAddr# fptr) n s1 of
                (# s2, r# #) -> (# s2, W8# r# #)
      )

This function is used in a number of performance-critical loops which
scrutinise the returned Word8 strictly. In these cases it is important for
efficiency that we avoid allocating the W8# constructor. Allowing
keepAliveLifted# to inline is sufficient to achieve this and disabling
case-of-bottom ensures that the simplifier cannot drop the touch# that
guarantees safety.

-}

-- | @keepAliveLifted# x f s0@ evaluates @f s0@ ensuring that @x@ remains
-- reachable to the garbage collector until evaluation concludes.
--
-- @since 0.7.0
keepAliveLifted#
    :: forall (arg :: TYPE 'LiftedRep) r.
       arg -> (State# RealWorld -> (# State# RealWorld, r #))
    -> State# RealWorld
    -> (# State# RealWorld, r #)
  -- See Note [The keepAlive# story]
keepAliveLifted# x k s0 =
    case k s0 of
      (# s1, r #) ->
        case touch# x s1 of
          s2 -> (# s2, r #)
{-# INLINE [0] keepAliveLifted# #-}

-- | @keepAliveUnlifted# x f s0@ evaluates @f s0@ ensuring that @x@ remains
-- reachable to the garbage collector until evaluation concludes.
--
-- @since 0.7.0
keepAliveUnlifted#
    :: forall (arg :: TYPE 'UnliftedRep) r.
       arg -> (State# RealWorld -> (# State# RealWorld, r #))
    -> State# RealWorld
    -> (# State# RealWorld, r #)
  -- See Note [The keepAlive# story]
keepAliveUnlifted# x k s0 =
    case k s0 of
      (# s1, r #) ->
        case touch# x s1 of
          s2 -> (# s2, r #)
{-# INLINE [0] keepAliveUnlifted# #-}
