\begin{code}
#ifndef RTSFLAGS_H
#define RTSFLAGS_H
\end{code}

For defaults, see the @initRtsFlagsDefaults@ routine.

\begin{code}
struct GC_FLAGS {
    FILE   *statsFile;
    I_	    giveStats; /* ToDo: replace with enum type? */
#define NO_GC_STATS	 0
#define VERBOSE_GC_STATS 1

    I_	    stksSize; /* this size is stored to record number of *words* */
    I_	    heapSize; /* this size is stored to record number of *words* */
    I_	    allocAreaSize;
    rtsBool allocAreaSizeGiven;
    I_	    specifiedOldGenSize; /* zero => use the rest of the heap */
    double  pcFreeHeap;
    I_	    minAllocAreaSize; /* derived from: pcFreeHeap, heap-size */

    rtsBool force2s; /* force the use of 2-space copying collection;
			forced to rtsTrue if we do *heap* profiling.
		     */
    rtsBool forceGC; /* force a major GC every <interval> bytes */
    I_	    forcingInterval; /* actually, stored as a number of *words* */
    rtsBool ringBell;
    W_	    trace;
	    /* bit  1 set: chatty GC summaries
	            2 set: details of minor collections
		    4 set: details of major collections, except marking
		    8 set: ditto, but marking this time
		   16 set: GC of MallocPtrs
		   32 set: GC of Concurrent things
	    */
#define DEBUG_TRACE_MINOR_GC	2
#define DEBUG_TRACE_MAJOR_GC	4
#define DEBUG_TRACE_MARKING	8
#define DEBUG_TRACE_MALLOCPTRS 16
#define DEBUG_TRACE_CONCURRENT 32

    rtsBool lazyBlackHoling;
    rtsBool doSelectorsAtGC;
    rtsBool squeezeUpdFrames;
};

struct DEBUG_FLAGS {
};

#if defined(PROFILING) || defined(PAR)
    /* with PROFILING, full cost-centre stuff (also PROFILING_FLAGS);
       with PAR, just the four fixed cost-centres.
    */
struct COST_CENTRE_FLAGS {
    W_	    doCostCentres;
# define COST_CENTRES_SUMMARY	1
# define COST_CENTRES_VERBOSE	2 /* incl. serial time profile */
# define COST_CENTRES_ALL	3

    char    sortBy;
# define SORTCC_LABEL	'C'
# define SORTCC_TIME 	'T'
# define SORTCC_ALLOC	'A'

    I_	    ctxtSwitchTicks; /* derived */
    I_	    profilerTicks;   /* derived */
    I_	    msecsPerTick;    /* derived */
};
#endif

#ifdef PROFILING
struct PROFILING_FLAGS {
    W_	doHeapProfile;
# define NO_HEAP_PROFILING	0	/* N.B. Used as indexes into arrays */
# define HEAP_BY_CC		1
# define HEAP_BY_MOD		2
# define HEAP_BY_GRP		3
# define HEAP_BY_DESCR		4
# define HEAP_BY_TYPE		5
# define HEAP_BY_TIME		6
  
# define CCchar    'C'
# define MODchar   'M'
# define GRPchar   'G'
# define DESCRchar 'D'
# define TYPEchar  'Y'
# define TIMEchar  'T'
};
#endif

#ifdef CONCURRENT
struct CONCURRENT_FLAGS {
    I_	    ctxtSwitchTime; /* in milliseconds */
    I_	    maxThreads;
    I_	    stkChunkSize;
    I_	    maxLocalSparks;
};
#endif /* CONCURRENT */

#ifdef PAR
struct PAR_FLAGS {
    rtsBool parallelStats; 	/* Gather parallel statistics */
    rtsBool granSimStats;	/* Full .gr profile (rtsTrue) or only END events? */
    rtsBool granSimStats_Binary;

    rtsBool outputDisabled;	/* Disable output for performance purposes */
    
    W_	    packBufferSize;
};

#endif /* PAR */

#ifdef GRAN
struct GRAN_FLAGS {
};
#endif /* GRAN */

#ifdef TICKY_TICKY
struct TICKY_FLAGS {
    rtsBool showTickyStats;
    FILE   *tickyFile;

    /* see also: doUpdEntryCounts in AllFlags */
};
#endif /* TICKY_TICKY */
\end{code}

Put them together:
\begin{code}
struct RTS_FLAGS {
    struct GC_FLAGS	GcFlags;
    struct DEBUG_FLAGS	DebugFlags; /* unused at present */

#if defined(PROFILING) || defined(PAR)
    struct COST_CENTRE_FLAGS CcFlags;
#endif
#ifdef PROFILING
    struct PROFILING_FLAGS ProfFlags;
#endif
#ifdef CONCURRENT
    struct CONCURRENT_FLAGS ConcFlags;
#endif
#ifdef PAR
    struct PAR_FLAGS	ParFlags;
#endif
#ifdef GRAN
    struct GRAN_FLAGS	GranFlags;
#endif
#ifdef TICKY_TICKY
    struct TICKY_FLAGS	TickyFlags;
#endif
};

extern struct RTS_FLAGS RTSflags;
\end{code}

Routines that operate-on/to-do-with RTS flags:
\begin{code}
void	initRtsFlagsDefaults (STG_NO_ARGS);
void	setupRtsFlags PROTO((int *argc,     char *argv[],
			     int *rts_argc, char *rts_argv[]));
\end{code}

OLD: This is the maximum identifier length that can be used for a cost
centre or description string. It includes the terminating null
character.

The printf formats are here, so we are less likely to make overly-long
filenames (with disastrous results).  No more than 128 chars, please!

\begin{code}
#define STATS_FILENAME_MAXLEN	128

#define GR_FILENAME_FMT		"%0.124s.gr"
#define GR_FILENAME_FMT_GUM	"%0.120s.%03d.%s"
#define HP_FILENAME_FMT		"%0.124s.hp"
#define LIFE_FILENAME_FMT	"%0.122s.life"
#define PROF_FILENAME_FMT	"%0.122s.prof"
#define PROF_FILENAME_FMT_GUM	"%0.118s.%03d.prof"
#define QP_FILENAME_FMT		"%0.124s.qp"
#define STAT_FILENAME_FMT	"%0.122s.stat"
#define TICKY_FILENAME_FMT	"%0.121s.ticky"
#define TIME_FILENAME_FMT	"%0.122s.time"
#define TIME_FILENAME_FMT_GUM	"%0.118s.%03d.time"
\end{code}

Multi-slurp protection:
\begin{code}
#endif	/* RTSFLAGS_H */
\end{code}
