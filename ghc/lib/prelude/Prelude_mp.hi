{-# GHC_PRAGMA INTERFACE VERSION 6 #-}
interface Prelude where
import PreludeArray((!), (//), Array, Assoc, _ByteArray, accum, accumArray, amap, array, assocs, bounds, elems, indices, ixmap, listArray)
import PreludeBuiltin(Bin, Char(..), Int(..), Integer(..), List(..), Tuple0, Tuple2, Tuple3, Tuple4, Tuple5, Tuple6, Tuple7, _Addr(..), _RealWorld(..), _State(..))
import PreludeComplex(Complex, cis, conjugate, imagPart, magnitude, mkPolar, phase, polar, realPart)
import PreludeCore(Bool(..), Eq(..), Fractional(..), Integral(..), Ix(..), Num(..), Ord(..), Real(..), RealFloat(..), RealFrac(..), Text(..), _readList, _showList, _showRational)
import PreludeIO(IOError, Request, Response, SigAct, abort, appendBinChan, appendBinFile, appendChan, appendFile, binDispatch, deleteFile, done, echo, exit, getArgs, getEnv, getProgName, interact, print, prints, readBinChan, readBinFile, readChan, readFile, setEnv, sigAction, statusChan, statusFile, stdecho, stderr, stdin, stdout, strDispatch, strListDispatch, succDispatch, writeBinFile, writeFile)
import PreludeList((!!), (++), (\\), all, and, any, break, concat, cycle, drop, dropWhile, elem, filter, foldl1, foldr1, genericLength, head, init, iterate, last, length, lines, map, maximum, minimum, notElem, nub, null, or, partition, product, products, repeat, reverse, scanl, scanl1, scanr, scanr1, span, splitAt, sum, sums, tail, take, takeWhile, transpose, unlines, unwords, unzip, unzip3, unzip4, unzip5, unzip6, unzip7, words, zip, zip3, zip4, zip5, zip6, zip7, zipWith, zipWith3, zipWith4, zipWith5, zipWith6, zipWith7)
import PreludePS(_PackedString, _appendPS, _breakPS, _byteArrayToPS, _concatPS, _consPS, _dropPS, _dropWhilePS, _filterPS, _foldlPS, _foldrPS, _headPS, _indexPS, _lengthPS, _linesPS, _mapPS, _nilPS, _nullPS, _packCBytes, _packCString, _packString, _psToByteArray, _putPS, _reversePS, _spanPS, _splitAtPS, _substrPS, _tailPS, _takePS, _takeWhilePS, _unpackPS, _wordsPS)
import PreludeRatio((%), Ratio(..), approxRational, denominator, numerator)
import PreludeText(_readRational, _showDigit, _showHex, _showRadix, lex, read, readDec, readFloat, readLitChar, readParen, readSigned, reads, show, showChar, showFloat, showInt, showLitChar, showParen, showSigned, showSpace__, showString, shows)
import Stdio(_FILE)
($) :: (a -> b) -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _F_ _IF_ARGS_ 2 2 XX 2 _/\_ u0 u1 -> \ (u2 :: u0 -> u1) (u3 :: u0) -> _APP_  u2 [ u3 ] _N_ #-}
(&&) :: Bool -> Bool -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "EL" _F_ _ALWAYS_ \ (u0 :: Bool) (u1 :: Bool) -> case u0 of { _ALG_ True  -> u1; False  -> _!_ False [] []; _NO_DEFLT_ } _N_ #-}
(.) :: (a -> c) -> (b -> a) -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "SLL" _F_ _ALWAYS_ _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u2) (u4 :: u1 -> u0) (u5 :: u1) -> let {(u6 :: u0) = _APP_  u4 [ u5 ]} in _APP_  u3 [ u6 ] _N_ #-}
(^) :: (Num b, Integral a) => b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 2122 _N_ _S_ "LU(U(LU(U(U(SL)LLLLLLL)LLLL)L)LLLLLLLLLLL)" _N_ _SPECIALISE_ [ Int, Double ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, Int ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, Integer ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Complex Double) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, Integer ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(^^) :: (Fractional b, Integral a) => b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 2222 _N_ _S_ "LU(LU(U(LLLSLLLL)LLL)LLLLLLLLLL)" _N_ _SPECIALISE_ [ Int, Double ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int, (Complex Double) ] 2 { _A_ 2 _U_ 21 _N_ _S_ "LU(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
appendBin :: Bin -> Bin -> Bin
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ _!_ _N_ _N_ #-}
asTypeOf :: a -> a -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 10 _N_ _N_ _F_ _IF_ARGS_ 1 0 X 1 _/\_ u0 -> _TYAPP_  _TYAPP_  _ORIG_ Prelude const { u0 } { u0 } _N_ #-}
atan2 :: RealFloat a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(AU(U(ALAASAAA)AAAA)A)AAAAAA)U(U(SLAA)LAAAAAAAAAALAAAAAA)AAAAAAAA)" {_A_ 5 _U_ 2212222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
chr :: Int -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ chr# [] [u0] of { _PRIM_ (u1 :: Char#) -> _!_ C# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ chr# [] [u1] of { _PRIM_ (u2 :: Char#) -> _!_ C# [] [u2] }; _NO_DEFLT_ } _N_ #-}
const :: b -> a -> b
	{-# GHC_PRAGMA _A_ 2 _U_ 10 _N_ _S_ "SA" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 2 XX 1 _/\_ u0 u1 -> \ (u2 :: u1) (u3 :: u0) -> u2 _N_ #-}
flip :: (b -> a -> c) -> a -> b -> c
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "SLL" _F_ _IF_ARGS_ 3 3 XXX 3 _/\_ u0 u1 u2 -> \ (u3 :: u1 -> u0 -> u2) (u4 :: u0) (u5 :: u1) -> _APP_  u3 [ u5, u4 ] _N_ #-}
fromIntegral :: (Integral a, Num b) => a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LU(AAAAAAAASA)L" {_A_ 3 _U_ 112 _N_ _N_ _F_ _IF_ARGS_ 2 3 CXX 6 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: Integer -> u1) (u4 :: u0) -> let {(uh :: Integer) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  uf [ u4 ]; _NO_DEFLT_ }} in _APP_  u3 [ uh ] _N_} _F_ _IF_ARGS_ 2 3 CCX 7 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: {{Num u1}}) (u4 :: u0) -> let {(uh :: Integer) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  uf [ u4 ]; _NO_DEFLT_ }} in case u3 of { _ALG_ _TUP_10 (ui :: {{Eq u1}}) (uj :: {{Text u1}}) (uk :: u1 -> u1 -> u1) (ul :: u1 -> u1 -> u1) (um :: u1 -> u1 -> u1) (un :: u1 -> u1) (uo :: u1 -> u1) (up :: u1 -> u1) (uq :: Integer -> u1) (ur :: Int -> u1) -> _APP_  uq [ uh ]; _NO_DEFLT_ } _SPECIALISE_ [ Int, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Double# [] [u0] of { _PRIM_ (u1 :: Double#) -> _!_ D# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Double# [] [u1] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Int, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Int#) -> case _#_ int2Float# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> case _#_ int2Float# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Int, Int ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Int } _N_ }, [ Int, Integer ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: Int#) -> _#_ int2Integer# [] [u0] _N_} _F_ _IF_ARGS_ 0 1 C 2 \ (u0 :: Int) -> case u0 of { _ALG_ I# (u1 :: Int#) -> _#_ int2Integer# [] [u1]; _NO_DEFLT_ } _N_ }, [ Int, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ encodeDouble# [] [u0, u1, u2, 0#] of { _PRIM_ (u3 :: Double#) -> _!_ D# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ encodeDouble# [] [u1, u2, u3, 0#] of { _PRIM_ (u4 :: Double#) -> _!_ D# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ encodeFloat# [] [u0, u1, u2, 0#] of { _PRIM_ (u3 :: Float#) -> _!_ F# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ encodeFloat# [] [u1, u2, u3, 0#] of { _PRIM_ (u4 :: Float#) -> _!_ F# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Int ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _F_ _IF_ARGS_ 0 3 XXX 3 \ (u0 :: Int#) (u1 :: Int#) (u2 :: ByteArray#) -> case _#_ integer2Int# [] [u0, u1, u2] of { _PRIM_ (u3 :: Int#) -> _!_ I# [] [u3] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Integer) -> case u0 of { _ALG_ J# (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u4 :: Int#) -> _!_ I# [] [u4] }; _NO_DEFLT_ } _N_ }, [ Integer, Integer ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Integer } _N_ }, [ Integer, (Ratio Integer) ] 2 { _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Integer) -> _!_ (:%) [Integer] [u0, _SPEC_ _ORIG_ PreludeCore __i1 [ (Integer) ]] _N_ } #-}
fromRealFrac :: (RealFrac a, Fractional b) => a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "LU(AAAS)L" {_A_ 3 _U_ 112 _N_ _N_ _F_ _IF_ARGS_ 2 3 CXX 7 _/\_ u0 u1 -> \ (u2 :: {{RealFrac u0}}) (u3 :: Ratio Integer -> u1) (u4 :: u0) -> let {(uf :: Ratio Integer) = case u2 of { _ALG_ _TUP_7 (u5 :: {{Real u0}}) (u6 :: {{Fractional u0}}) (u7 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> (a$z1, u0)) (u8 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (u9 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (ua :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (ub :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) -> case u5 of { _ALG_ _TUP_3 (uc :: {{Num u0}}) (ud :: {{Enum u0}}) (ue :: u0 -> Ratio Integer) -> _APP_  ue [ u4 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  u3 [ uf ] _N_} _F_ _IF_ARGS_ 2 3 CCX 8 _/\_ u0 u1 -> \ (u2 :: {{RealFrac u0}}) (u3 :: {{Fractional u1}}) (u4 :: u0) -> let {(uf :: Ratio Integer) = case u2 of { _ALG_ _TUP_7 (u5 :: {{Real u0}}) (u6 :: {{Fractional u0}}) (u7 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> (a$z1, u0)) (u8 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (u9 :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (ua :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) (ub :: _forall_ a$z1 =>{{Integral a$z1}} -> u0 -> a$z1) -> case u5 of { _ALG_ _TUP_3 (uc :: {{Num u0}}) (ud :: {{Enum u0}}) (ue :: u0 -> Ratio Integer) -> _APP_  ue [ u4 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in case u3 of { _ALG_ _TUP_4 (ug :: {{Num u1}}) (uh :: u1 -> u1 -> u1) (ui :: u1 -> u1) (uj :: Ratio Integer -> u1) -> _APP_  uj [ uf ]; _NO_DEFLT_ } _SPECIALISE_ [ Double, Double ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Double } _N_ }, [ Double, Float ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Double#) -> case _#_ double2Float# [] [u0] of { _PRIM_ (u1 :: Float#) -> _!_ F# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Double) -> case u0 of { _ALG_ D# (u1 :: Double#) -> case _#_ double2Float# [] [u1] of { _PRIM_ (u2 :: Float#) -> _!_ F# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Double, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Float, Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Float#) -> case _#_ float2Double# [] [u0] of { _PRIM_ (u1 :: Double#) -> _!_ D# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Float) -> case u0 of { _ALG_ F# (u1 :: Float#) -> case _#_ float2Double# [] [u1] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] }; _NO_DEFLT_ } _N_ }, [ Float, Float ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { Float } _N_ }, [ Float, (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Ratio Integer), Double ] 2 { _A_ 1 _U_ 1 _N_ _S_ "U(U(PPP)U(PPP))" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Ratio Integer), Float ] 2 { _A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Fractional fromRational (Float) _N_ }, [ (Ratio Integer), (Ratio Integer) ] 2 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ Prelude id { (Ratio Integer) } _N_ } #-}
fst :: (b, a) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u1, u0)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u1) (u4 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
gcd :: Integral a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAAAALAAL)AA)AALAAAAAAAA)" {_A_ 4 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(PPP)U(PPP)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
id :: a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_ #-}
isAlpha :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isAlphanum :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isAscii :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 2 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> _#_ ltInt# [] [u1, 128#] } _N_} _F_ _IF_ARGS_ 0 1 C 3 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> _#_ ltInt# [] [u2, 128#] }; _NO_DEFLT_ } _N_ #-}
isControl :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isDigit :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isLower :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isNullBin :: Bin -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ #-}
isPrint :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isSpace :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 1 _N_ _N_ _N_ _N_} _N_ _N_ #-}
isUpper :: Char -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lcm :: Integral a => a -> a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAALALAAL)AA)ALLAAAAAAAA)" {_A_ 3 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
maxChar :: Char
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ C# [] ['\o377'#] _N_ #-}
maxInt :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [2147483647#] _N_ #-}
minChar :: Char
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ C# [] ['\o0'#] _N_ #-}
minInt :: Int
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 2 _!_ I# [] [-2147483647#] _N_ #-}
not :: Bool -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "E" _F_ _ALWAYS_ \ (u0 :: Bool) -> case u0 of { _ALG_ True  -> _!_ False [] []; False  -> _!_ True [] []; _NO_DEFLT_ } _N_ #-}
nullBin :: Bin
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _S_ _!_ _N_ _N_ #-}
ord :: Char -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: Char#) -> case _#_ ord# [] [u0] of { _PRIM_ (u1 :: Int#) -> _!_ I# [] [u1] } _N_} _F_ _IF_ARGS_ 0 1 C 4 \ (u0 :: Char) -> case u0 of { _ALG_ C# (u1 :: Char#) -> case _#_ ord# [] [u1] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] }; _NO_DEFLT_ } _N_ #-}
otherwise :: Bool
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _ALWAYS_ _!_ True [] [] _N_ #-}
snd :: (a, b) -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 2 1 X 1 _/\_ u0 u1 -> \ (u2 :: u1) -> u2 _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: (u0, u1)) -> case u2 of { _ALG_ _TUP_2 (u3 :: u0) (u4 :: u1) -> u4; _NO_DEFLT_ } _N_ #-}
subtract :: Num a => a -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(AAASAAAAAA)LL" {_A_ 3 _U_ 122 _N_ _N_ _F_ _IF_ARGS_ 1 3 XXX 3 _/\_ u0 -> \ (u1 :: u0 -> u0 -> u0) (u2 :: u0) (u3 :: u0) -> _APP_  u1 [ u3, u2 ] _N_} _F_ _IF_ARGS_ 1 3 CXX 4 _/\_ u0 -> \ (u1 :: {{Num u0}}) (u2 :: u0) (u3 :: u0) -> case u1 of { _ALG_ _TUP_10 (u4 :: {{Eq u0}}) (u5 :: {{Text u0}}) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0) (ua :: u0 -> u0) (ub :: u0 -> u0) (uc :: Integer -> u0) (ud :: Int -> u0) -> _APP_  u7 [ u3, u2 ]; _NO_DEFLT_ } _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Double#) (u1 :: Double#) -> case _#_ minusDouble# [] [u1, u0] of { _PRIM_ (u2 :: Double#) -> _!_ D# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Double) (u1 :: Double) -> case u1 of { _ALG_ D# (u2 :: Double#) -> case u0 of { _ALG_ D# (u3 :: Double#) -> case _#_ minusDouble# [] [u2, u3] of { _PRIM_ (u4 :: Double#) -> _!_ D# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ Int ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Int#) (u1 :: Int#) -> case _#_ minusInt# [] [u1, u0] of { _PRIM_ (u2 :: Int#) -> _!_ I# [] [u2] } _N_} _F_ _IF_ARGS_ 0 2 CC 5 \ (u0 :: Int) (u1 :: Int) -> case u1 of { _ALG_ I# (u2 :: Int#) -> case u0 of { _ALG_ I# (u3 :: Int#) -> case _#_ minusInt# [] [u2, u3] of { _PRIM_ (u4 :: Int#) -> _!_ I# [] [u4] }; _NO_DEFLT_ }; _NO_DEFLT_ } _N_ }, [ (Complex Double) ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(LL)U(LL)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
toLower :: Char -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
toUpper :: Char -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
until :: (a -> Bool) -> (a -> a) -> a -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 222 _N_ _S_ "SLL" _N_ _N_ #-}
(||) :: Bool -> Bool -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "EL" _F_ _ALWAYS_ \ (u0 :: Bool) (u1 :: Bool) -> case u0 of { _ALG_ True  -> _!_ True [] []; False  -> u1; _NO_DEFLT_ } _N_ #-}
(!) :: Ix a => Array a b -> a -> b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(AASA)U(LP)L" {_A_ 4 _U_ 1222 _N_ _N_ _F_ _IF_ARGS_ 2 4 XXXX 7 _/\_ u0 u1 -> \ (u2 :: (u0, u0) -> u0 -> Int) (u3 :: (u0, u0)) (u4 :: Array# u1) (u5 :: u0) -> case _APP_  u2 [ u3, u5 ] of { _ALG_ I# (u6 :: Int#) -> case _#_ indexArray# [u1] [u4, u6] of { _ALG_ _Lift (u7 :: u1) -> u7; _NO_DEFLT_ }; _NO_DEFLT_ } _N_} _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: {{Ix u0}}) (u3 :: Array u0 u1) (u4 :: u0) -> case u2 of { _ALG_ _TUP_4 (u5 :: {{Ord u0}}) (u6 :: (u0, u0) -> [u0]) (u7 :: (u0, u0) -> u0 -> Int) (u8 :: (u0, u0) -> u0 -> Bool) -> case u3 of { _ALG_ _Array (u9 :: (u0, u0)) (ua :: Array# u1) -> case _APP_  u7 [ u9, u4 ] of { _ALG_ I# (ub :: Int#) -> case _#_ indexArray# [u1] [ua, ub] of { _ALG_ _Lift (uc :: u1) -> uc; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ } _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(U(P)U(P))P)U(P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(SS)P)U(U(P)U(P))" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(//) :: Ix a => Array a b -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASLA)" {_A_ 2 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(U(U(P)U(P))P)S" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(U(SS)P)S" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
accum :: Ix b => (c -> a -> c) -> Array b c -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 1222 _N_ _S_ "U(ASLA)" {_A_ 2 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 3 _U_ 222 _N_ _N_ _N_ _N_ } #-}
accumArray :: Ix b => (c -> a -> c) -> c -> (b, b) -> [Assoc b a] -> Array b c
	{-# GHC_PRAGMA _A_ 5 _U_ 22222 _N_ _S_ "U(ASLA)LLLL" _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 4 _U_ 2222 _N_ _N_ _N_ _N_ } #-}
amap :: Ix b => (a -> c) -> Array b a -> Array b c
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASLA)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ _N_, Int, _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(U(P)U(P))P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int), _N_ ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LU(U(SS)P)" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
array :: Ix a => (a, a) -> [Assoc a b] -> Array a b
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(ASLA)U(LL)S" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(U(P)U(P))S" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(SS)S" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
assocs :: Ix a => Array a b -> [Assoc a b]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ASLA)" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(U(P)U(P))P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(SS)P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
bounds :: Array b a -> (b, b)
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(LL)P)" {_A_ 3 _U_ 220 _N_ _N_ _F_ _IF_ARGS_ 2 3 XXX 3 _/\_ u0 u1 -> \ (u2 :: u1) (u3 :: u1) (u4 :: Array# u0) -> _!_ _TUP_2 [u1, u1] [u2, u3] _N_} _F_ _IF_ARGS_ 2 1 C 2 _/\_ u0 u1 -> \ (u2 :: Array u1 u0) -> case u2 of { _ALG_ _Array (u3 :: (u1, u1)) (u4 :: Array# u0) -> u3; _NO_DEFLT_ } _N_ #-}
elems :: Ix a => Array a b -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ASLA)" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(U(P)U(P))P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(SS)P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
indices :: Ix b => Array b a -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(ASAA)L" {_A_ 2 _U_ 11 _N_ _N_ _F_ _IF_ARGS_ 2 2 XC 5 _/\_ u0 u1 -> \ (u2 :: (u1, u1) -> [u1]) (u3 :: Array u1 u0) -> let {(u6 :: (u1, u1)) = case u3 of { _ALG_ _Array (u4 :: (u1, u1)) (u5 :: Array# u0) -> u4; _NO_DEFLT_ }} in _APP_  u2 [ u6 ] _N_} _F_ _IF_ARGS_ 2 2 CC 6 _/\_ u0 u1 -> \ (u2 :: {{Ix u1}}) (u3 :: Array u1 u0) -> let {(u6 :: (u1, u1)) = case u3 of { _ALG_ _Array (u4 :: (u1, u1)) (u5 :: Array# u0) -> u4; _NO_DEFLT_ }} in case u2 of { _ALG_ _TUP_4 (u7 :: {{Ord u1}}) (u8 :: (u1, u1) -> [u1]) (u9 :: (u1, u1) -> u1 -> Int) (ua :: (u1, u1) -> u1 -> Bool) -> _APP_  u8 [ u6 ]; _NO_DEFLT_ } _SPECIALISE_ [ _N_, Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(U(P)U(P))P)" {_A_ 3 _U_ 220 _N_ _N_ _N_ _N_} _N_ _N_ }, [ _N_, (Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(SS)P)" {_A_ 3 _U_ 220 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
ixmap :: (Ix b, Ix a) => (b, b) -> (b -> a) -> Array a c -> Array b c
	{-# GHC_PRAGMA _A_ 2 _U_ 12222 _N_ _S_ "U(ASLA)L" {_A_ 6 _U_ 222222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
listArray :: Ix a => (a, a) -> [b] -> Array a b
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASLA)" {_A_ 4 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(U(P)U(P))L" {_A_ 3 _U_ 221 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int), _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(SS)L" {_A_ 3 _U_ 221 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
cis :: RealFloat a => a -> Complex a
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
conjugate :: RealFloat a => Complex a -> Complex a
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LU(LL)" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
imagPart :: Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Complex u0) -> case u1 of { _ALG_ (:+) (u2 :: u0) (u3 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
magnitude :: RealFloat a => Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ALAAAAALAS)" {_A_ 3 _U_ 2221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(P)U(P))" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
mkPolar :: RealFloat a => a -> a -> Complex a
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ } #-}
phase :: RealFloat a => Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(U(U(AU(U(ALAASAAA)AAAA)A)AAAAAA)U(U(SLAA)LAAAAAAAAAALAAAAAA)AAAAAAAA)" {_A_ 5 _U_ 222221 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(U(P)U(P))" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
polar :: RealFloat a => Complex a -> (a, a)
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
realPart :: Complex a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Complex u0) -> case u1 of { _ALG_ (:+) (u2 :: u0) (u3 :: u0) -> u2; _NO_DEFLT_ } _N_ #-}
_readList :: ([Char] -> [(a, [Char])]) -> [Char] -> [([a], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ #-}
_showList :: (a -> [Char] -> [Char]) -> [a] -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 212 _N_ _S_ "LS" _N_ _N_ #-}
_showRational :: Int -> Ratio Integer -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LU(U(PPP)L)" {_A_ 5 _U_ 22222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
abort :: IOError -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 2 _U_ 00 _N_ _S_ "A" {_A_ 1 _U_ 0 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: [Response]) -> _!_ _NIL_ [Request] [] _N_} _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: IOError) -> _ORIG_ PreludeIO done _N_ #-}
appendBinChan :: [Char] -> Bin -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
appendBinFile :: [Char] -> Bin -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
appendChan :: [Char] -> [Char] -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
appendFile :: [Char] -> [Char] -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
binDispatch :: (IOError -> [Response] -> a) -> (Bin -> [Response] -> a) -> [Response] -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLS" _N_ _N_ #-}
deleteFile :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
done :: [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 1 _U_ 0 _N_ _S_ "A" {_A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _!_ _NIL_ [Request] [] _N_} _F_ _IF_ARGS_ 0 1 X 1 \ (u0 :: [Response]) -> _!_ _NIL_ [Request] [] _N_ #-}
echo :: Bool -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
exit :: IOError -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ #-}
getArgs :: (IOError -> [Response] -> [Request]) -> ([[Char]] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _N_ _N_ _N_ #-}
getEnv :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
getProgName :: (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _N_ _N_ _N_ #-}
interact :: ([Char] -> [Char]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ #-}
print :: Text a => a -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 1 _U_ 121 _N_ _N_ _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 11 _N_ _N_ _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 1 _U_ 21 _N_ _N_ _N_ _N_ } #-}
prints :: Text a => a -> [Char] -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 1 _U_ 1221 _N_ _N_ _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 2 _U_ 221 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 221 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 2 _U_ 221 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ [[Int]] ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 2 _U_ 221 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 2 _U_ 121 _N_ _N_ _N_ _N_ } #-}
readBinChan :: [Char] -> (IOError -> [Response] -> [Request]) -> (Bin -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
readBinFile :: [Char] -> (IOError -> [Response] -> [Request]) -> (Bin -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
readChan :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
readFile :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
setEnv :: [Char] -> [Char] -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
sigAction :: Int -> SigAct -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
statusChan :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
statusFile :: [Char] -> (IOError -> [Response] -> [Request]) -> ([Char] -> [Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _N_ _N_ _N_ #-}
stdecho :: [Char]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
stderr :: [Char]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
stdin :: [Char]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
stdout :: [Char]
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _N_ _N_ #-}
strDispatch :: (IOError -> [Response] -> a) -> ([Char] -> [Response] -> a) -> [Response] -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLS" _N_ _N_ #-}
strListDispatch :: (IOError -> [Response] -> a) -> ([[Char]] -> [Response] -> a) -> [Response] -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLS" _N_ _N_ #-}
succDispatch :: (IOError -> [Response] -> a) -> ([Response] -> a) -> [Response] -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LLS" _N_ _N_ #-}
writeBinFile :: [Char] -> Bin -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
writeFile :: [Char] -> [Char] -> (IOError -> [Response] -> [Request]) -> ([Response] -> [Request]) -> [Response] -> [Request]
	{-# GHC_PRAGMA _A_ 5 _U_ 22111 _N_ _N_ _N_ _N_ #-}
(!!) :: Integral a => [b] -> a -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LU(U(ASAAAAAA)AAA)AAAAAAAAAS)" {_A_ 3 _U_ 11112 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "SU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
(++) :: [a] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "SL" _N_ _N_ #-}
(\\) :: Eq a => [a] -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "LLS" _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ } #-}
all :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u3 :: Bool) = _!_ True [] []} in let {(u6 :: u0 -> Bool -> Bool) = \ (u4 :: u0) (u5 :: Bool) -> case _APP_  u1 [ u4 ] of { _ALG_ True  -> u5; False  -> _!_ False [] []; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u6, u3, u2 ] _N_ #-}
and :: [Bool] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Bool]) -> let {(u1 :: Bool) = _!_ True [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { Bool } { Bool } [ _ORIG_ Prelude (&&), u1, u0 ] _N_ #-}
any :: (a -> Bool) -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u3 :: Bool) = _!_ False [] []} in let {(u6 :: u0 -> Bool -> Bool) = \ (u4 :: u0) (u5 :: Bool) -> case _APP_  u1 [ u4 ] of { _ALG_ True  -> _!_ True [] []; False  -> u5; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u6, u3, u2 ] _N_ #-}
break :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
concat :: [[a]] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [[u0]]) -> let {(u8 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u7 :: [u0] -> u2 -> u2) = \ (u5 :: [u0]) (u6 :: u2) -> _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u2 } [ u3, u6, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { [u0] } { u2 } [ u7, u4, u1 ]} in _APP_  _TYAPP_  _build { u0 } [ u8 ] _N_ #-}
cycle :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u6 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> _LETREC_ {(u5 :: u2) = _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u2 } [ u3, u5, u1 ]} in u5} in _APP_  _TYAPP_  _build { u0 } [ u6 ] _N_ #-}
drop :: Integral a => a -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "U(AAAAAAAAAAAS)LS" {_A_ 3 _U_ 121 _N_ _N_ _N_ _N_} _F_ _IF_ARGS_ 2 3 CXX 7 _/\_ u0 u1 -> \ (u2 :: {{Integral u0}}) (u3 :: u0) (u4 :: [u1]) -> let {(uh :: Int) = case u2 of { _ALG_ _TUP_12 (u5 :: {{Real u0}}) (u6 :: {{Ix u0}}) (u7 :: u0 -> u0 -> u0) (u8 :: u0 -> u0 -> u0) (u9 :: u0 -> u0 -> u0) (ua :: u0 -> u0 -> u0) (ub :: u0 -> u0 -> (u0, u0)) (uc :: u0 -> u0 -> (u0, u0)) (ud :: u0 -> Bool) (ue :: u0 -> Bool) (uf :: u0 -> Integer) (ug :: u0 -> Int) -> _APP_  ug [ u3 ]; _NO_DEFLT_ }} in _APP_  _TYAPP_  _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u1 } [ uh, u4 ] _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)S" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(PPP)S" {_A_ 4 _U_ 2221 _N_ _N_ _F_ _IF_ARGS_ 1 4 XXXX 4 _/\_ u0 -> \ (u1 :: Int#) (u2 :: Int#) (u3 :: ByteArray#) (u4 :: [u0]) -> case _#_ integer2Int# [] [u1, u2, u3] of { _PRIM_ (u5 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u0 } [ u5, u4 ] } _N_} _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: Integer) (u2 :: [u0]) -> case u1 of { _ALG_ J# (u3 :: Int#) (u4 :: Int#) (u5 :: ByteArray#) -> case _#_ integer2Int# [] [u3, u4, u5] of { _PRIM_ (u6 :: Int#) -> _APP_  _TYAPP_  _WRKR_ _SPEC_ _ORIG_ PreludeList drop [ (Int), _N_ ] { u0 } [ u6, u2 ] }; _NO_DEFLT_ } _N_ } #-}
dropWhile :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
elem :: Eq a => a -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "LLS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Eq u0}}) (u2 :: u0) (u3 :: [u0]) -> let {(u6 :: u0 -> u0 -> Bool) = case u1 of { _ALG_ _TUP_2 (u4 :: u0 -> u0 -> Bool) (u5 :: u0 -> u0 -> Bool) -> u4; _NO_DEFLT_ }} in let {(u8 :: u0 -> Bool) = \ (u7 :: u0) -> _APP_  u6 [ u2, u7 ]} in _APP_  _TYAPP_  _ORIG_ PreludeList any { u0 } [ u8, u3 ] _SPECIALISE_ [ Char ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Char) (u1 :: [Char]) -> let {(u5 :: Char -> Bool) = \ (u2 :: Char) -> case u0 of { _ALG_ C# (u3 :: Char#) -> case u2 of { _ALG_ C# (u4 :: Char#) -> _#_ eqChar# [] [u3, u4]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList any { Char } [ u5, u1 ] _N_ }, [ Int ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Int) (u1 :: [Int]) -> let {(u5 :: Int -> Bool) = \ (u2 :: Int) -> case u0 of { _ALG_ I# (u3 :: Int#) -> case u2 of { _ALG_ I# (u4 :: Int#) -> _#_ eqInt# [] [u3, u4]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList any { Int } [ u5, u1 ] _N_ }, [ Integer ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Integer) (u1 :: [Integer]) -> let {(ua :: Integer -> Bool) = \ (u2 :: Integer) -> case u0 of { _ALG_ J# (u3 :: Int#) (u4 :: Int#) (u5 :: ByteArray#) -> case u2 of { _ALG_ J# (u6 :: Int#) (u7 :: Int#) (u8 :: ByteArray#) -> case _#_ cmpInteger# [] [u3, u4, u5, u6, u7, u8] of { _PRIM_ 0# -> _!_ True [] []; (u9 :: Int#) -> _!_ False [] [] }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList any { Integer } [ ua, u1 ] _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: [Char]) (u1 :: [[Char]]) -> let {(u3 :: [Char] -> Bool) = \ (u2 :: [Char]) -> _APP_  _CONSTM_ Eq (==) ([Char]) [ u0, u2 ]} in _APP_  _TYAPP_  _ORIG_ PreludeList any { [Char] } [ u3, u1 ] _N_ }, [ [Int] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: [Int]) (u1 :: [[Int]]) -> let {(u3 :: [Int] -> Bool) = \ (u2 :: [Int]) -> _APP_  _CONSTM_ Eq (==) ([Int]) [ u0, u2 ]} in _APP_  _TYAPP_  _ORIG_ PreludeList any { [Int] } [ u3, u1 ] _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: (Int, Int)) (u1 :: [(Int, Int)]) -> let {(ub :: (Int, Int) -> Bool) = \ (u2 :: (Int, Int)) -> case u0 of { _ALG_ _TUP_2 (u3 :: Int) (u4 :: Int) -> case u3 of { _ALG_ I# (u5 :: Int#) -> case u2 of { _ALG_ _TUP_2 (u6 :: Int) (u7 :: Int) -> case u6 of { _ALG_ I# (u8 :: Int#) -> case _#_ eqInt# [] [u5, u8] of { _ALG_ True  -> case u4 of { _ALG_ I# (u9 :: Int#) -> case u7 of { _ALG_ I# (ua :: Int#) -> _#_ eqInt# [] [u9, ua]; _NO_DEFLT_ }; _NO_DEFLT_ }; False  -> _!_ False [] []; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList any { (Int, Int) } [ ub, u1 ] _N_ } #-}
filter :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> let {(u8 :: u0 -> u3 -> u3) = \ (u6 :: u0) (u7 :: u3) -> case _APP_  u1 [ u6 ] of { _ALG_ True  -> _APP_  u4 [ u6, u7 ]; False  -> u7; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u3 } [ u8, u5, u2 ]} in _APP_  _TYAPP_  _build { u0 } [ u9 ] _N_ #-}
foldl1 :: (a -> a -> a) -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
foldr1 :: (a -> a -> a) -> [a] -> a
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
genericLength :: Num b => [a] -> b
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ _N_, Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ _N_, Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
head :: [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u2 :: u0) = _APP_  _TYAPP_  error { u0 } [ _NOREP_S_ "head{PreludeList}: head []\n" ]} in let {(u5 :: u0 -> u0 -> u0) = \ (u3 :: u0) (u4 :: u0) -> u3} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u0 } [ u5, u2, u1 ] _N_ #-}
init :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
iterate :: (a -> a) -> a -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> u0) (u2 :: u0) -> let {(ub :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> _LETREC_ {(u6 :: (u0 -> u0) -> u0 -> u3) = \ (u7 :: u0 -> u0) (u8 :: u0) -> let {(ua :: u3) = let {(u9 :: u0) = _APP_  u7 [ u8 ]} in _APP_  u6 [ u7, u9 ]} in _APP_  u4 [ u8, ua ]} in _APP_  u6 [ u1, u2 ]} in _APP_  _TYAPP_  _build { u0 } [ ub ] _N_ #-}
last :: [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
length :: [a] -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
lines :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
map :: (a -> b) -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: u0 -> u1) (u3 :: [u0]) -> let {(ua :: _forall_ a$z1 =>(u1 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u4 -> \ (u5 :: u1 -> u4 -> u4) (u6 :: u4) -> let {(u9 :: u0 -> u4 -> u4) = \ (u7 :: u0) -> let {(u8 :: u1) = _APP_  u2 [ u7 ]} in _APP_  u5 [ u8 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u4 } [ u9, u6, u3 ]} in _APP_  _TYAPP_  _build { u1 } [ ua ] _N_ #-}
maximum :: Ord a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
minimum :: Ord a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 11 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
notElem :: Eq a => a -> [a] -> Bool
	{-# GHC_PRAGMA _A_ 3 _U_ 121 _N_ _S_ "LLS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Eq u0}}) (u2 :: u0) (u3 :: [u0]) -> let {(u6 :: u0 -> u0 -> Bool) = case u1 of { _ALG_ _TUP_2 (u4 :: u0 -> u0 -> Bool) (u5 :: u0 -> u0 -> Bool) -> u5; _NO_DEFLT_ }} in let {(u8 :: u0 -> Bool) = \ (u7 :: u0) -> _APP_  u6 [ u2, u7 ]} in _APP_  _TYAPP_  _ORIG_ PreludeList all { u0 } [ u8, u3 ] _SPECIALISE_ [ Char ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Char) (u1 :: [Char]) -> let {(u5 :: Char -> Bool) = \ (u2 :: Char) -> case u0 of { _ALG_ C# (u3 :: Char#) -> case u2 of { _ALG_ C# (u4 :: Char#) -> _#_ neChar# [] [u3, u4]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList all { Char } [ u5, u1 ] _N_ }, [ Int ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Int) (u1 :: [Int]) -> let {(u5 :: Int -> Bool) = \ (u2 :: Int) -> case u0 of { _ALG_ I# (u3 :: Int#) -> case u2 of { _ALG_ I# (u4 :: Int#) -> _#_ neInt# [] [u3, u4]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList all { Int } [ u5, u1 ] _N_ }, [ Integer ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: Integer) (u1 :: [Integer]) -> let {(ua :: Integer -> Bool) = \ (u2 :: Integer) -> case u0 of { _ALG_ J# (u3 :: Int#) (u4 :: Int#) (u5 :: ByteArray#) -> case u2 of { _ALG_ J# (u6 :: Int#) (u7 :: Int#) (u8 :: ByteArray#) -> case _#_ cmpInteger# [] [u3, u4, u5, u6, u7, u8] of { _PRIM_ 0# -> _!_ False [] []; (u9 :: Int#) -> _!_ True [] [] }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList all { Integer } [ ua, u1 ] _N_ }, [ [Char] ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: [Char]) (u1 :: [[Char]]) -> let {(u3 :: [Char] -> Bool) = \ (u2 :: [Char]) -> _APP_  _CONSTM_ Eq (/=) ([Char]) [ u0, u2 ]} in _APP_  _TYAPP_  _ORIG_ PreludeList all { [Char] } [ u3, u1 ] _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ \ (u0 :: (Int, Int)) (u1 :: [(Int, Int)]) -> let {(ub :: (Int, Int) -> Bool) = \ (u2 :: (Int, Int)) -> case u0 of { _ALG_ _TUP_2 (u3 :: Int) (u4 :: Int) -> case u3 of { _ALG_ I# (u5 :: Int#) -> case u2 of { _ALG_ _TUP_2 (u6 :: Int) (u7 :: Int) -> case u6 of { _ALG_ I# (u8 :: Int#) -> case _#_ neInt# [] [u5, u8] of { _ALG_ True  -> _!_ True [] []; False  -> case u4 of { _ALG_ I# (u9 :: Int#) -> case u7 of { _ALG_ I# (ua :: Int#) -> _#_ neInt# [] [u9, ua]; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  _TYAPP_  _ORIG_ PreludeList all { (Int, Int) } [ ub, u1 ] _N_ } #-}
nub :: Eq a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "LS" _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ } #-}
null :: [a] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u2 :: Bool) = _!_ True [] []} in let {(u5 :: u0 -> Bool -> Bool) = \ (u3 :: u0) (u4 :: Bool) -> _!_ False [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { Bool } [ u5, u2, u1 ] _N_ #-}
or :: [Bool] -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Bool]) -> let {(u1 :: Bool) = _!_ False [] []} in _APP_  _TYAPP_  _TYAPP_  foldr { Bool } { Bool } [ _ORIG_ Prelude (||), u1, u0 ] _N_ #-}
partition :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: u0 -> ([u0], [u0]) -> ([u0], [u0])) = \ (u3 :: u0) (u4 :: ([u0], [u0])) -> case u4 of { _ALG_ _TUP_2 (u5 :: [u0]) (u6 :: [u0]) -> case _APP_  u1 [ u3 ] of { _ALG_ True  -> let {(u7 :: [u0]) = _!_ (:) [u0] [u3, u5]} in _!_ _TUP_2 [[u0], [u0]] [u7, u6]; False  -> let {(u8 :: [u0]) = _!_ (:) [u0] [u3, u6]} in _!_ _TUP_2 [[u0], [u0]] [u5, u8]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(ua :: [u0]) = _!_ _NIL_ [u0] []} in let {(ub :: ([u0], [u0])) = _!_ _TUP_2 [[u0], [u0]] [ua, ua]} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { ([u0], [u0]) } [ u9, ub, u2 ] _N_ #-}
product :: Num a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Num u0}}) -> let {(uc :: u0 -> u0 -> u0) = case u1 of { _ALG_ _TUP_10 (u2 :: {{Eq u0}}) (u3 :: {{Text u0}}) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0 -> u0) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0) (u8 :: u0 -> u0) (u9 :: u0 -> u0) (ua :: Integer -> u0) (ub :: Int -> u0) -> u6; _NO_DEFLT_ }} in let {(uo :: u0) = let {(ud :: Int) = _!_ I# [] [1#]} in case u1 of { _ALG_ _TUP_10 (ue :: {{Eq u0}}) (uf :: {{Text u0}}) (ug :: u0 -> u0 -> u0) (uh :: u0 -> u0 -> u0) (ui :: u0 -> u0 -> u0) (uj :: u0 -> u0) (uk :: u0 -> u0) (ul :: u0 -> u0) (um :: Integer -> u0) (un :: Int -> u0) -> _APP_  un [ ud ]; _NO_DEFLT_ }} in \ (up :: [u0]) -> _APP_  _TYAPP_  _TYAPP_  foldl { u0 } { u0 } [ uc, uo, up ] _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Double]) -> let {(u1 :: Double) = _!_ D# [] [1.0000000000000000##]} in _APP_  _TYAPP_  _TYAPP_  foldl { Double } { Double } [ _CONSTM_ Num (*) (Double), u1, u0 ] _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Int]) -> let {(u1 :: Int) = _!_ I# [] [1#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Int } { Int } [ _CONSTM_ Num (*) (Int), u1, u0 ] _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Integer]) -> let {(u1 :: Integer) = _#_ int2Integer# [] [1#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Integer } { Integer } [ _CONSTM_ Num (*) (Integer), u1, u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ let {(u6 :: Complex Double -> Complex Double -> Complex Double) = \ (u0 :: Complex Double) (u1 :: Complex Double) -> case u0 of { _ALG_ (:+) (u2 :: Double) (u3 :: Double) -> case u1 of { _ALG_ (:+) (u4 :: Double) (u5 :: Double) -> _APP_  _WRKR_ _CONSTM_ Num (*) (Complex Double) [ u2, u3, u4, u5 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(u8 :: Complex Double) = let {(u7 :: Int) = _!_ I# [] [1#]} in _APP_  _CONSTM_ Num fromInt (Complex Double) [ u7 ]} in \ (u9 :: [Complex Double]) -> _APP_  _TYAPP_  _TYAPP_  foldl { (Complex Double) } { (Complex Double) } [ u6, u8, u9 ] _N_ } #-}
products :: Num a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: [Integer]) -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList scanl { Integer } { Integer } [ _CONSTM_ Num (*) (Integer), _SPEC_ _ORIG_ PreludeCore __i1 [ (Integer) ], u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ } #-}
repeat :: a -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0) -> let {(u6 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> _LETREC_ {(u5 :: u2) = _APP_  u3 [ u1, u5 ]} in u5} in _APP_  _TYAPP_  _build { u0 } [ u6 ] _N_ #-}
reverse :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: [u0]) -> let {(u8 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u2 -> \ (u3 :: u0 -> u2 -> u2) (u4 :: u2) -> let {(u7 :: u2 -> u0 -> u2) = \ (u5 :: u2) (u6 :: u0) -> _APP_  u3 [ u6, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldl { u2 } { u0 } [ u7, u4, u1 ]} in _APP_  _TYAPP_  _build { u0 } [ u8 ] _N_ #-}
scanl :: (b -> a -> b) -> b -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _N_ _N_ _N_ #-}
scanl1 :: (a -> a -> a) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
scanr :: (a -> b -> b) -> b -> [a] -> [b]
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
scanr1 :: (a -> a -> a) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
span :: (a -> Bool) -> [a] -> ([a], [a])
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
splitAt :: Integral a => a -> [b] -> ([b], [b])
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LU(U(AAASAAAA)AAA)AAAAAAAAAS)" {_A_ 3 _U_ 11122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
sum :: Num a => [a] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: {{Num u0}}) -> let {(uc :: u0 -> u0 -> u0) = case u1 of { _ALG_ _TUP_10 (u2 :: {{Eq u0}}) (u3 :: {{Text u0}}) (u4 :: u0 -> u0 -> u0) (u5 :: u0 -> u0 -> u0) (u6 :: u0 -> u0 -> u0) (u7 :: u0 -> u0) (u8 :: u0 -> u0) (u9 :: u0 -> u0) (ua :: Integer -> u0) (ub :: Int -> u0) -> u4; _NO_DEFLT_ }} in let {(uo :: u0) = let {(ud :: Int) = _!_ I# [] [0#]} in case u1 of { _ALG_ _TUP_10 (ue :: {{Eq u0}}) (uf :: {{Text u0}}) (ug :: u0 -> u0 -> u0) (uh :: u0 -> u0 -> u0) (ui :: u0 -> u0 -> u0) (uj :: u0 -> u0) (uk :: u0 -> u0) (ul :: u0 -> u0) (um :: Integer -> u0) (un :: Int -> u0) -> _APP_  un [ ud ]; _NO_DEFLT_ }} in \ (up :: [u0]) -> _APP_  _TYAPP_  _TYAPP_  foldl { u0 } { u0 } [ uc, uo, up ] _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Double]) -> let {(u1 :: Double) = _!_ D# [] [0.0000000000000000##]} in _APP_  _TYAPP_  _TYAPP_  foldl { Double } { Double } [ _CONSTM_ Num (+) (Double), u1, u0 ] _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Int]) -> let {(u1 :: Int) = _!_ I# [] [0#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Int } { Int } [ _CONSTM_ Num (+) (Int), u1, u0 ] _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [Integer]) -> let {(u1 :: Integer) = _#_ int2Integer# [] [0#]} in _APP_  _TYAPP_  _TYAPP_  foldl { Integer } { Integer } [ _CONSTM_ Num (+) (Integer), u1, u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ let {(u6 :: Complex Double -> Complex Double -> Complex Double) = \ (u0 :: Complex Double) (u1 :: Complex Double) -> case u0 of { _ALG_ (:+) (u2 :: Double) (u3 :: Double) -> case u1 of { _ALG_ (:+) (u4 :: Double) (u5 :: Double) -> _APP_  _WRKR_ _CONSTM_ Num (+) (Complex Double) [ u2, u3, u4, u5 ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in let {(u8 :: Complex Double) = let {(u7 :: Int) = _!_ I# [] [0#]} in _APP_  _CONSTM_ Num fromInt (Complex Double) [ u7 ]} in \ (u9 :: [Complex Double]) -> _APP_  _TYAPP_  _TYAPP_  foldl { (Complex Double) } { (Complex Double) } [ u6, u8, u9 ] _N_ } #-}
sums :: Num a => [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 21 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 0 1 X 4 \ (u0 :: [Integer]) -> _APP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList scanl { Integer } { Integer } [ _CONSTM_ Num (+) (Integer), _SPEC_ _ORIG_ PreludeCore __i0 [ (Integer) ], u0 ] _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ } #-}
tail :: [a] -> [a]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 1 1 C 5 _/\_ u0 -> \ (u1 :: [u0]) -> case u1 of { _ALG_ (:) (u2 :: u0) (u3 :: [u0]) -> u3; _NIL_  -> _APP_  _TYAPP_  error { [u0] } [ _NOREP_S_ "tail{PreludeList}: tail []\n" ]; _NO_DEFLT_ } _N_ #-}
take :: Integral a => a -> [b] -> [b]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(LU(U(ASSAAAAA)AAA)AAAALAAAAL)" {_A_ 5 _U_ 2121222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Int, _N_ ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)L" {_A_ 2 _U_ 21 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer, _N_ ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
takeWhile :: (a -> Bool) -> [a] -> [a]
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _F_ _ALWAYS_ _/\_ u0 -> \ (u1 :: u0 -> Bool) (u2 :: [u0]) -> let {(u9 :: _forall_ a$z1 =>(u0 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u3 -> \ (u4 :: u0 -> u3 -> u3) (u5 :: u3) -> let {(u8 :: u0 -> u3 -> u3) = \ (u6 :: u0) (u7 :: u3) -> case _APP_  u1 [ u6 ] of { _ALG_ True  -> _APP_  u4 [ u6, u7 ]; False  -> u5; _NO_DEFLT_ }} in _APP_  _TYAPP_  _TYAPP_  foldr { u0 } { u3 } [ u8, u5, u2 ]} in _APP_  _TYAPP_  _build { u0 } [ u9 ] _N_ #-}
transpose :: [[a]] -> [[a]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unlines :: [[Char]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _ALWAYS_ \ (u0 :: [[Char]]) -> let {(u1 :: [Char]) = _!_ _NIL_ [Char] []} in let {(u6 :: [Char] -> [Char] -> [Char]) = \ (u2 :: [Char]) (u3 :: [Char]) -> let {(u4 :: Char) = _!_ C# [] ['\o12'#]} in let {(u5 :: [Char]) = _!_ (:) [Char] [u4, u3]} in _APP_  _TYAPP_  _ORIG_ PreludeList (++) { Char } [ u2, u5 ]} in _APP_  _TYAPP_  _TYAPP_  foldr { [Char] } { [Char] } [ u6, u1, u0 ] _N_ #-}
unwords :: [[Char]] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip :: [(a, b)] -> ([a], [b])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip3 :: [(a, b, c)] -> ([a], [b], [c])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
words :: [Char] -> [[Char]]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
zip :: [a] -> [b] -> [(a, b)]
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SL" _F_ _ALWAYS_ _/\_ u0 u1 -> \ (u2 :: [u0]) (u3 :: [u1]) -> let {(u6 :: u0 -> u1 -> (u0, u1)) = \ (u4 :: u0) (u5 :: u1) -> _!_ _TUP_2 [u0, u1] [u4, u5]} in _APP_  _TYAPP_  _TYAPP_  _TYAPP_  _ORIG_ PreludeList zipWith { u0 } { u1 } { (u0, u1) } [ u6, u2, u3 ] _N_ #-}
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "SLL" _N_ _N_ #-}
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
	{-# GHC_PRAGMA _A_ 4 _U_ 1111 _N_ _S_ "SLLL" _N_ _N_ #-}
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
	{-# GHC_PRAGMA _A_ 5 _U_ 11111 _N_ _S_ "SLLLL" _N_ _N_ #-}
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
	{-# GHC_PRAGMA _A_ 6 _U_ 111111 _N_ _S_ "SLLLLL" _N_ _N_ #-}
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
	{-# GHC_PRAGMA _A_ 7 _U_ 1111111 _N_ _S_ "SLLLLLL" _N_ _N_ #-}
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "LSL" _F_ _ALWAYS_ _/\_ u0 u1 u2 -> \ (u3 :: u0 -> u1 -> u2) (u4 :: [u0]) (u5 :: [u1]) -> let {(ui :: _forall_ a$z1 =>(u2 -> a$z1 -> a$z1) -> a$z1 -> a$z1) = _/\_ u6 -> \ (u7 :: u2 -> u6 -> u6) (u8 :: u6) -> _LETREC_ {(u9 :: [u0] -> [u1] -> u6) = \ (ua :: [u0]) (ub :: [u1]) -> case ua of { _ALG_ _NIL_  -> u8; (:) (uc :: u0) (ud :: [u0]) -> case ub of { _ALG_ _NIL_  -> u8; (:) (ue :: u1) (uf :: [u1]) -> let {(ug :: u6) = _APP_  u9 [ ud, uf ]} in let {(uh :: u2) = _APP_  u3 [ uc, ue ]} in _APP_  u7 [ uh, ug ]; _NO_DEFLT_ }; _NO_DEFLT_ }} in _APP_  u9 [ u4, u5 ]} in _APP_  _TYAPP_  _build { u2 } [ ui ] _N_ #-}
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
	{-# GHC_PRAGMA _A_ 4 _U_ 2111 _N_ _S_ "LSLL" _N_ _N_ #-}
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
	{-# GHC_PRAGMA _A_ 5 _U_ 21111 _N_ _S_ "LSLLL" _N_ _N_ #-}
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
	{-# GHC_PRAGMA _A_ 6 _U_ 211111 _N_ _S_ "LSLLLL" _N_ _N_ #-}
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
	{-# GHC_PRAGMA _A_ 7 _U_ 2111111 _N_ _S_ "LSLLLLL" _N_ _N_ #-}
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
	{-# GHC_PRAGMA _A_ 8 _U_ 21111111 _N_ _S_ "LSLLLLLL" _N_ _N_ #-}
_appendPS :: _PackedString -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "SS" _N_ _N_ #-}
_breakPS :: (Char -> Bool) -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_byteArrayToPS :: _ByteArray Int -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(U(U(P)U(P))P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_concatPS :: [_PackedString] -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_consPS :: Char -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _N_ _N_ _N_ #-}
_dropPS :: Int -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_dropWhilePS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
_filterPS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
_foldlPS :: (a -> Char -> a) -> a -> _PackedString -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
_foldrPS :: (Char -> a -> a) -> a -> _PackedString -> a
	{-# GHC_PRAGMA _A_ 3 _U_ 221 _N_ _S_ "LLS" _N_ _N_ #-}
_headPS :: _PackedString -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_indexPS :: _PackedString -> Int -> Char
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "SU(P)" {_A_ 2 _U_ 12 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_lengthPS :: _PackedString -> Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 C 6 \ (u0 :: _PackedString) -> case u0 of { _ALG_ _PS (u1 :: ByteArray#) (u2 :: Int#) (u3 :: Bool) -> _!_ I# [] [u2]; _CPS (u4 :: Addr#) (u5 :: Int#) -> _!_ I# [] [u5]; _NO_DEFLT_ } _N_ #-}
_linesPS :: _PackedString -> [_PackedString]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_mapPS :: (Char -> Char) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 21 _N_ _S_ "LS" _N_ _N_ #-}
_nilPS :: _PackedString
	{-# GHC_PRAGMA _A_ 0 _N_ _N_ _N_ _F_ _IF_ARGS_ 0 0 X 3 _!_ _CPS [] [""#, 0#] _N_ #-}
_nullPS :: _PackedString -> Bool
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 C 6 \ (u0 :: _PackedString) -> case u0 of { _ALG_ _PS (u1 :: ByteArray#) (u2 :: Int#) (u3 :: Bool) -> case u2 of { _PRIM_ 0# -> _!_ True [] []; (u4 :: Int#) -> _!_ False [] [] }; _CPS (u5 :: Addr#) (u6 :: Int#) -> case u6 of { _PRIM_ 0# -> _!_ True [] []; (u7 :: Int#) -> _!_ False [] [] }; _NO_DEFLT_ } _N_ #-}
_packCBytes :: Int -> _Addr -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_packCString :: _Addr -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_packString :: [Char] -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_psToByteArray :: _PackedString -> _ByteArray Int
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_putPS :: _FILE -> _PackedString -> _State _RealWorld -> ((), _State _RealWorld)
	{-# GHC_PRAGMA _A_ 3 _U_ 111 _N_ _S_ "LSU(P)" {_A_ 3 _U_ 112 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_reversePS :: _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_spanPS :: (Char -> Bool) -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_splitAtPS :: Int -> _PackedString -> (_PackedString, _PackedString)
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ #-}
_substrPS :: _PackedString -> Int -> Int -> _PackedString
	{-# GHC_PRAGMA _A_ 3 _U_ 211 _N_ _S_ "SU(P)U(P)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_tailPS :: _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_takePS :: Int -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "U(P)S" {_A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 5 \ (u0 :: Int#) (u1 :: _PackedString) -> case _#_ minusInt# [] [u0, 1#] of { _PRIM_ (u2 :: Int#) -> _APP_  _WRKR_ _ORIG_ PreludePS _substrPS [ u1, 0#, u2 ] } _N_} _F_ _ALWAYS_ \ (u0 :: Int) (u1 :: _PackedString) -> case u0 of { _ALG_ I# (u2 :: Int#) -> case _#_ minusInt# [] [u2, 1#] of { _PRIM_ (u3 :: Int#) -> _APP_  _WRKR_ _ORIG_ PreludePS _substrPS [ u1, 0#, u3 ] }; _NO_DEFLT_ } _N_ #-}
_takeWhilePS :: (Char -> Bool) -> _PackedString -> _PackedString
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _S_ "LS" _N_ _N_ #-}
_unpackPS :: _PackedString -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
_wordsPS :: _PackedString -> [_PackedString]
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ #-}
(%) :: Integral a => a -> a -> Ratio a
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SA)AAALALLAL)AA)ALLAAAAAAAA)" {_A_ 3 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Integer ] 1 { _A_ 2 _U_ 11 _N_ _S_ "LU(PPP)" {_A_ 4 _U_ 1222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
approxRational :: RealFrac a => a -> a -> Ratio Integer
	{-# GHC_PRAGMA _A_ 3 _U_ 122 _N_ _S_ "U(U(LU(U(ASAALAAA)AAAA)L)AAAAAA)LL" {_A_ 5 _U_ 21222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 2 _U_ 11 _N_ _S_ "U(P)U(P)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
denominator :: Ratio a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(AS)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Ratio u0) -> case u1 of { _ALG_ (:%) (u2 :: u0) (u3 :: u0) -> u3; _NO_DEFLT_ } _N_ #-}
numerator :: Ratio a -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(SA)" {_A_ 1 _U_ 1 _N_ _N_ _F_ _IF_ARGS_ 1 1 X 1 _/\_ u0 -> \ (u1 :: u0) -> u1 _N_} _F_ _IF_ARGS_ 1 1 C 2 _/\_ u0 -> \ (u1 :: Ratio u0) -> case u1 of { _ALG_ (:%) (u2 :: u0) (u3 :: u0) -> u2; _NO_DEFLT_ } _N_ #-}
_readRational :: [Char] -> Ratio Integer
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
_showDigit :: Int -> Char
	{-# GHC_PRAGMA _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ #-}
_showHex :: Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ #-}
_showRadix :: Int -> Int -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 3 _U_ 112 _N_ _S_ "U(P)U(P)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ #-}
lex :: [Char] -> [([Char], [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ #-}
read :: Text a => [Char] -> a
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(SAAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Float] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
readDec :: Integral a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 22 _N_ _N_ _N_ _SPECIALISE_ [ Int ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ } #-}
readFloat :: RealFloat a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _S_ "LS" _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 2 _N_ _S_ "S" _N_ _N_ } #-}
readLitChar :: [Char] -> [(Char, [Char])]
	{-# GHC_PRAGMA _A_ 0 _U_ 1 _N_ _N_ _N_ _N_ #-}
readParen :: Bool -> ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _S_ "EL" _N_ _N_ #-}
readSigned :: Real a => ([Char] -> [(a, [Char])]) -> [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 2 _U_ 122 _N_ _N_ _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ } #-}
reads :: Text a => [Char] -> [(a, [Char])]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(SAAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Bool] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Bool) _N_ }, [ [Char] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Char) _N_ }, [ [Double] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Double) _N_ }, [ [Float] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Int) _N_ }, [ [Integer] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Integer) _N_ }, [ [[Char]] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList ([Char]) _N_ }, [ [[Int]] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList ([Int]) _N_ }, [ [Complex Double] ] 1 { _A_ 0 _U_ 2 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text readList (Complex Double) _N_ }, [ (Ratio Integer) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 2 _N_ _S_ _!_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ () ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 0 _U_ 2 _N_ _N_ _N_ _N_ } #-}
show :: Text a => a -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 12 _N_ _S_ "U(ASAA)" {_A_ 1 _U_ 12 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 1 _U_ 2 _N_ _S_ "E" _N_ _N_ }, [ Char ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(P)" {_A_ 1 _U_ 2 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(PPP)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 1 _N_ _S_ "S" _N_ _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 1 _U_ 1 _N_ _N_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ () ] 1 { _A_ 1 _U_ 1 _N_ _S_ "E" _N_ _N_ }, [ (Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LL)" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 1 _U_ 1 _N_ _S_ "U(LLL)" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showChar :: Char -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 2 XX 3 \ (u0 :: Char) (u1 :: [Char]) -> _!_ (:) [Char] [u0, u1] _N_ #-}
showFloat :: RealFloat a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(AU(SAAA)AAAAL)LLLALAAAA)" {_A_ 5 _U_ 1122222 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showInt :: Integral a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(U(U(U(SL)LLLLLLLLL)LL)LLLLLSLLLLL)" _N_ _SPECIALISE_ [ Int ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showLitChar :: Char -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 22 _N_ _N_ _N_ _N_ #-}
showParen :: Bool -> ([Char] -> [Char]) -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 0 _U_ 122 _N_ _N_ _N_ _N_ #-}
showSigned :: Real a => (a -> [Char] -> [Char]) -> Int -> a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 12222 _N_ _S_ "U(LU(U(ASAAAAAA)AAAA)A)" {_A_ 2 _U_ 212122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Double ] 1 { _A_ 3 _U_ 2112 _N_ _S_ "LLU(P)" {_A_ 3 _U_ 2122 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 4 _U_ 0112 _N_ _S_ "ALU(P)L" {_A_ 3 _U_ 122 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 4 _U_ 0112 _N_ _S_ "ALU(PPP)L" {_A_ 5 _U_ 12222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}
showSpace__ :: [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 2 _N_ _N_ _N_ _N_ #-}
showString :: [Char] -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 2 _U_ 12 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _TYAPP_  _ORIG_ PreludeList (++) { Char } _N_ #-}
shows :: Text a => a -> [Char] -> [Char]
	{-# GHC_PRAGMA _A_ 1 _U_ 122 _N_ _S_ "U(ASAA)" {_A_ 1 _U_ 122 _N_ _N_ _N_ _N_} _N_ _SPECIALISE_ [ Bool ] 1 { _A_ 2 _U_ 22 _N_ _N_ _N_ _N_ }, [ Char ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Double ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(P)" {_A_ 1 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Int ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(P)L" {_A_ 2 _U_ 22 _N_ _N_ _N_ _N_} _N_ _N_ }, [ Integer ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(PPP)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ [Bool] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [Bool]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { Bool } [ _WRKR_ _CONSTM_ Text showsPrec (Bool), u0 ] _N_ }, [ [Char] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Char) _N_ }, [ [Double] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Double) _N_ }, [ [Int] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Int) _N_ }, [ [Integer] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Integer) _N_ }, [ [[Char]] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [[Char]]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { [Char] } [ _CONSTM_ Text showList (Char), u0 ] _N_ }, [ [[Int]] ] 1 { _A_ 1 _U_ 12 _N_ _S_ "S" _F_ _IF_ARGS_ 0 1 X 3 \ (u0 :: [[Int]]) -> _APP_  _TYAPP_  _ORIG_ PreludeCore _showList { [Int] } [ _CONSTM_ Text showList (Int), u0 ] _N_ }, [ [Complex Double] ] 1 { _A_ 1 _U_ 22 _N_ _N_ _F_ _IF_ARGS_ 0 0 X 1 _CONSTM_ Text showList (Complex Double) _N_ }, [ (Ratio Integer) ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(LL)" {_A_ 2 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Array Int Double) ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ (Array (Int, Int) Double) ] 1 { _A_ 1 _U_ 22 _N_ _N_ _N_ _N_ }, [ _PackedString ] 1 { _A_ 2 _U_ 12 _N_ _N_ _N_ _N_ }, [ (Complex Double) ] 1 { _A_ 1 _U_ 12 _N_ _S_ "U(LL)" {_A_ 2 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ () ] 1 { _A_ 2 _U_ 12 _N_ _S_ "EL" _F_ _IF_ARGS_ 0 2 CX 4 \ (u0 :: ()) (u1 :: [Char]) -> case u0 of { _ALG_ _TUP_0  -> _APP_  _TYAPP_  _ORIG_ PreludeList (++) { Char } [ _NOREP_S_ "()", u1 ]; _NO_DEFLT_ } _N_ }, [ (Int, Int) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Integer, Integer) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LL)L" {_A_ 3 _U_ 222 _N_ _N_ _N_ _N_} _N_ _N_ }, [ (Int, Int, Int) ] 1 { _A_ 2 _U_ 12 _N_ _S_ "U(LLL)L" {_A_ 4 _U_ 2222 _N_ _N_ _N_ _N_} _N_ _N_ } #-}

