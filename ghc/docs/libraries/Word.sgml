<sect> <idx/Word/
<label id="sec:Word">
<p>

This library provides unsigned integers of various sizes.
The types supported are as follows:

<tabular ca="ll">
<!-- ToDo: figure out why the ldoc DTD doesn't allow hline's - it looks as if -->
<!-- it should. -->
<!-- <hline> -->
type     | number of bits @
Word8    | 8  @
Word16   | 16 @
Word32   | 32 @
Word64   | 64 @
<!-- <hline> -->
</tabular>


For each type <it/W/ above, we provide the following functions and
instances.  The type <it/I/ refers to the signed integer type of the
same size.

<tscreen><verb>
data W            -- Unsigned Ints
instance Eq       W
instance Ord      W
instance Show     W
instance Read     W
instance Bounded  W
instance Num      W
instance Real     W
instance Integral W
instance Enum     W
instance Ix       W
instance Bits     W
</verb></tscreen>
Plus
<tscreen><verb>
word8ToWord16  :: Word8   -> Word16
word8ToWord32  :: Word8   -> Word32
word8ToWord64  :: Word8   -> Word64

word16ToWord8   :: Word16  -> Word8
word16ToWord32  :: Word16  -> Word32
word16ToWord64  :: Word16  -> Word64

word32ToWord8  :: Word32 -> Word8
word32ToWord16 :: Word32 -> Word16
word32ToWord64 :: Word32 -> Word64

word64ToWord8  :: Word64 -> Word8
word64ToWord16 :: Word64 -> Word16
word64ToWord32 :: Word64 -> Word32

word8ToInt     :: Word8  -> Int
word16ToInt    :: Word16 -> Int
word32ToInt    :: Word32 -> Int
word64ToInt    :: Word64 -> Int

intToWord8     :: Int    -> Word8
intToWord16    :: Int    -> Word16
intToWord32    :: Int    -> Word32
intToWord64    :: Int    -> Word64

word64ToInteger :: Word64  -> Integer
integerToWord64 :: Integer -> Word64

</verb></tscreen>

Notes: 
<itemize>
<item>
  All arithmetic is performed modulo 2^n

  One non-obvious consequence of this is that <tt/negate/
  should <em/not/ raise an error on negative arguments.

<item>
The coercion <tt/wToI/ converts an unsigned n-bit value to the
signed n-bit value with the same representation.  For example,
<tt/word8ToInt8 0xff = -1/. 
Likewise, <tt/iToW/ converts signed n-bit values to the
corresponding unsigned n-bit value.

<item>
Use <tt/Prelude.fromIntegral :: (Integral a, Num b) => a -> b/ to
coerce between different sizes or to preserve sign when converting
between values of the same size.

<item>
It would be very natural to add a type a type <tt/Natural/ providing
an unbounded size unsigned integer --- just as <tt/Integer/ provides
unbounded size signed integers.  We do not do that yet since there is
no demand for it.  Doing so would require <tt/Bits.bitSize/ to return
<tt/Maybe Int/.

<item>
The rules that hold for <tt/Enum/ instances over a bounded type
such as <tt/Int/ (see the section of the Haskell report dealing
with arithmetic sequences) also hold for the <tt/Enum/ instances
over the various <tt/Word/ types defined here.

</itemize>

<bf/Implementation notes:/

<itemize>
<item> Hugs only provides <tt/Eq/, <tt/Ord/, <tt/Read/ and <tt/Show/
instances for <tt/Word64/ at the moment.
</itemize>
