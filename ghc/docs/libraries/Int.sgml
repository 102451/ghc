<sect> <idx/Int/
<label id="sec:Int">
<p>

This interface provides a collection of sized, signed integers. The
types supported are as follows:

<tabular ca="ll">
type    | number of bits @ 
<!-- <hline>  -->
Int8    | 8  @
Int16   | 16 @
Int32   | 32 @
Int64   | 64 @
<!-- <hline>  -->
</tabular>

For each type <it/I/ above, we provide the following instances.

<tscreen><verb>
data I            -- Signed Ints
iToInt            :: I -> Int  -- not provided for Int64
intToI            :: Int -> I  -- not provided for Int64
instance Eq       I
instance Ord      I
instance Show     I
instance Read     I
instance Bounded  I
instance Num      I
instance Real     I
instance Integral I
instance Enum     I
instance Ix       I
instance Bits     I
</verb></tscreen>

Plus the coercion functions

<tscreen><verb>
int8ToInt16 :: Int8   -> Int16
int8ToInt32 :: Int8   -> Int32
int8ToInt64 :: Int8   -> Int64

int16ToInt8  :: Int16 -> Int8
int16ToInt32 :: Int16 -> Int32
int16ToInt64 :: Int16 -> Int64

int32ToInt8  :: Int32 -> Int8
int32ToInt16 :: Int32 -> Int16
int32ToInt64 :: Int32 -> Int64

int64ToInt8  :: Int64 -> Int8
int64ToInt16 :: Int64 -> Int16
int64ToInt32 :: Int64 -> Int32

int8ToInt  :: Int8  -> Int
int16ToInt :: Int16 -> Int
int32ToInt :: Int32 -> Int
int64ToInt :: Int64 -> Int

intToInt8  :: Int   -> Int8
intToInt16 :: Int   -> Int16
intToInt32 :: Int   -> Int32
intToInt64 :: Int   -> Int64

integerToInt8  :: Integer -> Int8
integerToInt16 :: Integer -> Int16
integerToInt32 :: Integer -> Int32
integerToInt64 :: Integer -> Int64

int64ToInteger :: Int64 -> Integer
int32ToInteger :: Int32 -> Integer
int16ToInteger :: Int16 -> Integer
int8ToInteger  :: Int8  -> Integer

</verb></tscreen>

<itemize>
<item>
The rules that hold for <tt/Enum/ instances over a bounded type
such as <tt/Int/ (see the section of the Haskell report dealing
with arithmetic sequences) also hold for the <tt/Enum/ instances
over the various <tt/Int/ types defined here.

<item>
Right and left shifts by amounts greater than or equal to the width of
the type result in either zero or -1, depending on the sign of the
value being shifted.  This is contrary to the behaviour in C, which is
undefined; a common interpretation is to truncate the shift count to
the width of the type, for example <tt>1 &lt;&lt; 32 == 1</tt> in some
C implementations.

<item>
Hugs does not provide <tt/Int64/ at the moment.

</itemize>

The <tt/Int/ module also exports the overloaded operations for
converting to and from Haskell <tt/Int/s:

<tscreen><verb>
toInt   :: (Integral a) => a -> Int
fromInt :: (Num a) => Int -> a
</verb></tscreen>

Portability note: both Hugs98 and all releases of GHC prior to
ghc-4.05 also exports these two via the Prelude. So, to have code
that uses <tt>toInt</tt> and <tt>fromInt</tt> be maximally portable,
make sure you add an import on <tt>Int</tt> (even if the version
of Hugs or GHC you're currently using may not export these two
from there.)

