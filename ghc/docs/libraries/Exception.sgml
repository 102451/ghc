<sect> <idx/Exception/ 
<label id="sec:Exception">
<p>

The Exception library provides an interface for raising and catching
both built-in and user defined exceptions.

Exceptions are defined by the following (non-abstract) datatype:

<tscreen><verb>
data Exception
  = IOException 	IOError	   -- IO exceptions (from 'fail')
  | ArithException  	ArithError -- Arithmetic exceptions
  | ErrorCall		String	   -- Calls to 'error'
  | NoMethodError       String	   -- A non-existent method was invoked
  | PatternMatchFail	String	   -- A pattern match failed
  | NonExhaustiveGuards String	   -- A guard match failed
  | RecSelError		String	   -- Selecting a non-existent field
  | RecConError		String	   -- Field missing in record construction
  | RecUpdError		String	   -- Record doesn't contain updated field
  | AssertionFailed	String	   -- Assertions
  | DynException	Dynamic	   -- Dynamic exceptions
  | ExternalException   ExtError   -- External exceptions

instance Eq   Exception
instance Ord  Exception
instance Show Exception

data ArithError
  = Overflow
  | Underflow
  | LossOfPrecision
  | DivideByZero
  | Denormal

instance Eq   ArithError
instance Ord  ArithError
instance Show ArithError

data ExtError
  = StackOverflow
  | HeapOverflow
  | ThreadKilled

instance Eq   ExtError
instance Ord  ExtError
instance Show ExtError
</verb></tscreen>

An implementation should raise the appropriate exception when one of
the above conditions arises.  <em>Note: GHC currently doesn't generate
the arithmetic or the external exceptions.</em>

Exceptions may be thrown explicitly from anywhere:

<tscreen><verb>
throw :: Exception -> a
</verb></tscreen>

Exceptions may be caught and examined in the <tt/IO/ monad:

<tscreen><verb>
catch       :: IO a -> (Exception  -> IO a) -> IO a
catchIO     :: IO a -> (IOError    -> IO a) -> IO a
catchArith  :: IO a -> (ArithError -> IO a) -> IO a
catchError  :: IO a -> (String     -> IO a) -> IO a

getException   :: a -> IO (Maybe Exception)
getExceptionIO :: IO a -> IO (Either Exception a)
</verb></tscreen>

Each of the functions <tt/catchIO/, <tt/catchArith/, and
<tt/catchError/ only catch a specific type of exception.  All other
exceptions are effectively re-thrown.  An uncaught exception will
normally cause the program to terminate, with the offending exception
displayed.

Note that <tt/catchIO/ is identical to <tt/IO.catch/.  The
implementation of <tt/IO/ errors in GHC and Hugs uses exceptions for
speed.

Also, don't forget to <tt/import Prelude hidiing (catch)/ when using
this library, to avoid the name clash between <tt/Exception.catch/ and
<tt/IO.catch/.

The <tt/getException/ function is useful for evaluating a non-IO typed
value and testing for exceptions.  <tt/getException/ evaluates its
first argument (as if you'd applied <tt/seq/ to it), returning
<tt/Just &lt;exception&gt;/ if an exception was raised, or
<tt/Nothing/ otherwise.  Note that due to Haskell's unspecified
evaluation order, an expression may return one of several possible
exceptions: consider the expression <tt/error "urk" + 1 `div` 0/.  Does
<tt/getException/ return <tt/Just (ErrorCall "urk")/ or <tt/Just
(ArithError DivideByZero)/?  The answer is "either": getException
makes a non-deterministic choice about which exception to return.  If
you call it again, you might get a different exception back.  This is
ok, because <tt/getException/ is an IO computation.

<tt/getExceptionIO/ is the equivalent function for <tt/IO/ computations
--- it runs its first argument, and returns either the return value or
the exception if one was raised.  Passing a value of type <tt/IO a/ to
<tt/getException/ won't work, because the <tt/IO/ type is represented
by a function, and <tt/getException/ will only evaluate its argument
to head normal form, hence the <tt/IO/ computation won't be
performed.  Use <tt/getExceptionIO/ instead.

<sect1> <idx/Dynamic Exceptions/ 
<label id="sec:Dynamic-Exceptions">
<p>

Because the <tt/Exception/ datatype isn't extendible, we added an
interface for throwing and catching exceptions of type <tt/Dynamic/
(see Section <ref name="Dynamic" id="sec:Dynamic">), which allows
exception values of any type in the <tt/Typeable/ class to be thrown
and caught.

<tscreen><verb>
throwDyn :: Typeable exception => exception -> b
catchDyn :: Typeable exception => IO a -> (exception -> IO a) -> IO a
</verb></tscreen>

The <tt/catchDyn/ function only catches exceptions of the required
type; all other exceptions are re-thrown as with <tt/catchIO/ and
friends above.

