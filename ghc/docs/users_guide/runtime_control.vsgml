%************************************************************************
%*                                                                      *
<sect1>Running a compiled program
<label id="runtime-control">
<p>
<nidx>runtime control of Haskell programs</nidx>
<nidx>running, compiled program</nidx>
<nidx>RTS options</nidx>
%*                                                                      *
%************************************************************************

To make an executable program, the GHC system compiles your code and
then links it with a non-trivial runtime system (RTS), which handles
storage management, profiling, etc.

You have some control over the behaviour of the RTS, by giving special
command-line arguments to your program.

When your Haskell program starts up, its RTS extracts command-line
arguments bracketed between @+RTS@<nidx>+RTS option</nidx> and
@-RTS@<nidx>-RTS option</nidx> as its own.  For example:

<tscreen><verb>
% ./a.out -f +RTS -p -S -RTS -h foo bar
</verb></tscreen>

The RTS will snaffle @-p -S@ for itself, and the remaining arguments
@-f -h foo bar@ will be handed to your program if/when it calls
@System.getArgs@.

No @-RTS@ option is required if the runtime-system options extend to
the end of the command line, as in this example:

<tscreen><verb>
% hls -ltr /usr/etc +RTS -A5m
</verb></tscreen>

If you absolutely positively want all the rest of the options in a
command line to go to the program (and not the RTS), use a
@--RTS@<nidx>--RTS option</nidx>.

As always, for RTS options that take @<size>@s: If the last
character of @size@ is a K or k, multiply by 1000; if an M or m, by
1,000,000; if a G or G, by 1,000,000,000.  (And any wraparound in the
counters is <em>your</em> fault!)

Giving a @+RTS -f@<nidx>-f RTS option</nidx> option will print out the
RTS options actually available in your program (which vary, depending
on how you compiled).

%************************************************************************
%*                                                                      *
<sect2>RTS options to control the garbage-collector
<label id="rts-options-gc">
<p>
<nidx>RTS options, garbage-collection</nidx>
%*                                                                      *
%************************************************************************

There are several options to give you precise control over garbage
collection.  Hopefully, you won't need any of these in normal
operation, but there are several things that can be tweaked for
maximum performance.

<descrip>
<tag>@-A<size>@:</tag>
<nidx>-A&lt;size&gt; RTS option</nidx>
<nidx>allocation area, size</nidx>

[Default: 256k] Set the allocation area size used by the garbage
collector.  The allocation area (actually generation 0 step 0) is
fixed and is never resized (unless you use <tt/-H/, below).

Increasing the allocation area size may or may not give better
performance (a bigger allocation area means worse cache behaviour but
fewer garbage collections and less promotion).

With only 1 generation (<tt/-G1/) the <tt/-A/ option specifies the
minimum allocation area, since the actual size of the allocation area
will be resized according to the amount of data in the heap (see
<tt/-F/, below).

<tag>@-F<factor>@:</tag>
<nidx>-F&lt;factor&gt; RTS option</nidx>
<nidx>heap size, factor</nidx>

[Default: 2] This option controls the amount of memory reserved for
the older generations (and in the case of a two space collector the
size of the allocation area) as a factor of the amount of live data.
For example, if there was 2M of live data in the oldest generation
when we last collected it, then by default we'll wait until it grows
to 4M before collecting it again.

The default seems to work well here.  If you have plenty of memory, it
is usually better to use <tt/-H&lt;size&gt;/ than to increase
<tt/-F&lt;factor&gt;/.

The <tt/-F/ setting will be automatically reduced by the garbage
collector when the maximum heap size (the <tt/-M&lt;size&gt;/ setting)
is approaching.

<tag>@-G<generations>@:</tag>
<nidx>-G&lt;generations&gt; RTS option</nidx>
<nidx>generations, number of</nidx>

[Default: 2] Set the number of generations used by the garbage
collector.  The default of 2 seems to be good, but the garbage
collector can support any number of generations.  Anything larger than
about 4 is probably not a good idea unless your program runs for a
<em/long/ time, because the oldest generation will never get
collected.

Specifying 1 generation with @+RTS -G1@ gives you a simple 2-space
collector, as you would expect.  In a 2-space collector, the @-A@
option (see above) specifies the <em/minimum/ allocation area size,
since the allocation area will grow with the amount of live data in
the heap.  In a multi-generational collector the allocation area is a
fixed size (unless you use the <tt/-H/ option, see below).

<tag>@-H<size>@:</tag>
<nidx>-H&lt;size&gt; RTS option</nidx>
<nidx>heap size, suggested</nidx>

[Default: 0] This option provides a "suggested heap size" for the
garbage collector.  The garbage collector will use about this much
memory until the program residency grows and the heap size needs to be
expanded to retain reasonable performance.

By default, the heap will start small, and grow and shrink as
necessary.  This can be bad for performance, so if you have plenty of
memory it's worthwhile supplying a big <tt/-H&lt;size&gt/.  For
improving GC performance, using <tt/-H&lt;size&gt/ is usually a better
bet than <tt/-A&lt;size&gt/.

<tag>@-k<size>@:</tag>
<nidx>-k&lt;size&gt; RTS option</nidx>
<nidx>stack, minimum size</nidx>

[Default: 1k] Set the initial stack size for new threads.  Thread
stacks (including the main thread's stack) live on the heap, and grow
as required.  The default value is good for concurrent applications
with lots of small threads; if your program doesn't fit this model
then increasing this option may help performance.

The main thread is normally started with a slightly larger heap to cut
down on unnecessary stack growth while the program is starting up.

<tag>@-K<size>@:</tag>
<nidx>-K&lt;size&gt; RTS option</nidx>
<nidx>stack, maximum size</nidx>

[Default: 1M] Set the maximum stack size for an individual thread to
@<size>@ bytes.  This option is there purely to stop the program
eating up all the available memory in the machine if it gets into an
infinite loop.

<tag>@-m<n>@:</tag>
<nidx>-m&lt;n&gt; RTS option</nidx>
Minimum \% @<n>@ of heap which must be available for allocation.
The default is 3\%.
<nidx>heap, minimum free</nidx>

<tag>@-M<size>@:</tag>
<nidx>-M&lt;size&gt; RTS option</nidx>
<nidx>heap size, maximum</nidx>

[Default: 64M] Set the maximum heap size to @<size>@ bytes.  The heap
normally grows and shrinks according to the memory requirements of the
program.  The only reason for having this option is to stop the heap
growing without bound and filling up all the available swap space,
which at the least will result in the program being summarily killed
by the operating system.

<tag>@-s<file>@ or @-S<file>@:</tag>
<nidx>-S&lt;file&gt; RTS option</nidx>
<nidx>-s&lt;file&gt; RTS option</nidx>
Write modest (@-s@) or verbose (@-S@) garbage-collector
statistics into file @<file>@. The default @<file>@ is
@<program>@@.stat@. The @<file>@ @stderr@ is treated
specially, with the output really being sent to @stderr@.

This option is useful for watching how the storage manager adjusts the
heap size based on the current amount of live data.

% ToDo: --SDM
%For some garbage collectors (not including the default one, sadly),
%you can convert the @-S@ output into a residency graph (in
%PostScript), using the @stat2resid@<nidx>stat2resid</nidx> utility in
%the GHC distribution (@ghc/utils/stat2resid@).

% <tag>@-j<size>@:</tag>
% <nidx>-j&lt;size&gt; RTS option</nidx>
% Force a major garbage collection every @<size>@ bytes.  (Normally
% used because you're keen on getting major-GC stats, notably heap residency
% info.)

</descrip>

%************************************************************************
%*                                                                      *
<sect2>RTS options for profiling and Concurrent/Parallel Haskell
<p>
%*                                                                      *
%************************************************************************

The RTS options related to profiling are described in Section <ref
name="How to control your profiled program at runtime"
id="prof-rts-options">; and those for concurrent/parallel stuff, in
Section <ref name="RTS options for Concurrent/Parallel Haskell"
id="parallel-rts-opts">.

%************************************************************************
%*                                                                      *
<sect2>RTS options for hackers, debuggers, and over-interested souls
<p>
<nidx>RTS options, hacking/debugging</nidx>
%*                                                                      *
%************************************************************************

These RTS options might be used (a)~to avoid a GHC bug, (b)~to see
``what's really happening'', or (c)~because you feel like it.  Not
recommended for everyday use!

<descrip>
<tag>@-B@:</tag>
<nidx>-B RTS option</nidx>
Sound the bell at the start of each (major) garbage collection.

Oddly enough, people really do use this option!  Our pal in Durham
(England), Paul Callaghan, writes: ``Some people here use it for a
variety of purposes---honestly!---e.g., confirmation that the
code/machine is doing something, infinite loop detection, gauging cost
of recently added code. Certain people can even tell what stage [the
program] is in by the beep pattern. But the major use is for annoying
others in the same office...''

<tag>@-r<file>@:</tag>
<nidx>-r &lt;file&gt; RTS option</nidx>
<nidx>ticky ticky profiling</nidx>
Produce ``ticky-ticky'' statistics at the end of the program run.
The @<file>@ business works just like on the @-S@ RTS option (above).

``Ticky-ticky'' statistics are counts of various program actions
(updates, enters, etc.)  The program must have been compiled using
@-ticky@<nidx>-ticky option</nidx> (a.k.a. ``ticky-ticky profiling''),
and, for it to be really useful, linked with suitable system
libraries.  Not a trivial undertaking: consult the installation guide
on how to set things up for easy ``ticky-ticky'' profiling.

<tag>@-D<num>@:</tag>
<nidx>-D RTS option</nidx>
An RTS debugging flag; varying quantities of output depending on which
bits are set in @<num>@.  Only works if the RTS was compiled with the
@DEBUG@ option.

% Blackholing can't be turned off in new RTS --SDM
%
% <tag>@-N@:</tag>
% <nidx>-N RTS option</nidx>
% 
% Normally, the garbage collector black-holes closures which are being
% evaluated, as a space-saving measure.  This option turns off
% blackholing.  You shouldn't ever need to use it.
% 
% Historical note: this option used to be used to work around a problem
% with signal handling, where a signal handler might need to evaluate
% blackholed closures.  Signal handlers are now run in a separate
% thread, and don't suffer from this problem.

<tag>@-Z@:</tag>
<nidx>-Z RTS option</nidx>
Turn <em>off</em> ``update-frame squeezing'' at garbage-collection time.
(There's no particularly good reason to turn it off.)
</descrip>

%************************************************************************
%*                                                                      *
<sect2>``Hooks'' to change RTS behaviour
<label id="rts-hooks">
<p>
<nidx>hooks, RTS</nidx>
<nidx>RTS hooks</nidx>
<nidx>RTS behaviour, changing</nidx>
%*                                                                      *
%************************************************************************

GHC lets you exercise rudimentary control over the RTS settings for
any given program, by compiling in a ``hook'' that is called by the
run-time system.  The RTS contains stub definitions for all these
hooks, but by writing your own version and linking it on the GHC
command line, you can override the defaults.

The function @defaultsHook@<nidx>defaultHook</nidx> lets you change various
RTS options.  The commonest use for this is to give your program a
default heap and/or stack size that is greater than the default.  For
example, to set @-H8m -K1m@:

<tscreen><verb>
#include "Rts.h"
#include "RtsFlags.h"
void defaultsHook (void) {
   RTSflags.GcFlags.stksSize =  1000002 / sizeof(W_);
   RTSflags.GcFlags.heapSize =  8000002 / sizeof(W_);
}
</verb></tscreen>

Don't use powers of two for heap/stack sizes: these are more likely to
interact badly with direct-mapped caches.  The full set of flags is
defined in @ghc/rts/RtsFlags.h@ the the GHC source tree.

You can also change the messages printed when the runtime system
``blows up,'' e.g., on stack overflow.  The hooks for these are as
follows:

<descrip>
<tag>@void ErrorHdrHook (FILE *)@:</tag>
<nidx>ErrorHdrHook</nidx>
What's printed out before the message from @error@.

<tag>@void OutOfHeapHook (unsigned long, unsigned long)@:</tag>
<nidx>OutOfHeapHook</nidx>
The heap-overflow message.

<tag>@void StackOverflowHook (long int)@:</tag>
<nidx>StackOverflowHook</nidx>
The stack-overflow message.

<tag>@void MallocFailHook (long int)@:</tag>
<nidx>MallocFailHook</nidx>
The message printed if @malloc@ fails.

<tag>@void PatErrorHdrHook (FILE *)@:</tag>
<nidx>PatErrorHdrHook</nidx>
The message printed if a pattern-match fails (the failures
that were not handled by the Haskell programmer).

<tag>@void PreTraceHook (FILE *)@:</tag>
<nidx>PreTraceHook</nidx>
What's printed out before a @trace@ message.

<tag>@void PostTraceHook (FILE *)@:</tag>
<nidx>PostTraceHook</nidx>
What's printed out after a @trace@ message.
</descrip>

For example, here is the ``hooks'' code used by GHC itself:
<tscreen><verb>
#include <stdio.h>
#define W_ unsigned long int
#define I_ long int

void
ErrorHdrHook (FILE *where)
{
    fprintf(where, "\n"); /* no "Fail: " */
}

void
OutOfHeapHook (W_ request_size, W_ heap_size) /* both sizes in bytes */
{
    fprintf(stderr, "GHC's heap exhausted;\nwhile trying to 
	allocate %lu bytes in a %lu-byte heap;\nuse the `-H<size>'
	option to increase the total heap size.\n",
	request_size,
	heap_size);
}

void
StackOverflowHook (I_ stack_size)    /* in bytes */
{
    fprintf(stderr, "GHC stack-space overflow: current size
	%ld bytes.\nUse the `-K<size>' option to increase it.\n",
	stack_size);
}

void
PatErrorHdrHook (FILE *where)
{
    fprintf(where, "\n*** Pattern-matching error within GHC!\n\n
	This is a compiler bug; please report it to
	glasgow-haskell-bugs@dcs.gla.ac.uk.\n\nFail: ");
}

void
PreTraceHook (FILE *where)
{
    fprintf(where, "\n"); /* not "Trace On" */
}

void
PostTraceHook (FILE *where)
{
    fprintf(where, "\n"); /* not "Trace Off" */
}
</verb></tscreen>
