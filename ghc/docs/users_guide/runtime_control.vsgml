%************************************************************************
%*                                                                      *
<sect1>Running a compiled program
<label id="runtime-control">
<p>
<nidx>runtime control of Haskell programs</nidx>
<nidx>running, compiled program</nidx>
<nidx>RTS options</nidx>
%*                                                                      *
%************************************************************************

To make an executable program, the GHC system compiles your code and
then links it with a non-trivial runtime system (RTS), which handles
storage management, profiling, etc.

You have some control over the behaviour of the RTS, by giving special
command-line arguments to your program.

When your Haskell program starts up, its RTS extracts command-line
arguments bracketed between @+RTS@<nidx>+RTS option</nidx> and
@-RTS@<nidx>-RTS option</nidx> as its own.  For example:

<tscreen><verb>
% ./a.out -f +RTS -p -S -RTS -h foo bar
</verb></tscreen>

The RTS will snaffle @-p -S@ for itself, and the remaining arguments
@-f -h foo bar@ will be handed to your program if/when it calls
@System.getArgs@.

No @-RTS@ option is required if the runtime-system options extend to
the end of the command line, as in this example:

<tscreen><verb>
% hls -ltr /usr/etc +RTS -A5m
</verb></tscreen>

If you absolutely positively want all the rest of the options in a
command line to go to the program (and not the RTS), use a
@--RTS@<nidx>--RTS option</nidx>.

As always, for RTS options that take @<size>@s: If the last
character of @size@ is a K or k, multiply by 1000; if an M or m, by
1,000,000; if a G or G, by 1,000,000,000.  (And any wraparound in the
counters is <em>your</em> fault!)

Giving a @+RTS -f@<nidx>-f RTS option</nidx> option will print out the
RTS options actually available in your program (which vary, depending
on how you compiled).

%************************************************************************
%*                                                                      *
<sect2>RTS options to control the garbage-collector
<label id="rts-options-gc">
<p>
<nidx>RTS options, garbage-collection</nidx>
%*                                                                      *
%************************************************************************

There are several options to give you precise control over garbage
collection.  Hopefully, you won't need any of these in normal
operation, but there are several things that can be tweaked for
maximum performance.

<descrip>
<tag>@-A<size>@:</tag>
<nidx>-A&lt;size&gt; RTS option</nidx>
<nidx>allocation area, size</nidx>

[Default: 256k] Set the minimum (and initial) allocation area size
used by the garbage collector.  The allocation area is resized after
each garbage collection to be a multiple of the size of the current
live data (currently a factor of 2).

Increasing the minimum allocation area size will typically give better
performance for programs which quickly generate a large amount of live
data.

<tag>@-k<size>@:</tag>
<nidx>-k&lt;size&gt; RTS option</nidx>
<nidx>stack, minimum size</nidx>

[Default: 1k] Set the initial stack size for new threads.  Thread
stacks (including the main thread's stack) live on the heap, and grow
as required.  The default value is good for concurrent applications
with lots of small threads; if your program doesn't fit this model
then increasing this option may help performance.

The main thread is normally started with a slightly larger heap to cut
down on unnecessary stack growth while the program is starting up.

<tag>@-K<size>@:</tag>
<nidx>-K&lt;size&gt; RTS option</nidx>
<nidx>stack, maximum size</nidx>

[Default: 1M] Set the maximum stack size for an individual thread to
@<size>@ bytes.  This option is there purely to stop the program
eating up all the available memory in the machine if it gets into an
infinite loop.

<tag>@-m<n>@:</tag>
<nidx>-m&lt;n&gt; RTS option</nidx>
Minimum \% @<n>@ of heap which must be available for allocation.
The default is 3\%.
<nidx>heap, minimum free</nidx>

<tag>@-M<size>@:</tag>
<nidx>-M&lt;size&gt; RTS option</nidx>
<nidx>heap size, maximum</nidx>

[Default: 64M] Set the maximum heap size to @<size>@ bytes.  The heap
normally grows and shrinks according to the memory requirements of the
program.  The only reason for having this option is to stop the heap
growing without bound and filling up all the available swap space,
which at the least will result in the program being summarily killed
by the operating system.

<tag>@-s<file>@ or @-S<file>@:</tag>
<nidx>-S&lt;file&gt; RTS option</nidx>
<nidx>-s&lt;file&gt; RTS option</nidx>
Write modest (@-s@) or verbose (@-S@) garbage-collector
statistics into file @<file>@. The default @<file>@ is
@<program>@@.stat@. The @<file>@ @stderr@ is treated
specially, with the output really being sent to @stderr@.

This option is useful for watching how the storage manager adjusts the
heap size based on the current amount of live data.

% ToDo: --SDM
%For some garbage collectors (not including the default one, sadly),
%you can convert the @-S@ output into a residency graph (in
%PostScript), using the @stat2resid@<nidx>stat2resid</nidx> utility in
%the GHC distribution (@ghc/utils/stat2resid@).

<tag>@-F2s@:</tag> 
<nidx>-F2s RTS option</nidx>

Forces a program compiled for generational GC to use two-space copying
collection. The two-space collector may outperform the generational
collector for programs which have a very low heap residency. It can
also be used to generate a statistics file from which a basic heap
residency profile can be produced (see Section <ref name="stat2resid -
residency info from GC stats" id="stat2resid">).

There will still be a small execution overhead imposed by the
generational compilation as the test for old generation updates will
still be executed (of course none will actually happen).  This
overhead is typically less than 1\%.

<tag>@-j<size>@:</tag>
<nidx>-j&lt;size&gt; RTS option</nidx>
Force a major garbage collection every @<size>@ bytes.  (Normally
used because you're keen on getting major-GC stats, notably heap residency
info.)

</descrip>

%************************************************************************
%*                                                                      *
<sect2>RTS options for profiling and Concurrent/Parallel Haskell
<p>
%*                                                                      *
%************************************************************************

The RTS options related to profiling are described in Section <ref
name="How to control your profiled program at runtime"
id="prof-rts-options">; and those for concurrent/parallel stuff, in
Section <ref name="RTS options for Concurrent/Parallel Haskell"
id="parallel-rts-opts">.

%************************************************************************
%*                                                                      *
<sect2>RTS options for hackers, debuggers, and over-interested souls
<p>
<nidx>RTS options, hacking/debugging</nidx>
%*                                                                      *
%************************************************************************

These RTS options might be used (a)~to avoid a GHC bug, (b)~to see
``what's really happening'', or (c)~because you feel like it.  Not
recommended for everyday use!

<descrip>
<tag>@-B@:</tag>
<nidx>-B RTS option</nidx>
Sound the bell at the start of each (major) garbage collection.

Oddly enough, people really do use this option!  Our pal in Durham
(England), Paul Callaghan, writes: ``Some people here use it for a
variety of purposes---honestly!---e.g., confirmation that the
code/machine is doing something, infinite loop detection, gauging cost
of recently added code. Certain people can even tell what stage [the
program] is in by the beep pattern. But the major use is for annoying
others in the same office...''

<tag>@-r<file>@:</tag>
<nidx>-r &lt;file&gt; RTS option</nidx>
<nidx>ticky ticky profiling</nidx>
Produce ``ticky-ticky'' statistics at the end of the program run.
The @<file>@ business works just like on the @-S@ RTS option (above).

``Ticky-ticky'' statistics are counts of various program actions
(updates, enters, etc.)  The program must have been compiled using
@-fstg-reduction-counts@<nidx>-fstg-reduction-counts option</nidx>
(a.k.a. ``ticky-ticky profiling''), and, for it to be really useful,
linked with suitable system libraries.  Not a trivial undertaking:
consult the installation guide on how to set things up for easy
``ticky-ticky'' profiling.

<tag>@-D<num>@:</tag>
<nidx>-D RTS option</nidx>
An RTS debugging flag; varying quantities of output depending on which
bits are set in @<num>@.  Only works if the RTS was compiled with the
@DEBUG@ option.

<tag>@-N@:</tag>
<nidx>-N RTS option</nidx>

Normally, the garbage collector black-holes closures which are being
evaluated, as a space-saving measure.  This option turns off
blackholing.  You shouldn't ever need to use it.

Historical note: this option used to be used to work around a problem
with signal handling, where a signal handler might need to evaluate
blackholed closures.  Signal handlers are now run in a separate
thread, and don't suffer from this problem.

<tag>@-Z@:</tag>
<nidx>-Z RTS option</nidx>
Turn <em>off</em> ``update-frame squeezing'' at garbage-collection time.
(There's no particularly good reason to turn it off.)
</descrip>

%************************************************************************
%*                                                                      *
<sect2>``Hooks'' to change RTS behaviour
<label id="rts-hooks">
<p>
<nidx>hooks, RTS</nidx>
<nidx>RTS hooks</nidx>
<nidx>RTS behaviour, changing</nidx>
%*                                                                      *
%************************************************************************

GHC lets you exercise rudimentary control over the RTS settings for
any given program, by compiling in a ``hook'' that is called by the
run-time system.  The RTS contains stub definitions for all these
hooks, but by writing your own version and linking it on the GHC
command line, you can override the defaults.

The function @defaultsHook@<nidx>defaultHook</nidx> lets you change various
RTS options.  The commonest use for this is to give your program a
default heap and/or stack size that is greater than the default.  For
example, to set @-H8m -K1m@:

<tscreen><verb>
#include "Rts.h"
#include "RtsFlags.h"
void defaultsHook (void) {
   RTSflags.GcFlags.stksSize =  1000002 / sizeof(W_);
   RTSflags.GcFlags.heapSize =  8000002 / sizeof(W_);
}
</verb></tscreen>

Don't use powers of two for heap/stack sizes: these are more likely to
interact badly with direct-mapped caches.  The full set of flags is
defined in @ghc/rts/RtsFlags.h@ the the GHC source tree.

You can also change the messages printed when the runtime system
``blows up,'' e.g., on stack overflow.  The hooks for these are as
follows:

<descrip>
<tag>@void ErrorHdrHook (FILE *)@:</tag>
<nidx>ErrorHdrHook</nidx>
What's printed out before the message from @error@.

<tag>@void OutOfHeapHook (unsigned long, unsigned long)@:</tag>
<nidx>OutOfHeapHook</nidx>
The heap-overflow message.

<tag>@void StackOverflowHook (long int)@:</tag>
<nidx>StackOverflowHook</nidx>
The stack-overflow message.

<tag>@void MallocFailHook (long int)@:</tag>
<nidx>MallocFailHook</nidx>
The message printed if @malloc@ fails.

<tag>@void PatErrorHdrHook (FILE *)@:</tag>
<nidx>PatErrorHdrHook</nidx>
The message printed if a pattern-match fails (the failures
that were not handled by the Haskell programmer).

<tag>@void PreTraceHook (FILE *)@:</tag>
<nidx>PreTraceHook</nidx>
What's printed out before a @trace@ message.

<tag>@void PostTraceHook (FILE *)@:</tag>
<nidx>PostTraceHook</nidx>
What's printed out after a @trace@ message.
</descrip>

For example, here is the ``hooks'' code used by GHC itself:
<tscreen><verb>
#include <stdio.h>
#define W_ unsigned long int
#define I_ long int

void
ErrorHdrHook (FILE *where)
{
    fprintf(where, "\n"); /* no "Fail: " */
}

void
OutOfHeapHook (W_ request_size, W_ heap_size) /* both sizes in bytes */
{
    fprintf(stderr, "GHC's heap exhausted;\nwhile trying to 
	allocate %lu bytes in a %lu-byte heap;\nuse the `-H<size>'
	option to increase the total heap size.\n",
	request_size,
	heap_size);
}

void
StackOverflowHook (I_ stack_size)    /* in bytes */
{
    fprintf(stderr, "GHC stack-space overflow: current size
	%ld bytes.\nUse the `-K<size>' option to increase it.\n",
	stack_size);
}

void
PatErrorHdrHook (FILE *where)
{
    fprintf(where, "\n*** Pattern-matching error within GHC!\n\n
	This is a compiler bug; please report it to
	glasgow-haskell-bugs@dcs.gla.ac.uk.\n\nFail: ");
}

void
PreTraceHook (FILE *where)
{
    fprintf(where, "\n"); /* not "Trace On" */
}

void
PostTraceHook (FILE *where)
{
    fprintf(where, "\n"); /* not "Trace Off" */
}
</verb></tscreen>
