<Chapter id="utils">
<Title>Other Haskell utility programs
</Title>

<IndexTerm><Primary>utilities, Haskell</Primary></IndexTerm>

<Para>
This section describes other program(s) which we distribute, that help
with the Great Haskell Programming Task.
</Para>

<Sect1 id="mkdependHS">
<Title>Makefile dependencies in Haskell: using <Command>mkdependHS</Command>
</Title>

<Para>
<IndexTerm><Primary>mkdependHS</Primary></IndexTerm>
<IndexTerm><Primary>Makefile dependencies</Primary></IndexTerm>
<IndexTerm><Primary>dependencies in Makefiles</Primary></IndexTerm>
</Para>

<Para>
You run <Command>mkdependHS</Command> like this:

<Screen>
mkdependHS [mkdependHS options] [-- GHC options --] srcfile1 [srcfile2 ...]
</Screen>

or

<Screen>
ghc -M [mkdependHS options(prefix with -optdep)] [ GHC options ] srcfile1 [srcfile2 ...]
</Screen>

To see <Command>mkdependHS</Command>'s command-line flags, give it a duff flag,
e.g., <Command>mkdependHS -help</Command>.
</Para>

<Para>
In general, if module <Literal>A</Literal> contains the line

<ProgramListing>
import B ...blah...
</ProgramListing>

then <Command>mkdependHS</Command> will generate a dependency line of the form:

<ProgramListing>
A.o : B.hi
</ProgramListing>

If module <Literal>A</Literal> contains the line 

<ProgramListing>
import {-# SOURCE #-} B ...blah...
</ProgramListing>

then <Command>mkdependHS</Command> will generate a dependency line of the form:

<ProgramListing>
A.o : B.hi-boot
</ProgramListing>

(See <XRef LinkEnd="hi-files"> for details of interface files.)
If <Literal>A</Literal> imports multiple modules, then there will be multiple lines with <Filename>A.o</Filename> as the
target.
</Para>

<Para>
By default, <Command>mkdependHS</Command> generates all the dependencies, and then
concatenates them onto the end of
<Filename>makefile</Filename> (or <Filename>Makefile</Filename> if <Filename>makefile</Filename> doesn't exist) bracketed by
the lines "<Literal>&num; DO NOT DELETE: Beginning of Haskell dependencies</Literal>" and
"<Literal>&num; DO NOT DELETE: End of Haskell dependencies</Literal>".  If these lines
already exist in the <Filename>makefile</Filename>, <Command>mkdependHS</Command> deletes the old
dependencies first.
</Para>

<Para>
<Command>mkdependHS</Command> takes GHC options between <Literal>--</Literal> brackets.
It understands the following ones. Any options between <Literal>--</Literal> brackets
that it doesn't understand are simply ignored; this way you can feed your
Makefile's standard GHC options to <Command>mkdependHS</Command> un-filtered.
<VariableList>

<VarListEntry>
<Term><Option>-cpp</Option></Term>
<ListItem>
<Para>
Run the C pre-processor over the input files. The
default is not to.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-D&lt;blah&gt;</Option></Term>
<ListItem>
<Para>
A cpp <Option>&num;define</Option>; usual meaning.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-i&lt;dirs&gt;</Option></Term>
<ListItem>
<Para>
Add <Filename>&lt;dirs&gt;</Filename> (colon-separated) to list of directories
to search for "import"ed modules.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-I&lt;dir&gt;</Option></Term>
<ListItem>
<Para>
Add <Filename>&lt;dir&gt;</Filename> to list of directories to search for
.h files (i.e., usual meaning).
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-syslib &lt;blah&gt;</Option></Term>
<ListItem>
<Para>
This program uses this GHC system library; take
appropriate action (e.g., recognise when they are
"import"ing a module from that library).
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

<Para>
Here are the <Command>mkdependHS</Command>-specific options (not between <Literal>--</Literal>'s):
<VariableList>

<VarListEntry>
<Term><Option>-v</Option></Term>
<ListItem>
<Para>
Be verbose.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-v -v</Option></Term>
<ListItem>
<Para>
Be very verbose.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-w</Option></Term>
<ListItem>
<Para>
Turn off warnings about interface file shadowing.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-f blah</Option></Term>
<ListItem>
<Para>
Use <Filename>blah</Filename> as the makefile, rather than <Filename>makefile</Filename>
or <Filename>Makefile</Filename>.  If <Filename>blah</Filename> doesn't exist, <Command>mkdependHS</Command> creates it.
We often use <Option>-f .depend</Option> to put the dependencies in <Filename>.depend</Filename> and
then <Command>include</Command> the file <Filename>.depend</Filename> into <Filename>Makefile</Filename>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-o &lt;osuf&gt;</Option></Term>
<ListItem>
<Para>
Use <Filename>.&lt;osuf&gt;</Filename> as the "target file" suffix ( default: <Literal>o</Literal>).
Multiple <Option>-o</Option> flags are permitted (GHC2.05 onwards).  Thus "<Option>-o hc -o o</Option>"
will generate dependencies for <Filename>.hc</Filename> and <Filename>.o</Filename> files.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-s &lt;suf&gt;</Option></Term>
<ListItem>
<Para>
Make extra dependencies that declare that files with
suffix <Filename>.&lt;suf&gt;&lowbar;&lt;osuf&gt;</Filename> depend on interface files with suffix <Filename>.&lt;suf&gt;&lowbar;hi</Filename>, or
(for <Literal>&lcub;-&num; SOURCE &num;-&rcub;</Literal> imports) on <Filename>.hi-boot</Filename>.
Multiple <Option>-s</Option> flags are permitted.
For example, <Option>-o hc -s a -s b</Option> will
make dependencies for <Filename>.hc</Filename> on <Filename>.hi</Filename>, <Filename>.a&lowbar;hc</Filename> on <Filename>.a&lowbar;hi</Filename>, and <Filename>.b&lowbar;hc</Filename> on <Filename>.b&lowbar;hi</Filename>.
(Useful in conjunction with NoFib "ways".)  
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>--exclude-module=&lt;file&gt;</Option></Term>
<ListItem>
<Para>
Regard <Filename>&lt;file&gt;</Filename> as "stable"; i.e., exclude it from having
dependencies on it.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-x</Option></Term>
<ListItem>
<Para>
same as <Option>--exclude-module</Option>
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>--exclude-directory=&lt;dirs&gt;</Option></Term>
<ListItem>
<Para>
Regard the colon-separated list of directories <Filename>&lt;dirs&gt;</Filename> as containing stable,
don't generate any dependencies on modules therein.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>-Xdirs</Option></Term>
<ListItem>
<Para>
same as <Option>--exclude-directory</Option>.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>--include-module=&lt;file&gt;</Option></Term>
<ListItem>
<Para>
Regard <Filename>&lt;file&gt;</Filename> as not "stable"; i.e., generate dependencies
on it (if any). This option is normally used in conjunction 
with the <Option>--exclude-directory</Option> option.
</Para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Option>--include-prelude</Option></Term>
<ListItem>
<Para>
Regard prelude libraries as unstable, i.e., generate dependencies
on the prelude modules used (including <Literal>Prelude</Literal>).
This option is normally only used by the various system libraries. If
a <Option>-syslib</Option> option is used, dependencies will also be
generated on the library's interfaces. 
</Para>
</ListItem>
</VarListEntry>
</VariableList>
</Para>

</Sect1>

<Sect1 id="hstags">
<Title>Emacs `TAGS' for Haskell: <Command>hstags</Command>
</Title>

<Para>
<IndexTerm><Primary>hstags</Primary></IndexTerm>
<IndexTerm><Primary>TAGS for Haskell</Primary></IndexTerm>
</Para>

<Para>
`Tags' is a facility for indexing the definitions of
programming-language things in a multi-file program, and then using
that index to jump around among these definitions.
</Para>

<Para>
Rather than scratch your head, saying ``Now where did we define
`foo'?'', you just do (in Emacs) <Literal>M-. foo RET</Literal>, and You're There!
Some people go wild over this stuff&hellip;
</Para>

<Para>
GHC comes with a program <Command>hstags</Command>, which build Emacs-able TAGS files.  The invocation syntax is:

<Screen>
hstags [GHC-options] file [files...]
</Screen>

</Para>

<Para>
The best thing is just to feed it your GHC command-line flags.
A good Makefile entry might be:

<ProgramListing>
tags:
        $(RM) TAGS
        hstags $(GHC_FLAGS) *.lhs
</ProgramListing>

</Para>

<Para>
The only flags of its own are: <Option>-v</Option> to be verbose; <Option>-a</Option> to
<Emphasis>APPEND</Emphasis> to the TAGS file, rather than write to it.
</Para>

<Para>
Shortcomings: (1)&nbsp;Instance declarations don't get into the TAGS file
(but the definitions inside them do); as instances aren't named, this
is probably just as well.  (2)&nbsp;Data-constructor definitions don't get
in.  Go for the corresponding type constructor instead.
</Para>

<Para>
(Actually, GHC also comes with <Command>etags</Command> &lsqb;for C&rsqb;, and <Command>perltags</Command>
&lsqb;for You Know What&rsqb;.  And&mdash;I cannot tell a lie&mdash;there is Denis
Howe's <Command>fptags</Command> &lsqb;for Haskell, etc.&rsqb; in the <Filename>ghc/CONTRIB</Filename>
section&hellip;)
</Para>

</Sect1>

<Sect1 id="happy">
<Title>``Yacc for Haskell'': <Command>happy</Command>
</Title>

<Para>
<IndexTerm><Primary>happy</Primary></IndexTerm>
<IndexTerm><Primary>Yacc for Haskell</Primary></IndexTerm>
<IndexTerm><Primary>parser generator for Haskell</Primary></IndexTerm>
Andy Gill and Simon Marlow have written a parser-generator for
Haskell, called <Command>happy</Command>.<IndexTerm><Primary>happy parser generator</Primary></IndexTerm> <Command>Happy</Command>
is to Haskell what <Command>Yacc</Command> is to C.
</Para>

<Para>
You can get <Command>happy</Command> by FTP from <Literal>ftp.dcs.gla.ac.uk</Literal> in
<Filename>pub/haskell/happy</Filename>, the file <Filename>happy-1.5-src.tar.gz</Filename>.
</Para>

<Para>
<Command>Happy</Command> is at its shining best when compiled by GHC.
</Para>

</Sect1>

<Sect1 id="pphs">
<Title>Pretty-printing Haskell: <Command>pphs</Command>
</Title>

<Para>
<IndexTerm><Primary>pphs</Primary></IndexTerm>
<IndexTerm><Primary>pretty-printing Haskell code</Primary></IndexTerm>
</Para>

<Para>
Andrew Preece has written
<Command>pphs</Command>,<IndexTerm><Primary>pphs</Primary></IndexTerm><IndexTerm><Primary>pretty-printing Haskell</Primary></IndexTerm>
a utility to pretty-print Haskell code in LaTeX documents.
Keywords in bolds, variables in italics&mdash;that sort of thing.  It is
good at lining up program clauses and equals signs, things that are
very tiresome to do by hand.
</Para>

<Para>
The code is distributed with GHC in <Filename>ghc/CONTRIB/pphs</Filename>.
</Para>

</Sect1>

</Chapter>
