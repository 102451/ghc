<Chapter id="using-GHC">
<title>Using GHC
</title>

<para>
<IndexTerm><Primary>GHC, using</Primary></IndexTerm>
<IndexTerm><Primary>using GHC</Primary></IndexTerm>
GHC is a command-line compiler: in order to compile a Haskell program,
GHC must be invoked on the source file(s) by typing a command to the
shell.  The steps involved in compiling a program can be automated
using the <command>make</command> tool (this is especially useful if the program
consists of multiple source files which depend on each other).  This
section describes how to use GHC from the command-line.
</para>

<Sect1 id="command-line-structure">
<title>Overall command-line structure
</title>

<para>
<IndexTerm><Primary>structure, command-line</Primary></IndexTerm>
<IndexTerm><Primary>command-line structure</Primary></IndexTerm>
</para>

<para>
An invocation of GHC takes the following form:
</para>

<para>

<Screen>
ghc [argument...]
</Screen>

</para>

<para>
Command-line arguments are either options or file names.
</para>

<para>
Command-line options begin with <literal>-</literal>.  They may <emphasis>not</emphasis> be
grouped: <option>-vO</option> is different from <option>-v -O</option>.  Options need not
precede filenames: e.g., <command>ghc *.o -o foo</command>.  All options are
processed and then applied to all files; you cannot, for example, invoke
<command>ghc -c -O1 Foo.hs -O2 Bar.hs</command> to apply different optimisation
levels to the files <filename>Foo.hs</filename> and <filename>Bar.hs</filename>.  For conflicting
options, e.g., <option>-c -S</option>, we reserve the right to do anything we
want.  (Usually, the last one applies.)
</para>

</Sect1>

<Sect1 id="file-suffixes">
<title>Meaningful file suffixes
</title>

<para>
<IndexTerm><Primary>suffixes, file</Primary></IndexTerm>
<IndexTerm><Primary>file suffixes for GHC</Primary></IndexTerm>
</para>

<para>
File names with &ldquo;meaningful&rdquo; suffixes (e.g., <filename>.lhs</filename> or <filename>.o</filename>)
cause the &ldquo;right thing&rdquo; to happen to those files.
</para>

<para>
<VariableList>

<VarListEntry>
<Term><filename>.lhs</filename>:</Term>
<ListItem>
<para>
<IndexTerm><Primary>lhs suffix</Primary></IndexTerm>
A &ldquo;literate Haskell&rdquo; module.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.hs</filename>:</Term>
<ListItem>
<para>
A not-so-literate Haskell module.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.hi</filename>:</Term>
<ListItem>
<para>
A Haskell interface file, probably compiler-generated.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.hc</filename>:</Term>
<ListItem>
<para>
Intermediate C file produced by the Haskell compiler.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.c</filename>:</Term>
<ListItem>
<para>
A C&nbsp;file not produced by the Haskell compiler.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.s</filename>:</Term>
<ListItem>
<para>
An assembly-language source file, usually
produced by the compiler.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><filename>.o</filename>:</Term>
<ListItem>
<para>
An object file, produced by an assembler.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>

<para>
Files with other suffixes (or without suffixes) are passed straight
to the linker.
</para>

</Sect1>

  <sect1 id="options-help">
    <title>Help and verbosity options</title>

    <IndexTerm><Primary>help options</Primary></IndexTerm>
    <IndexTerm><Primary>verbosity options</Primary></IndexTerm>

    <variablelist>
      <varlistentry>
	<term><literal>-help</literal></term>
	<term><literal>-?</literal></term>
	<indexterm><primary><literal>-?</literal></primary></indexterm>
	<indexterm><primary><literal>-help</literal></primary></indexterm>
	<listitem>
	  <para>Cause GHC to spew a long usage message to standard
          output and then exit.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>-v</literal></term>
	<indexterm><primary><literal>-v</literal></primary></indexterm>
	<listitem>
	  <para>The <option>-v</option> option makes GHC
          <emphasis>verbose</emphasis>: it reports its version number
          and shows (on stderr) exactly how it invokes each phase of
          the compilation system.  Moreover, it passes the
          <option>-v</option> flag to most phases; each reports its
          version number (and possibly some other information).</para>

	  <para>Please, oh please, use the <option>-v</option> option
          when reporting bugs!  Knowing that you ran the right bits in
          the right order is always the first thing we want to
          verify.</para>
	</listitem>
      </varlistentry>
	
      <varlistentry>
	<term><literal>-v</literal><replaceable>n</replaceable></term>
	<indexterm><primary><option>-v</option></primary></indexterm>
	<listitem>
	  <para>To provide more control over the compiler's verbosity,
	  the <option>-v</option> flag takes an optional numeric
	  argument.  Specifying <option>-v</option> on its own is
	  equivalent to <option>-v3</option>, and the other levels
	  have the following meanings:</para>
	  
	  <variablelist>
	    <varlistentry>
	      <term><literal>-v0</literal></term>
	      <listitem>
		<para>Disable all non-essential messages (this is the
		default).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>-v1</literal></term>
	      <listitem>
		<para>Minimal verbosity: print one line per
		compilation (this is the default when
		<option>--make</option> or
		<option>--interactive</option> is on).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>-v2</literal></term>
	      <listitem>
		<para>Print the name of each compilation phase as it
		is executed. (equivalent to
		<option>-dshow-passes</option>).</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>-v3</literal></term>
	      <listitem>
		<para>The same as <option>-v2</option>, except that in
                addition the full command line (if appropriate) for
                each compilation phase is also printed.</para>
	      </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><literal>-v4</literal></term>
	      <listitem>
		<para>The same as <option>-v3</option> except that the
		intermediate program representation after each
		compilation phase is also printed (excluding
		preprocessed and C/assembly files).</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	</listitem>
      </varlistentry>
      
      <varlistentry>
	<term><literal>--version</literal></term>
	<indexterm><primary><literal>--version</literal></primary></indexterm>
	<listitem>
	  <para>Print a one-line string including GHC's version number.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>--numeric-version</literal></term>
	<indexterm><primary><literal>--numeric-version</literal></primary></indexterm>
	<listitem>
	  <para>Print GHC's numeric version number only.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>
    
  <Sect1 id="options-order">
    <title>Running the right phases in the right order</title>

    <indexterm><primary>order of passes in GHC</primary></indexterm>
    <indexterm><primary>pass ordering in GHC</primary></indexterm>


    <para>The basic task of the <command>ghc</command> driver is to
    run each input file through the right phases (compiling, linking,
    etc.).</para>

    <para>The first phase to run is determined by the input-file
    suffix, and the last phase is determined by a flag.  If no
    relevant flag is present, then go all the way through linking.
    This table summarises:</para>

<InformalTable>
<TGroup Cols="4">
<ColSpec Align="Left">
<ColSpec Align="Left">
<ColSpec Align="Left">
<ColSpec Align="Left">
<TBody>

<Row>
<Entry>Phase of the compilation system</Entry>
<Entry>Suffix saying &ldquo;start here&rdquo;</Entry>
<Entry>Flag saying &ldquo;stop after&rdquo;</Entry>
<Entry>(suffix of) output file</Entry>
</Row>

<Row>
<Entry>
literate pre-processor </Entry>
<Entry> .lhs </Entry>
<Entry> - </Entry>
<Entry> .hs </Entry>
</Row>
<Row>
<Entry>
C pre-processor (opt.) </Entry>
<Entry> .hs (with <literal>-cpp</literal>) </Entry>
<Entry> -E </Entry>
<Entry> .hspp </Entry>
</Row>
<Row>
<Entry>
Haskell compiler </Entry>
<Entry> .hs </Entry>
<Entry> -C, -S </Entry>
<Entry> .hc, .s </Entry>
</Row>
<Row>
<Entry>
C compiler (opt.) </Entry>
<Entry> .hc or .c </Entry>
<Entry> -S </Entry>
<Entry> .s </Entry>
</Row>
<Row>
<Entry>
assembler </Entry>
<Entry> .s </Entry>
<Entry> -c </Entry>
<Entry> .o </Entry>
</Row>
<Row>
<Entry>
linker </Entry>
<Entry> other </Entry>
<Entry> - </Entry>
<Entry> a.out </Entry>
</Row>
</TBody>
</TGroup>
</InformalTable>

<IndexTerm><Primary>-C option</Primary></IndexTerm>
<IndexTerm><Primary>-S option</Primary></IndexTerm>
<IndexTerm><Primary>-c option</Primary></IndexTerm>

<para>
Thus, a common invocation would be: <command>ghc -c Foo.hs</command>
</para>

<para>
Note: What the Haskell compiler proper produces depends on whether a
native-code generator is used (producing assembly language) or not
(producing C).
</para>
    
    <para>NOTE: the option <option>-E</option><IndexTerm><Primary>-E
    option</Primary></IndexTerm> runs just the pre-processing passes
    of the compiler, dumping the result in a file.  Note that this
    differs from all GHCs prior to version 4.11, in which the result
    was dumped to the standard output.  If used in conjunction with
    -cpp, the output is the code blocks of the original (literal)
    source after having put it through the grinder that is the C
    pre-processor. Sans <option>-cpp</option>, the output is the
    de-litted version of the original source.</para>

    <para>The following options also affect which phases get run:</para>

    <variablelist>
      <varlistentry>
	<term><option>-cpp</option></term>
	<indexterm><primary><option>-cpp</option></primary></indexterm>
	<listitem>
	  <para>Run the C pre-processor on the Haskell source before
	  compiling it.  See <xref linkend="c-pre-processor"> for more
	  details.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fasm</option></term>
	<indexterm><primary><option>-fasm</option></primary></indexterm>
	<listitem>
	  <para>Use GHC's native code generator rather than compiling
	  via C.  This will compile faster (up to twice as fast), but
	  may produce code that is slightly slower than compiling via
	  C.  <option>-fasm</option> is the default when optimisation
	  is off (see <xref linkend="options-optimise">).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fvia-C</option></term>
	<indexterm><primary><option>-fvia-C</option></primary>
	</indexterm>
	<listitem>
	  <para>Compile via C instead of using the native code
	  generator.  This is default for optimised compilations, and
	  on architectures for which GHC doesn't have a native code
	  generator.</para>
	</listitem>
      </varlistentry>
    </variablelist>
  </sect1>

  <sect1 id="options-output">
    <title>Re-directing the compilation output(s)</title>

    <indexterm><primary>output-directing options</primary></indexterm>
    <indexterm><primary>redirecting compilation output</primary></indexterm>


    <variablelist>
      <varlistentry>
	<term><literal>-o</literal></term>
	<indexterm><primary><literal>-o</literal></primary></indexterm>
	<listitem>
	  <para>GHC's compiled output normally goes into a
          <filename>.hc</filename>, <filename>.o</filename>, etc.,
          file, depending on the last-run compilation phase.  The
          option <option>-o foo</option><IndexTerm><Primary>-o
          option</Primary></IndexTerm> re-directs the output of that
          last-run phase to file <filename>foo</filename>.</para>

	  <para>Note: this &ldquo;feature&rdquo; can be
          counterintuitive: <command>ghc -C -o foo.o foo.hs</command>
          will put the intermediate C code in the file
          <filename>foo.o</filename>, name notwithstanding!</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>-odir</literal></term>
	<indexterm><primary><literal>-odir</literal></primary></indexterm>
	<listitem>
	  <para>The <option>-o</option> option isn't of much use if
          you have <emphasis>several</emphasis> input files&hellip;
          Non-interface output files are normally put in the same
          directory as their corresponding input file came from.  You
          may specify that they be put in another directory using the
          <option>-odir &lt;dir&gt;</option><IndexTerm><Primary>-odir
          &lt;dir&gt; option</Primary></IndexTerm> (the &ldquo;Oh,
          dear&rdquo; option).  For example:</para>

<Screen>
% ghc -c parse/Foo.hs parse/Bar.hs gurgle/Bumble.hs -odir `arch`
</Screen>

          <para>The output files, <filename>Foo.o</filename>,
          <filename>Bar.o</filename>, and
          <filename>Bumble.o</filename> would be put into a
          subdirectory named after the architecture of the executing
          machine (<filename>sun4</filename>,
          <filename>mips</filename>, etc).  The directory must already
          exist; it won't be created.</para>

          <para>Note that the <option>-odir</option> option does
          <emphasis>not</emphasis> affect where the interface files
          are put.  In the above example, they would still be put in
          <filename>parse/Foo.hi</filename>,
          <filename>parse/Bar.hi</filename>, and
          <filename>gurgle/Bumble.hi</filename>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>-ohi</literal></term>
	<indexterm><primary><literal>-ohi</literal></primary></indexterm>
	<listitem>
	  <para></para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>-osuf</literal></term>
	<term><literal>-hisuf</literal></term>
	<indexterm><primary><literal>-osuf</literal></primary></indexterm>
	<indexterm><primary><literal>-hisuf</literal></primary></indexterm>
	<listitem>
	  <para>EXOTICA: The <option>-osuf
          &lt;suffix&gt;</option><IndexTerm><Primary>-osuf
          &lt;suffix&gt; option</Primary></IndexTerm> will change the
          <filename>.o</filename> file suffix for object files to
          whatever you specify.  (We use this in compiling the
          prelude.).</para>

	  <para>Similarly, the <option>-hisuf
          &lt;suffix&gt;</option><IndexTerm><Primary>-hisuf
          &lt;suffix&gt; option</Primary></IndexTerm> will change the
          <filename>.hi</filename> file suffix for non-system
          interface files (see <XRef LinkEnd="hi-options">).</para>

	  <para>The <option>-hisuf</option>/<option>-osuf</option>
          game is useful if you want to compile a program with both
          GHC and HBC (say) in the same directory.  Let HBC use the
          standard <filename>.hi</filename>/<filename>.o</filename>
          suffixes; add <option>-hisuf g&lowbar;hi -osuf
          g&lowbar;o</option> to your <command>make</command> rule for
          GHC compiling&hellip;</para>
	</listitem>
      </varlistentry>
    </variablelist>
	
    <sect2 id="keeping-intermediates">
      <title>Keeping Intermediate Files</title>
      <indexterm><primary>intermediate files, saving</primary>
      </indexterm>
      <indexterm><primary><literal>.hc</literal> files, saving</primary>
      </indexterm>
      <indexterm><primary><literal>.s</literal> files, saving</primary>
      </indexterm>


      <para>The following options are useful for keeping certain
      intermediate files around, when normally GHC would throw these
      away after compilation:</para>

      <variablelist>
	<varlistentry>
	  <term><literal>-keep-hc-files</literal></term>
	  <indexterm>
	    <primary><literal>-keep-hc-files</literal></primary>
	  </indexterm>
	  <listitem>
	    <para>Keep intermediate <literal>.hc</literal> files when
	    doing <literal>.hs</literal>-to-<literal>.o</literal>
	    compilations via C (NOTE: <literal>.hc</literal> files
	    aren't generated when using the native code generator, you
	    may need to use <literal>-fvia-C</literal> to force them
	    to be produced).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>-keep-s-files</literal></term>
	  <indexterm>
	    <primary><literal>-keep-s-files</literal></primary>
	  </indexterm>
	  <listitem>
	    <para>Keep intermediate <literal>.s</literal> files.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>-keep-raw-s-files</literal></term>
	  <indexterm>
	    <primary><literal>-keep-raw-s-files</literal></primary>
	  </indexterm>
	  <listitem>
	    <para>Keep intermediate <literal>.raw-s</literal> files.
	    These are the direct output from the C compiler, before
	    GHC does &ldquo;assembly mangling&rdquo; to produce the
	    <literal>.s</literal> file.  Again, these are not produced
	    when using the native code generator.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><literal>-keep-tmp-files</literal></term>
	  <indexterm>
	    <primary><literal>-keep-tmp-files</literal></primary>
	  </indexterm>
	  <indexterm>
	    <primary>temporary files</primary>
	    <secondary>keeping</secondary>
	  </indexterm>
	  <listitem>
	    <para>Instructs the GHC driver not to delete any of its
	    temporary files, which it normally keeps in
	    <literal>/tmp</literal> (or possibly elsewhere; see <xref
	    linkend="temp-files">).  Running GHC with
	    <literal>-v</literal> will show you what temporary files
	    were generated along the way.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="temp-files">
      <title>Redirecting temporary files</title>

      <indexterm>
	<primary>temporary files</primary>
	<secondary>redirecting</secondary>
      </indexterm>

      <variablelist>
	<varlistentry>
	  <term><literal>-tmpdir</literal></term>
	  <indexterm><primary><literal>-tmpdir</literal></primary></indexterm>
	  <listitem>
	    <para>If you have trouble because of running out of space
            in <filename>/tmp</filename> (or wherever your
            installation thinks temporary files should go), you may
            use the <option>-tmpdir
            &lt;dir&gt;</option><IndexTerm><Primary>-tmpdir
            &lt;dir&gt; option</Primary></IndexTerm> option to specify
            an alternate directory.  For example, <option>-tmpdir
            .</option> says to put temporary files in the current
            working directory.</para>

	    <para>Alternatively, use your <Constant>TMPDIR</Constant>
            environment variable.<IndexTerm><Primary>TMPDIR
            environment variable</Primary></IndexTerm> Set it to the
            name of the directory where temporary files should be put.
            GCC and other programs will honour the
            <Constant>TMPDIR</Constant> variable as well.</para>

	    <para>Even better idea: Set the
            <Constant>DEFAULT_TMPDIR</Constant> make variable when
            building GHC, and never worry about
            <Constant>TMPDIR</Constant> again. (see the build
            documentation).</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

  </sect1>

  <sect1 id="options-sanity">
    <title>Warnings and sanity-checking</title>

    <indexterm><primary>sanity-checking options</primary></indexterm>
    <indexterm><primary>warnings</primary></indexterm>


    <para>GHC has a number of options that select which types of
    non-fatal error messages, otherwise known as warnings, can be
    generated during compilation.  By default, you get a standard set
    of warnings which are generally likely to indicate bugs in your
    program.  These are:
    <option>-fwarn-overlpapping-patterns</option>,
    <option>-fwarn-deprecations</option>,
    <option>-fwarn-duplicate-exports</option>,
    <option>-fwarn-missing-fields</option>, and
    <option>-fwarn-missing-methods</option>.  The following flags are
    simple ways to select standard &ldquo;packages&rdquo; of warnings:
    </para>

    <VariableList>

      <varlistentry>
	<term><option>-W</option>:</term>
	<listitem>
	  <IndexTerm><Primary>-W option</Primary></IndexTerm>
	  <para>Provides the standard warnings plus
	  <option>-fwarn-incomplete-patterns</option>,
	  <option>-fwarn-unused-matches</option>,
	  <option>-fwarn-unused-imports</option> and
	  <option>-fwarn-unused-binds</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-w</option>:</term>
	<listitem>
	  <IndexTerm><Primary>-w option</Primary></IndexTerm>
	  <para>Turns off all warnings, including the standard ones.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-Wall</option>:</term>
	<listitem>
	  <indexterm><primary>-Wall option</primary></indexterm>
	  <para>Turns on all warning options.</para>
	</listitem>
      </varlistentry>

    </variablelist>

    <para>The full set of warning options is described below.  To turn
    off any warning, simply give the corresponding
    <option>-fno-warn-...</option> option on the command line.</para>

    <variablelist>

      <varlistentry>
	<term><option>-fwarn-deprecations</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-deprecations</option></primary>
	  </indexterm>
	  <indexterm><primary>deprecations</primary></indexterm>
	  <para>Causes a warning to be emitted when a deprecated
	  function or type is used.  Entities can be marked as
	  deprecated using a pragma, see <xref
	  linkend="deprecated-pragma">.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-duplicate-exports</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-duplicate-exports option</primary></indexterm>
	  <indexterm><primary>duplicate exports, warning</primary></indexterm>
	  <indexterm><primary>export lists, duplicates</primary></indexterm>

	  <para>Have the compiler warn about duplicate entries in
          export lists. This is useful information if you maintain
          large export lists, and want to avoid the continued export
          of a definition after you've deleted (one) mention of it in
          the export list.</para>

	  <para>This option is on by default.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-hi-shadowing</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-hi-shadowing option</primary></indexterm>
	  <indexterm><primary>shadowing</primary>
	    <secondary>interface files</secondary></indexterm>

	  <para>Causes the compiler to emit a warning when a module or
	  interface file in the current directory is shadowing one
	  with the same module name in a library or other
	  directory.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-incomplete-patterns</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-incomplete-patterns option</primary></indexterm>
	  <indexterm><primary>incomplete patterns, warning</primary></indexterm>
	  <indexterm><primary>patterns, incomplete</primary></indexterm>

	  <para>Similarly for incomplete patterns, the function
          <function>g</function> below will fail when applied to
          non-empty lists, so the compiler will emit a warning about
          this when <option>-fwarn-incomplete-patterns</option> is
          enabled.</para>

<programlisting>
g [] = 2
</programlisting>

	  <para>This option isn't enabled be default because it can be
          a bit noisy, and it doesn't always indicate a bug in the
          program.  However, it's generally considered good practice
          to cover all the cases in your functions.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-missing-fields</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-missing-fields option</primary></indexterm>
	  <indexterm><primary>missing fields, warning</primary></indexterm>
	  <indexterm><primary>fields, missing</primary></indexterm>

	  <para>This option is on by default, and warns you whenever
          the construction of a labelled field constructor isn't
          complete, missing initializers for one or more fields. While
          not an error (the missing fields are initialised with
          bottoms), it is often an indication of a programmer error.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-missing-methods</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-missing-methods option</primary></indexterm>
	  <indexterm><primary>missing methods, warning</primary></indexterm>
	  <indexterm><primary>methods, missing</primary></indexterm>

	  <para>This option is on by default, and warns you whenever
          an instance declaration is missing one or more methods, and
          the corresponding class declaration has no default
          declaration for them.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-missing-signatures</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-missing-signatures option</primary></indexterm>
	  <indexterm><primary>type signatures, missing</primary></indexterm>

	  <para>If you would like GHC to check that every top-level
          function/value has a type signature, use the
          <option>-fwarn-missing-signatures</option> option.  This
          option is off by default.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-name-shadowing</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-name-shadowing option</primary></indexterm>
	  <indexterm><primary>shadowing, warning</primary></indexterm>
	  
	  <para>This option causes a warning to be emitted whenever an
          inner-scope value has the same name as an outer-scope value,
          i.e. the inner value shadows the outer one.  This can catch
          typographical errors that turn into hard-to-find bugs, e.g.,
          in the inadvertent cyclic definition <literal>let x = ... x
          ... in</literal>.</para>

	  <para>Consequently, this option does
          <emphasis>will</emphasis> complain about cyclic recursive
          definitions.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-overlapping-patterns</option>:</term>
	<indexterm><primary>-fwarn-overlapping-patterns option</primary></indexterm>
	<indexterm><primary>overlapping patterns, warning</primary></indexterm>
	<indexterm><primary>patterns, overlapping</primary></indexterm>
	<listitem>
	  <para>By default, the compiler will warn you if a set of
          patterns are overlapping, i.e.,</para>

<programlisting>
f :: String -&#62; Int
f []     = 0
f (_:xs) = 1
f "2"    = 2
</programlisting>

	  <para>where the last pattern match in <Function>f</Function>
          won't ever be reached, as the second pattern overlaps
          it. More often than not, redundant patterns is a programmer
          mistake/error, so this option is enabled by default.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-simple-patterns</option>:</term>
	<listitem>
	  <indexterm><primary><option>-fwarn-simple-patterns</option></primary>
	  </indexterm>
	  <para>Causes the compiler to warn about lambda-bound
	  patterns that can fail, eg. <literal>\(x:xs)->...</literal>.
	  Normally, these aren't treated as incomplete patterns by
	  <option>-fwarn-incomplete-patterns</option>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-type-defaults</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-type-defaults option</primary></indexterm>
	  <indexterm><primary>defaulting mechanism, warning</primary></indexterm>
	  <para>Have the compiler warn/inform you where in your source
          the Haskell defaulting mechanism for numeric types kicks
          in. This is useful information when converting code from a
          context that assumed one default into one with another,
          e.g., the `default default' for Haskell 1.4 caused the
          otherwise unconstrained value <Constant>1</Constant> to be
          given the type <literal>Int</literal>, whereas Haskell 98
          defaults it to <literal>Integer</literal>.  This may lead to
          differences in performance and behaviour, hence the
          usefulness of being non-silent about this.</para>

	  <para>This warning is off by default.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-binds</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-unused-binds option</primary></indexterm>
	  <indexterm><primary>unused binds, warning</primary></indexterm>
	  <indexterm><primary>binds, unused</primary></indexterm>
	  <para>Report any function definitions (and local bindings)
          which are unused.  For top-level functions, the warning is
          only given if the binding is not exported.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-imports</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-unused-imports option</primary></indexterm>
	  <indexterm><primary>unused imports, warning</primary></indexterm>
	  <indexterm><primary>imports, unused</primary></indexterm>

	  <para>Report any objects that are explicitly imported but
	  never used.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-fwarn-unused-matches</option>:</term>
	<listitem>
	  <indexterm><primary>-fwarn-unused-matches option</primary></indexterm>
	  <indexterm><primary>unused matches, warning</primary></indexterm>
	  <indexterm><primary>matches, unused</primary></indexterm>

	  <para>Report all unused variables which arise from pattern
          matches, including patterns consisting of a single variable.
          For instance <literal>f x y = []</literal> would report
          <VarName>x</VarName> and <VarName>y</VarName> as unused.  To
          eliminate the warning, all unused variables can be replaced
          with wildcards.</para>
	</listitem>
      </varlistentry>

    </VariableList>

    <para>If you're feeling really paranoid, the
    <option>-dcore-lint</option> option<indexterm><primary>-dcore-lint
    option</primary></indexterm> is a good choice.  It turns on
    heavyweight intra-pass sanity-checking within GHC.  (It checks
    GHC's sanity, not yours.)</para>

  </sect1>

  &separate;
  &packages;

  <sect1 id="options-optimise">
    <title>Optimisation (code improvement)</title>

    <indexterm><primary>optimisation</primary></indexterm>
    <indexterm><primary>improvement, code</primary></indexterm>

    <para>The <option>-O*</option> options specify convenient
    &ldquo;packages&rdquo; of optimisation flags; the
    <option>-f*</option> options described later on specify
    <emphasis>individual</emphasis> optimisations to be turned on/off;
    the <option>-m*</option> options specify
    <emphasis>machine-specific</emphasis> optimisations to be turned
    on/off.</para>

    <sect2 id="optimise-pkgs">
      <title><option>-O*</option>: convenient &ldquo;packages&rdquo; of optimisation flags.</title>

      <para>There are <emphasis>many</emphasis> options that affect
      the quality of code produced by GHC.  Most people only have a
      general goal, something like &ldquo;Compile quickly&rdquo; or
      &ldquo;Make my program run like greased lightning.&rdquo; The
      following &ldquo;packages&rdquo; of optimisations (or lack
      thereof) should suffice.</para>

      <para>Once you choose a <option>-O*</option>
      &ldquo;package,&rdquo; stick with it&mdash;don't chop and
      change.  Modules' interfaces <emphasis>will</emphasis> change
      with a shift to a new <option>-O*</option> option, and you may
      have to recompile a large chunk of all importing modules before
      your program can again be run safely (see <XRef
      LinkEnd="recomp">).</para>

      <variablelist>

	<varlistentry>
	  <term>No <option>-O*</option>-type option specified:</term>
	  <indexterm><primary>-O* not specified</primary></indexterm>
	  <listitem>
	    <para>This is taken to mean: &ldquo;Please compile
            quickly; I'm not over-bothered about compiled-code
            quality.&rdquo; So, for example: <command>ghc -c
            Foo.hs</command></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-O0</option>:</term>
	  <indexterm><primary><option>-O0</option></primary></indexterm>
	  <listitem>
	    <para>Means &ldquo;turn off all optimisation&rdquo;,
	    reverting to the same settings as if no
	    <option>-O</option> options had been specified.  Saying
	    <option>-O0</option> can be useful if
	    eg. <command>make</command> has inserted a
	    <option>-O</option> on the command line already.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-O</option> or <option>-O1</option>:</term>
	  <indexterm><primary>-O option</primary></indexterm>
	  <indexterm><primary>-O1 option</primary></indexterm>
	  <indexterm><primary>optimise</primary><secondary>normally</secondary></indexterm>
	  <listitem>
	    <para>Means: &ldquo;Generate good-quality code without
            taking too long about it.&rdquo; Thus, for example:
            <command>ghc -c -O Main.lhs</command></para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-O2</option>:</term>
	  <indexterm><primary>-O2 option</primary></indexterm>
	  <indexterm><primary>optimise</primary><secondary>aggressively</secondary></indexterm>
	  <listitem>
	    <para>Means: &ldquo;Apply every non-dangerous
            optimisation, even if it means significantly longer
            compile times.&rdquo;</para>

	    <para>The avoided &ldquo;dangerous&rdquo; optimisations
            are those that can make runtime or space
            <emphasis>worse</emphasis> if you're unlucky.  They are
            normally turned on or off individually.</para>

	    <para>At the moment, <option>-O2</option> is
            <emphasis>unlikely</emphasis> to produce better code than
            <option>-O</option>.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-O2-for-C</option>:</term>
	  <indexterm><primary>-O2-for-C option</primary></indexterm>
	  <indexterm><primary>gcc, invoking with -O2</primary></indexterm>
	  <listitem>
	    <para>Says to run GCC with <option>-O2</option>, which may
            be worth a few percent in execution speed.  Don't forget
            <option>-fvia-C</option>, lest you use the native-code
            generator and bypass GCC altogether!</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-Ofile &lt;file&gt;</option>:</term>
	  <indexterm><primary>-Ofile &lt;file&gt; option</primary></indexterm>
	  <indexterm><primary>optimising, customised</primary></indexterm>
	  <listitem>
	    <para>(NOTE: not supported yet in GHC 5.x.  Please ask if
	    you're interested in this.)</para>
	    
	    <para>For those who need <emphasis>absolute</emphasis>
            control over <emphasis>exactly</emphasis> what options are
            used (e.g., compiler writers, sometimes :-), a list of
            options can be put in a file and then slurped in with
            <option>-Ofile</option>.</para>

	    <para>In that file, comments are of the
            <literal>&num;</literal>-to-end-of-line variety; blank
            lines and most whitespace is ignored.</para>

	    <para>Please ask if you are baffled and would like an
	    example of <option>-Ofile</option>!</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>We don't use a <option>-O*</option> flag for day-to-day
      work.  We use <option>-O</option> to get respectable speed;
      e.g., when we want to measure something.  When we want to go for
      broke, we tend to use <option>-O -fvia-C -O2-for-C</option> (and
      we go for lots of coffee breaks).</para>

      <para>The easiest way to see what <option>-O</option> (etc.)
      &ldquo;really mean&rdquo; is to run with <option>-v</option>,
      then stand back in amazement.</para>
    </sect2>

    <sect2 id="options-f">
      <title><option>-f*</option>: platform-independent flags</title>

      <indexterm><primary>-f* options (GHC)</primary></indexterm>
      <indexterm><primary>-fno-* options (GHC)</primary></indexterm>

      <para>These flags turn on and off individual optimisations.
      They are normally set via the <option>-O</option> options
      described above, and as such, you shouldn't need to set any of
      them explicitly (indeed, doing so could lead to unexpected
      results).  However, there are one or two that may be of
      interest:</para>

      <variablelist>
	<varlistentry>
	  <term><option>-fexcess-precision</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-fexcess-precision</option></primary></indexterm>
	    <para>When this option is given, intermediate floating
	    point values can have a <emphasis>greater</emphasis>
	    precision/range than the final type.  Generally this is a
	    good thing, but some programs may rely on the exact
	    precision/range of
	    <literal>Float</literal>/<literal>Double</literal> values
	    and should not use this option for their compilation.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-fno-strictness</option></term>
	  <indexterm><primary><option>-fno-strictness</option></primary>
	  </indexterm>
	  <listitem>
	    <para>Turns off the strictness analyser; sometimes it eats
	    too many cycles.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-fno-cpr-analyse</option></term>
	  <indexterm><primary><option>-fno-cpr-analyse</option></primary>
	  </indexterm>
	  <listitem>
	    <para>Turns off the CPR (constructed product result)
	    analysis; it is somewhat experimental.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funbox-strict-fields</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-funbox-strict-fields</option></primary></indexterm>
	    <indexterm><primary>strict constructor fields</primary></indexterm>
	    <indexterm><primary>constructor fields, strict</primary></indexterm>

	    <para>This option causes all constructor fields which are
            marked strict (i.e. &ldquo;!&rdquo;) to be unboxed or
            unpacked if possible.  For example:</para>

<ProgramListing>
data T = T !Float !Float
</ProgramListing>

	    <para>will create a constructor <literal>T</literal>
            containing two unboxed floats if the
            <option>-funbox-strict-fields</option> flag is given.
            This may not always be an optimisation: if the
            <Function>T</Function> constructor is scrutinised and the
            floats passed to a non-strict function for example, they
            will have to be reboxed (this is done automatically by the
            compiler).</para>

	    <para>This option should only be used in conjunction with
            <option>-O</option>, in order to expose unfoldings to the
            compiler so the reboxing can be removed as often as
            possible.  For example:</para>

<ProgramListing>
f :: T -&#62; Float
f (T f1 f2) = f1 + f2
</ProgramListing>

	    <para>The compiler will avoid reboxing
            <Function>f1</Function> and <Function>f2</Function> by
            inlining <Function>+</Function> on floats, but only when
            <option>-O</option> is on.</para>

	    <para>Any single-constructor data is eligible for
	    unpacking; for example</para>

<ProgramListing>
data T = T !(Int,Int)
</ProgramListing>

	    <para>will store the two <literal>Int</literal>s directly
            in the <Function>T</Function> constructor, by flattening
            the pair.  Multi-level unpacking is also supported:</para>

<ProgramListing>
data T = T !S
data S = S !Int !Int
</ProgramListing>

	    <para>will store two unboxed <literal>Int&num;</literal>s
	    directly in the <Function>T</Function> constructor.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funfolding-update-in-place&lt;n&gt;</option></term>
	  <indexterm><primary><option>-funfolding-update-in-place</option></primary></indexterm>
	  <listitem>
	    <para>Switches on an experimental "optimisation".
            Switching it on makes the compiler a little keener to
            inline a function that returns a constructor, if the
            context is that of a thunk.
<ProgramListing>
   x = plusInt a b
</ProgramListing>
            If we inlined plusInt we might get an opportunity to use
            update-in-place for the thunk 'x'.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funfolding-interface-threshold&lt;n&gt;</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-funfolding-interface-threshold</option></primary></indexterm>
	    <indexterm><primary>inlining, controlling</primary></indexterm>
	    <indexterm><primary>unfolding, controlling</primary></indexterm>

	    <para>(Default: 30) By raising or lowering this number,
            you can raise or lower the amount of pragmatic junk that
            gets spewed into interface files.  (An unfolding has a
            &ldquo;size&rdquo; that reflects the cost in terms of
            &ldquo;code bloat&rdquo; of expanding that unfolding in
            another module.  A bigger function would be assigned a
            bigger cost.)</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funfolding-creation-threshold&lt;n&gt;</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-funfolding-creation-threshold</option></primary></indexterm>
	    <indexterm><primary>inlining, controlling</primary></indexterm>
	    <indexterm><primary>unfolding, controlling</primary></indexterm>
	    
	    <para>(Default: 30) This option is similar to
            <option>-funfolding-interface-threshold</option>, except
            that it governs unfoldings within a single module.
            Increasing this figure is more likely to result in longer
            compile times than faster code.  The next option is more
            useful:</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term><option>-funfolding-use-threshold&lt;n&gt;</option>:</term>
	  <listitem>
	    <indexterm><primary><option>-funfolding-use-threshold</option></primary></indexterm>
	    <indexterm><primary>inlining, controlling</primary></indexterm>
	    <indexterm><primary>unfolding, controlling</primary></indexterm>

	    <para>(Default: 8) This is the magic cut-off figure for
            unfolding: below this size, a function definition will be
            unfolded at the call-site, any bigger and it won't.  The
            size computed for a function depends on two things: the
            actual size of the expression minus any discounts that
            apply (see <option>-funfolding-con-discount</option>).</para>
	  </listitem>
	</varlistentry>
      </variablelist>

    </sect2>

  </sect1>

&phases;  

<Sect1 id="sec-using-concurrent">
<title>Using Concurrent Haskell</title>

<para>
<indexterm><primary>Concurrent Haskell&mdash;use</primary></indexterm>
</para>

<para>
GHC (as of version 4.00) supports Concurrent Haskell by default,
without requiring a special option or libraries compiled in a certain
way.  To get access to the support libraries for Concurrent Haskell
(i.e. <literal>Concurrent</literal> and friends), use the
<option>-package concurrent</option> option.
</para>

<para>
Three RTS options are provided for modifying the behaviour of the
threaded runtime system.  See the descriptions of
<option>-C[&lt;us&gt;]</option>, <option>-q</option>, and
<option>-t&lt;num&gt;</option> in <XRef LinkEnd="parallel-rts-opts">.
</para>

<para>
Concurrent Haskell is described in more detail in <XRef
LinkEnd="sec-Concurrent">.
</para>

</Sect1>

<Sect1 id="sec-using-parallel">
<title>Using Parallel Haskell</title>

<para>
<indexterm><primary>Parallel Haskell&mdash;use</primary></indexterm>
</para>

<para>
&lsqb;You won't be able to execute parallel Haskell programs unless PVM3
(Parallel Virtual Machine, version 3) is installed at your site.]
</para>

<para>
To compile a Haskell program for parallel execution under PVM, use the
<option>-parallel</option> option,<indexterm><primary>-parallel
option</primary></indexterm> both when compiling <emphasis>and
linking</emphasis>.  You will probably want to <literal>import
Parallel</literal> into your Haskell modules.
</para>

<para>
To run your parallel program, once PVM is going, just invoke it
&ldquo;as normal&rdquo;.  The main extra RTS option is
<option>-N&lt;n&gt;</option>, to say how many PVM
&ldquo;processors&rdquo; your program to run on.  (For more details of
all relevant RTS options, please see <XRef
LinkEnd="parallel-rts-opts">.)
</para>

<para>
In truth, running Parallel Haskell programs and getting information
out of them (e.g., parallelism profiles) is a battle with the vagaries of
PVM, detailed in the following sections.
</para>

<sect2>
<title>Dummy's guide to using PVM</title>

<para>
<indexterm><primary>PVM, how to use</primary></indexterm>
<indexterm><primary>Parallel Haskell&mdash;PVM use</primary></indexterm>
Before you can run a parallel program under PVM, you must set the
required environment variables (PVM's idea, not ours); something like,
probably in your <filename>.cshrc</filename> or equivalent:

<ProgramListing>
setenv PVM_ROOT /wherever/you/put/it
setenv PVM_ARCH `$PVM_ROOT/lib/pvmgetarch`
setenv PVM_DPATH $PVM_ROOT/lib/pvmd
</ProgramListing>

</para>

<para>
Creating and/or controlling your &ldquo;parallel machine&rdquo; is a purely-PVM
business; nothing specific to Parallel Haskell.
</para>

<para>
You use the <command>pvm</command><indexterm><primary>pvm command</primary></indexterm> command to start PVM on your
machine.  You can then do various things to control/monitor your
&ldquo;parallel machine;&rdquo; the most useful being:
</para>

<para>
<InformalTable>
<TGroup Cols=2>
<ColSpec Align="Left">
<TBody>

<Row>
<Entry><KeyCombo><KeyCap>Control</KeyCap><KeyCap>D</KeyCap></KeyCombo></Entry>
<Entry>exit <command>pvm</command>, leaving it running</Entry>
</Row>

<Row>
<Entry><command>halt</command></Entry>
<Entry>kill off this &ldquo;parallel machine&rdquo; &amp; exit</Entry>
</Row>

<Row>
<Entry><command>add &lt;host&gt;</command></Entry>
<Entry>add <command>&lt;host&gt;</command> as a processor</Entry>
</Row>

<Row>
<Entry><command>delete &lt;host&gt;</command></Entry>
<Entry>delete <command>&lt;host&gt;</command></Entry>
</Row>

<Row>
<Entry><command>reset</command></Entry>
<Entry>kill what's going, but leave PVM up</Entry>
</Row>

<Row>
<Entry><command>conf</command></Entry>
<Entry>list the current configuration</Entry>
</Row>

<Row>
<Entry><command>ps</command></Entry>
<Entry>report processes' status</Entry>
</Row>

<Row>
<Entry><command>pstat &lt;pid&gt;</command></Entry>
<Entry>status of a particular process</Entry>
</Row>

</TBody>
</TGroup>
</InformalTable>
</para>

<para>
The PVM documentation can tell you much, much more about <command>pvm</command>!
</para>

</sect2>

<sect2>
<title>Parallelism profiles</title>

<para>
<indexterm><primary>parallelism profiles</primary></indexterm>
<indexterm><primary>profiles, parallelism</primary></indexterm>
<indexterm><primary>visualisation tools</primary></indexterm>
</para>

<para>
With Parallel Haskell programs, we usually don't care about the
results&mdash;only with &ldquo;how parallel&rdquo; it was!  We want pretty pictures.
</para>

<para>
Parallelism profiles (&agrave; la <command>hbcpp</command>) can be generated with the
<option>-q</option><indexterm><primary>-q RTS option (concurrent, parallel)</primary></indexterm> RTS option.  The
per-processor profiling info is dumped into files named
<filename>&lt;full-path&gt;&lt;program&gt;.gr</filename>.  These are then munged into a PostScript picture,
which you can then display.  For example, to run your program
<filename>a.out</filename> on 8 processors, then view the parallelism profile, do:
</para>

<para>

<Screen>
% ./a.out +RTS -N8 -q
% grs2gr *.???.gr &#62; temp.gr     # combine the 8 .gr files into one
% gr2ps -O temp.gr              # cvt to .ps; output in temp.ps
% ghostview -seascape temp.ps   # look at it!
</Screen>

</para>

<para>
The scripts for processing the parallelism profiles are distributed
in <filename>ghc/utils/parallel/</filename>.
</para>

</sect2>

<sect2>
<title>Other useful info about running parallel programs</title>

<para>
The &ldquo;garbage-collection statistics&rdquo; RTS options can be useful for
seeing what parallel programs are doing.  If you do either
<option>+RTS -Sstderr</option><indexterm><primary>-Sstderr RTS option</primary></indexterm> or <option>+RTS -sstderr</option>, then
you'll get mutator, garbage-collection, etc., times on standard
error. The standard error of all PE's other than the `main thread'
appears in <filename>/tmp/pvml.nnn</filename>, courtesy of PVM.
</para>

<para>
Whether doing <option>+RTS -Sstderr</option> or not, a handy way to watch
what's happening overall is: <command>tail -f /tmp/pvml.nnn</command>.
</para>

</sect2>

<Sect2 id="parallel-rts-opts">
<title>RTS options for Concurrent/Parallel Haskell
</title>

<para>
<indexterm><primary>RTS options, concurrent</primary></indexterm>
<indexterm><primary>RTS options, parallel</primary></indexterm>
<indexterm><primary>Concurrent Haskell&mdash;RTS options</primary></indexterm>
<indexterm><primary>Parallel Haskell&mdash;RTS options</primary></indexterm>
</para>

<para>
Besides the usual runtime system (RTS) options
(<XRef LinkEnd="runtime-control">), there are a few options particularly
for concurrent/parallel execution.
</para>

<para>
<VariableList>

<varlistentry>
<term><option>-N&lt;N&gt;</option>:</term>
<listitem>
<para>
<indexterm><primary>-N&lt;N&gt; RTS option (parallel)</primary></indexterm>
(PARALLEL ONLY) Use <literal>&lt;N&gt;</literal> PVM processors to run this program;
the default is 2.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-C[&lt;us&gt;]</option>:</term>
<listitem>
<para>
<indexterm><primary>-C&lt;us&gt; RTS option</primary></indexterm> Sets
the context switch interval to <literal>&lt;s&gt;</literal> seconds.
A context switch will occur at the next heap block allocation after
the timer expires (a heap block allocation occurs every 4k of
allocation).  With <option>-C0</option> or <option>-C</option>,
context switches will occur as often as possible (at every heap block
allocation).  By default, context switches occur every 20ms
milliseconds.  Note that GHC's internal timer ticks every 20ms, and
the context switch timer is always a multiple of this timer, so 20ms
is the maximum granularity available for timed context switches.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-q[v]</option>:</term>
<listitem>
<para>
<indexterm><primary>-q RTS option</primary></indexterm>
(PARALLEL ONLY) Produce a quasi-parallel profile of thread activity,
in the file <FIlename>&lt;program&gt;.qp</FIlename>.  In the style of <command>hbcpp</command>, this profile
records the movement of threads between the green (runnable) and red
(blocked) queues.  If you specify the verbose suboption (<option>-qv</option>), the
green queue is split into green (for the currently running thread
only) and amber (for other runnable threads).  We do not recommend
that you use the verbose suboption if you are planning to use the
<command>hbcpp</command> profiling tools or if you are context switching at every heap
check (with <option>-C</option>).
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-t&lt;num&gt;</option>:</term>
<listitem>
<para>
<indexterm><primary>-t&lt;num&gt; RTS option</primary></indexterm>
(PARALLEL ONLY) Limit the number of concurrent threads per processor
to <literal>&lt;num&gt;</literal>.  The default is 32.  Each thread requires slightly over 1K
<emphasis>words</emphasis> in the heap for thread state and stack objects.  (For
32-bit machines, this translates to 4K bytes, and for 64-bit machines,
8K bytes.)
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-d</option>:</term>
<listitem>
<para>
<indexterm><primary>-d RTS option (parallel)</primary></indexterm>
(PARALLEL ONLY) Turn on debugging.  It pops up one xterm (or GDB, or
something&hellip;) per PVM processor.  We use the standard <command>debugger</command>
script that comes with PVM3, but we sometimes meddle with the
<command>debugger2</command> script.  We include ours in the GHC distribution,
in <filename>ghc/utils/pvm/</filename>.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-e&lt;num&gt;</option>:</term>
<listitem>
<para>
<indexterm><primary>-e&lt;num&gt; RTS option (parallel)</primary></indexterm>
(PARALLEL ONLY) Limit the number of pending sparks per processor to
<literal>&lt;num&gt;</literal>. The default is 100. A larger number may be appropriate if
your program generates large amounts of parallelism initially.
</para>
</listitem>
</varlistentry>
<varlistentry>
<term><option>-Q&lt;num&gt;</option>:</term>
<listitem>
<para>
<indexterm><primary>-Q&lt;num&gt; RTS option (parallel)</primary></indexterm>
(PARALLEL ONLY) Set the size of packets transmitted between processors
to <literal>&lt;num&gt;</literal>. The default is 1024 words. A larger number may be
appropriate if your machine has a high communication cost relative to
computation speed.
</para>
</listitem>
</varlistentry>
</VariableList>
</para>

</sect2>

</Sect1>

  <sect1 id="options-platform">
    <title>Platform-specific Flags</title>

    <indexterm><primary>-m* options</primary></indexterm>
    <indexterm><primary>platform-specific options</primary></indexterm>
    <indexterm><primary>machine-specific options</primary></indexterm>

    <para>Some flags only make sense for particular target
    platforms.</para>

    <variablelist>

      <varlistentry>
	<term><option>-mv8</option>:</term>
	<listitem>
	  <para>(SPARC machines)<indexterm><primary>-mv8 option (SPARC
          only)</primary></indexterm> Means to pass the like-named
          option to GCC; it says to use the Version 8 SPARC
          instructions, notably integer multiply and divide.  The
          similiar <option>-m*</option> GCC options for SPARC also
          work, actually.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-mlong-calls</option>:</term>
	<listitem>
	  <para>(HPPA machines)<indexterm><primary>-mlong-calls option
          (HPPA only)</primary></indexterm> Means to pass the
          like-named option to GCC.  Required for Very Big modules,
          maybe.  (Probably means you're in trouble&hellip;)</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><option>-monly-[32]-regs</option>:</term>
	<listitem>
	  <para>(iX86 machines)<indexterm><primary>-monly-N-regs
          option (iX86 only)</primary></indexterm> GHC tries to
          &ldquo;steal&rdquo; four registers from GCC, for performance
          reasons; it almost always works.  However, when GCC is
          compiling some modules with four stolen registers, it will
          crash, probably saying:

<Screen>
Foo.hc:533: fixed or forbidden register was spilled.
This may be due to a compiler bug or to impossible asm
statements or clauses.
</Screen>

          Just give some registers back with
          <option>-monly-N-regs</option>.  Try `3' first, then `2'.
          If `2' doesn't work, please report the bug to us.</para>
	</listitem>
      </varlistentry>
    </variablelist>

  </sect1>

&runtime
&debug
&flags

</Chapter>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: sgml ***
     ;;; sgml-parent-document: ("users_guide.sgml" "book" "chapter") ***
     ;;; End: ***
 -->
