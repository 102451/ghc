<Chapter id="win32-dlls">
<Title>Building and using Win32 DLLs
</Title>

<Para>
<IndexTerm><Primary>Dynamic link libraries, Win32</Primary></IndexTerm>
<IndexTerm><Primary>DLLs, Win32</Primary></IndexTerm>
On Win32 platforms, the compiler is capable of both producing and using
dynamic link libraries (DLLs) containing ghc-compiled code. This
section shows you how to make use of this facility.
</Para>

<Sect1 id="win32-dlls-link">
<Title>Linking with DLLs
</Title>

<Para>
The default on Win32 platforms is to link applications in such a way
that the executables will use the Prelude and system libraries DLLs,
rather than contain (large chunks of) them. This is transparent at the
command-line, so 
</Para>

<Para>

<Screen>
sh$ cat main.hs
module Main where
main = putStrLn "hello, world!"
sh$ ghc -o main main.hs
ghc: module version changed to 1; reason: no old .hi file
sh$ strip main.exe
sh$ ls -l main.exe
-rwxr-xr-x   1 544      everyone     6144 May  3 17:11 main.exe*
sh$ ./main
hello, world!
sh$ 
</Screen>

</Para>

<Para>
will give you a binary as before, but the <Filename>main.exe</Filename> generated will use the Prelude and RTS DLLs instead.
</Para>

<Para>
6K for a <Literal>"hello, world"</Literal> application---not bad, huh? :-)
</Para>

</Sect1>

<Sect1 id="win32-dlls-linking-static">
<Title>Not linking with DLLs
<IndexTerm><Primary>-static option (Win32)</Primary></IndexTerm></Title>

<Para>
This is no longer supported, and probably doesn't work; but if you want to build an executable that doesn't depend on any ghc-compiled DLLs, use the <Option>-static</Option> option to link in the code statically.
</Para>

<Para>
Notice that you cannot mix code that has been compiled with
<Option>-static</Option> and not, so you have to use the <Option>-static</Option>
option on all the Haskell modules that make up your application.
</Para>

</Sect1>

<Sect1 id="win32-dlls-create">
<Title>Creating a DLL
</Title>

<Para>
<IndexTerm><Primary>Creating a Win32 DLL</Primary></IndexTerm>
<IndexTerm><Primary>--mk-dll</Primary></IndexTerm>
Sealing up your Haskell library inside a DLL is quite straightforward;
compile up the object files that make up the library, and then build
the DLL by issuing the following command:
</Para>

<Para>
<Screen>
ghc --mk-dll -o HSsuper.dll A.o Super.o B.o libmine.a -lgdi32
</Screen>
</Para>

<Para>
By feeding the ghc compiler driver the option <Option>--mk-dll</Option>, it
will build a DLL rather than produce an executable. The DLL will
consist of all the object files and archives given on the command
line.
</Para>

<Para>
A couple of things to notice:
</Para>

<Para>

<ItemizedList>
<ListItem>

<Para>

Since DLLs correspond to packages (see <XRef LinkEnd="packages">) you need
to use <Option>-package-name dll-name</Option> when compiling modules that
belong to a DLL. If you don't, Haskell code that calls entry points in that
DLL will do so incorrectly, and a crash will result.

</Para>
</ListItem>
<ListItem>

<Para>
By default, the entry points of all the object files will
be exported from the DLL when using <Option>--mk-dll</Option>. Should you want to constrain this, you can specify the <Emphasis>module definition file</Emphasis> to use on the command line as follows:

<Screen>
ghc --mk-dll -o .... -optdll--def -optdllMyDef.def
</Screen>

See Microsoft documentation for details, but a module definition file
simply lists what entry points you want to export. Here's one that's
suitable when building a Haskell COM server DLL:

<ProgramListing>
EXPORTS
 DllCanUnloadNow     = DllCanUnloadNow@0
 DllGetClassObject   = DllGetClassObject@12
 DllRegisterServer   = DllRegisterServer@0
 DllUnregisterServer = DllUnregisterServer@0
</ProgramListing>


</Para>
</ListItem>
<ListItem>

<Para>
In addition to creating a DLL, the <Option>--mk-dll</Option> option will also
create an import library. The import library name is derived from the
name of the DLL, as follows:

<ProgramListing>
DLL: HScool.dll  ==&#62; import lib: libHScool_imp.a
</ProgramListing>


The naming scheme may look a bit weird, but it has the purpose of
allowing the co-existence of import libraries with ordinary static
libraries (e.g., <Filename>libHSfoo.a</Filename> and <Filename>libHSfoo&lowbar;imp.a</Filename>.

Additionally, when the compiler driver is linking in non-static mode,
it will rewrite occurrence of <Option>-lHSfoo</Option> on the command line to
<Option>-lHSfoo&lowbar;imp</Option>. By doing this for you, switching from non-static
to static linking is simply a question of adding <Option>-static</Option> to
your command line.

</Para>
</ListItem>

</ItemizedList>

</Para>

</Sect1>

</Chapter>

<!-- Emacs stuff:
     ;;; Local Variables: ***
     ;;; mode: sgml ***
     ;;; sgml-parent-document: ("users_guide.sgml" "book" "chapter") ***
     ;;; End: ***
 -->
