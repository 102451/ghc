% both concurrent and parallel
%************************************************************************
%*                                                                      *
<sect1>Concurrent and Parallel Haskell
<label id="concurrent-and-parallel">
<p>
<nidx>Concurrent Haskell</nidx>
<nidx>Parallel Haskell</nidx>
%*                                                                      *
%************************************************************************

Concurrent and Parallel Haskell are Glasgow extensions to Haskell
which let you structure your program as a group of independent
`threads'.

Concurrent and Parallel Haskell have very different purposes.

Concurrent Haskell is for applications which have an inherent
structure of interacting, concurrent tasks (i.e. `threads').  Threads
in such programs may be <em>required</em>.  For example, if a concurrent
thread has been spawned to handle a mouse click, it isn't
optional---the user wants something done!

A Concurrent Haskell program implies multiple `threads' running within
a single Unix process on a single processor.

You will find at least one paper about Concurrent Haskell hanging off
of <url name="Simon Peyton Jones's Web page"
url="http://www.dcs.gla.ac.uk/~simonpj/">.

Parallel Haskell is about <em>speed</em>---spawning threads onto multiple
processors so that your program will run faster.  The `threads'
are always <em>advisory</em>---if the runtime system thinks it can
get the job done more quickly by sequential execution, then fine.

A Parallel Haskell program implies multiple processes running on
multiple processors, under a PVM (Parallel Virtual Machine) framework.

Parallel Haskell is still relatively new; it is more about ``research
fun'' than about ``speed.'' That will change.

Again, check Simon's Web page for publications about Parallel Haskell
(including ``GUM'', the key bits of the runtime system).

Some details about Parallel Haskell follow.  For more information
about concurrent Haskell, see the Concurrent section in the <htmlurl
name="GHC/Hugs Extension Libraries" url="libs.html"> documentation.

%************************************************************************
%*                                                                      *
<sect2>Features specific to Parallel Haskell
<nidx>Parallel Haskell---features</nidx>
<p>
%*                                                                      *
%************************************************************************

%************************************************************************
%*                                                                      *
<sect3>The @Parallel@ interface (recommended)
<nidx>Parallel interface</nidx>
<p>
%*                                                                      *
%************************************************************************

GHC provides two functions for controlling parallel execution, through
the @Parallel@ interface:

<tscreen><verb>
interface Parallel where
infixr 0 `par`
infixr 1 `seq`

par :: a -> b -> b
seq :: a -> b -> b
</verb></tscreen>

The expression @(x `par` y)@ <em>sparks</em> the evaluation of @x@
(to weak head normal form) and returns @y@.  Sparks are queued for
execution in FIFO order, but are not executed immediately.  At the
next heap allocation, the currently executing thread will yield
control to the scheduler, and the scheduler will start a new thread
(until reaching the active thread limit) for each spark which has not
already been evaluated to WHNF.

The expression @(x `seq` y)@ evaluates @x@ to weak head normal
form and then returns @y@.  The @seq@ primitive can be used to
force evaluation of an expression beyond WHNF, or to impose a desired
execution sequence for the evaluation of an expression.

For example, consider the following parallel version of our old
nemesis, @nfib@:

<tscreen><verb>
import Parallel

nfib :: Int -> Int
nfib n | n <= 1 = 1
       | otherwise = par n1 (seq n2 (n1 + n2 + 1))
                     where n1 = nfib (n-1) 
                           n2 = nfib (n-2)
</verb></tscreen>

For values of @n@ greater than 1, we use @par@ to spark a thread
to evaluate @nfib (n-1)@, and then we use @seq@ to force the
parent thread to evaluate @nfib (n-2)@ before going on to add
together these two subexpressions.  In this divide-and-conquer
approach, we only spark a new thread for one branch of the computation
(leaving the parent to evaluate the other branch).  Also, we must use
@seq@ to ensure that the parent will evaluate @n2@ <em>before</em>
@n1@ in the expression @(n1 + n2 + 1)@.  It is not sufficient to
reorder the expression as @(n2 + n1 + 1)@, because the compiler may
not generate code to evaluate the addends from left to right.

%************************************************************************
%*                                                                      *
<sect3>Underlying functions and primitives
<nidx>parallelism primitives</nidx>
<nidx>primitives for parallelism</nidx>
<p>
%*                                                                      *
%************************************************************************

The functions @par@ and @seq@ are wired into GHC, and unfold
into uses of the @par#@ and @seq#@ primitives, respectively.  If
you'd like to see this with your very own eyes, just run GHC with the
@-ddump-simpl@ option.  (Anything for a good time...)

%************************************************************************
%*                                                                      *
<sect3>Scheduling policy for concurrent/parallel threads
<nidx>Scheduling---concurrent/parallel</nidx>
<nidx>Concurrent/parallel scheduling</nidx>
<p>
%*                                                                      *
%************************************************************************

Runnable threads are scheduled in round-robin fashion.  Context
switches are signalled by the generation of new sparks or by the
expiry of a virtual timer (the timer interval is configurable with the
@-C[<num>]@<nidx>-C&lt;num&gt; RTS option (concurrent,
parallel)</nidx> RTS option).  However, a context switch doesn't
really happen until the current heap block is full.  You can't get any
faster context switching than this.

When a context switch occurs, pending sparks which have not already
been reduced to weak head normal form are turned into new threads.
However, there is a limit to the number of active threads (runnable or
blocked) which are allowed at any given time.  This limit can be
adjusted with the @-t<num>@<nidx>-t &lt;num&gt; RTS option (concurrent, parallel)</nidx>
RTS option (the default is 32).  Once the
thread limit is reached, any remaining sparks are deferred until some
of the currently active threads are completed.
