%
% (c) The GRASP/AQUA Project, Glasgow University, 1992-1998
%
\section[TcIfaceSig]{Type checking of type signatures in interface files}

\begin{code}
module TcIfaceSig ( tcInterfaceSigs ) where

#include "HsVersions.h"

import HsSyn		( HsDecl(..), IfaceSig(..) )
import TcMonad
import TcMonoType	( tcHsType, tcHsTypeKind, 
				-- NB: all the tyars in interface files are kinded,
				-- so tcHsType will do the Right Thing without
				-- having to mess about with zonking
			  tcExtendTyVarScope
			)
import TcEnv		( ValueEnv, tcExtendTyVarEnv, 
			  tcExtendGlobalValEnv, tcSetValueEnv,
			  tcLookupTyConByKey, tcLookupValueMaybe,
			  explicitLookupValue, badCon, badPrimOp
			)
import TcType		( TcKind, kindToTcKind )

import RnHsSyn		( RenamedHsDecl )
import HsCore
import HsDecls		( HsIdInfo(..), HsStrictnessInfo(..) )
import CallConv		( cCallConv )
import Const		( Con(..), Literal(..) )
import CoreSyn
import CoreUtils	( coreExprType )
import CoreUnfold
import CoreLint		( lintUnfolding )
import WwLib		( mkWrapper )
import PrimOp		( PrimOp(..) )

import Id		( Id, mkImportedId, mkUserId,
			  isPrimitiveId_maybe, isDataConId_maybe
			)
import IdInfo
import DataCon		( dataConSig, dataConArgTys )
import SpecEnv		( addToSpecEnv )
import Type		( mkSynTy, mkTyVarTys, splitAlgTyConApp )
import Var		( IdOrTyVar, mkTyVar, tyVarKind )
import VarEnv
import Name		( Name, NamedThing(..) )
import Unique		( rationalTyConKey )
import TysWiredIn	( integerTy, stringTy )
import ErrUtils		( pprBagOfErrors )
import Maybes		( maybeToBool, MaybeErr(..) )
import Outputable	
import Util		( zipWithEqual )
\end{code}

Ultimately, type signatures in interfaces will have pragmatic
information attached, so it is a good idea to have separate code to
check them.

As always, we do not have to worry about user-pragmas in interface
signatures.

\begin{code}
tcInterfaceSigs :: ValueEnv		-- Envt to use when checking unfoldings
		-> [RenamedHsDecl]	-- Ignore non-sig-decls in these decls
		-> TcM s [Id]
		

tcInterfaceSigs unf_env (SigD (IfaceSig name ty id_infos src_loc) : rest)
  = tcAddSrcLoc src_loc (
    tcAddErrCtxt (ifaceSigCtxt name) (
	tcHsType ty						`thenTc` \ sigma_ty ->
	tcIdInfo unf_env name sigma_ty noIdInfo id_infos	`thenTc` \ id_info ->
	returnTc (mkImportedId name sigma_ty id_info)
    ))						`thenTc` \ sig_id ->
    tcInterfaceSigs unf_env rest		`thenTc` \ sig_ids ->
    returnTc (sig_id : sig_ids)

tcInterfaceSigs unf_env (other_decl : rest) = tcInterfaceSigs unf_env rest

tcInterfaceSigs unf_env [] = returnTc []
\end{code}

\begin{code}
tcIdInfo unf_env name ty info info_ins
  = foldlTc tcPrag noIdInfo info_ins
  where
    tcPrag info (HsArity arity) = returnTc (arity `setArityInfo` info)
    tcPrag info (HsUpdate upd)  = returnTc (upd   `setUpdateInfo` info)
    tcPrag info (HsNoCafRefs)   = returnTc (NoCafRefs `setCafInfo` info)
    tcPrag info (HsCprInfo cpr_info)     = returnTc (cpr_info `setCprInfo` info)

    tcPrag info (HsUnfold inline_prag maybe_expr)
	= (case maybe_expr of
		Just expr -> tcPragExpr unf_env name [] expr
		Nothing   -> returnNF_Tc Nothing
	  )				 	`thenNF_Tc` \ maybe_expr' ->
	  let
		-- maybe_expr doesn't get looked at if the unfolding
		-- is never inspected; so the typecheck doesn't even happen
		unfold_info = case maybe_expr' of
				Nothing    -> NoUnfolding
				Just expr' -> mkUnfolding expr' 
		info1 = unfold_info `setUnfoldingInfo` info

		info2 = inline_prag `setInlinePragInfo` info1
	  in
	  returnTc info2

    tcPrag info (HsStrictness strict)
	= tcStrictness unf_env ty info strict

    tcPrag info (HsSpecialise tyvars tys rhs)
	= tcExtendTyVarScope tyvars		$ \ tyvars' ->
	  mapAndUnzipTc tcHsTypeKind tys	`thenTc` \ (kinds, tys') -> 
		-- Assume that the kinds match the kinds of the 
		-- type variables of the function; this is, after all, an
		-- interface file generated by the compiler!

	  tcPragExpr unf_env name tyvars' rhs	`thenNF_Tc` \ maybe_rhs' ->
	  let
		-- If spec_env isn't looked at, none of this 
		-- actually takes place
	    spec_env  = specInfo info
 	    spec_env' = case maybe_rhs' of
			  Nothing -> spec_env
			  Just rhs' -> case addToSpecEnv True {- overlap ok -} spec_env tyvars' tys' rhs' of
					  Succeeded spec_env' -> spec_env'
					  Failed err	      -> pprTrace "tcIdInfo: bad specialisation"
							  	 	  (ppr name <+> ppr err) $
								 spec_env
	  in
	  returnTc (spec_env' `setSpecInfo` info)
\end{code}

\begin{code}
tcStrictness unf_env ty info (HsStrictnessInfo (demands, bot_result) maybe_worker)
  = tcWorker unf_env maybe_worker		`thenNF_Tc` \ maybe_worker_id ->
    -- We are relying here on cpr info always appearing before strictness info
    -- fingers crossed ....
    uniqSMToTcM (mkWrapper ty demands (cprInfo info))
      		                                `thenNF_Tc` \ wrap_fn ->
    let
	-- Watch out! We can't pull on maybe_worker_id too eagerly!
	info' = case maybe_worker_id of
			Just worker_id -> setUnfoldingInfo (mkUnfolding (wrap_fn worker_id)) $
                                          setWorkerInfo (Just worker_id) $
					  setInlinePragInfo IWantToBeINLINEd info

			Nothing        -> info

	has_worker = maybeToBool maybe_worker_id
    in
    returnTc (StrictnessInfo demands bot_result `setStrictnessInfo` info')
\end{code}

\begin{code}
tcWorker unf_env Nothing = returnNF_Tc Nothing

tcWorker unf_env (Just (worker_name,_))
  = returnNF_Tc (trace_maybe maybe_worker_id)
  where
    maybe_worker_id = explicitLookupValue unf_env worker_name

	-- The trace is so we can see what's getting dropped
    trace_maybe Nothing  = pprTrace "tcWorker failed:" (ppr worker_name) Nothing
    trace_maybe (Just x) = Just x
\end{code}

For unfoldings we try to do the job lazily, so that we never type check
an unfolding that isn't going to be looked at.

\begin{code}
tcPragExpr :: ValueEnv -> Name -> [IdOrTyVar] -> UfExpr Name -> NF_TcM s (Maybe CoreExpr)
tcPragExpr unf_env name in_scope_vars core_expr
  = forkNF_Tc (
	recoverNF_Tc no_unfolding (
		tcSetValueEnv unf_env $
		tcCoreExpr core_expr	`thenTc` \ core_expr' ->

		-- Check for type consistency in the unfolding
		tcGetSrcLoc		`thenNF_Tc` \ src_loc -> 
		returnTc (lintUnfolding src_loc in_scope_vars core_expr')
    ))			
  where
	-- The trace tells what wasn't available, for the benefit of
	-- compiler hackers who want to improve it!
    no_unfolding = getErrsTc		`thenNF_Tc` \ (warns,errs) ->
		   returnNF_Tc (pprTrace "tcUnfolding failed with:" 
				   	 (hang (ppr name) 4 (pprBagOfErrors errs))
					 Nothing)
\end{code}


Variables in unfoldings
~~~~~~~~~~~~~~~~~~~~~~~
****** Inside here we use only the Global environment, even for locally bound variables.
****** Why? Because we know all the types and want to bind them to real Ids.

\begin{code}
tcVar :: Name -> TcM s Id
tcVar name
  = tcLookupValueMaybe name	`thenNF_Tc` \ maybe_id ->
    case maybe_id of {
	Just id -> returnTc id;
	Nothing -> failWithTc (noDecl name)
    }

noDecl name = hsep [ptext SLIT("Warning: no binding for"), ppr name]
\end{code}

UfCore expressions.

\begin{code}
tcCoreExpr :: UfExpr Name -> TcM s CoreExpr

tcCoreExpr (UfType ty)
  = tcHsTypeKind ty	`thenTc` \ (_, ty') ->
	-- It might not be of kind type
    returnTc (Type ty')

tcCoreExpr (UfVar name)
  = tcVar name 	`thenTc` \ id ->
    returnTc (Var id)

tcCoreExpr (UfCon con args) 
  = tcUfCon con			`thenTc` \ con' ->
    mapTc tcCoreExpr args	`thenTc` \ args' ->
    returnTc (Con con' args')

tcCoreExpr (UfTuple name args) 
  = tcUfDataCon name		`thenTc` \ con ->
    mapTc tcCoreExpr args	`thenTc` \ args' ->
    let
	-- Put the missing type arguments back in
	con_args = map (Type . coreExprType) args' ++ args'
    in
    returnTc (Con con con_args)

tcCoreExpr (UfLam bndr body)
  = tcCoreLamBndr bndr 		$ \ bndr' ->
    tcCoreExpr body		`thenTc` \ body' ->
    returnTc (Lam bndr' body')

tcCoreExpr (UfApp fun arg)
  = tcCoreExpr fun		`thenTc` \ fun' ->
    tcCoreExpr arg		`thenTc` \ arg' ->
    returnTc (App fun' arg')

tcCoreExpr (UfCase scrut case_bndr alts) 
  = tcCoreExpr scrut					`thenTc` \ scrut' ->
    let
	scrut_ty = coreExprType scrut'
	case_bndr' = mkUserId case_bndr scrut_ty
    in
    tcExtendGlobalValEnv [case_bndr']	$
    mapTc (tcCoreAlt scrut_ty) alts	`thenTc` \ alts' ->
    returnTc (Case scrut' case_bndr' alts')

tcCoreExpr (UfLet (UfNonRec bndr rhs) body)
  = tcCoreExpr rhs		`thenTc` \ rhs' ->
    tcCoreValBndr bndr 		$ \ bndr' ->
    tcCoreExpr body		`thenTc` \ body' ->
    returnTc (Let (NonRec bndr' rhs') body')

tcCoreExpr (UfLet (UfRec pairs) body)
  = tcCoreValBndrs bndrs	$ \ bndrs' ->
    mapTc tcCoreExpr rhss	`thenTc` \ rhss' ->
    tcCoreExpr body		`thenTc` \ body' ->
    returnTc (Let (Rec (bndrs' `zip` rhss')) body')
  where
    (bndrs, rhss) = unzip pairs

tcCoreExpr (UfNote note expr) 
  = tcCoreExpr expr		`thenTc` \ expr' ->
    case note of
	UfCoerce to_ty -> tcHsType to_ty	`thenTc` \ to_ty' ->
			  returnTc (Note (Coerce to_ty' (coreExprType expr')) expr')
	UfInlineCall   -> returnTc (Note InlineCall expr')
	UfSCC cc       -> returnTc (Note (SCC cc) expr')

tcCoreNote (UfSCC cc)   = returnTc (SCC cc)
tcCoreNote UfInlineCall = returnTc InlineCall 


-- rationalTy isn't built in so, we have to construct it
-- (the "ty" part of the incoming literal is simply bottom)
tcUfCon (UfLitCon (NoRepRational lit _)) 
  = tcLookupTyConByKey rationalTyConKey	`thenNF_Tc` \ rational_tycon ->
    let
	rational_ty  = mkSynTy rational_tycon []
    in
    returnTc (Literal (NoRepRational lit rational_ty)) 

-- Similarly for integers and strings, except that they are wired in
tcUfCon (UfLitCon (NoRepInteger lit _)) 
  = returnTc (Literal (NoRepInteger lit integerTy))
tcUfCon (UfLitCon (NoRepStr lit _))
  = returnTc (Literal (NoRepStr lit stringTy))

tcUfCon (UfLitCon other_lit)
  = returnTc (Literal other_lit)

-- The dreaded lit-lits are also similar, except here the type
-- is read in explicitly rather than being implicit
tcUfCon (UfLitLitCon lit ty)
  = tcHsType ty		`thenTc` \ ty' ->
    returnTc (Literal (MachLitLit lit ty'))

tcUfCon (UfDataCon name) = tcUfDataCon name

tcUfCon (UfPrimOp name)
  = tcVar name		`thenTc` \ op_id ->
    case isPrimitiveId_maybe op_id of
	Just op -> returnTc (PrimOp op)
	Nothing -> failWithTc (badPrimOp name)

tcUfCon (UfCCallOp str is_dyn casm gc)
  = case is_dyn of
       True  -> 
          tcGetUnique `thenNF_Tc` \ u ->
	  returnTc (PrimOp (CCallOp (Right u) casm gc cCallConv))
       False -> returnTc (PrimOp (CCallOp (Left str) casm gc cCallConv))

tcUfDataCon name
  = tcVar name		`thenTc` \ con_id ->
    case isDataConId_maybe con_id of
	Just con -> returnTc (DataCon con)
	Nothing  -> failWithTc (badCon name)
\end{code}

\begin{code}
tcCoreLamBndr (UfValBinder name ty) thing_inside
  = tcHsType ty			`thenTc` \ ty' ->
    let
	id = mkUserId name ty'
    in
    tcExtendGlobalValEnv [id] $
    thing_inside id
    
tcCoreLamBndr (UfTyBinder name kind) thing_inside
  = let
	tyvar = mkTyVar name kind
    in
    tcExtendTyVarEnv [tyvar] (thing_inside tyvar)
    
tcCoreValBndr (UfValBinder name ty) thing_inside
  = tcHsType ty			`thenTc` \ ty' ->
    let
	id = mkUserId name ty'
    in
    tcExtendGlobalValEnv [id] $
    thing_inside id
    
tcCoreValBndrs bndrs thing_inside		-- Expect them all to be ValBinders
  = mapTc tcHsType tys			`thenTc` \ tys' ->
    let
	ids = zipWithEqual "tcCoreValBndr" mkUserId names tys'
    in
    tcExtendGlobalValEnv ids $
    thing_inside ids
  where
    names = [name | UfValBinder name _  <- bndrs]
    tys   = [ty   | UfValBinder _    ty <- bndrs]
\end{code}    

\begin{code}
tcCoreAlt scrut_ty (UfDefault, names, rhs)
  = ASSERT( null names )
    tcCoreExpr rhs		`thenTc` \ rhs' ->
    returnTc (DEFAULT, [], rhs')
  
tcCoreAlt scrut_ty (UfLitCon lit, names, rhs)
  = ASSERT( null names )
    tcCoreExpr rhs		`thenTc` \ rhs' ->
    returnTc (Literal lit, [], rhs')

tcCoreAlt scrut_ty (UfLitLitCon str ty, names, rhs)
  = ASSERT( null names )
    tcCoreExpr rhs		`thenTc` \ rhs' ->
    tcHsType ty			`thenTc` \ ty' ->
    returnTc (Literal (MachLitLit str ty'), [], rhs')

-- A case alternative is made quite a bit more complicated
-- by the fact that we omit type annotations because we can
-- work them out.  True enough, but its not that easy!
tcCoreAlt scrut_ty (UfDataCon con_name, names, rhs)
  = tcVar con_name		`thenTc` \ con_id ->
    let
	con			= case isDataConId_maybe con_id of
					Just con -> con
					Nothing  -> pprPanic "tcCoreAlt" (ppr con_id)

	(main_tyvars, _, ex_tyvars, _, _, _) = dataConSig con

	(tycon, inst_tys, cons) = splitAlgTyConApp scrut_ty
	ex_tyvars'		= [mkTyVar name (tyVarKind tv) | (name,tv) <- names `zip` ex_tyvars] 
	ex_tys'			= mkTyVarTys ex_tyvars'
	arg_tys			= dataConArgTys con (inst_tys ++ ex_tys')
	id_names		= drop (length ex_tyvars) names
	arg_ids
#ifdef DEBUG
		| length id_names /= length arg_tys
		= pprPanic "tcCoreAlts" (ppr (con_name, names, rhs) $$
					 (ppr main_tyvars <+> ppr ex_tyvars) $$
					 ppr arg_tys)
		| otherwise
#endif
		= zipWithEqual "tcCoreAlts" mkUserId id_names arg_tys
    in
    ASSERT( con `elem` cons && length inst_tys == length main_tyvars )
    tcExtendTyVarEnv ex_tyvars'			$
    tcExtendGlobalValEnv arg_ids		$
    tcCoreExpr rhs					`thenTc` \ rhs' ->
    returnTc (DataCon con, ex_tyvars' ++ arg_ids, rhs')
\end{code}

\begin{code}
ifaceSigCtxt sig_name
  = hsep [ptext SLIT("In an interface-file signature for"), ppr sig_name]
\end{code}

