{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface FiniteMap where
import Maybes(Labda)
import Outputable(Outputable)
data FiniteMap a b 
type FiniteSet a = FiniteMap a ()
data Labda a 
addListToFM :: Ord a => FiniteMap a b -> [(a, b)] -> FiniteMap a b
addListToFM_C :: Ord a => (b -> b -> b) -> FiniteMap a b -> [(a, b)] -> FiniteMap a b
addToFM :: Ord a => FiniteMap a b -> a -> b -> FiniteMap a b
delListFromFM :: Ord a => FiniteMap a b -> [a] -> FiniteMap a b
elemFM :: Ord a => a -> FiniteMap a b -> Bool
elementOf :: Ord a => a -> FiniteMap a () -> Bool
eltsFM :: FiniteMap a b -> [b]
emptyFM :: FiniteMap a b
emptySet :: FiniteMap a ()
fmToList :: FiniteMap a b -> [(a, b)]
isEmptyFM :: FiniteMap a b -> Bool
isEmptySet :: FiniteMap a () -> Bool
keysFM :: FiniteMap b a -> [b]
listToFM :: Ord a => [(a, b)] -> FiniteMap a b
lookupFM :: Ord a => FiniteMap a b -> a -> Labda b
lookupWithDefaultFM :: Ord a => FiniteMap a b -> b -> a -> b
minusFM :: Ord a => FiniteMap a b -> FiniteMap a b -> FiniteMap a b
minusSet :: Ord a => FiniteMap a () -> FiniteMap a () -> FiniteMap a ()
mkSet :: Ord a => [a] -> FiniteMap a ()
plusFM :: Ord a => FiniteMap a b -> FiniteMap a b -> FiniteMap a b
plusFM_C :: Ord a => (b -> b -> b) -> FiniteMap a b -> FiniteMap a b -> FiniteMap a b
setToList :: FiniteMap a () -> [a]
singletonFM :: a -> b -> FiniteMap a b
union :: Ord a => FiniteMap a () -> FiniteMap a () -> FiniteMap a ()
instance Outputable a => Outputable (FiniteMap a b)

