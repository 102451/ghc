{-# GHC_PRAGMA INTERFACE VERSION 5 #-}
interface Util where
import CharSeq(CSeq)
import Maybes(Labda(..))
import PreludePS(_PackedString)
import Pretty(Delay, Pretty(..), PrettyRep)
data Labda a   = Hamna | Ni a
type Pretty = Int -> Bool -> PrettyRep
data PrettyRep 
assertPanic :: [Char] -> Int -> a
assoc :: Eq a => [Char] -> [(a, b)] -> a -> b
cmpPString :: _PackedString -> _PackedString -> Int#
equivClasses :: (a -> a -> Int#) -> [a] -> [[a]]
hasNoDups :: Eq a => [a] -> Bool
isIn :: Eq a => [Char] -> a -> [a] -> Bool
isSingleton :: [a] -> Bool
isn'tIn :: Eq a => [Char] -> a -> [a] -> Bool
lengthExceeds :: [a] -> Int -> Bool
mapAccumB :: (b -> c -> a -> (b, c, d)) -> b -> c -> [a] -> (b, c, [d])
mapAccumL :: (b -> a -> (b, c)) -> b -> [a] -> (b, [c])
mapAccumR :: (b -> a -> (b, c)) -> b -> [a] -> (b, [c])
nOfThem :: Int -> a -> [a]
naturalMergeSortLe :: (a -> a -> Bool) -> [a] -> [a]
panic :: [Char] -> a
pprPanic :: [Char] -> (Int -> Bool -> PrettyRep) -> a
pprTrace :: [Char] -> (Int -> Bool -> PrettyRep) -> a -> a
removeDups :: (a -> a -> Int#) -> [a] -> ([a], [[a]])
runs :: (a -> a -> Bool) -> [a] -> [[a]]
sortLt :: (a -> a -> Bool) -> [a] -> [a]
transitiveClosure :: (a -> [a]) -> (a -> a -> Bool) -> [a] -> [a]
unzipWith :: (a -> b -> c) -> [(a, b)] -> [c]
zipEqual :: [a] -> [b] -> [(a, b)]

