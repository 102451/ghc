{- NOT YET DONE:


-----------------------------------------------------------------------
-- $Id: primops.txt,v 1.1 2001/02/26 15:44:59 rrt Exp $
--
-- Primitive Operations
--
-----------------------------------------------------------------------

-- To add a new primop, you currently need to update the following files:
--
--	- this file (ghc/compiler/prelude/primops.txt), which includes
--	  the type of the primop, and various other properties (its
--	  strictness attributes, whether it is defined as a macro
--	  or as out-of-line code, etc.)
--
--	- ghc/lib/std/PrelGHC.hi-boot, to declare the primop
--
--	- if the primop is inline (i.e. a macro), then:
--		ghc/includes/PrimOps.h
--		ghc/compiler/nativeGen/StixPrim.lhs
--
--	- or, for an out-of-line primop:
--	        ghc/includes/PrimOps.h (just add the declaration)
--		ghc/rts/PrimOps.hc     (define it here)
--
--	- the User's Guide
--

-- The default attribute values which apply if you don't specify
-- other ones.  Attribute values can be True, False, or arbitrary
-- text between curly brackets.  This is a kludge to enable 
-- processors of this file to easily get hold of simple info
-- (eg, out_of_line), whilst avoiding parsing complex expressions
-- needed for strictness and usage info.

defaults
   has_side_effects = False
   out_of_line      = False
   commutable       = False
   needs_wrapper    = False
   can_fail         = False
   strictness       = { \ arity -> StrictnessInfo (replicate arity wwPrim) False }
   usage            = { nomangle other }


------------------------------------------------------------------------
--- Support for the metacircular interpreter                         ---
------------------------------------------------------------------------

primop   IndexOffClosureOp_Ptr  "indexPtrOffClosure#"  GenPrimOp
   a -> Int# -> (# b #)
primop   IndexOffClosureOp_Word "indexWordOffClosure#"  GenPrimOp
   a -> Int# -> Word#


primop   Addr2IntOp  "addr2Int#"     GenPrimOp   Addr# -> Int#

primop   DoubleDecodeOp   "decodeDouble#" GenPrimOp    
   Double# -> (# Int#, Int#, ByteArr# #)
   with out_of_line = True

primop   FloatDecodeOp   "decodeFloat#" GenPrimOp
   Float# -> (# Int#, Int#, ByteArr# #)
   with out_of_line = True

primop   IntegerSubOp   "minusInteger#" GenPrimOp  
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with out_of_line = True

primop   IntegerMulOp   "timesInteger#" GenPrimOp   
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with commutable = True
        out_of_line = True

primop   IntegerGcdOp   "gcdInteger#" GenPrimOp    
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with commutable = True
        out_of_line = True

primop   IntegerIntGcdOp   "gcdIntegerInt#" GenPrimOp
   Int# -> ByteArr# -> Int# -> Int#
   with commutable = True

primop   IntegerDivExactOp   "divExactInteger#" GenPrimOp
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with out_of_line = True

primop   IntegerQuotOp   "quotInteger#" GenPrimOp
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with out_of_line = True

primop   IntegerRemOp   "remInteger#" GenPrimOp
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr# #)
   with out_of_line = True

primop   IntegerCmpOp   "cmpInteger#"   GenPrimOp  
   Int# -> ByteArr# -> Int# -> ByteArr# -> Int#
   with needs_wrapper = True

primop   IntegerCmpIntOp   "cmpIntegerInt#" GenPrimOp
   Int# -> ByteArr# -> Int# -> Int#
   with needs_wrapper = True

primop   IntegerQuotRemOp   "quotRemInteger#" GenPrimOp
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr#, Int#, ByteArr# #)
   with can_fail = True
        out_of_line = True

primop   IntegerDivModOp    "divModInteger#"  GenPrimOp
   Int# -> ByteArr# -> Int# -> ByteArr# -> (# Int#, ByteArr#, Int#, ByteArr# #)
   with can_fail = True
        out_of_line = True

primop   Integer2IntOp   "integer2Int#"    GenPrimOp
   Int# -> ByteArr# -> Int#
   with needs_wrapper = True

primop   Integer2WordOp   "integer2Word#"   GenPrimOp
   Int# -> ByteArr# -> Word#
   with needs_wrapper = True

primop   IntegerToInt64Op   "integerToInt64#" GenPrimOp
   Int# -> ByteArr# -> Int64#

primop   IntegerToWord64Op   "integerToWord64#" GenPrimOp
   Int# -> ByteArr# -> Word64#

------------------------------------------------------------------------
--- Arrays                                                           ---
------------------------------------------------------------------------

primop  NewByteArrayOp_Char "newCharArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_Int "newIntArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_Word "newWordArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_Addr "newAddrArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_Float "newFloatArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_Double "newDoubleArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True

primop  NewByteArrayOp_StablePtr "newStablePtrArray#" GenPrimOp
   Int# -> State# s -> (# State# s, MutByteArr# s #)
   with out_of_line = True



primop  ReadByteArrayOp_Char "readCharArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Char# #)

primop  ReadByteArrayOp_Int "readIntArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Int# #)

primop  ReadByteArrayOp_Word "readWordArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Word# #)

primop  ReadByteArrayOp_Addr "readAddrArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Addr# #)

primop  ReadByteArrayOp_Float "readFloatArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Float# #)

primop  ReadByteArrayOp_Double "readDoubleArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Double# #)

primop  ReadByteArrayOp_StablePtr "readStablePtrArray#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, StablePtr# a #)

primop  ReadByteArrayOp_Int64 "readInt64Array#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Int64# #)

primop  ReadByteArrayOp_Word64 "readWord64Array#" GenPrimOp
   MutByteArr# s -> Int# -> State# s -> (# State# s, Word64# #)



primop  WriteByteArrayOp_Char "writeCharArray#" GenPrimOp
   MutByteArr# s -> Int# -> Char# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Int "writeIntArray#" GenPrimOp
   MutByteArr# s -> Int# -> Int# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Word "writeWordArray#" GenPrimOp
   MutByteArr# s -> Int# -> Word# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Addr "writeAddrArray#" GenPrimOp
   MutByteArr# s -> Int# -> Addr# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Float "writeFloatArray#" GenPrimOp
   MutByteArr# s -> Int# -> Float# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Double "writeDoubleArray#" GenPrimOp
   MutByteArr# s -> Int# -> Double# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_StablePtr "writeStablePtrArray#" GenPrimOp
   MutByteArr# s -> Int# -> StablePtr# a -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Int64 "writeInt64Array#" GenPrimOp
   MutByteArr# s -> Int# -> Int64# -> State# s -> State# s
   with has_side_effects = True

primop  WriteByteArrayOp_Word64 "writeWord64Array#" GenPrimOp
   MutByteArr# s -> Int# -> Word64# -> State# s -> State# s
   with has_side_effects = True


primop IndexByteArrayOp_Char "indexCharArray#" GenPrimOp
   ByteArr# -> Int# -> Char#

primop IndexByteArrayOp_Int "indexIntArray#" GenPrimOp
   ByteArr# -> Int# -> Int#

primop IndexByteArrayOp_Word "indexWordArray#" GenPrimOp
   ByteArr# -> Int# -> Word#

primop IndexByteArrayOp_Addr "indexAddrArray#" GenPrimOp
   ByteArr# -> Int# -> Addr#

primop IndexByteArrayOp_Float "indexFloatArray#" GenPrimOp
   ByteArr# -> Int# -> Float#

primop IndexByteArrayOp_Double "indexDoubleArray#" GenPrimOp
   ByteArr# -> Int# -> Double#

primop IndexByteArrayOp_StablePtr "indexStablePtrArray#" GenPrimOp
   ByteArr# -> Int# -> StablePtr# a

primop IndexByteArrayOp_Int64 "indexInt64Array#" GenPrimOp
   ByteArr# -> Int# -> Int64#

primop IndexByteArrayOp_Word64 "indexWord64Array#" GenPrimOp
   ByteArr# -> Int# -> Word64#




primop ReadOffAddrOp_Char "readCharOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Char# #)

primop ReadOffAddrOp_Int "readIntOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Int# #)

primop ReadOffAddrOp_Word "readWordOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Word# #)

primop ReadOffAddrOp_Addr "readAddrOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Addr# #)

primop ReadOffAddrOp_Float "readFloatOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Float# #)

primop ReadOffAddrOp_Double "readDoubleOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Double# #)

primop ReadOffAddrOp_StablePtr "readStablePtrOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, StablePtr# a #)

primop ReadOffAddrOp_ForeignObj "readForeignObjOffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, ForeignObj# #)

primop ReadOffAddrOp_Int64 "readInt64OffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Int64# #)

primop ReadOffAddrOp_Word64 "readWord64OffAddr#" GenPrimOp
   Addr# -> Int# -> State# s -> (# State# s, Word64# #)


primop  WriteOffAddrOp_Char "writeCharOffAddr#" GenPrimOp
   Addr# -> Int# -> Char# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Int "writeIntOffAddr#" GenPrimOp
   Addr# -> Int# -> Int# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Word "writeWordOffAddr#" GenPrimOp
   Addr# -> Int# -> Word# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Addr "writeAddrOffAddr#" GenPrimOp
   Addr# -> Int# -> Addr# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Float "writeFloatOffAddr#" GenPrimOp
   Addr# -> Int# -> Float# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Double "writeDoubleOffAddr#" GenPrimOp
   Addr# -> Int# -> Double# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_StablePtr "writeStablePtrOffAddr#" GenPrimOp
   Addr# -> Int# -> StablePtr# a -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_ForeignObj "writeForeignObjOffAddr#" GenPrimOp
   Addr# -> Int# -> ForeignObj# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Int64 "writeInt64OffAddr#" GenPrimOp
   Addr# -> Int# -> Int64# -> State# s -> State# s
   with has_side_effects = True

primop  WriteOffAddrOp_Word64 "writeWord64OffAddr#" GenPrimOp
   Addr# -> Int# -> Word64# -> State# s -> State# s
   with has_side_effects = True



primop  NewArrayOp "newArray#" GenPrimOp
   Int# -> a -> State# s -> (# State# s, MutArr# s a #)
   with
   strictness  = { \ arity -> StrictnessInfo [wwPrim, wwLazy, wwPrim] False }
   usage       = { mangle NewArrayOp [mkP, mkM, mkP] mkM }
   out_of_line = True

primop  SameMutableArrayOp "sameMutableArray#" GenPrimOp
   MutArr# s a -> MutArr# s a -> Bool
   with
   usage = { mangle SameMutableArrayOp [mkP, mkP] mkM }

primop  SameMutableByteArrayOp "sameMutableByteArray#" GenPrimOp
   MutByteArr# s -> MutByteArr# s -> Bool

primop  ReadArrayOp "readArray#" GenPrimOp
   MutArr# s a -> Int# -> State# s -> (# State# s, a #)
   with
   usage = { mangle ReadArrayOp [mkM, mkP, mkP] mkM }

primop  WriteArrayOp "writeArray#" GenPrimOp
   MutArr# s a -> Int# -> a -> State# s -> State# s
   with
   usage            = { mangle WriteArrayOp [mkM, mkP, mkM, mkP] mkR }
   strictness       = { \ arity -> StrictnessInfo [wwPrim, wwPrim, wwLazy, wwPrim] False }
   has_side_effects = True

primop  IndexArrayOp "indexArray#" GenPrimOp
   Array# a -> Int# -> (# a #)
   with
   usage = { mangle  IndexArrayOp [mkM, mkP] mkM }

primop  UnsafeFreezeArrayOp "unsafeFreezeArray#" GenPrimOp
   MutArr# s a -> State# s -> (# State# s, Array# a #)
   with
   usage            = { mangle UnsafeFreezeArrayOp [mkM, mkP] mkM }
   has_side_effects = True

primop  UnsafeFreezeByteArrayOp "unsafeFreezeByteArray#" GenPrimOp
   MutByteArr# s -> State# s -> (# State# s, ByteArr# #)
   with
   has_side_effects = True

primop  UnsafeThawArrayOp  "unsafeThawArray#" GenPrimOp
   Array# a -> State# s -> (# State# s, MutArr# s a #)
   with
   usage       = { mangle UnsafeThawArrayOp [mkM, mkP] mkM }
   out_of_line = True

primop  SizeofByteArrayOp "sizeofByteArray#" GenPrimOp  
   ByteArr# -> Int#

primop  SizeofMutableByteArrayOp "sizeofMutableByteArray#" GenPrimOp
   MutByteArr# s -> Int#

------------------------------------------------------------------------
--- Mutable variables                                                ---
------------------------------------------------------------------------

primop  NewMutVarOp "newMutVar#" GenPrimOp
   a -> State# s -> (# State# s, MutVar# s a #)
   with
   usage       = { mangle NewMutVarOp [mkM, mkP] mkM }
   strictness  = { \ arity -> StrictnessInfo [wwLazy, wwPrim] False }
   out_of_line = True

primop  ReadMutVarOp "readMutVar#" GenPrimOp
   MutVar# s a -> State# s -> (# State# s, a #)
   with
   usage = { mangle ReadMutVarOp [mkM, mkP] mkM }

primop  WriteMutVarOp "writeMutVar#"  GenPrimOp
   MutVar# s a -> a -> State# s -> State# s
   with
   strictness       = { \ arity -> StrictnessInfo [wwPrim, wwLazy, wwPrim] False }
   usage            = { mangle WriteMutVarOp [mkM, mkM, mkP] mkR }
   has_side_effects = True

primop  SameMutVarOp "sameMutVar#" GenPrimOp
   MutVar# s a -> MutVar# s a -> Bool
   with
   usage = { mangle SameMutVarOp [mkP, mkP] mkM }

------------------------------------------------------------------------
--- Exceptions                                                       ---
------------------------------------------------------------------------

primop  CatchOp "catch#" GenPrimOp
          (State# RealWorld -> (# State# RealWorld, a #) )
       -> (b -> State# RealWorld -> (# State# RealWorld, a #) ) 
       -> State# RealWorld
       -> (# State# RealWorld, a #)
   with
   strictness = { \ arity -> StrictnessInfo [wwLazy, wwLazy, wwPrim] False }
	-- Catch is actually strict in its first argument
	-- but we don't want to tell the strictness
	-- analyser about that!
   usage = { mangle CatchOp [mkM, mkM . (inFun CatchOp mkM mkM), mkP] mkM }
        --     [mkO, mkO . (inFun mkM mkO)] mkO
        -- might use caught action multiply
   out_of_line = True

primop  RaiseOp "raise#" GenPrimOp
   a -> b
   with
   strictness  = { \ arity -> StrictnessInfo [wwLazy] True }
      -- NB: True => result is bottom
   usage       = { mangle RaiseOp [mkM] mkM }
   out_of_line = True

primop  BlockAsyncExceptionsOp "blockAsyncExceptions#" GenPrimOp
        (State# RealWorld -> (# State# RealWorld, a #))
     -> (State# RealWorld -> (# State# RealWorld, a #))
   with
   strictness  = { \ arity -> StrictnessInfo [wwLazy] False }
   out_of_line = True

primop  UnblockAsyncExceptionsOp "unblockAsyncExceptions#" GenPrimOp
        (State# RealWorld -> (# State# RealWorld, a #))
     -> (State# RealWorld -> (# State# RealWorld, a #))
   with
   strictness  = { \ arity -> StrictnessInfo [wwLazy] False }
   out_of_line = True

------------------------------------------------------------------------
--- MVars (not the same as mutable variables!)                       ---
------------------------------------------------------------------------

primop  NewMVarOp "newMVar#"  GenPrimOp
   State# s -> (# State# s, MVar# s a #)
   with
   usage       = { mangle NewMVarOp [mkP] mkR }
   out_of_line = True

primop  TakeMVarOp "takeMVar#" GenPrimOp
   MVar# s a -> State# s -> (# State# s, a #)
   with
   usage            = { mangle TakeMVarOp [mkM, mkP] mkM }
   has_side_effects = True
   out_of_line      = True

primop  PutMVarOp "putMVar#" GenPrimOp
   MVar# s a -> a -> State# s -> State# s
   with
   strictness       = { \ arity -> StrictnessInfo [wwPrim, wwLazy, wwPrim] False }
   usage            = { mangle PutMVarOp [mkM, mkM, mkP] mkR }
   has_side_effects = True
   out_of_line      = True

primop  SameMVarOp "sameMVar#" GenPrimOp
   MVar# s a -> MVar# s a -> Bool
   with
   usage = { mangle SameMVarOp [mkP, mkP] mkM }

primop  TakeMaybeMVarOp "tryTakeMVar#" GenPrimOp
   MVar# s a -> State# s -> (# State# s, Int#, a #)
   with
   usage            = { mangle TakeMaybeMVarOp [mkM, mkP] mkM }
   has_side_effects = True
   out_of_line      = True

primop  IsEmptyMVarOp "isEmptyMVar#" GenPrimOp
   MVar# s a -> State# s -> (# State# s, Int# #)
   with
   usage = { mangle IsEmptyMVarOp [mkP, mkP] mkM }


------------------------------------------------------------------------
--- delay/wait operations                                            ---
------------------------------------------------------------------------

primop  DelayOp "delay#" GenPrimOp
   Int# -> State# s -> State# s
   with
   needs_wrapper    = True
   has_side_effects = True
   out_of_line      = True

primop  WaitReadOp "waitRead#" GenPrimOp
   Int# -> State# s -> State# s
   with
   needs_wrapper    = True
   has_side_effects = True
   out_of_line      = True

primop  WaitWriteOp "waitWrite#" GenPrimOp
   Int# -> State# s -> State# s
   with
   needs_wrapper    = True
   has_side_effects = True
   out_of_line      = True

------------------------------------------------------------------------
--- concurrency primitives                                           ---
------------------------------------------------------------------------

primop  ForkOp "fork#" GenPrimOp
   a -> State# RealWorld -> (# State# RealWorld, ThreadId# #)
   with
   usage            = { mangle ForkOp [mkO, mkP] mkR }
   strictness       = { \ arity -> StrictnessInfo [wwLazy, wwPrim] False }
   has_side_effects = True
   out_of_line      = True

primop  KillThreadOp "killThread#"  GenPrimOp
   ThreadId# -> a -> State# RealWorld -> State# RealWorld
   with
   usage            = { mangle KillThreadOp [mkP, mkM, mkP] mkR }
   has_side_effects = True
   out_of_line      = True

primop  YieldOp "yield#" GenPrimOp
   State# RealWorld -> State# RealWorld
   with
   has_side_effects = True
   out_of_line      = True

primop  MyThreadIdOp "myThreadId#" GenPrimOp
    State# RealWorld -> (# State# RealWorld, ThreadId# #)

------------------------------------------------------------------------
--- foreign objects                                                  ---
------------------------------------------------------------------------

primop  MkForeignObjOp "mkForeignObj#" GenPrimOp
   Addr# -> State# RealWorld -> (# State# RealWorld, ForeignObj# #)
   with
   has_side_effects = True
   out_of_line      = True

primop  WriteForeignObjOp "writeForeignObj#" GenPrimOp
   ForeignObj# -> Addr# -> State# s -> State# s
   with
   has_side_effects = True

primop ForeignObjToAddrOp "foreignObjToAddr#" GenPrimOp
   ForeignObj# -> Addr#

primop TouchOp "touch#" GenPrimOp
   o -> State# RealWorld -> State# RealWorld
   with
   strictness       = { \ arity -> StrictnessInfo [wwLazy, wwPrim] False }

------------------------------------------------------------------------
--- Bytecode objects                                                 ---
------------------------------------------------------------------------

primop  NewBCOOp "newBCO#" GenPrimOp
   Int# -> Int# -> Int# -> a -> State# RealWorld -> (# State# RealWorld, BCO# #)
   with
   has_side_effects = True
   out_of_line      = True
   strictness       = { \ arity -> StrictnessInfo 
                                   [wwPrim, wwPrim, wwPrim, wwLazy, wwPrim] False }
   usage            = { mangle NewBCOOp [mkP, mkP, mkP, mkM, mkP] mkR }

primop  WriteBCOPtrOp "writeBCOPtr#" GenPrimOp
   BCO# -> Int# -> o -> State# RealWorld -> State# RealWorld
   with
   usage            = { mangle WriteBCOPtrOp [mkP, mkP, mkM, mkP] mkR }
   strictness       = { \ arity -> StrictnessInfo 
                                   [wwPrim, wwPrim, wwLazy, wwPrim] False }
   has_side_effects = True

primop  WriteBCONonPtrOp "writeBCONonPtr#" GenPrimOp
   BCO# -> Int# -> Word# -> State# RealWorld -> State# RealWorld
   with
   has_side_effects = True

primop  WriteBCOInstrOp "writeBCOInstr#" GenPrimOp
   BCO# -> Int# -> Word# -> State# RealWorld -> State# RealWorld
   with
   has_side_effects = True

primop  ReadBCOPtrOp "readBCOPtr#"  GenPrimOp
   BCO# -> Int# -> State# RealWorld -> (# State# RealWorld, Word# #)
   with
   usage = { mangle ReadBCOPtrOp [mkP, mkP] mkM }

primop  ReadBCONonPtrOp "readBCONonPtr#"  GenPrimOp
   BCO# -> Int# -> State# RealWorld -> (# State# RealWorld, Word# #)

primop  ReadBCOInstrOp "readBCOInstr#" GenPrimOp
   BCO# -> Int# -> State# RealWorld -> (# State# RealWorld, Word# #)

primop  SameBCOOp "sameBCO#" GenPrimOp
   BCO# -> BCO# -> Bool
   with
   -- is this usage right?
   usage = { mangle SameMutableArrayOp [mkP, mkP] mkM }


------------------------------------------------------------------------
--- Weak pointers                                                    ---
------------------------------------------------------------------------

-- note that tyvar "o" denoted openAlphaTyVar

primop  MkWeakOp "mkWeak#" GenPrimOp
   o -> b -> c -> State# RealWorld -> (# State# RealWorld, Weak# b #)
   with
   strictness       = { \ arity -> StrictnessInfo [wwLazy, wwLazy, wwLazy, wwPrim] False }
   usage            = { mangle MkWeakOp [mkZ, mkM, mkM, mkP] mkM }
   has_side_effects = True
   out_of_line      = True

primop  DeRefWeakOp "deRefWeak#" GenPrimOp
   Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, a #)
   with
   usage            = { mangle DeRefWeakOp [mkM, mkP] mkM }
   has_side_effects = True

primop  FinalizeWeakOp "finalizeWeak#" GenPrimOp
   Weak# a -> State# RealWorld -> (# State# RealWorld, Int#, 
              (State# RealWorld -> (# State# RealWorld, Unit #)) #)
   with
   usage            = { mangle FinalizeWeakOp [mkM, mkP] 
                               (mkR . (inUB FinalizeWeakOp 
                                            [id,id,inFun FinalizeWeakOp mkR mkM])) }
   has_side_effects = True
   out_of_line      = True


------------------------------------------------------------------------
--- Stable pointers and names                                        ---
------------------------------------------------------------------------

primop  MakeStablePtrOp "makeStablePtr#" GenPrimOp
   a -> State# RealWorld -> (# State# RealWorld, StablePtr# a #)
   with
   strictness       = { \ arity -> StrictnessInfo [wwLazy, wwPrim] False }
   usage            = { mangle MakeStablePtrOp [mkM, mkP] mkM }
   has_side_effects = True

primop  DeRefStablePtrOp "deRefStablePtr#" GenPrimOp
   StablePtr# a -> State# RealWorld -> (# State# RealWorld, a #)
   with
   usage            = { mangle DeRefStablePtrOp [mkM, mkP] mkM }
   needs_wrapper    = True
   has_side_effects = True

primop  EqStablePtrOp "eqStablePtr#" GenPrimOp
   StablePtr# a -> StablePtr# a -> Int#
   with
   usage            = { mangle EqStablePtrOp [mkP, mkP] mkR }
   has_side_effects = True

primop  MakeStableNameOp "makeStableName#" GenPrimOp
   a -> State# RealWorld -> (# State# RealWorld, StableName# a #)
   with
   usage            = { mangle MakeStableNameOp [mkZ, mkP] mkR }
   strictness       = { \ arity -> StrictnessInfo [wwLazy, wwPrim] False }
   needs_wrapper    = True
   has_side_effects = True
   out_of_line      = True

primop  EqStableNameOp "eqStableName#" GenPrimOp
   StableName# a -> StableName# a -> Int#
   with
   usage = { mangle EqStableNameOp [mkP, mkP] mkR }

primop  StableNameToIntOp "stableNameToInt#" GenPrimOp
   StableName# a -> Int#
   with
   usage = { mangle StableNameToIntOp [mkP] mkR }

------------------------------------------------------------------------
--- Unsafe pointer equality (#1 Bad Guy: Alistair Reid :)            ---
------------------------------------------------------------------------

primop  ReallyUnsafePtrEqualityOp "reallyUnsafePtrEquality#" GenPrimOp
   a -> a -> Int#
   with
   usage = { mangle ReallyUnsafePtrEqualityOp [mkZ, mkZ] mkR }

------------------------------------------------------------------------
--- Parallelism                                                      ---
------------------------------------------------------------------------

primop  SeqOp "seq#" GenPrimOp
   a -> Int#
   with
   usage            = { mangle  SeqOp [mkO] mkR }
   strictness       = { \ arity -> StrictnessInfo [wwStrict] False }
      -- Seq is strict in its argument; see notes in ConFold.lhs
   has_side_effects = True

primop  ParOp "par#" GenPrimOp
   a -> Int#
   with
   usage            = { mangle ParOp [mkO] mkR }
   strictness       = { \ arity -> StrictnessInfo [wwLazy] False }
      -- Note that Par is lazy to avoid that the sparked thing
      -- gets evaluted strictly, which it should *not* be
   has_side_effects = True

-- HWL: The first 4 Int# in all par... annotations denote:
--   name, granularity info, size of result, degree of parallelism
--      Same  structure as _seq_ i.e. returns Int#
-- KSW: v, the second arg in parAt# and parAtForNow#, is used only to determine
--   `the processor containing the expression v'; it is not evaluated

primop  ParGlobalOp  "parGlobal#"  GenPrimOp
   a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
   with
   usage            = { mangle ParGlobalOp [mkO, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  ParLocalOp  "parLocal#"  GenPrimOp
   a -> Int# -> Int# -> Int# -> Int# -> b -> Int#
   with
   usage            = { mangle ParLocalOp [mkO, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  ParAtOp  "parAt#"  GenPrimOp
   b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
   with
   usage            = { mangle ParAtOp [mkO, mkZ, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  ParAtAbsOp  "parAtAbs#"  GenPrimOp
   a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
   with
   usage            = { mangle ParAtAbsOp [mkO, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  ParAtRelOp  "parAtRel#" GenPrimOp
   a -> Int# -> Int# -> Int# -> Int# -> Int# -> b -> Int#
   with
   usage            = { mangle ParAtRelOp [mkO, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  ParAtForNowOp  "parAtForNow#" GenPrimOp
   b -> a -> Int# -> Int# -> Int# -> Int# -> c -> Int#
   with
   usage            = { mangle ParAtForNowOp [mkO, mkZ, mkP, mkP, mkP, mkP, mkM] mkM }
   has_side_effects = True

primop  CopyableOp  "copyable#" GenPrimOp
   a -> Int#
   with
   usage            = { mangle CopyableOp [mkZ] mkR }
   has_side_effects = True

primop  NoFollowOp "noFollow#" GenPrimOp
   a -> Int#
   with
   usage            = { mangle NoFollowOp [mkZ] mkR }
   has_side_effects = True


------------------------------------------------------------------------
--- tag to enum stuff                                                ---
------------------------------------------------------------------------

primop  DataToTagOp "dataToTag#" GenPrimOp
   a -> Int#
   with
   strictness = { \ arity -> StrictnessInfo [wwLazy] False }

primop  TagToEnumOp "tagToEnum#" GenPrimOp     
   Int# -> a


thats_all_folks

------------------------------------------------------------------------
---                                                                  ---
------------------------------------------------------------------------


    -- Char#-related ops:

    -- Int#-related ops:

    -- Float#-related ops:

    -- primitive ops for primitive arrays


    | ReadOffAddrOp	PrimRep
    | WriteOffAddrOp    PrimRep
    | IndexOffAddrOp	PrimRep
	-- PrimRep can be one of :
	--	{Char,Int,Word,Addr,Float,Double,StablePtr,Int64,Word64}Rep.
	-- This is just a cheesy encoding of a bunch of ops.
	-- Note that ForeignObjRep is not included -- the only way of
	-- creating a ForeignObj is with a ccall or casm.
    | IndexOffForeignObjOp PrimRep

    | UnsafeFreezeArrayOp | UnsafeFreezeByteArrayOp
    | SizeofByteArrayOp   | SizeofMutableByteArrayOp



    -- exceptions

    -- foreign objects
    | MkForeignObjOp
    | WriteForeignObjOp

    -- weak pointers
    | MkWeakOp
    | DeRefWeakOp
    | FinalizeWeakOp

    -- stable names
    | MakeStableNameOp
    | EqStableNameOp
    | StableNameToIntOp

    -- stable pointers
    | MakeStablePtrOp
    | DeRefStablePtrOp
    | EqStablePtrOp

    -- Foreign calls
    | CCallOp CCall
    -- Operation to test two closure addresses for equality (yes really!)
    -- BLAME ALASTAIR REID FOR THIS!  THE REST OF US ARE INNOCENT!
    | ReallyUnsafePtrEqualityOp

    -- parallel stuff
    | SeqOp
    | ParOp

    -- concurrency
    | ForkOp
    | KillThreadOp
    | YieldOp
    | MyThreadIdOp
    | DelayOp
    | WaitReadOp
    | WaitWriteOp

    -- more parallel stuff
    | ParGlobalOp	-- named global par
    | ParLocalOp	-- named local par
    | ParAtOp		-- specifies destination of local par
    | ParAtAbsOp	-- specifies destination of local par (abs processor)
    | ParAtRelOp	-- specifies destination of local par (rel processor)
    | ParAtForNowOp	-- specifies initial destination of global par
    | CopyableOp	-- marks copyable code
    | NoFollowOp	-- marks non-followup expression

    -- tag-related
    | DataToTagOp
    | TagToEnumOp
-}
