Parsed, Haskellised:
module OneOfEverything (
	fixn,
	FooData,
	FooDataB(..),
	FooDataC(..),
	EqTree(EqLeaf,  EqBranch),
	EqClass(..),
	OrdClass(orda,  ordb),
	OneC..,
	OneOfEverything..
    ) where
import Prelude {-
	   interface Prelude where
	       import PreludeBuiltin ( trace, Char )
	       import PreludeCore ( Bool, String, ReadS, ShowS, Text )
	       import PreludeRatio (
		   %, numerator, denominator, approxRational )
	       import PreludeComplex (
		   realPart,
		   imagPart,
		   conjugate,
		   mkPolar,
		   cis,
		   polar,
		   magnitude,
		   phase )
	       import PreludeList (
		   head,
		   last,
		   tail,
		   init,
		   null,
		   \\,
		   genericLength,
		   length,
		   !!,
		   filter,
		   partition,
		   foldl1,
		   scanl,
		   scanl1,
		   foldr1,
		   scanr,
		   scanr1,
		   iterate,
		   repeat,
		   cycle,
		   take,
		   drop,
		   splitAt,
		   takeWhile,
		   dropWhile,
		   span,
		   break,
		   lines,
		   words,
		   unlines,
		   unwords,
		   nub,
		   reverse,
		   and,
		   or,
		   any,
		   all,
		   elem,
		   notElem,
		   sum,
		   product,
		   sums,
		   products,
		   maximum,
		   minimum,
		   concat,
		   transpose,
		   zip,
		   zip3,
		   zip4,
		   zip5,
		   zip6,
		   zip7,
		   zipWith,
		   zipWith3,
		   zipWith4,
		   zipWith5,
		   zipWith6,
		   zipWith7,
		   unzip,
		   unzip3,
		   unzip4,
		   unzip5,
		   unzip6,
		   unzip7 )
	       import PreludeArray (
		   array,
		   listArray,
		   !,
		   bounds,
		   indices,
		   elems,
		   assocs,
		   accumArray,
		   //,
		   accum,
		   amap,
		   ixmap )
	       import PreludeText (
		   reads,
		   shows,
		   show,
		   read,
		   showChar,
		   readLitChar,
		   showLitChar,
		   readSigned,
		   showSigned,
		   readDec,
		   showInt,
		   readFloat,
		   showFloat )
	       import PreludeIO (
		   stdin,
		   stdout,
		   stderr,
		   stdecho,
		   done,
		   readFile,
		   writeFile,
		   appendFile,
		   readBinFile,
		   writeBinFile,
		   appendBinFile,
		   deleteFile,
		   statusFile,
		   readChan,
		   appendChan,
		   readBinChan,
		   appendBinChan,
		   statusChan,
		   echo,
		   getArgs,
		   getProgName,
		   getEnv,
		   setEnv,
		   abort,
		   exit,
		   print,
		   prints,
		   interact )
	       instance (Eq a, Eq b) => Eq (a, b)
	       instance (Ord a, Ord b) => Ord (a, b)
	       instance (Ix a, Ix b) => Ix (a, b)
	       instance (Text a, Text b) => Text (a, b)
	       instance (Binary a, Binary b) => Binary (a, b)
	       instance (Eq a, Eq b, Eq c) => Eq (a, b, c)
	       instance (Ord a, Ord b, Ord c) => Ord (a, b, c)
	       instance (Ix a, Ix b, Ix c) => Ix (a, b, c)
	       instance (Text a, Text b, Text c) => Text (a, b, c)
	       instance (Binary a, Binary b, Binary c) => Binary (a, b, c)
	       instance (Eq a, Eq b, Eq c, Eq d) => Eq (a, b, c, d)
	       instance (Ord a, Ord b, Ord c, Ord d) => Ord (a, b, c, d)
	       instance (Ix a, Ix b, Ix c, Ix d) => Ix (a, b, c, d)
	       instance (Text a, Text b, Text c, Text d) => Text (a, b, c, d)
	       instance (Binary a, Binary b, Binary c, Binary d) => Binary (a,
									    b,
									    c,
									    d)
	       ^ :: (Num b, Integral a) => b -> a -> b
	       ^^ :: (Fractional b, Integral a) => b -> a -> b
	       appendBin :: Bin -> Bin -> Bin
	       asTypeOf :: a -> a -> a
	       atan2 :: RealFloat a => a -> a -> a
	       chr :: Int -> Char
	       fromIntegral :: (Integral a, Num b) => a -> b
	       fromRealFrac :: (RealFrac a, Fractional b) => a -> b
	       gcd :: Integral a => a -> a -> a
	       isAlpha :: Char -> Bool
	       isAlphanum :: Char -> Bool
	       isAscii :: Char -> Bool
	       isControl :: Char -> Bool
	       isDigit :: Char -> Bool
	       isLower :: Char -> Bool
	       isNullBin :: Bin -> Bool
	       isPrint :: Char -> Bool
	       isSpace :: Char -> Bool
	       isUpper :: Char -> Bool
	       lcm :: Integral a => a -> a -> a
	       maxChar :: Char
	       maxInt :: Int
	       minChar :: Char
	       minInt :: Int
	       nullBin :: Bin
	       ord :: Char -> Int
	       subtract :: Num a => a -> a -> a
	       toLower :: Char -> Char
	       toUpper :: Char -> Char
	       until :: (a -> Bool) -> (a -> a) -> a -> a
	       trace :: String -> a -> a
	       % :: Integral a => a -> a -> Ratio a
	       numerator :: Integral a => Ratio a -> a
	       denominator :: Integral a => Ratio a -> a
	       approxRational :: RealFrac a => a -> a -> Rational
	       cis :: RealFloat a => a -> Complex a
	       conjugate :: RealFloat a => Complex a -> Complex a
	       imagPart :: RealFloat a => Complex a -> a
	       magnitude :: RealFloat a => Complex a -> a
	       mkPolar :: RealFloat a => a -> a -> Complex a
	       phase :: RealFloat a => Complex a -> a
	       polar :: RealFloat a => Complex a -> (a, a)
	       realPart :: RealFloat a => Complex a -> a
	       !! :: Integral a => [b] -> a -> b
	       \\ :: Eq a => [a] -> [a] -> [a]
	       all :: (a -> Bool) -> [a] -> Bool
	       and :: [Bool] -> Bool
	       any :: (a -> Bool) -> [a] -> Bool
	       break :: (a -> Bool) -> [a] -> ([a], [a])
	       concat :: [[a]] -> [a]
	       cycle :: [a] -> [a]
	       drop :: Integral a => a -> [b] -> [b]
	       dropWhile :: (a -> Bool) -> [a] -> [a]
	       elem :: Eq a => a -> [a] -> Bool
	       filter :: (a -> Bool) -> [a] -> [a]
	       foldl1 :: (a -> a -> a) -> [a] -> a
	       foldr1 :: (a -> a -> a) -> [a] -> a
	       genericLength :: Num b => [a] -> b
	       head :: [a] -> a
	       init :: [a] -> [a]
	       iterate :: (a -> a) -> a -> [a]
	       last :: [a] -> a
	       length :: [a] -> Int
	       lines :: [Char] -> [[Char]]
	       maximum :: Ord a => [a] -> a
	       minimum :: Ord a => [a] -> a
	       notElem :: Eq a => a -> [a] -> Bool
	       nub :: Eq a => [a] -> [a]
	       null :: [a] -> Bool
	       or :: [Bool] -> Bool
	       partition :: (a -> Bool) -> [a] -> ([a], [a])
	       product :: Num a => [a] -> a
	       products :: Num a => [a] -> [a]
	       repeat :: a -> [a]
	       reverse :: [a] -> [a]
	       scanl :: (b -> a -> b) -> b -> [a] -> [b]
	       scanl1 :: (a -> a -> a) -> [a] -> [a]
	       scanr :: (a -> b -> b) -> b -> [a] -> [b]
	       scanr1 :: (a -> a -> a) -> [a] -> [a]
	       span :: (a -> Bool) -> [a] -> ([a], [a])
	       splitAt :: Integral a => a -> [b] -> ([b], [b])
	       sum :: Num a => [a] -> a
	       sums :: Num a => [a] -> [a]
	       tail :: [a] -> [a]
	       take :: Integral a => a -> [b] -> [b]
	       takeWhile :: (a -> Bool) -> [a] -> [a]
	       transpose :: [[a]] -> [[a]]
	       unlines :: [[Char]] -> [Char]
	       unwords :: [[Char]] -> [Char]
	       unzip :: [(a, b)] -> ([a], [b])
	       unzip3 :: [(a, b, c)] -> ([a], [b], [c])
	       unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
	       unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])
	       unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])
	       unzip7 ::
		   [(a, b, c, d, e, f, g)]
		   -> ([a], [b], [c], [d], [e], [f], [g])
	       words :: [Char] -> [[Char]]
	       zip :: [a] -> [b] -> [(a, b)]
	       zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
	       zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
	       zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]
	       zip6 ::
		   [a]
		   -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]
	       zip7 ::
		   [a]
		   -> [b]
		      -> [c]
			 -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]
	       zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
	       zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
	       zipWith4 ::
		   (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
	       zipWith5 ::
		   (a -> b -> c -> d -> e -> f)
		   -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]
	       zipWith6 ::
		   (a -> b -> c -> d -> e -> f -> g)
		   -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]
	       zipWith7 ::
		   (a -> b -> c -> d -> e -> f -> g -> h)
		   -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]
	       ! :: Ix a => Array a b -> a -> b
	       // :: Ix a => Array a b -> [Assoc a b] -> Array a b
	       accum ::
		   Ix b => (c -> a -> c)
			   -> Array b c -> [Assoc b a] -> Array b c
	       accumArray ::
		   Ix b => (c -> a -> c)
			   -> c -> (b, b) -> [Assoc b a] -> Array b c
	       amap :: Ix b => (a -> c) -> Array b a -> Array b c
	       array :: Ix a => (a, a) -> [Assoc a b] -> Array a b
	       assocs :: Ix a => Array a b -> [Assoc a b]
	       bounds :: Ix b => Array b a -> (b, b)
	       elems :: Ix a => Array a b -> [b]
	       indices :: Ix b => Array b a -> [b]
	       ixmap ::
		   (Ix b, Ix a) => (b, b) -> (b -> a) -> Array a c -> Array b c
	       listArray :: Ix a => (a, a) -> [b] -> Array a b
	       read :: Text a => [Char] -> a
	       readDec :: Integral a => [Char] -> [(a, [Char])]
	       readFloat :: RealFloat a => [Char] -> [(a, [Char])]
	       readLitChar :: [Char] -> [(Char, [Char])]
	       readSigned ::
		   Real a => ([Char] -> [(a, [Char])])
			     -> [Char] -> [(a, [Char])]
	       reads :: Text a => [Char] -> [(a, [Char])]
	       show :: Text a => a -> [Char]
	       showChar :: Char -> [Char] -> [Char]
	       showFloat :: RealFloat a => a -> [Char] -> [Char]
	       showInt :: Integral a => a -> [Char] -> [Char]
	       showLitChar :: Char -> [Char] -> [Char]
	       showSigned ::
		   Real a => (a -> [Char] -> [Char])
			     -> Int -> a -> [Char] -> [Char]
	       shows :: Text a => a -> [Char] -> [Char]
	       abort :: IOError -> [Response] -> [Request]
	       appendBinChan ::
		   [Char]
		   -> Bin
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       appendBinFile ::
		   [Char]
		   -> Bin
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       appendChan ::
		   [Char]
		   -> [Char]
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       appendFile ::
		   [Char]
		   -> [Char]
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       binDispatch ::
		   (IOError -> [Response] -> a)
		   -> (Bin -> [Response] -> a) -> [Response] -> a
	       deleteFile ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Response] -> [Request]) -> [Response] -> [Request]
	       done :: [Response] -> [Request]
	       echo ::
		   Bool
		   -> (IOError -> [Response] -> [Request])
		      -> ([Response] -> [Request]) -> [Response] -> [Request]
	       exit :: IOError -> [Response] -> [Request]
	       getArgs ::
		   (IOError -> [Response] -> [Request])
		   -> ([[Char]] -> [Response] -> [Request])
		      -> [Response] -> [Request]
	       getEnv ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Char] -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       getProgName ::
		   (IOError -> [Response] -> [Request])
		   -> ([Char] -> [Response] -> [Request])
		      -> [Response] -> [Request]
	       interact :: ([Char] -> [Char]) -> [Response] -> [Request]
	       print :: Text a => a -> [Response] -> [Request]
	       prints :: Text a => a -> [Char] -> [Response] -> [Request]
	       readBinChan ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> (Bin -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       readBinFile ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> (Bin -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       readChan ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Char] -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       readFile ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Char] -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       setEnv ::
		   [Char]
		   -> [Char]
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       statusChan ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Char] -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       statusFile ::
		   [Char]
		   -> (IOError -> [Response] -> [Request])
		      -> ([Char] -> [Response] -> [Request])
			 -> [Response] -> [Request]
	       stdecho :: [Char]
	       stderr :: [Char]
	       stdin :: [Char]
	       stdout :: [Char]
	       strDispatch ::
		   (IOError -> [Response] -> a)
		   -> ([Char] -> [Response] -> a) -> [Response] -> a
	       strListDispatch ::
		   (IOError -> [Response] -> a)
		   -> ([[Char]] -> [Response] -> a) -> [Response] -> a
	       succDispatch ::
		   (IOError -> [Response] -> a)
		   -> ([Response] -> a) -> [Response] -> a
	       writeBinFile ::
		   [Char]
		   -> Bin
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	       writeFile ::
		   [Char]
		   -> [Char]
		      -> (IOError -> [Response] -> [Request])
			 -> ([Response] -> [Request]) -> [Response] -> [Request]
	   -}
import OneA {-
	   interface OneA where
	       import OneB ( fB ) renaming (fB to fBa)
	       type SynA = Float
	       data DataAA 
	       data Ord a => DataAB a
		   = ConAB1 a
		   | ConAB2
		   deriving (Text)
	       class Ord a => ClassA a where
		   clsA :: a -> String
	       instance ClassA Int
	       fA :: a -> a
	   -}
renaming (fA to renamedA)
import OneB {-
	   interface OneB where
	       fB :: a -> a
	   -}
	 (fB) 
import OneC {-
	   interface OneC where
	       fC :: a -> a
	   -}
	hiding (fC) 
import OneC {-
	   interface OneC where
	       fC :: a -> a
	   -}
	hiding (fC) 
renaming (fc to renamedC)
infixr 9 .
infixr 8 ^
infixr 8 ^^
infixr 3 &&
infixr 2 ||
infixr 0 $
infixl 9 !
infixl 9 //
infix  1 :=
infix  6 :+
infixr 8 **
infixl 7 *
infixl 7 /
infixl 7 `quot`
infixl 7 `rem`
infixl 7 `div`
infixl 7 `mod`
infixl 6 +
infixl 6 -
infix  4 ==
infix  4 /=
infix  4 <
infix  4 <=
infix  4 >=
infix  4 >
infixl 9 !!
infix  5 \\
infix  4 `elem`
infix  4 `notElem`
infixl 7 %
infix  6 `fixn`
infixl 7 +#
infixr 8 `fixr`
type Pair a b = (a, b)
data FooData
    = FooCon Int
data FooDataB
    = FooConB Double
data Eq a => EqTree a
    = EqLeaf a
    | EqBranch (EqLeaf a) (EqLeaf a)
class Eq a => EqClass a where
    eqc :: a -> Char
    eqc x = '?'
class Ord a => OrdClass a where
    orda :: a -> Char
    ordb :: a -> Char
    ordc :: a -> Char
instance Eq a => EqClass EqTree a where
    eqc x = 'a'
default (Integer, Rational)
bindwith :: (OrdClass a, OrdClass b) => a -> b -> b
g :: (Num a, Eq b) => Foo a -> [b] -> (a, a, a) -> b
{- rec -}
fixn x y = x
fixl x y = x
fixr x y = x
singlebind
    x = x
bindwith
    a b = b
reca a = recb a
recb a = reca a
~(a, b, c)
    | nullity b = a
    | nullity c = a
    | otherwise = a
 where
    {- rec -}
    nullity = null
mat a b c d | foof a b = d
	    | foof a c = d
	    | foof b c = d
	    where
		{- rec -}
		foof a b = a == b
expr a b c d = ((((((((a + ((:) a b)) + (a : b))
		     + (((1 - 'c') - "abc") - 1.2929999999999999))
		    + ((\ x y z -> x) 42))
		   + ((9 *)))
		  + ((* 8)))
		 + (case x of
		      [] | null x -> 99
			 | otherwise -> 98
			 | True -> 97
			 where
			     {- rec -}
			     null x = False))
		+ ([ z | z <- c, isSpace z ]))
	       + (let
		    {- rec -}
		    y = foo
		  in (((((((y + ([1, 2, 3, 4])) + ((4, 3, 2, 1)))
			  + ((4 :: Num a => a)))
			 + (if 42 == 42.000000000000000 then 1 else 4))
			+ ([ 1 ..  ]))
		       + ([ 2, 4 ..  ]))
		      + ([ 3 .. 5 ]))
		     + ([ 4, 8 .. 999 ]))
f _
  x
  1
  1.9299999999999999
  'c'
  "dog"
  ~y
  (z@(Foo a b))
  (c Bar d)
  [1, 2]
  (3, 4)
  (n+42) = y
g x y z = head y

Enter trace(0):
doRenamings:tossing them away
Exit  trace(0)
 
Unknown name in export list: FooDataC
"read001.hs", line 38: undefined type constructor: EqLeaf
"read001.hs", line 38: undefined type constructor: EqLeaf
"read001.hs", line 112: undefined type constructor: Foo
"read001.hs", line 95: undefined value: x
"read001.hs", line 95: undefined value: x
"read001.hs", line 95: undefined value: foo
"read001.hs", line 107: undefined value: Foo
"read001.hs", line 107: undefined value: Bar
Fail: Compilation errors found

ghc: execution of the Haskell compiler had trouble
