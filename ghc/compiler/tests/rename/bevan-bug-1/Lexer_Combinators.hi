interface Lexer_Combinators where
import Lexer_State(Lexer_State)
and_also :: (Lexer_State -> (b, Lexer_State)) -> (Lexer_State -> (a, Lexer_State)) -> Lexer_State -> (b, Lexer_State)
	{-# ARITY and_also = 3 #-}
and_then :: (Lexer_State -> (a, Lexer_State)) -> (Lexer_State -> (b, Lexer_State)) -> Lexer_State -> (b, Lexer_State)
	{-# ARITY and_then = 3 #-}
and_with :: (Lexer_State -> (a, Lexer_State)) -> (a -> Lexer_State -> (b, Lexer_State)) -> Lexer_State -> (b, Lexer_State)
	{-# ARITY and_with = 3 #-}
return :: a -> Lexer_State -> (a, Lexer_State)
	{-# ARITY return = 2 #-}

