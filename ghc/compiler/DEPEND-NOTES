add types/InstEnv, InstEnv.hi-boot
add coreSyn/CoreRules.*
add coreSyn/CoreTidy.lhs
add coreSyn/CoreFVs.lhs
remove coreSyn/FreeVars.lhs
add coreSyn/Subst.*
remove simplCore/MagicUFs.*

remove specialise/SpecEnv.*



ToDo
~~~~
* Test effect of eta-expanding past (case x of ..)

* Bottom strictness isn't right.  Should be (eg) SSX, not just X.

* Enumeration types in worker/wrapper for strictness analysis

* Use (!) types in data cons to unbox.

* Check constant folding

* .hi file isn't updated if the only change is to the exports.
  For example, UgenAll.lhs re-exports all of U_binding.hs; when a data type
  decl in the latter changes, the .hi file for the former isn't updated.
  I think this happens when a module exports another mdodule thus:

	module UgenAll( module U_binding, ... ) where

* This should be reported as an error:
	data T k = MkT (k Int#)

* Bogus report of overlapped pattern for
	f (R {field = [c]}) = 1
  	f (R {})	      = 2
  This shows up for TyCon.maybeTyConSingleCon

*  > module Main( main ) where

   > f :: String -> Int
   > f "=<" = 0
   > f "="  = 0
   
   > g :: [Char] -> Int
   > g ['=','<'] = 0
   > g ['=']     = 0
   
   > main = return ()
   
   For ``f'' the following is reported.
   
   tmp.lhs:4: 
    Pattern match(es) are overlapped in the definition of function `f'
            "=" = ...

   There are no complaints for definition for ``g''.

* Without -O I don't think we need change the module version
  if the usages change; I forget why it changes even with -O

* Record selectors for existential type; no good!  What to do?
  Record update doesn't make sense either.

  Need to be careful when figuring out strictness, and when generating
  worker-wrapper split.

  Also when deriving.

* Consructor re-use via CSE

		Notes on module dependencies
		~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The Name/Var/Type group is a bit complicated. Here's the deal
Things in brackets are what the module *uses*.
A 'loop' indicates a use from a module compiled later

	Name, PrimRep, FieldLabel (loop Type.Type)
then
	Var (loop Const.Con, loop IdInfo.IdInfo, 
	     loop Type.GenType, loop Type.Kind)
then
	VarEnv, VarSet, ThinAir
then
	Class (loop TyCon.TyCon, loop Type.Type, loop InstEnv.InstEnv)
then
	TyCon (loop Type.Type, loop Type.Kind, loop DataCon.DataCon)
then
	Type (loop DataCon.DataCon, loop Subst.substTy)
then
	DataCon, TysPrim, Unify, PprType
then
	InstEnv (Unify)
then
	IdInfo (loop CoreRules.CoreRules) 
	TysWiredIn (DataCon.mkDataCon, loop MkId.mkDataConId)
then
	PrimOp (PprType, TysWiredIn, IdInfo.StrictnessInfo)
then
	Const (PrimOp.PrimOp, TysWiredIn.stringTy)
then
	Id (Const.Con(..)), CoreSyn
then
	CoreUtils (loop PprCore.pprCoreExpr), CoreFVs
then	
	OccurAnal (ThinAir.noRepStrs -- an awkward dependency)
then
	CoreUnfold (loop OccurAnal.globalOccurAnalyse)
then
	Rules (Unfolding), Subst (Unfolding, CoreFVs), CoreTidy (noUnfolding)
then
	MkId (CoreUnfold.mkUnfolding, Subst)


