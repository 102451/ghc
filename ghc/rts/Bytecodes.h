/* -*- mode: hugs-c; -*- */

/* --------------------------------------------------------------------------
 * Instructions
 *
 * Notes:
 * o INTERNAL_ERROR is never generated by the compiler and usually
 *   indicates as error in the heap.
 *   PANIC is generated by the compiler whenever it tests an "irrefutable"
 *   pattern which fails.  If we don't see too many of these, we could
 *   optimise out the redundant test.
 *
 * o If you add any new instructions, you have to check that each enumeration
 *   has at most 256 entries in it --- some of the lists are very close to
 *   overflowing.
 * ------------------------------------------------------------------------*/

typedef enum
    { i_INTERNAL_ERROR  /* Instruction 0 raises an internal error */

    , i_PANIC           /* irrefutable pattern match failed! */

    , i_STK_CHECK
    , i_HP_CHECK

    , i_ARG_CHECK

    , i_ALLOC_AP
    , i_ALLOC_PAP
    , i_ALLOC_CONSTR
    , i_MKAP
    , i_MKPAP
    , i_PACK

    , i_SLIDE

    , i_TEST
    , i_UNPACK

    , i_VAR
    , i_CONST
    , i_CONST2 /* 16 bit offsets - ad-hoc fix for general problem */
    , i_ENTER

    , i_RETADDR

    , i_VOID

    , i_RETURN_GENERIC

    , i_VAR_INT
    , i_CONST_INT
    , i_RETURN_INT
    , i_PACK_INT
    , i_UNPACK_INT
    , i_TEST_INT

#ifdef PROVIDE_INT64
    , i_VAR_INT64
    , i_CONST_INT64
    , i_RETURN_INT64
    , i_PACK_INT64
    , i_UNPACK_INT64
#endif
#ifdef PROVIDE_INTEGER
    , i_CONST_INTEGER
#endif
#ifdef PROVIDE_WORD
    , i_VAR_WORD
    , i_CONST_WORD
    , i_RETURN_WORD
    , i_PACK_WORD
    , i_UNPACK_WORD
#endif
#ifdef PROVIDE_ADDR
    , i_VAR_ADDR
    , i_CONST_ADDR
    , i_RETURN_ADDR
    , i_PACK_ADDR
    , i_UNPACK_ADDR
#endif
    , i_VAR_CHAR
    , i_CONST_CHAR
    , i_RETURN_CHAR
    , i_PACK_CHAR
    , i_UNPACK_CHAR

    , i_VAR_FLOAT
    , i_CONST_FLOAT
    , i_RETURN_FLOAT
    , i_PACK_FLOAT
    , i_UNPACK_FLOAT

    , i_VAR_DOUBLE
    , i_CONST_DOUBLE
    , i_RETURN_DOUBLE
    , i_PACK_DOUBLE
    , i_UNPACK_DOUBLE

#ifdef PROVIDE_STABLE
    , i_VAR_STABLE
    , i_RETURN_STABLE
    , i_PACK_STABLE
    , i_UNPACK_STABLE
#endif

    , i_PRIMOP1         /* Primop: next byte is an Primop1 */
    , i_PRIMOP2         /* Primop: next byte is an Primop2 */

    , MAX_Instr = i_PRIMOP2
} Instr;

typedef enum
    { i_INTERNAL_ERROR1  /* Instruction 0 raises an internal error */

    /* Char# operations */
    , i_gtChar
    , i_geChar
    , i_eqChar
    , i_neChar
    , i_ltChar
    , i_leChar
    , i_charToInt
    , i_intToChar

    /* Int# operations */
    , i_gtInt
    , i_geInt
    , i_eqInt
    , i_neInt
    , i_ltInt
    , i_leInt
    , i_minInt
    , i_maxInt
    , i_plusInt
    , i_minusInt
    , i_timesInt
    , i_quotInt
    , i_remInt
    , i_quotRemInt
    , i_negateInt
    , i_andInt
    , i_orInt
    , i_xorInt
    , i_notInt
    , i_shiftLInt
    , i_shiftRAInt
    , i_shiftRLInt

#ifdef PROVIDE_INT64
    /* Int64# operations */
    , i_gtInt64
    , i_geInt64
    , i_eqInt64
    , i_neInt64
    , i_ltInt64
    , i_leInt64
    , i_minInt64
    , i_maxInt64
    , i_plusInt64
    , i_minusInt64
    , i_timesInt64
    , i_quotInt64
    , i_remInt64
    , i_quotRemInt64
    , i_negateInt64
    , i_andInt64
    , i_orInt64
    , i_xorInt64
    , i_notInt64
    , i_shiftLInt64
    , i_shiftRAInt64
    , i_shiftRLInt64
    , i_int64ToInt 
    , i_intToInt64 
#ifdef PROVIDE_WORD
    , i_int64ToWord 
    , i_wordToInt64 
#endif
    , i_int64ToFloat 
    , i_floatToInt64 
    , i_int64ToDouble 
    , i_doubleToInt64 
#endif
#ifdef PROVIDE_WORD
    /* Word# operations */
    , i_gtWord
    , i_geWord
    , i_eqWord
    , i_neWord
    , i_ltWord
    , i_leWord
    , i_minWord
    , i_maxWord
    , i_plusWord
    , i_minusWord
    , i_timesWord
    , i_quotWord
    , i_remWord
    , i_quotRemWord
    , i_negateWord
    , i_andWord
    , i_orWord
    , i_xorWord
    , i_notWord
    , i_shiftLWord
    , i_shiftRAWord
    , i_shiftRLWord
    , i_intToWord
    , i_wordToInt
#endif
#ifdef PROVIDE_ADDR
    /* Addr# operations */
    , i_gtAddr
    , i_geAddr
    , i_eqAddr
    , i_neAddr
    , i_ltAddr
    , i_leAddr
    , i_intToAddr
    , i_addrToInt

    /* Stateless Addr operations */
    , i_indexCharOffAddr
    , i_indexIntOffAddr
#ifdef PROVIDE_INT64
    , i_indexInt64OffAddr
#endif
#ifdef PROVIDE_WORD
    , i_indexWordOffAddr
#endif
#ifdef PROVIDE_ADDR
    , i_indexAddrOffAddr
#endif
    , i_indexFloatOffAddr
    , i_indexDoubleOffAddr
#ifdef PROVIDE_STABLE
    , i_indexStableOffAddr
#endif

    , i_readCharOffAddr
    , i_readIntOffAddr
#ifdef PROVIDE_INT64
    , i_readInt64OffAddr
#endif
#ifdef PROVIDE_WORD
    , i_readWordOffAddr
#endif
#ifdef PROVIDE_ADDR
    , i_readAddrOffAddr
#endif
    , i_readFloatOffAddr
    , i_readDoubleOffAddr
#ifdef PROVIDE_STABLE
    , i_readStableOffAddr
#endif

    , i_writeCharOffAddr
    , i_writeIntOffAddr
#ifdef PROVIDE_INT64
    , i_writeInt64OffAddr
#endif
#ifdef PROVIDE_WORD
    , i_writeWordOffAddr
#endif
#ifdef PROVIDE_ADDR
    , i_writeAddrOffAddr
#endif
    , i_writeFloatOffAddr
    , i_writeDoubleOffAddr
#ifdef PROVIDE_STABLE
    , i_writeStableOffAddr
#endif

#endif /* PROVIDE_ADDR */

#ifdef PROVIDE_INTEGER
    /* Integer operations */
    , i_compareInteger
    , i_negateInteger
    , i_plusInteger
    , i_minusInteger
    , i_timesInteger
    , i_quotRemInteger
    , i_divModInteger
    , i_integerToInt
    , i_intToInteger
#ifdef PROVIDE_INT64
    , i_integerToInt64
    , i_int64ToInteger
#endif
#ifdef PROVIDE_WORD
    , i_integerToWord
    , i_wordToInteger
#endif
    , i_integerToFloat
    , i_floatToInteger
    , i_integerToDouble
    , i_doubleToInteger
#endif

    /* Float# operations */
    , i_gtFloat
    , i_geFloat
    , i_eqFloat
    , i_neFloat
    , i_ltFloat
    , i_leFloat
    , i_minFloat
    , i_maxFloat
    , i_radixFloat
    , i_digitsFloat
    , i_minExpFloat
    , i_maxExpFloat
    , i_plusFloat
    , i_minusFloat
    , i_timesFloat
    , i_divideFloat
    , i_negateFloat
    , i_floatToInt
    , i_intToFloat
    , i_expFloat
    , i_logFloat
    , i_sqrtFloat
    , i_sinFloat
    , i_cosFloat
    , i_tanFloat
    , i_asinFloat
    , i_acosFloat
    , i_atanFloat
    , i_sinhFloat
    , i_coshFloat
    , i_tanhFloat
    , i_powerFloat
#ifdef PROVIDE_INT64
    , i_decodeFloatz
    , i_encodeFloatz
#endif
#ifdef PROVIDE_INTEGER
    , i_decodeFloatZ
    , i_encodeFloatZ
#endif
    , i_isNaNFloat
    , i_isInfiniteFloat
    , i_isDenormalizedFloat
    , i_isNegativeZeroFloat
    , i_isIEEEFloat

    /* Double# operations */
    , i_gtDouble
    , i_geDouble
    , i_eqDouble
    , i_neDouble
    , i_ltDouble
    , i_leDouble
    , i_minDouble
    , i_maxDouble
    , i_radixDouble
    , i_digitsDouble
    , i_minExpDouble
    , i_maxExpDouble
    , i_plusDouble
    , i_minusDouble
    , i_timesDouble
    , i_divideDouble
    , i_negateDouble
    , i_doubleToInt
    , i_intToDouble
    , i_doubleToFloat
    , i_floatToDouble
    , i_expDouble
    , i_logDouble
    , i_sqrtDouble
    , i_sinDouble
    , i_cosDouble
    , i_tanDouble
    , i_asinDouble
    , i_acosDouble
    , i_atanDouble
    , i_sinhDouble
    , i_coshDouble
    , i_tanhDouble
    , i_powerDouble
#ifdef PROVIDE_INT64
    , i_decodeDoublez
    , i_encodeDoublez
#endif
#ifdef PROVIDE_INTEGER
    , i_decodeDoubleZ
    , i_encodeDoubleZ
#endif
    , i_isNaNDouble
    , i_isInfiniteDouble
    , i_isDenormalizedDouble
    , i_isNegativeZeroDouble
    , i_isIEEEDouble

    /* If you add a new primop to this table, check you don't
     * overflow the 256 limit.  That is MAX_Primop1 <= 255.
     * Current value (30/10/98) = 0xc8
     */
    , MAX_Primop1 = i_isIEEEDouble
} Primop1;


typedef enum
    { i_INTERNAL_ERROR2  /* Instruction 0 raises an internal error */

    , i_raise       
    , i_catch       
    , i_force

#ifdef PROVIDE_ARRAY
    /* Ref operations */
    , i_newRef
    , i_writeRef
    , i_readRef
    , i_sameRef

    /* Prim[Mutable]Array operations */
    , i_sameMutableArray
    , i_unsafeFreezeArray

    , i_newArray
    , i_writeArray
    , i_readArray
    , i_indexArray
    , i_sizeArray
    , i_sizeMutableArray

    /* Prim[Mutable]ByteArray operations */
    , i_sameMutableByteArray
    , i_unsafeFreezeByteArray
    , i_newByteArray

    , i_writeCharArray
    , i_readCharArray
    , i_indexCharArray

    , i_writeIntArray
    , i_readIntArray
    , i_indexIntArray

#ifdef PROVIDE_INT64
    , i_writeInt64Array
    , i_readInt64Array
    , i_indexInt64Array
#endif

    /* {write,read,index}IntegerArray not provided */

#ifdef PROVIDE_WORD
    , i_writeWordArray
    , i_readWordArray
    , i_indexWordArray
#endif
#ifdef PROVIDE_ADDR
    , i_writeAddrArray
    , i_readAddrArray
    , i_indexAddrArray
#endif
    , i_writeFloatArray
    , i_readFloatArray
    , i_indexFloatArray

    , i_writeDoubleArray
    , i_readDoubleArray
    , i_indexDoubleArray

#ifdef PROVIDE_STABLE
    , i_writeStableArray
    , i_readStableArray
    , i_indexStableArray
#endif

    /* {write,read,index}ForeignObjArray not provided */

#endif /* PROVIDE_ARRAY */

#ifdef PROVIDE_PTREQUALITY
    , i_reallyUnsafePtrEquality
#endif
#ifdef PROVIDE_COERCE
    , i_unsafeCoerce
#endif

#ifdef PROVIDE_FOREIGN
    /* ForeignObj# operations */
    , i_makeForeignObj

    , indexCharOffForeignObj
    , indexIntOffForeignObj
    , indexInt64OffForeignObj
    , indexWordOffForeignObj
    , indexAddrOffForeignObj
    , indexFloatOffForeignObj
    , indexDoubleOffForeignObj
    , indexStablePtrOffForeignObj
#endif
#ifdef PROVIDE_WEAK
    /* Weak# operations */
    , i_makeWeak
    , i_deRefWeak
#endif 
#ifdef PROVIDE_STABLE
    /* StablePtr# operations */
    , i_makeStablePtr
    , i_deRefStablePtr
    , i_freeStablePtr
#endif

#ifdef PROVIDE_CONCURRENT
    /* Concurrency operations */
    , i_fork
    , i_killThread
    , i_sameMVar
    , i_newMVar
    , i_takeMVar
    , i_putMVar
    , i_delay
    , i_waitRead
    , i_waitWrite
#endif

    /* CCall! */
    , i_ccall_Id
    , i_ccall_IO

    /* If you add a new primop to this table, check you don't
     * overflow the 256 limit.  That is MAX_Primop2 <= 255.
     * Current value (30/10/98) = 0x42
     */
    , MAX_Primop2 = i_ccall_IO
} Primop2;

typedef unsigned int InstrPtr; /* offset of instruction within BCO */

/*-------------------------------------------------------------------------*/
