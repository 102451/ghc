#
# reads CPP output and turns #line things into appropriate Haskell
# pragmas
#
# considered to be GHC-project specific
#
#
# NOTE: this script needs RAWCPP set in order to do something
# useful:
#

$Verbose = 0;
$file = '';
@args = ();

$Cpp = ${RAWCPP};

foreach (@ARGV) {
    /^-v$/ && do { $Verbose = 1; next; };

    /^[^-]/ && do { 
	if ($file ne '') { 
	    die "usage: hscpp [arg...] file";
	} else {
	    $file = $_; 
	};
	next;
    };

    push @args, $_;
}

print STDERR "hscpp:CPP invoked: $Cpp @args - <$file\n" if $Verbose;
open(INPIPE, "$Cpp @args - <$file |") 
	|| die "Can't open C pre-processor pipe\n";

while (<INPIPE>) {

    print STDERR $_;

# line directives come in flavo[u]rs:
#   s/^#\s*line\s+\d+$/\{\-# LINE \-\}/;   IGNORE THIS ONE FOR NOW
    s/^#\s*line\s+(\d+)\s+(\".+\")$/\{\-# LINE \1 \2 \-\}/;
    s/^#\s*(\d+)\s+(\".*\").*/\{\-# LINE \1 \2 \-\}/;

    s/^#\s*(\d+)\s+(\"\").*//;  # these are a result of our using stdin in
				# the $(CPP) command line above.

    print $_;
}

close(INPIPE) || exit(1); # exit is so we reflect any errors.

exit(0);
