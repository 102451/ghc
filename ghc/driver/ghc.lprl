%
% (c) The GRASP/AQUA Project, Glasgow University, 1992-1996
%
% *** MSUB does some substitutions here ***
% *** grep for $( ***
%

This is the driver script for the Glasgow Haskell compilation system.
It is written in \tr{perl}.  The first section includes a long
``usage'' message that describes how the driver is supposed to work.

%************************************************************************
%*									*
\section[Driver-usage]{Usage message}
%*									*
%************************************************************************

\begin{code}
($Pgm = $0) =~ s|.*/||;
$ShortUsage  =  "\nUsage: For basic information, try the `-help' option.\n";
$LongUsage = "\n" . <<EOUSAGE;
Use of the Glorious Haskell Compilation System driver:

    $Pgm [command-line-options-and-input-files]

------------------------------------------------------------------------
This driver ($Pgm) guides each input file through (some of the)
possible phases of a compilation:

    - unlit:	extract code from a "literate program"
    - hscpp:	run code through the C pre-processor (if -cpp flag given)
    - hsc:	run the Haskell compiler proper
    - gcc:	run the C compiler (if compiling via C)
    - as:	run the assembler
    - ld:	run the linker

For each input file, the phase to START with is determined by the
file's suffix:
    - .lhs	literate Haskell: unlit
    - .hs	illiterate Haskell: hsc
    - .hc	C from the Haskell compiler: gcc
    - .c	C not from the Haskell compiler: gcc
    - .s	assembly language: as
    - other	passed directly to the linker: ld

If no files are given on the command line, input is taken from
standard input, and processing is as for an .hs file.  (All output is
to stdout or stderr, however).

The phase at which to STOP processing is determined by a command-line
option:
    -C		stop after generating C (.hc output)
    -E		stop after generating preprocessed C (.i output)
    -S		stop after generating assembler (.s output)
    -c		stop after generating object files (.o output)

Other commonly-used options are:

    -O		An `optimising' package of compiler flags, for faster code

    -prof	Compile for cost-centre profiling
		(add -auto for automagic cost-centres on top-level functions)

    -fglasgow-exts  Allow Glasgow extensions (unboxed types, etc.)

    -H14m	Increase compiler's heap size

The User's Guide has more information about GHC's *many* options.

Given the above, here are some TYPICAL invocations of $Pgm:

    # compile a Haskell module to a .o file, optimising:
    % $Pgm -c -O Foo.hs
    # compile a Haskell module to C (a .hc file), using a bigger heap:
    % $Pgm -C -H16m Foo.hs
    # compile Haskell-produced C (.hc) to assembly language:
    % $Pgm -S Foo.hc
    # link three .o files into an executable called "test":
    % $Pgm -o test Foo.o Bar.o Baz.o
------------------------------------------------------------------------
EOUSAGE
\end{code}

%************************************************************************
%*									*
\section[Driver-init]{Initialisation}
%*									*
%************************************************************************

Establish what executables to run for the various phases (all the
\tr{$(FOO)} make-variables are \tr{msub}bed for from the
\tr{Makefile}), what the default options are for those phases, and
other similar boring stuff.
\begin{code}
select(STDERR); $| = 1; select(STDOUT); # no STDERR buffering, please.

$HostPlatform   = '$(HOSTPLATFORM)';
$TargetPlatform = '$(TARGETPLATFORM)';

#------------------------------------------------------------------------
# If you are adjusting paths by hand for a binary GHC distribution,
# de-commenting the line to set GLASGOW_HASKELL_ROOT should do.
# Or you can leave it as is, and set the environment variable externally.
#------------------------------------------------------------------------
# $ENV{'GLASGOW_HASKELL_ROOT'} = '/some/absolute/path/name';

if (! $ENV{'GLASGOW_HASKELL_ROOT'}) { # good -- death to environment variables
    $TopPwd	    = '$(TOP_PWD)';
    $InstLibDirGhc  = '$(INSTLIBDIR_GHC)';
    $InstDataDirGhc = '$(INSTDATADIR_GHC)';
} else {
    $TopPwd = $ENV{'GLASGOW_HASKELL_ROOT'};

    if ('$(INSTLIBDIR_GHC)' =~ /.*(\/lib\/ghc\/\d\.\d\d\/[^-]-[^-]-[^-]\/.*)/) {
	$InstLibDirGhc	= $ENV{'GLASGOW_HASKELL_ROOT'} . $1;
    } else {
	print STDERR "GLASGOW_HASKELL_ROOT environment variable is set;\nBut can't untangle $(INSTLIBDIR_GHC).\n(Installation error)\n";
	exit(1);
    }

    if ('$(INSTDATADIR_GHC)' =~ /.*(\/lib\/ghc\/\d\.\d\d\/.*)/) {
	$InstDataDirGhc	= $ENV{'GLASGOW_HASKELL_ROOT'} . $2;
    } else {
	print STDERR "GLASGOW_HASKELL_ROOT environment variable is set;\nBut can't untangle $(INSTDATADIR_GHC).\n(Installation error)\n";
	exit(1);
    }
}

if ( $(INSTALLING) ) {
    $InstSysLibDir  = $InstDataDirGhc;
    $InstSysLibDir  =~ s/\/ghc\//\/hslibs\//;
} else {
    $InstSysLibDir  = "$TopPwd/hslibs";
}

$Status  = 0; # just used for exit() status
$Verbose = '';

# set up signal handler
sub quit_upon_signal { &tidy_up_and_die(1, ''); }
$SIG{'INT'}  = 'quit_upon_signal';
$SIG{'QUIT'} = 'quit_upon_signal';

# where to get "require"d .prl files at runtime (poor man's dynamic loading)
#   (use LIB, not DATA, because we can't be sure of arch-independence)
@INC = ( ( $(INSTALLING) ) ? $InstLibDirGhc
			   : "$TopPwd/$(CURRENT_DIR)" );

if ( $ENV{'TMPDIR'} ) { # where to make tmp file names
    $Tmp_prefix = ($ENV{'TMPDIR'} . "/ghc$$");
} else {
    $Tmp_prefix ="$(TMPDIR)/ghc$$";
    $ENV{'TMPDIR'} = '$(TMPDIR)'; # set the env var as well
}

@Files_to_tidy = (); # files we nuke in the case of abnormal termination

$Unlit = ( $(INSTALLING) ) ? "$InstLibDirGhc/unlit"
			     : "$TopPwd/$(CURRENT_DIR)/$(GHC_UNLIT)";
@Unlit_flags	= ();

$Cp   = '$(CP)';
$Rm   = '$(RM)';
$Diff = '$(CONTEXT_DIFF)';
$Cat  = 'cat';
$Cmp  = 'cmp';
$Time = '';

$HsCpp	 = # but this is re-set to "cat" (after options) if -cpp not seen
	   ( $(INSTALLING) ) ? "$InstLibDirGhc/hscpp"
			     : "$TopPwd/$(CURRENT_DIR)/$(GHC_HSCPP)";
@HsCpp_flags	= ();
$genSPECS_flag	= '';		# See ../utils/hscpp/hscpp.prl

$HsC	 = ( $(INSTALLING) ) ? "$InstLibDirGhc/hsc"
			     : "$TopPwd/$(CURRENT_DIR)/$(GHC_HSC)";

$SysMan	 = ( $(INSTALLING) ) ? "$InstLibDirGhc/SysMan"
			     : "$TopPwd/$(CURRENT_DIR)/$(GHC_SYSMAN)";

# HsC_rts_flags: if we want to talk to the LML runtime system
# NB: we don't use powers-of-2 sizes, because this may do
#   terrible things to cache behavior.
$Specific_heap_size = 6 * 1000 * 1000;
$Specific_stk_size  = 1000 * 1000;
$Scale_sizes_by     = 1.0;
@HsC_rts_flags      = ();

@HsP_flags	= (); # these are the flags destined solely for
		      # the flex/yacc parser
@HsC_flags	= ();
@HsC_antiflags  = ();
\end{code}

The optimisations/etc to be done by the compiler are {\em normally}
expressed with a \tr{-O} (or \tr{-O2}) flag, or by its absence.

\begin{code}
$OptLevel      = 0; # no -O == 0; -O == 1; -O2 == 2; -Ofile == 3
$MinusO2ForC   = 0; # set to 1 if -O2 should be given to C compiler
$StolenX86Regs = 4; # **HACK*** of the very worst sort
$CoreLint      = '';
\end{code}

These variables represent parts of the -O/-O2/etc ``templates,''
which are filled in later, using these.
These are the default values, which may be changed by user flags.
\begin{code}
$Oopt_UnfoldingUseThreshold	= '-funfolding-use-threshold8';
$Oopt_MaxSimplifierIterations	= '-fmax-simplifier-iterations4';
$Oopt_PedanticBottoms		= '-fpedantic-bottoms'; # ON by default
$Oopt_MonadEtaExpansion		= '';
$Oopt_FinalStgProfilingMassage	= '';
$Oopt_StgStats			= '';
$Oopt_SpecialiseUnboxed		= '';
$Oopt_DoSpecialise		= ''; # ToDo:LATER: '-fspecialise';
$Oopt_FoldrBuild		= 0; # *Off* by default!
$Oopt_FB_Support		= ''; # was '-fdo-arity-expand';
#$Oopt_FoldrBuildWW		= 0; # Off by default
$Oopt_FoldrBuildInline		= ''; # was '-fdo-inline-foldr-build';
\end{code}

Things to do with C compilers/etc:
\begin{code}
$CcRegd	 	= '$(GHC_OPT_HILEV_ASM)';
@CcBoth_flags	= ('-S');   # flags for *any* C compilation
@CcInjects	= ();

# GCC flags: those for all files, those only for .c files; those only for .hc files
@CcRegd_flags    = ('-ansi', '-D__STG_GCC_REGS__', '-D__STG_TAILJUMPS__');
@CcRegd_flags_c	= ();
@CcRegd_flags_hc = ();

$As	 	= ''; # "assembler" is normally GCC
@As_flags	= ();

$Lnkr	 	= ''; # "linker" is normally GCC
@Ld_flags	= ();

# 'nm' is used for consistency checking (ToDo: mk-world-ify)
# ToDo: check the OS or something ("alpha" is surely not the crucial question)
$Nm = ($TargetPlatform =~ /^alpha-/) ? 'nm -B' : 'nm';
\end{code}

What options \tr{-user-setup-a} turn into (user-defined ``packages''
of options).  Note that a particular user-setup implies a particular
Prelude ({\em including} its interface file(s)).
\begin{code}
$BuildTag	= ''; # default is sequential build w/ Appel-style GC

%BuildAvail	= ('',	    '$(Build_normal)',
		   '_p',    '$(Build_p)',
		   '_t',    '$(Build_t)',
		   '_u',    '$(Build_u)',
		   '_mc',   '$(Build_mc)',
		   '_mr',   '$(Build_mr)',
		   '_mt',   '$(Build_mt)',
		   '_mp',   '$(Build_mp)',
		   '_mg',   '$(Build_mg)',
		   '_2s',   '$(Build_2s)',
		   '_1s',   '$(Build_1s)',
		   '_du',   '$(Build_du)',
		   '_a',    '$(Build_a)',
		   '_b',    '$(Build_b)',
		   '_c',    '$(Build_c)',
		   '_d',    '$(Build_d)',
		   '_e',    '$(Build_e)',
		   '_f',    '$(Build_f)',
		   '_g',    '$(Build_g)',
		   '_h',    '$(Build_h)',
		   '_i',    '$(Build_i)',
		   '_j',    '$(Build_j)',
		   '_k',    '$(Build_k)',
		   '_l',    '$(Build_l)',
		   '_m',    '$(Build_m)',
		   '_n',    '$(Build_n)',
		   '_o',    '$(Build_o)',
		   '_A',    '$(Build_A)',
		   '_B',    '$(Build_B)' );

%BuildDescr	= ('',	    'normal sequential',
		   '_p',    'profiling',
		   '_t',    'ticky-ticky profiling',
#OLD:		   '_u',    'unregisterized (using portable C only)',
		   '_mc',   'concurrent',
		   '_mr',   'profiled concurrent',
		   '_mt',   'ticky concurrent',
		   '_mp',   'parallel',
		   '_mg',   'GranSim',
		   '_2s',   '2-space GC',
		   '_1s',   '1-space GC',
		   '_du',   'dual-mode GC',
		   '_a',    'user way a',
		   '_b',    'user way b',
		   '_c',    'user way c',
		   '_d',    'user way d',
		   '_e',    'user way e',
		   '_f',    'user way f',
		   '_g',    'user way g',
		   '_h',    'user way h',
		   '_i',    'user way i',
		   '_j',    'user way j',
		   '_k',    'user way k',
		   '_l',    'user way l',
		   '_m',    'user way m',
		   '_n',    'user way n',
		   '_o',    'user way o',
		   '_A',    'user way A',
		   '_B',    'user way B' );

# these are options that are "fed back" through the option processing loop
%UserSetupOpts	= ('_a', '$(GHC_BUILD_OPTS_a)',
		   '_b', '$(GHC_BUILD_OPTS_b)',
		   '_c', '$(GHC_BUILD_OPTS_c)',
		   '_d', '$(GHC_BUILD_OPTS_d)',
		   '_e', '$(GHC_BUILD_OPTS_e)',
		   '_f', '$(GHC_BUILD_OPTS_f)',
		   '_g', '$(GHC_BUILD_OPTS_g)',
		   '_h', '$(GHC_BUILD_OPTS_h)',
		   '_i', '$(GHC_BUILD_OPTS_i)',
		   '_j', '$(GHC_BUILD_OPTS_j)',
		   '_k', '$(GHC_BUILD_OPTS_k)',
		   '_l', '$(GHC_BUILD_OPTS_l)',
		   '_m', '$(GHC_BUILD_OPTS_m)',
		   '_n', '$(GHC_BUILD_OPTS_n)',
		   '_o', '$(GHC_BUILD_OPTS_o)',
		   '_A', '$(GHC_BUILD_OPTS_A)',
		   '_B', '$(GHC_BUILD_OPTS_B)',

		   # the GC ones don't have any "fed back" options
		   '_2s', '',
		   '_1s', '',
		   '_du', '' );

# per-build code fragments which are eval'd
%EvaldSetupOpts	= ('',	    '', # this one must *not* be set!

			    # profiled sequential
		   '_p',    'push(@HsC_flags,  \'-fscc-profiling\');
			     push(@CcBoth_flags, \'-DPROFILING\');',

			    #and maybe ...
			    #push(@CcBoth_flags, '-DPROFILING_DETAIL_COUNTS');

			    # ticky-ticky sequential
		   '_t',    'push(@HsC_flags, \'-fticky-ticky\');
			     push(@CcBoth_flags, \'-DTICKY_TICKY\');',

#OLD:			    # unregisterized (ToDo????)
#		   '_u',    '',

			    # concurrent
		   '_mc',   '$StkChkByPageFaultOK = 0;
			     push(@HsC_flags,  \'-fconcurrent\');
			     push(@HsCpp_flags,\'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\');
			     push(@Cpp_define, \'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\');',

			    # profiled concurrent
		   '_mr',   '$StkChkByPageFaultOK = 0;
			     push(@HsC_flags,  \'-fconcurrent\', \'-fscc-profiling\');
			     push(@HsCpp_flags,\'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\');
			     push(@Cpp_define, \'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\', \'-DPROFILING\');',

			    # ticky-ticky concurrent
		   '_mt',   '$StkChkByPageFaultOK = 0;
			     push(@HsC_flags,  \'-fconcurrent\', \'-fticky-ticky\');
			     push(@HsCpp_flags,\'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\');
			     push(@Cpp_define, \'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\', \'-DTICKY_TICKY\');',

			    # parallel
		   '_mp',   '$StkChkByPageFaultOK = 0;
			     push(@HsC_flags,  \'-fconcurrent\');
			     push(@HsCpp_flags,\'-D__PARALLEL_HASKELL__\',   \'-DPAR\');
			     push(@Cpp_define, \'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\', \'-DPAR\');',

			    # GranSim
		   '_mg',   '$StkChkByPageFaultOK = 0;
			     push(@HsC_flags,  \'-fconcurrent\', \'-fgransim\');
			     push(@HsCpp_flags,\'-D__GRANSIM__\',   \'-DGRAN\');
			     push(@Cpp_define, \'-D__CONCURRENT_HASKELL__\', \'-DCONCURRENT\', \'-DGRAN\');',

		   '_2s',   'push (@CcBoth_flags, \'-DGC2s\');',
		   '_1s',   'push (@CcBoth_flags, \'-DGC1s\');',
		   '_du',   'push (@CcBoth_flags, \'-DGCdu\');',

		   '_a',    '', # these user-way guys should not be set!
		   '_b',    '',
		   '_c',    '',
		   '_d',    '',
		   '_e',    '',
		   '_f',    '',
		   '_g',    '',
		   '_h',    '',
		   '_i',    '',
		   '_j',    '',
		   '_k',    '',
		   '_l',    '',
		   '_m',    '',
		   '_n',    '',
		   '_o',    '',
		   '_A',    '',
		   '_B',    '' );
\end{code}

Import/include directories (\tr{-I} options) are sufficiently weird to
require special handling.
\begin{code}
@Import_dir	= ('.'); #-i things
@Include_dir	= ('.'); #-I things; other default(s) stuck on AFTER option processing

@SysImport_dir	= ( $(INSTALLING) )
		    ? ( "$InstDataDirGhc/imports" )
		    : ( "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)/ghc"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)/glaExts"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)/required"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)/concurrent" );

# We need to look in ghc/ and glaExts/ when searching for implicitly needed .hi files, but 
# we should really *not* look there for explicitly imported modules.

$GhcVersionInfo  = int ($(PROJECTVERSION) * 100);
$Haskell1Version = 3; # i.e., Haskell 1.3
@Cpp_define	 = ();

@UserLibrary_dir= ();	#-L things;...
@UserLibrary   	= ();	#-l things asked for by the user

@SysLibrary_dir = ( ( $(INSTALLING) )	#-syslib things supplied by the system
		    ? $InstLibDirGhc
		    : ( "$TopPwd/$(CURRENT_DIR)/$(GHC_RUNTIMESRC)"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_RUNTIMESRC)/gmp"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)"
		      , "$TopPwd/$(CURRENT_DIR)/$(GHC_LIBSRC)/cbits"
		      )
		  );
@SysLibrary = (); # will be built up as we go along

$TopClosureFile # defaults to 1.2 one; will be mangled later
	= ( $(INSTALLING) ) ? "$InstLibDirGhc/TopClosureXXXX.o"
			    : "$TopPwd/$(CURRENT_DIR)/$(GHC_RUNTIMESRC)/main/TopClosureXXXX.o";
\end{code}

We are given a list of files with various presumably-known suffixes
(unknown-suffix files go straight to the linker).  For each file, we
begin by assuming that we'll run every phase over it.  However: (1)
global flags (\tr{-c}, \tr{-S}, etc.) tell us not to run any phase
past a certain point; and (2) the file's suffix tells us what phase to
start with.  Linking is weird and kept track of separately.

Here are the initial defaults applied to all files:
\begin{code}
$Cpp_flag_set = 0;	# (hack)
$Only_preprocess_C = 0;	# pretty hackish
$PostprocessCcOutput = 0;

# native code-gen or via C?
$HaveNativeCodeGen = $(GhcWithNativeCodeGen);
$HscOut = '-C='; # '-C=' ==> .hc output; '-S=' ==> .s output; '-N=' ==> neither
$HscOut = '-S='
    if $HaveNativeCodeGen && $TargetPlatform =~ /^(alpha|sparc)-/; #ToDo: add |i386 !
$ProduceHi   = '-hifile=';
$HiOnStdout  = 0;
$HiDiff_flag = '';

$CollectingGCstats = 0;
$CollectGhcTimings = 0;
$DEBUGging = '';	# -DDEBUG and all that it entails (um... not really)
$PROFing = '';		# set to p or e if profiling
$PROFgroup = '';	# set to group if an explicit -Ggroup specified
$PROFauto = '';	        # set to relevant hsc flag if -auto or -auto-all
$PROFcaf  = '';	        # set to relevant hsc flag if -caf-all
$PROFignore_scc = '';	# set to relevant parser flag if explicit sccs ignored
$UNPROFscc_auto = '';	# set to relevant hsc flag if forcing auto sccs without profiling
$TICKYing = '';    	# set to t if compiling for ticky-ticky profiling
$PARing = '';		# set to p if compiling for PAR
$CONCURing = '';    	# set to c if compiling for CONCURRENT
$GRANing = '';		# set to g if compiling for GRAN
$StkChkByPageFaultOK = 1; # may be set to 0 (false) for some builds
$Specific_output_dir = '';  	# set by -odir <dir>
$Specific_output_file = '';	# set by -o <file>; "-" for stdout
$Specific_hi_file = '';		# set by -ohi <file>; "-" for stdout
$Specific_dump_file = '';	# set by -odump <file>; "-" for stdout
$Using_dump_file = 0;
$Isuffix    = '';
$Osuffix    = '';	# default: use the normal suffix for that kind of output
$HiSuffix   = 'hi';
$SysHiSuffix= 'hi';
$Do_recomp_chkr = 0;	# don't use the recompilatio checker unless asked
$Do_cc	    = -1;   # a MAGIC indeterminate value; will be set to 1 or 0.
$Do_as	    = 1;
$Do_lnkr    = 1;
$Keep_hc_file_too = 0;
$Keep_s_file_too = 0;
$UseGhcInternals = 0; # if 1, may use GHC* modules
$SplitObjFiles = 0;
$NoOfSplitFiles = 0;
$Dump_parser_output = 0;
$Dump_raw_asm = 0;
$Dump_asm_splitting_info = 0;
$NoImplicitPrelude = 0;

# and the list of files
@Input_file = ();

# and files to be linked...
@Link_file  = ();
\end{code}

We inject consistency-checking information into \tr{.hc} files (both
when created by the Haskell compiler and when compiled by the C
compiler), so that we can check that an executable is made from
consistently-built pieces.  (The check is normally done just after
linking.)  The checking is done by introducing/munging
\tr{what(1)}-style strings.  Anyway, here are the relevant global
variables and their defaults:
\begin{code}
$LinkChk = 1;	# set to 0 if the link check should *not* be done

# major & minor version numbers; major numbers must always agree;
# minor disagreements yield a warning.
$HsC_major_version = 30;
$HsC_minor_version = 0;
$Cc_major_version  = 35;
$Cc_minor_version  = 0;

# options: these must always agree
$HsC_consist_options = '';    # we record, in this order:
			      #	    Build tag; debugging?
$Cc_consist_options  = '';    # we record, in this order:
			      #	    Build tag; debugging?
\end{code}

%************************************************************************
%*									*
\section[Driver-parse-argv]{Munge the command-line options}
%*									*
%************************************************************************

Now slurp through the arguments.
\begin{code}

#---------- user defined prelude ---------------------------------------

if (grep(/^-user-prelude$/, @ARGV)) {

    # If ARGV contains -user-prelude we are compiling a piece of 
    # prelude for the user, probably with additional specialise pragmas

    # We strip out the -O -f and -user-prelude flags provided on
    # the command line and add the ones used to compile the prelude
    # ToDo: get these options from a common definition in mkworld

    # We also enable any options forced through with -user-prelude-force

    # Hey, Check out this grep statement ;-)  (PS)

    @ARGV = grep((!/^-O/ && !/^-f/ && !/^-user-prelude$/) || s/^-user-prelude-force//,
		 @ARGV);

    unshift(@ARGV,
	'-fcompiling-ghc-internals=???', # ToDo!!!!
        '-O',
        '-fshow-pragma-name-errs',
        '-fshow-import-specs',
        '-fglasgow-exts',
        '-genSPECS',
        '-DUSE_FOLDR_BUILD',
	'-dcore-lint');

    print STDERR "ghc: -user-prelude options:\n", "@ARGV", "\n";
}

# can't use getopt(s); what we want is too complicated
arg: while($_ = $ARGV[0]) {
    shift(@ARGV);

    #---------- help -------------------------------------------------------
    if (/^-\?$/ || /^-help$/) { print $LongUsage; exit $Status; }

    #---------- verbosity and such -----------------------------------------
    /^-v$/	    && do { $Verbose = '-v'; $Time = 'time'; next arg; };

    #---------- what phases are to be run ----------------------------------
    /^-recomp/	    && do { $Do_recomp_chkr = 1; next arg; };

    /^-cpp$/	    && do { $Cpp_flag_set = 1; next arg; };
    # change the global default:
    # we won't run cat; we'll run the real thing
	
    /^-C$/	    && do { $Do_cc = 0; $Do_as = 0; $Do_lnkr = 0; $HscOut = '-C=';
			    next arg; };
    # stop after generating C
	
    /^-noC$/	    && do { $HscOut = '-N='; $ProduceHi = '-nohifile=';
			    $Do_cc = 0; $Do_as = 0; $Do_lnkr = 0;
			    next arg; };
    # leave out actual C generation (debugging) [also turns off interface gen]

    /^-hi$/	    && do { $HiOnStdout = 1; $ProduceHi = '-hifile='; next arg; };
    # _do_ generate an interface; usually used as: -noC -hi

    /^-nohi$/	    && do { $ProduceHi = '-nohifile='; next arg; };
    # don't generate an interface (even if generating C)

    /^-hi-diffs$/ &&		 do { $HiDiff_flag = 'normal'; next arg; };
    /^-hi-diffs-with-usages$/ && do { $HiDiff_flag = 'usages'; next arg; };
    /^-no-hi-diffs$/ &&		 do { $HiDiff_flag = '';       next arg; };
    # show/disable diffs if the interface file changes

    /^-E$/	    && do { push(@CcBoth_flags, '-E');
			    $Only_preprocess_C = 1;
			    $Do_as = 0; $Do_lnkr = 0; next arg; };
    # stop after preprocessing C

    /^-S$/	    && do { $Do_as = 0; $Do_lnkr = 0; next arg; };
    # stop after generating assembler
	
    /^-c$/	    && do { $Do_lnkr = 0; next arg; };
    # stop after generating .o files
	
    /^-link-chk$/    && do { $LinkChk = 1; next arg; };
    /^-no-link-chk$/ && do { $LinkChk = 0; next arg; };
    # don't do consistency-checking after a link

    /^-tmpdir$/ && do { $Tmp_prefix = &grab_arg_arg('-tmpdir', '');
			$Tmp_prefix = "$Tmp_prefix/ghc$$";
			$ENV{'TMPDIR'} = $Tmp_prefix; # for those who use it...
			next arg; };
    # use an alternate directory for temp files

    #---------- redirect output --------------------------------------------

    # -o <file>; applies to the last phase, whatever it is
    # "-o -" sends it to stdout
    # if <file> has a directory component, that dir must already exist

    /^-odir$/	    && do { $Specific_output_dir = &grab_arg_arg('-odir', '');
			    if (! -d $Specific_output_dir) {
				print STDERR "$Pgm: -odir: no such directory: $Specific_output_dir\n";
				$Status++;
			    }
			    next arg; };

    /^-o$/	    && do { $Specific_output_file = &grab_arg_arg('-o', '');
			    if ($Specific_output_file ne '-'
			     && $Specific_output_file =~ /(.*)\/[^\/]*$/) {
				local($dir_part) = $1;
				if (! -d $dir_part) {
				    print STDERR "$Pgm: no such directory: $dir_part\n";
				    $Status++;
				}
			    }
			    next arg; };

    # NB: -isuf not documented yet (because it doesn't work yet)
    /^-isuf$/	    && do { $Isuffix  = &grab_arg_arg('-isuf', '');
			    if ($Isuffix =~ /\./ ) {
				print STDERR "$Pgm: -isuf suffix shouldn't contain a .\n";
				$Status++;
			    }
			    next arg; };

    /^-osuf$/	    && do { $Osuffix  = &grab_arg_arg('-osuf', '');
			    if ($Osuffix =~ /\./ ) {
				print STDERR "$Pgm: -osuf suffix shouldn't contain a .\n";
				$Status++;
			    }
			    next arg; };

    # -ohi <file>; send the interface to <file>; "-ohi -" to send to stdout
    /^-ohi$/	    && do { $Specific_hi_file = &grab_arg_arg('-ohi', '');
			    if ($Specific_hi_file ne '-'
			     && $Specific_hi_file =~ /(.*)\/[^\/]*$/) {
				local($dir_part) = $1;
				if (! -d $dir_part) {
				    print STDERR "$Pgm: no such directory: $dir_part\n";
				    $Status++;
				}
			    }
			    next arg; };

    /^-hisuf$/	    && do { $HiSuffix = &grab_arg_arg('-hisuf', '');
			    if ($HiSuffix =~ /\./ ) {
				print STDERR "$Pgm: -hisuf suffix shouldn't contain a .\n";
				$Status++;
			    }
			    next arg; };
    /^-hisuf-prelude$/ && do { # as esoteric as they come...
			    $SysHiSuffix = &grab_arg_arg('-hisuf-prelude', '');
			    if ($SysHiSuffix =~ /\./ ) {
				print STDERR "$Pgm: -hisuf-prelude suffix shouldn't contain a .\n";
				$Status++;
			    }
			    next arg; };

    /^-odump$/	    && do { $Specific_dump_file = &grab_arg_arg('-odump', '');
			    if ($Specific_dump_file =~ /(.*)\/[^\/]*$/) {
				local($dir_part) = $1;
				if (! -d $dir_part) {
				    print STDERR "$Pgm: no such directory: $dir_part\n";
				    $Status++;
				}
			    }
			    next arg; };

    #-------------- scc & Profiling Stuff ----------------------------------

    /^-prof$/ && do { $PROFing = 'p'; next arg; }; # profiling -- details later!

    /^-auto/ && do {
		# generate auto SCCs on top level bindings
		# -auto-all = all top level bindings
		# -auto     = only top level exported bindings
		$PROFauto = ( /-all/ )
			    ? '-fauto-sccs-on-all-toplevs'
			    : '-fauto-sccs-on-exported-toplevs';
		next arg; };

    /^-caf-all/ && do { # generate individual CAF SCC annotations
		$PROFcaf = '-fauto-sccs-on-individual-cafs';
		next arg; };

    /^-ignore-scc$/ && do {
	        # forces ignore of scc annotations even if profiling
		$PROFignore_scc = '-W';
		next arg; };

    /^-G(.*)$/	&& do { push(@HsC_flags, "-G=$1");   # set group for cost centres
			next arg; };

    /^-unprof-scc-auto/ && do {
		# generate auto SCCs on top level bindings when not profiling
		# used to measure optimisation effects of presence of sccs
		$UNPROFscc_auto = ( /-all/ )
			    ? '-fauto-sccs-on-all-toplevs'
			    : '-fauto-sccs-on-exported-toplevs';
		next arg; };

    #--------- ticky/concurrent/parallel -----------------------------------
    # we sort out the details a bit later on

    /^-concurrent$/ && do { $CONCURing = 'c'; next arg; }; # concurrent Haskell
    /^-gransim$/    && do { $GRANing   = 'g'; next arg; }; # GranSim
    /^-ticky$/	    && do { $TICKYing  = 't'; next arg; }; # ticky-ticky
    /^-parallel$/   && do { $PARing    = 'p'; next arg; } ; # parallel Haskell

    #-------------- "user ways" --------------------------------------------

    (/^-user-setup-([a-oA-Z])$/
    || /^$(GHC_BUILD_FLAG_a)$/
    || /^$(GHC_BUILD_FLAG_b)$/
    || /^$(GHC_BUILD_FLAG_c)$/
    || /^$(GHC_BUILD_FLAG_d)$/
    || /^$(GHC_BUILD_FLAG_e)$/
    || /^$(GHC_BUILD_FLAG_f)$/
    || /^$(GHC_BUILD_FLAG_g)$/
    || /^$(GHC_BUILD_FLAG_h)$/
    || /^$(GHC_BUILD_FLAG_i)$/
    || /^$(GHC_BUILD_FLAG_j)$/
    || /^$(GHC_BUILD_FLAG_k)$/
    || /^$(GHC_BUILD_FLAG_l)$/
    || /^$(GHC_BUILD_FLAG_m)$/
    || /^$(GHC_BUILD_FLAG_n)$/
    || /^$(GHC_BUILD_FLAG_o)$/
    || /^$(GHC_BUILD_FLAG_A)$/
    || /^$(GHC_BUILD_FLAG_B)$/

    || /^$(GHC_BUILD_FLAG_2s)$/ # GC ones...
    || /^$(GHC_BUILD_FLAG_1s)$/
    || /^$(GHC_BUILD_FLAG_du)$/
    ) && do {
		/^-user-setup-([a-oA-Z])$/  && do { $BuildTag = "_$1"; };

		/^$(GHC_BUILD_FLAG_a)$/  && do { $BuildTag = '_a';  };
		/^$(GHC_BUILD_FLAG_b)$/  && do { $BuildTag = '_b';  };
		/^$(GHC_BUILD_FLAG_c)$/  && do { $BuildTag = '_c';  };
		/^$(GHC_BUILD_FLAG_d)$/  && do { $BuildTag = '_d';  };
		/^$(GHC_BUILD_FLAG_e)$/  && do { $BuildTag = '_e';  };
		/^$(GHC_BUILD_FLAG_f)$/  && do { $BuildTag = '_f';  };
		/^$(GHC_BUILD_FLAG_g)$/  && do { $BuildTag = '_g';  };
		/^$(GHC_BUILD_FLAG_h)$/  && do { $BuildTag = '_h';  };
		/^$(GHC_BUILD_FLAG_i)$/  && do { $BuildTag = '_i';  };
		/^$(GHC_BUILD_FLAG_j)$/  && do { $BuildTag = '_j';  };
		/^$(GHC_BUILD_FLAG_k)$/  && do { $BuildTag = '_k';  };
		/^$(GHC_BUILD_FLAG_l)$/  && do { $BuildTag = '_l';  };
		/^$(GHC_BUILD_FLAG_m)$/  && do { $BuildTag = '_m';  };
		/^$(GHC_BUILD_FLAG_n)$/  && do { $BuildTag = '_n';  };
		/^$(GHC_BUILD_FLAG_o)$/  && do { $BuildTag = '_o';  };
		/^$(GHC_BUILD_FLAG_A)$/  && do { $BuildTag = '_A';  };
		/^$(GHC_BUILD_FLAG_B)$/  && do { $BuildTag = '_B';  };

		/^$(GHC_BUILD_FLAG_2s)$/ && do { $BuildTag = '_2s'; };
		/^$(GHC_BUILD_FLAG_1s)$/ && do { $BuildTag = '_1s'; };
		/^$(GHC_BUILD_FLAG_du)$/ && do { $BuildTag = '_du'; };

		local($stuff) = $UserSetupOpts{$BuildTag};
		local(@opts)  = split(/\s+/, $stuff);
		
		# feed relevant ops into the arg-processing loop (if any)
		unshift(@ARGV, @opts) if $#opts >= 0;

		next arg; };

    #---------- set search paths for libraries and things ------------------

    # we do -i just like HBC (-i clears the list; -i<colon-separated-items>
    # prepends the items to the list); -I is for including C .h files.

    /^-i$/	    && do { @Import_dir = ();  # import path cleared!
			    @SysImport_dir = ();
			    print STDERR "WARNING: import paths cleared by `-i'\n";
			    next arg; };

    /^-i(.*)/	    && do { local(@new_items)
			      = split( /:/, &grab_arg_arg('-i', $1));
			    unshift(@Import_dir, @new_items);
			    next arg; };

    /^-I(.*)/	    && do { push(@Include_dir,     &grab_arg_arg('-I', $1)); next arg; };
    /^-L(.*)/	    && do { push(@UserLibrary_dir, &grab_arg_arg('-L', $1)); next arg; };
    /^-l(.*)/	    && do { push(@UserLibrary,'-l'.&grab_arg_arg('-l', $1)); next arg; };

    /^-syslib(.*)/  && do { local($syslib) = &grab_arg_arg('-syslib',$1);
			    print STDERR "$Pgm: no such system library (-syslib): $syslib\n",
			      $Status++ unless $syslib =~ /^(hbc|ghc|posix|contrib)$/;

			    unshift(@SysImport_dir,
				$(INSTALLING)
				? "$InstSysLibDir/$syslib/imports"
				: "$TopPwd/hslibs/$syslib/src");

			    if ( $(INSTALLING) ) {
				push(@SysLibrary_dir,
					("$InstSysLibDir/$TargetPlatform"));
			    } else {
				push(@SysLibrary_dir,
					("$TopPwd/hslibs/$syslib"
					,"$TopPwd/hslibs/$syslib/cbits"));
			    }

			    push(@SysLibrary, "-lHS$syslib");
			    push(@SysLibrary, "-lHS${syslib}_cbits")
			      unless $syslib eq 'contrib'; #HACK! it has no cbits

			    next arg; };

    #=======================================================================
    # various flags that we can harmlessly send to one program or another
    # (we will later "reclaim" some of the compiler ones now sent to gcc)
    #=======================================================================

    #---------- this driver itself (ghc) -----------------------------------
    # these change what executable is run for each phase:
    /^-pgmL(.*)$/   && do { $Unlit   = $1; next arg; };
    /^-pgmP(.*)$/   && do { $HsCpp   = $1; next arg; };
    /^-pgmC(.*)$/   && do { $HsC     = $1; next arg; };
    /^-pgmcO?(.*)$/ && do { $CcRegd  = $1; next arg; }; # the O? for back compat
    /^-pgma(.*)$/   && do { $As      = $1; next arg; };
    /^-pgml(.*)$/   && do { $Lnkr    = $1; next arg; };

    #---------- the get-anything-through opts (all pgms) -------------------
    # these allow arbitrary option-strings to go to any phase:
    /^-optL(.*)$/   && do { push(@Unlit_flags,   $1); next arg; };
    /^-optP(.*)$/   && do { push(@HsCpp_flags,   $1); next arg; };
    /^-optCrts(.*)$/&& do { push(@HsC_rts_flags, $1); next arg; };
    /^-optC(.*)$/   && do { push(@HsC_flags,     $1); next arg; };
    /^-optc(.*)$/   && do { push(@CcBoth_flags,  $1); next arg; };
    /^-opta(.*)$/   && do { push(@As_flags,      $1); next arg; };
    /^-optl(.*)$/   && do { push(@Ld_flags,      $1); next arg; };

    #---------- Haskell C pre-processor (hscpp) ----------------------------
    /^-D(.*)/	    && do { push(@HsCpp_flags, "'-D".&grab_arg_arg('-D',$1)."'"); next arg; };
    /^-U(.*)/	    && do { push(@HsCpp_flags, "'-U".&grab_arg_arg('-U',$1)."'"); next arg; };

    /^-genSPECS/   && do { $Cpp_flag_set = 1;
			   $genSPECS_flag = $_;
			    next arg; };

    #---------- post-Haskell "assembler"------------------------------------
    /^-ddump-raw-asm$/		  && do { $Dump_raw_asm	       = 1; next arg; };
    /^-ddump-asm-splitting-info$/ && do { $Dump_asm_splitting_info = 1; next arg; };

    #---------- Haskell compiler (hsc) -------------------------------------

    /^-keep-hc-files?-too$/	&& do { $Keep_hc_file_too = 1; next arg; };
    /^-keep-s-files?-too$/	&& do { $Keep_s_file_too = 1;  next arg; };

    /^-fhaskell-1\.3$/		&& do { next arg; }; # a no-op right now

    /^-fignore-interface-pragmas$/ && do { push(@HsC_flags, $_); next arg; };

    /^-fno-implicit-prelude$/      && do { $NoImplicitPrelude= 1; push(@HsC_flags, $_); next arg; };

    /^-user-prelude-force/	&& do { # ignore if not -user-prelude
				        next arg; };

    /^-split-objs/	&& do {
			if ( $TargetPlatform !~ /^(alpha|hppa1\.1|i386|m68k|mips|powerpc|sparc)-/ ) {
			    $SplitObjFiles = 0;
			    print STDERR "WARNING: don't know how to split objects on this platform: $TargetPlatform\n`-split-objs' option ignored\n";
			} else {
			    $SplitObjFiles = 1;
    			    $HscOut = '-C=';

			    push(@HsC_flags, "-fglobalise-toplev-names"); 
			    push(@CcBoth_flags, '-DUSE_SPLIT_MARKERS');

			    require('ghc-split.prl')
			     || &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-split.prl!\n");
			}
			next arg; };

    /^-fglasgow-exts$/
		&& do { push(@HsC_flags, $_);
			push(@HsP_flags, '-N');

#			push(@HsC_flags, '-fshow-import-specs');

			next arg; };

    /^-fspeciali[sz]e-unboxed$/
		&& do { $Oopt_DoSpecialise	= '-fspecialise';
			$Oopt_SpecialiseUnboxed	= '-fspecialise-unboxed';
			next arg; };
    /^-fspeciali[sz]e$/
		&& do { $Oopt_DoSpecialise = '-fspecialise'; next arg; };
    /^-fno-speciali[sz]e$/
		&& do { $Oopt_DoSpecialise = ''; next arg; };


# Now the foldr/build options, which are *on* by default (for -O).

    /^-ffoldr-build$/
		    && do { $Oopt_FoldrBuild = 1; 
			    $Oopt_FB_Support = '-fdo-arity-expand';
			    #print "Yes F/B\n";
			    next arg; };

    /^-fno-foldr-build$/
		    && do { $Oopt_FoldrBuild = 0; 
			    $Oopt_FB_Support = ''; 
			    next arg; };

    /^-fno-foldr-build-rule$/
		    && do { $Oopt_FoldrBuild = 0; 
			    next arg; };

    /^-fno-enable-tech$/
		    && do { $Oopt_FB_Support = ''; 
			    next arg; };

    /^-fno-snapback-to-append$/
		    && do { $Oopt_FoldrBuildInline .= ' -fdo-not-fold-back-append '; 
			    #print "No Foldback of append\n";
			    next arg; };

    # ---------------

    /^-fasm-(.*)$/  && do { $HscOut = '-S='; next arg; }; # force using nativeGen
    /^-fvia-C$/	    && do { $HscOut = '-C='; next arg; }; # force using C compiler

    # ---------------

    /^(-funfolding-use-threshold)(.*)$/
		    && do { $Oopt_UnfoldingUseThreshold = $1 . &grab_arg_arg($1, $2);
			    next arg; };

    /^(-fmax-simplifier-iterations)(.*)$/
		    && do { $Oopt_MaxSimplifierIterations = $1 . &grab_arg_arg($1, $2);
			    next arg; };

    /^-fno-pedantic-bottoms$/
		    && do { $Oopt_PedanticBottoms = ''; next arg; };

    /^-fdo-monad-eta-expansion$/
		    && do { $Oopt_MonadEtaExpansion = $_; next arg; };

    /^-fno-let-from-(case|app|strict-let)$/ # experimental, really (WDP 95/10)
		    && do { push(@HsC_flags, $_); next arg; };

    /^(-freturn-in-regs-threshold)(.*)$/
		    && do { local($what) = $1;
			    local($num)  = &grab_arg_arg($what, $2);
			    if ($num < 2 || $num > 8) {
				die "Bad experimental flag: $_\n";
			    } else {
				$HscOut = '-C='; # force using C compiler
				push(@HsC_flags, "$what$num");
				push(@CcRegd_flags, "-D__STG_REGS_AVAIL__=$num");
			    }
			    next arg; };

    # ---------------

    /^-fno-(.*)$/   && do { push(@HsC_antiflags, "-f$1");
			    &squashHscFlag("-f$1");
			    next arg; };

    /^-f(show-import-specs)/
		    && do { push(@HsC_flags, $_); next arg; };

    # ---------------

    /^-mlong-calls$/ && do { # for GCC for HP-PA boxes
			    unshift(@CcBoth_flags, ( $_ ));
			    next arg; };

    /^-m(v8|sparclite|cypress|supersparc|cpu=(cypress|supersparc))$/
		     && do { # for GCC for SPARCs
			    unshift(@CcBoth_flags, ( $_ ));
			    next arg; };

    /^-monly-([432])-regs/ && do { # for iX86 boxes only; no effect otherwise
			    $StolenX86Regs = $1;
			    next arg; };

    #*************** ... and lots of debugging ones (form: -d* )

    # -d(no-)core-lint is done this way so it is turn-off-able.
    /^-dcore-lint/       && do { $CoreLint = '-dcore-lint'; next arg; };
    /^-dno-core-lint/    && do { $CoreLint = '';    	    next arg; };

    /^-d(dump|ppr)-/         && do { push(@HsC_flags, $_); next arg; };
    /^-dverbose-(simpl|stg)/ && do { push(@HsC_flags, $_); next arg; };
    /^-dshow-passes/	     && do { push(@HsC_flags, $_); next arg; };
    /^-dshow-rn-trace/	     && do { push(@HsC_flags, $_); next arg; };
    /^-dsource-stats/        && do { push(@HsC_flags, $_); next arg; };
    /^-dsimplifier-stats/    && do { push(@HsC_flags, $_); next arg; };
    /^-dstg-stats/	     && do { $Oopt_StgStats = $_; next arg; };

    #*************** ... and now all these -R* ones for its runtime system...

    /^-Rscale-sizes?(.*)/ && do {
    	$Scale_sizes_by = &grab_arg_arg('-Rscale-sizes', $1);
	next arg; };

    /^(-H|-Rmax-heapsize)(.*)/ && do {
    	local($heap_size) = &grab_arg_arg($1, $2);
    	if ($heap_size =~ /(\d+)[Kk]$/) {
	    $heap_size = $1 * 1000;
	} elsif ($heap_size =~ /(\d+)[Mm]$/) {
	    $heap_size = $1 * 1000 * 1000;
	} elsif ($heap_size =~ /(\d+)[Gg]$/) {
	    $heap_size = $1 * 1000 * 1000 * 1000;
	}
	if ($heap_size <= 0) {
	    print STDERR "$Pgm: resetting heap-size to zero!!!\n";
	    $Specific_heap_size = 0;
	
	# if several heap sizes given, take the largest...
	} elsif ($heap_size >= $Specific_heap_size) {
	    $Specific_heap_size = $heap_size;
	} else {
	    print STDERR "$Pgm: ignoring heap-size-setting option ($_)...not the largest seen\n";
	}
	next arg; };

    /^-(K|Rmax-(stk|stack)size)(.*)/ && do {
    	local($stk_size) = &grab_arg_arg('-Rmax-stksize', $3);
    	if ($stk_size =~ /(\d+)[Kk]$/) {
	    $stk_size = $1 * 1000;
	} elsif ($stk_size =~ /(\d+)[Mm]$/) {
	    $stk_size = $1 * 1000 * 1000;
	} elsif ($stk_size =~ /(\d+)[Gg]$/) {
	    $stk_size = $1 * 1000 * 1000 * 1000;
	}
	if ($stk_size <= 0) {
	    print STDERR "$Pgm: resetting stack-size to zero!!!\n";
	    $Specific_stk_size = 0;

	# if several stack sizes given, take the largest...
	} elsif ($stk_size >= $Specific_stk_size) {
	    $Specific_stk_size = $stk_size;
	} else {
	    print STDERR "$Pgm: ignoring stack-size-setting option (-Rmax-stksize $stk_size)...not the largest seen\n";
	}
	next arg; };

    /^-Rgc-stats$/ && do {  $CollectingGCstats++;
			    # the two RTSs do this diff ways; we will try to compensate
			    next arg; };

    /^-Rghc-timing/ && do { $CollectGhcTimings = 1; next arg; };

    #---------- C high-level assembler (gcc) -------------------------------
    /^-(Wall|ansi|pedantic)$/ && do { push(@CcBoth_flags, $_); next arg; };

    # -dgcc-lint is a useful way of making GCC very fussy.
    # From alan@spri.levels.unisa.edu.au (Alan Modra).
    /^-dgcc-lint$/ && do { push(@CcBoth_flags, '-Wall -Wpointer-arith -Wbad-function-cast -Wcast-qual -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations -Wnested-externs'); next arg; };
    # An alternate set, from mark@sgcs.com (Mark W. Snitily)
    # -Wall -Wstrict-prototypes -Wmissing-prototypes -Wcast-align -Wshadow

    # inject "#include <wurble>" into the compiler's C output!

    /^-#include(.*)/	&& do {
	local($to_include) = &grab_arg_arg('-#include', $1);
	push(@CcInjects, "#include $to_include\n");
	next arg; };

    #---------- Linker (gcc, really) ---------------------------------------

    /^-static$/		&& do { push(@Ld_flags, $_); next arg; };

    #---------- mixed cc and linker magic ----------------------------------
    # this optimisation stuff is finally sorted out later on...

    /^-O2-for-C$/ && do { $MinusO2ForC = 1; next arg; };

    /^-O[1-2]?$/ && do {
#		print STDERR "$Pgm: NOTE: this version of GHC doesn't support -O or -O2\n";
		local($opt_lev) = ( /^-O2$/ ) ? 2 : 1; # max 'em
		$OptLevel = ( $opt_lev > $OptLevel ) ? $opt_lev : $OptLevel;

		$HscOut = '-C=' if $OptLevel == 2; # force use of C compiler
		next arg; };

    /^-Onot$/	&& do { $OptLevel = 0; next arg; }; # # set it to <no opt>

    /^-Ofile(.*)/ && do {
		$OptLevel = 3;
		local($ofile) = &grab_arg_arg('-Ofile', $1);
		@HsC_minusO3_flags = ();

		open(OFILE, "< $ofile") || die "Can't open $ofile!\n";
		while (<OFILE>) {
		    chop;
		    s/\#.*//;	    # death to comments
		    s/[ \t]+//g;    # death to whitespace
		    next if /^$/;   # ditto, blank lines
		    s/([()*{}])/\\$1/g;    # protect shell metacharacters
		    if ( /^C:(.*)/ ) {
			push(@CcBoth_flags, $1);
		    } else {
			push(@HsC_minusO3_flags, $_);
		    }
		}
		close(OFILE);
		next arg; };

    /^-debug$/	&& do { # all this does is mark a .hc/.o as "debugging"
			# in the consistency info
			$DEBUGging = 'd';
			next arg; };

    #---------- linking .a file --------------------------------------------

    /^-Main(.*)/ && do {
		# specifies main or mainPrimIO to be linked
		$Ld_main = $1;
		next arg; }; 

    #---------- catch unrecognized flags -----------------------------------

    /^-./ && do {
	print STDERR "$Pgm: unrecognised option: $_\n";
	$Status++;
	next arg; };

    #---------- anything else is considered an input file ------------------
    # (well, .o and .a files are immediately queued up as linker fodder..)
    if (/\.[oa]$/) {
	push(@Link_file, $_);
    } else {
	push(@Input_file, $_);
    }

    # input files must exist:
    if (! -f $_) {
	print STDERR "$Pgm: input file doesn't exist: $_\n";
	$Status++;
    }
}

# if there are several input files,
# we don't allow \tr{-o <file>} or \tr{-ohi <file>} options...
# (except if linking, of course)

if ($#Input_file > 0 && ( ! $Do_lnkr )) {
    if ( ($Specific_output_file ne '' && $Specific_output_file ne '-')
      || ($Specific_hi_file ne ''     && $Specific_hi_file ne '-') ) {
	print STDERR "$Pgm: You can't use -o or -ohi options if you have multiple input files.\n";
	print STDERR "\tPerhaps the -odir option will do what you want.\n";
	$Status++;
    }
}

# check for various pathological -o and -odir combinations...
if ($Specific_output_dir ne '' && $Specific_output_file ne '') {
    if ($Specific_output_file eq '-') {
	print STDERR "$Pgm: can't set output directory with -ohi AND have output to stdout\n";
	$Status++;
    } else { # amalgamate...
    	$Specific_output_file = "$Specific_output_dir/$Specific_output_file";
	# ToDo: check we haven't got a junk name now...
	$Specific_output_dir  = ''; # reset
    }
}

# PROFILING stuff after argv mangling:
if ( ! $PROFing ) {
    # warn about any scc exprs found (in case scc used as identifier)
    push(@HsP_flags, '-W');

    # add -auto sccs even if not profiling !
    push(@HsC_flags, $UNPROFscc_auto) if $UNPROFscc_auto;

} else {
    push(@HsC_flags, $PROFauto) if $PROFauto;
    push(@HsC_flags, $PROFcaf)  if $PROFcaf;
    #push(@HsC_flags, $PROFdict) if $PROFdict;

    $Oopt_FinalStgProfilingMassage = '-fmassage-stg-for-profiling';

    push(@HsP_flags, (($PROFignore_scc) ? $PROFignore_scc : '-S'));

    if ( $SplitObjFiles ) {
	# can't split with cost centres -- would need global and externs
    	print STDERR "$Pgm: WARNING: splitting objects when profiling will *BREAK* if any _scc_s are present!\n";
	# (but it's fine if there aren't any _scc_s around...)
#	$SplitObjFiles = 0; # unset
	#not an error: for now: $Status++;
    }
}

# crash and burn if there were errors
if ( $Status > 0 ) {
    print STDERR $ShortUsage;
    exit $Status;
}
\end{code}

%************************************************************************
%*									*
\section[Driver-post-argv-mangling]{Setup after reading options}
%*									*
%************************************************************************

%************************************************************************
%*									*
\subsection{Set up for optimisation level (\tr{-O} or whatever)}
%*									*
%************************************************************************

We come now to the default ``wads of options'' that are turned on by
\tr{-O0} (do min optimisation), \tr{-O} (ordinary optimisation),
\tr{-O2} (aggressive optimisation), or no O-ish flag (compile speed is
more important).

The user can also specify his/her own list of options in a file; in
that case, the work is already done (see stuff about @minusO3@,
earlier...).

GHC allows very precise control of what happens during a compilation.
Core-to-Core and STG-to-STG passes can be run in any order, as many
times as you like.  Individual transformations can be turned on or
disabled.

Sadly, however, there are some interdependencies \& Things You Must
Not Do.  Here is the list.

CORE-TO-CORE PASSES:
\begin{description}
\item[\tr{-fspecialise}:]
The specialiser must have dependency-analysed input; but if you run
the simplifier to do this, you must not let it toss away unused
bindings!  (The typechecker conveys some specialisation info via
``unused'' bindings...)

\item[\tr{-ffloat-inwards}:]
Floating inwards should be done before strictness analysis, because
the latter will give better results.

\item[\tr{-fstatic-args}:]
The static-arguments-transformation pass {\em must} have the
simplifier run right after it.

\item[\tr{-fcalc-inlinings[12]}:]
Not required, but there may be slight gains by re-simplifying after
this is done.  (You could then \tr{-fcalc-inlinings} again, just for
fun.)

\item[\tr{-ffull-laziness}:]
The (outwards-)let-floater should be the {\em last} Core-to-Core pass
that's run.  (Um, well, howzabout the simplifier just once more...)
\end{description}

STG-TO-STG PASSES:
\begin{description}
\item[\tr{-fupdate-analysis}:]
It really really wants to be the last STG-to-STG pass that is run.
\end{description}

\begin{code}
@HsC_minusNoO_flags
  = (	'-fsimplify',
	  '\(',
	  $Oopt_FB_Support,
#	  '-falways-float-lets-from-lets',	# no idea why this was here (WDP 95/09)
	  '-ffloat-lets-exposing-whnf',
	  '-ffloat-primops-ok',
	  '-fcase-of-case',
#	  '-fdo-lambda-eta-expansion',	# too complicated
	  '-freuse-con',
#	  '-flet-to-case',	# no strictness analysis, so...
	  $Oopt_PedanticBottoms,
#	  $Oopt_MonadEtaExpansion,	# no thanks
	  '-fsimpl-uf-use-threshold0',
	  '-fessential-unfoldings-only',
#	  $Oopt_UnfoldingUseThreshold,	# no thanks
	  $Oopt_MaxSimplifierIterations,
	  '\)',
	$Oopt_AddAutoSccs,
#	'-ffull-laziness',	# removed 95/04 WDP following Andr\'e's lead
	
	$Oopt_FinalStgProfilingMassage
    );

@HsC_minusO_flags # NOTE: used for *both* -O and -O2 (some conditional bits)
  = (
	'-fdo-eta-reduction',

	# initial simplify: mk specialiser happy: minimum effort please
	'-fsimplify',
	  '\(', 
	  $Oopt_FB_Support,
	  '-fkeep-spec-pragma-ids',	# required before specialisation
	  '-fsimpl-uf-use-threshold0',
	  '-fessential-unfoldings-only',
	  '-fmax-simplifier-iterations1',
	  $Oopt_PedanticBottoms,
	  '\)',

	($Oopt_DoSpecialise) ? (
	  '-fspecialise-overloaded',
	  $Oopt_SpecialiseUnboxed,
	  $Oopt_DoSpecialise,
	) : (),

	'-fsimplify', 			# need dependency anal after specialiser ...
	  '\(', 			# need tossing before calc-inlinings ...
	  $Oopt_FB_Support,
	  '-ffloat-lets-exposing-whnf',
	  '-ffloat-primops-ok',
	  '-fcase-of-case',
	  '-fdo-case-elim',
	  '-fcase-merge',
	  '-fdo-lambda-eta-expansion',
	  '-freuse-con',
	  $Oopt_PedanticBottoms,
	  $Oopt_MonadEtaExpansion,
	  $Oopt_UnfoldingUseThreshold,
	  $Oopt_MaxSimplifierIterations,
	  '\)',

#LATER:	'-fcalc-inlinings1', -- pointless for 2.01

#	($Oopt_FoldrBuildWW) ? (
#		'-ffoldr-build-ww-anal',
#		'-ffoldr-build-worker-wrapper',
#		'-fsimplify', 
#		  '\(', 
#		  $Oopt_FB_Support,
#		  '-ffloat-lets-exposing-whnf',
#		  '-ffloat-primops-ok',
#		  '-fcase-of-case',
#		  '-fdo-case-elim',
#		  '-fcase-merge',
#		  '-fdo-lambda-eta-expansion',
#		  '-freuse-con',
#		  $Oopt_PedanticBottoms,
#		  $Oopt_MonadEtaExpansion,
#		  $Oopt_UnfoldingUseThreshold,
#		  $Oopt_MaxSimplifierIterations,
#		  '\)',
#	 ) : (),

	# this pass-ordering sequence was agreed by Simon and Andr\'e
	# (WDP 94/07, 94/11).
	'-ffull-laziness',

	($Oopt_FoldrBuild) ? (
	  '-ffoldr-build-on',		# desugar list comprehensions for foldr/build

	  '-fsimplify', 
	    '\(', 
	    '-fignore-inline-pragma',	# **** NB!
	    '-fdo-foldr-build',		# NB
	    $Oopt_FB_Support,
	    '-ffloat-lets-exposing-whnf',
	    '-ffloat-primops-ok',
	    '-fcase-of-case',
	    '-fdo-case-elim',
	    '-fcase-merge',
	    '-fdo-lambda-eta-expansion',	# After full laziness
	    '-freuse-con',
	    $Oopt_PedanticBottoms,
	    $Oopt_MonadEtaExpansion,
	    $Oopt_UnfoldingUseThreshold,
	    $Oopt_MaxSimplifierIterations,
	    '\)',
	) : (),

	'-ffloat-inwards',

	'-fsimplify',
	  '\(', 
	  $Oopt_FB_Support,
	  '-ffloat-lets-exposing-whnf',
	  '-ffloat-primops-ok',
	  '-fcase-of-case',
	  '-fdo-case-elim',
	  '-fcase-merge',
	  '-fdo-lambda-eta-expansion',
	  '-freuse-con',
  	  ($Oopt_FoldrBuildInline),
			# you need to inline foldr and build
	  ($Oopt_FoldrBuild) ? ('-fdo-foldr-build') : (), 
			# but do reductions if you see them!
	  $Oopt_PedanticBottoms,
	  $Oopt_MonadEtaExpansion,
	  $Oopt_UnfoldingUseThreshold,
	  $Oopt_MaxSimplifierIterations,
	  '\)',

	'-fstrictness',

	'-fsimplify',
	  '\(', 
	  $Oopt_FB_Support,
	  '-ffloat-lets-exposing-whnf',
	  '-ffloat-primops-ok',
	  '-fcase-of-case',
	  '-fdo-case-elim',
	  '-fcase-merge',
	  '-fdo-lambda-eta-expansion',
	  '-freuse-con',
	  '-flet-to-case',		# Aha! Only done after strictness analysis
	  $Oopt_PedanticBottoms,
	  $Oopt_MonadEtaExpansion,
	  $Oopt_UnfoldingUseThreshold,
	  $Oopt_MaxSimplifierIterations,
	  '\)',

	'-ffloat-inwards',

# Case-liberation for -O2.  This should be after
# strictness analysis and the simplification which follows it.

#	( ($OptLevel != 2)
#        ? ''
#	: "-fliberate-case -fsimplify \\( $Oopt_FB_Support -ffloat-lets-exposing-whnf -ffloat-primops-ok -fcase-of-case -fdo-case-elim -fcase-merge -fdo-lambda-eta-expansion -freuse-con -flet-to-case $Oopt_PedanticBottoms $Oopt_MonadEtaExpansion $Oopt_UnfoldingUseThreshold $Oopt_MaxSimplifierIterations \\)" ),

# Final clean-up simplification:

	'-fsimplify',
	  '\(', 
	  $Oopt_FB_Support,
	  '-ffloat-lets-exposing-whnf',
	  '-ffloat-primops-ok',
	  '-fcase-of-case',
	  '-fdo-case-elim',
	  '-fcase-merge',
	  '-fdo-lambda-eta-expansion',
	  '-freuse-con',
	  '-flet-to-case',
	  '-fignore-inline-pragma',	# **** NB!
	  $Oopt_FoldrBuildInline,	
	  ($Oopt_FoldrBuild) ? ('-fdo-foldr-build') : (), 
			# but still do reductions if you see them!
	  $Oopt_PedanticBottoms,
	  $Oopt_MonadEtaExpansion,
	  $Oopt_UnfoldingUseThreshold,
	  $Oopt_MaxSimplifierIterations,
	  '\)',

      #	'-fstatic-args',

#LATER:	'-fcalc-inlinings2', -- pointless for 2.01

      # stg2stg passes
	'-fupdate-analysis',
	'-flambda-lift',
	$Oopt_FinalStgProfilingMassage,
	$Oopt_StgStats,

      # flags for stg2stg
	'-flet-no-escape',

      # SPECIAL FLAGS for -O2
	($OptLevel == 2) ? (
	  '-fsemi-tagging',
	) : (),
    );
\end{code}

Sort out what we're going to do about optimising.  First, the @hsc@
flags and regular @cc@ flags to worry about:
\begin{code}
if ( $OptLevel <= 0 ) {

    # for this level, we tell the parser -fignore-interface-pragmas
    push(@HsC_flags, '-fignore-interface-pragmas');
    # and tell the compiler not to produce them
    push(@HsC_flags, '-fomit-interface-pragmas');

    &add_Hsc_flags( @HsC_minusNoO_flags );
    push(@CcBoth_flags, ($MinusO2ForC) ? '-O2' : '-O');	# not optional!

} elsif ( $OptLevel == 1 || $OptLevel == 2 ) {

    &add_Hsc_flags( @HsC_minusO_flags );
    push(@CcBoth_flags, ($MinusO2ForC || $OptLevel == 2) ? '-O2' : '-O'); # not optional!
    # -O? to GCC is not optional! -O2 probably isn't worth it generally,
    # but it *is* useful in compiling the garbage collectors (so said
    # Patrick many moons ago...).

} else { # -Ofile, then...

    &add_Hsc_flags( @HsC_minusO3_flags );
    push(@CcBoth_flags, ($MinusO2ForC) ? '-O2' : '-O');	# possibly to be elaborated...
}
\end{code}

%************************************************************************
%*									*
\subsection{Check for consistency, etc.}
%*									*
%************************************************************************

Sort out @$BuildTag@, @$PROFing@, @$CONCURing@, @$PARing@,
@$GRANing@, @$TICKYing@:
\begin{code}
if ( $BuildTag ne '' ) {
    local($b) = $BuildDescr{$BuildTag};
    if ($CONCURing eq 'c') { print STDERR "$Pgm: Can't mix $b with -concurrent.\n"; exit 1; }
    if ($PARing    eq 'p') { print STDERR "$Pgm: Can't mix $b with -parallel.\n"; exit 1; }
    if ($GRANing   eq 'g') { print STDERR "$Pgm: Can't mix $b with -gransim.\n"; exit 1; }
    if ($TICKYing  eq 't') { print STDERR "$Pgm: Can't mix $b with -ticky.\n"; exit 1; }

    # ok to have a user-way profiling build
    # eval the profiling opts ... but leave user-way BuildTag 
    if ($PROFing   eq 'p') { eval($EvaldSetupOpts{'_p'}); }

} elsif ( $PROFing eq 'p' ) {
    if ($PARing   eq 'p') { print STDERR "$Pgm: Can't do profiling with -parallel.\n"; exit 1; }
    if ($GRANing  eq 'g') { print STDERR "$Pgm: Can't do profiling with -gransim.\n"; exit 1; }
    if ($TICKYing eq 't') { print STDERR "$Pgm: Can't do profiling with -ticky.\n"; exit 1; }
    $BuildTag = ($CONCURing eq 'c') ? '_mr' : '_p' ; # possibly "profiled concurrent"...

} elsif ( $CONCURing eq 'c' ) {
    if ($PARing  eq 'p') { print STDERR "$Pgm: Can't mix -concurrent with -parallel.\n"; exit 1; }
    if ($GRANing eq 'g') { print STDERR "$Pgm: Can't mix -concurrent with -gransim.\n"; exit 1; }
    $BuildTag = ($TICKYing eq 't')  ? '_mt' : '_mc' ; # possibly "ticky concurrent"...
    # "profiled concurrent" already acct'd for...

} elsif ( $PARing eq 'p' ) {
    if ($GRANing  eq 'g') { print STDERR "$Pgm: Can't mix -parallel with -gransim.\n"; exit 1; }
    if ($TICKYing eq 't') { print STDERR "$Pgm: Can't mix -parallel with -ticky.\n"; exit 1; }
    $BuildTag = '_mp';

    if ( $Do_lnkr && ( ! $ENV{'PVM_ROOT'} || ! $ENV{'PVM_ARCH'} )) {
	print STDERR "$Pgm: both your PVM_ROOT and PVM_ARCH environment variables must be set for linking under -parallel.\n";
	exit(1);
    }

} elsif ( $GRANing eq 'g' ) {
    if ($TICKYing eq 't') { print STDERR "$Pgm: Can't mix -gransim with -ticky.\n"; exit 1; }
    $BuildTag = '_mg';

} elsif ( $TICKYing eq 't' ) {
    $BuildTag = '_t';
}
\end{code}

\begin{code}
if ( $BuildTag ne '' ) { # something other than normal sequential...

    push(@HsP_flags, "-syshisuffix=$BuildTag.hi"); # use appropriate Prelude .hi files

    $HscOut = '-C='; # must go via C

    eval($EvaldSetupOpts{$BuildTag});
}
\end{code}

Decide what the consistency-checking options are in force for this run:
\begin{code}
$HsC_consist_options = "${BuildTag},${DEBUGging}";
$Cc_consist_options  = "${BuildTag},${DEBUGging}";
\end{code}

%************************************************************************
%*									*
\subsection{Add on machine-specific C-compiler flags}
%*									*
%************************************************************************

Shove on magical machine-specific options.  We use \tr{unshift} to
stick them on the {\em front} of the arrays, so that ``later''
user-specified flags can clobber them (e.g., \tr{-U__STG_REV_TBLS__}).

Note: a few ``always apply'' flags were set at the very beginning.

\begin{code}
if ($TargetPlatform =~ /^alpha-/) {
    # we know how to *mangle* asm for alpha
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;
    unshift(@CcBoth_flags,  ('-static'));

} elsif ($TargetPlatform =~ /^hppa/) {
    # we know how to *mangle* asm for hppa
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcBoth_flags,  ('-static'));
    # We don't put in '-mlong-calls', because it's only
    # needed for very big modules (sigh), and we don't want
    # to hobble ourselves further on all the other modules
    # (most of them).
    unshift(@CcBoth_flags,  ('-D_HPUX_SOURCE'));
        # ___HPUX_SOURCE, not _HPUX_SOURCE, is #defined if -ansi!
        # (very nice, but too bad the HP /usr/include files don't agree.)

} elsif ($TargetPlatform =~ /^i386-/) {
    # we know how to *mangle* asm for X86
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;

    # -fno-defer-pop : basically the same game as for m68k
    #
    # -fomit-frame-pointer : *must* ; because we're stealing
    #	the fp (%ebp) for our register maps.  *All* register
    #	maps (in MachRegs.lh) must steal it.

    unshift(@CcRegd_flags_hc, '-fno-defer-pop');
    unshift(@CcRegd_flags,    '-fomit-frame-pointer');
    unshift(@CcRegd_flags,    "-DSTOLEN_X86_REGS=$StolenX86Regs");

} elsif ($TargetPlatform =~ /^m68k-/) {
    # we know how to *mangle* asm for m68k
    unshift (@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift (@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;

    # -fno-defer-pop : for the .hc files, we want all the pushing/
    #     popping of args to routines to be explicit; if we let things
    #     be deferred 'til after an STGJUMP, imminent death is certain!
    #
    # -fomit-frame-pointer : *don't*
    #	  It's better to have a6 completely tied up being a frame pointer
    #	  rather than let GCC pick random things to do with it.
    #	  (If we want to steal a6, then we would try to do things
    #	  as on iX86, where we *do* steal the frame pointer [%ebp].)

    unshift(@CcRegd_flags_hc, '-fno-defer-pop');
    unshift(@CcRegd_flags,    '-fno-omit-frame-pointer');
	# maybe gives reg alloc a better time
	# also: -fno-defer-pop is not sufficiently well-behaved without it

} elsif ($TargetPlatform =~ /^mips-/) {
    # we (hope to) know how to *mangle* asm for MIPSen
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;
    unshift(@CcBoth_flags,  ('-static'));

} elsif ($TargetPlatform =~ /^powerpc-/) {
    # we know how to *mangle* asm for PowerPC
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;
    unshift(@CcBoth_flags,  ('-static')); # always easier to start with
    unshift(@CcRegd_flags, ('-finhibit-size-directive')); # avoids traceback tables

} elsif ($TargetPlatform =~ /^sparc-/) {
    # we know how to *mangle* asm for SPARC
    unshift(@CcRegd_flags, ('-D__STG_REV_TBLS__'));
    unshift(@CcRegd_flags, ('-DSTACK_CHECK_BY_PAGE_FAULT=1')) if $StkChkByPageFaultOK;

}
\end{code}

Same unshifting magic, but for special linker flags.

Should really be whether or not we prepend underscores to global symbols,
not an architecture test.  (JSM)

\begin{code}
$Under = (   $TargetPlatform =~ /^alpha-/
	  || $TargetPlatform =~ /^hppa/
	  || $TargetPlatform =~ /^mips-sgi-irix/
	  || $TargetPlatform =~ /^powerpc-/
	  || $TargetPlatform =~ /-solaris/
	  || $TargetPlatform =~ /-linux$/
	 )
	 ? '' : '_';

unshift(@Ld_flags,
      (($Ld_main) ? (
        '-u', "${Under}Main_" . $Ld_main . '_closure',
       ) : ()
#       , '-u', "${Under}STbase_unsafePerformPrimIO_fast1"
#       , '-u', "${Under}Prelude_Z91Z93_closure"	 # i.e., []
#       , '-u', "${Under}Prelude_IZh_static_info"
#       , '-u', "${Under}Prelude_False_inregs_info"
#       , '-u', "${Under}Prelude_True_inregs_info"
#       , '-u', "${Under}Prelude_CZh_static_info"
#       , '-u', "${Under}DEBUG_REGS"
	))
       ; # just for fun, now...
\end{code}

%************************************************************************
%*									*
\subsection{Set up include paths and system-library enslurpment}
%*									*
%************************************************************************

Now that we know what garbage-collector, etc., are required, we can
finalise our list of libraries to slurp through, and generally Get
Ready for Business.

\begin{code}
# default includes must be added AFTER option processing
if ( ! $(INSTALLING) ) {
    push (@Include_dir, "$TopPwd/$(CURRENT_DIR)/$(GHC_INCLUDESRC)");
} else {
    push (@Include_dir, "$InstLibDirGhc/includes");
    push (@Include_dir, "$InstDataDirGhc/includes");
}
\end{code}

\begin{code}
push(@SysLibrary, ( '-lHS', '-lHS_cbits' )); # basic I/O and prelude stuff

local($f);
foreach $f (@SysLibrary) {
    next if $f =~ /_cbits/;
    $f .= $BuildTag if $f =~ /^-lHS/;
}

# fiddle the TopClosure file name...
$TopClosureFile =~ s/XXXX//;

# Push library HSrts, plus boring clib bit
push(@SysLibrary, "-lHSrts${BuildTag}");
push(@SysLibrary, '-lHSclib');

# Push the pvm libraries
if ($BuildTag eq '_mp') {
    $pvmlib = "$ENV{'PVM_ROOT'}/lib/$ENV{'PVM_ARCH'}";
    push(@SysLibrary, "-L$pvmlib", '-lpvm3', '-lgpvm3');
    if ( $ENV{'PVM_ARCH'} eq 'SUNMP' ) {
        push(@SysLibrary, '-lthread', '-lsocket', '-lnsl');
    } elsif ( $ENV{'PVM_ARCH'} eq 'SUN4SOL2' ) {
        push(@SysLibrary, '-lsocket', '-lnsl');
    }
}

# Push the GNU multi-precision arith lib; and the math library
push(@SysLibrary, '-lgmp');
push(@SysLibrary, '-lm');
\end{code}

%************************************************************************
%*									*
\subsection{Check that this system was built to do what we are asking}
%*									*
%************************************************************************

Before continuing we check that the appropriate build is available.

\begin{code}
die "$Pgm: no BuildAvail?? $BuildTag\n" if ! $BuildAvail{$BuildTag}; # sanity

if ( $BuildAvail{$BuildTag} =~ /^NO$/ ) {
    print STDERR "$Pgm: a `", $BuildDescr{$BuildTag},
	"' \"build\" is not available with your GHC setup.\n";
    print STDERR "(It was not configured for it at your site.)\n";
    print STDERR $ShortUsage;
    exit 1;
}
\end{code}

%************************************************************************
%*									*
\subsection{Final miscellaneous setup bits before we start going}
%*									*
%************************************************************************

Record largest specific heapsize, if any.
\begin{code}
$Specific_heap_size = $Specific_heap_size * $Scale_sizes_by;
push(@HsC_rts_flags, '-H'.$Specific_heap_size);
$Specific_stk_size = $Specific_stk_size * $Scale_sizes_by;
push(@HsC_rts_flags, "-K$Specific_stk_size");

# hack to avoid running hscpp
$HsCpp = $Cat if ! $Cpp_flag_set;
\end{code}

If no input or link files seen, then we let 'em feed in stdin; this is
mainly for debugging.
\begin{code}
if ($#Input_file < 0 && $#Link_file < 0) {
    @Input_file = ( '-' );

    open(INF, "> $Tmp_prefix.hs") || &tidy_up_and_die(1,"Can't open $Tmp_prefix.hs\n");
    print STDERR "Enter your Haskell program, end with ^D (on a line of its own):\n";
    while (<>) { print INF $_; }
    close(INF) || &tidy_up_and_die(1,"Failed writing to $Tmp_prefix.hs\n");
}
\end{code}

Tell the world who we are, if they asked.
\begin{code}
print STDERR "$(PROJECTNAME), version $(PROJECTVERSION) $(PROJECTPATCHLEVEL)\n"
    if $Verbose;
\end{code}

%************************************************************************
%*									*
\section[Driver-main-loop]{Main loop: Process input files, and link if required}
%*									*
%************************************************************************

Process the input files; don't continue with linking if there are
problems (global variable @$Status@ non-zero).
\begin{code}
foreach $ifile (@Input_file) {
    &ProcessInputFile($ifile);
}

if ( $Status > 0 ) { # don't link if there were errors...
    print STDERR $ShortUsage;
    &tidy_up();
    exit $Status;
}
\end{code}

Link if appropriate.
\begin{code}
if ($Do_lnkr) {
    local($libdirs) = '';

    # glue them together:
    push(@UserLibrary_dir, @SysLibrary_dir);

    $libdirs = '-L' . join(' -L',@UserLibrary_dir) if $#UserLibrary_dir >= 0;

    # for a linker, use an explicitly given one, or the going C compiler ...
    local($lnkr) = ( $Lnkr ) ? $Lnkr : $CcRegd;

    local($output) = ($Specific_output_file ne '') ? "-o $Specific_output_file" : '';
    @Files_to_tidy = ($Specific_output_file ne '') ? $Specific_output_file : 'a.out';

    local($to_do) = "$lnkr $Verbose @Ld_flags $output @Link_file $TopClosureFile $libdirs @UserLibrary @SysLibrary";
    &run_something($to_do, 'Linker');

    # finally, check the consistency info in the binary
    local($executable) = $Files_to_tidy[0];
    @Files_to_tidy = (); # reset; we don't want to nuke it if it's inconsistent

    if ( $LinkChk ) {
    	# dynamically load consistency-chking code; then do it.
	require('ghc-consist.prl')
	    || &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-consist.prl!\n");

    	&chk_consistency_info ( $executable );
    }

    # if PVM parallel stuff, we do truly weird things.
    # Essentially: (1) move the executable over to where PVM expects
    # to find it.  (2) create a script in place of the executable
    # which will cause the program to be run, via SysMan.
    if ( $PARing eq 'p' ) {
	local($pvm_executable) = $executable;
	local($pvm_executable_base);

	if ( $pvm_executable !~ /^\// ) { # a relative path name: make absolute
	    local($pwd) = `pwd`;
	    chop($pwd);
	    $pwd =~ s/^\/tmp_mnt//;
	    $pvm_executable = "$pwd/$pvm_executable";
	}

	$pvm_executable =~ s|/|=|g; # make /s into =s
	$pvm_executable_base = $pvm_executable;

	$pvm_executable = $ENV{'PVM_ROOT'} . '/bin/' . $ENV{'PVM_ARCH'}
			. "/$pvm_executable";

	&run_something("$Rm -f $pvm_executable; $Cp -p $executable $pvm_executable && $Rm -f $executable", 'Moving binary to PVM land');

	# OK, now create the magic script for "$executable"
	open(EXEC, "> $executable") || &tidy_up_and_die(1,"$Pgm: couldn't open $executable to write!\n");
	print EXEC <<EOSCRIPT1;
#!$(PERL)
# =!=!=!=!=!=!=!=!=!=!=!
# This script is automatically generated: DO NOT EDIT!!!
# Generated by Glasgow Haskell, version $(PROJECTVERSION) $(PROJECTPATCHLEVEL)
#
\$pvm_executable      = '$pvm_executable';
\$pvm_executable_base = '$pvm_executable_base';
\$SysMan = '$SysMan';
EOSCRIPT1

	print EXEC <<\EOSCRIPT2;
# first, some magical shortcuts to run "commands" on the binary
# (which is hidden)
if ($#ARGV == 1 && $ARGV[0] eq '+RTS' && $ARGV[1] =~ /^--((size|file|strip|rm|nm).*)/ ) {
    local($cmd) = $1;
    system("$cmd $pvm_executable");
    exit(0); # all done
}

# OK, really run it; process the args first
$ENV{'PE'} = $pvm_executable_base;
$debug = '';
$nprocessors = 2; # the default
@nonPVM_args = ();
$in_RTS_args = 0;

# ToDo: handle --RTS
args: while ($a = shift(@ARGV)) {
    if ( $a eq '+RTS' ) {
	$in_RTS_args = 1;
    } elsif ( $a eq '-RTS' ) {
	$in_RTS_args = 0;
    }
    if ( $a eq '-d' && $in_RTS_args ) {
	$debug = '-';
    } elsif ( $a =~ /^-N(\d+)/ && $in_RTS_args ) {
	$nprocessors = $1;
    } else {
	push(@nonPVM_args, $a);
    }
}

local($return_val) = 0;
system("$SysMan $debug $pvm_executable $nprocessors @nonPVM_args");
$return_val = $?;
system("mv $ENV{'HOME'}/$pvm_executable_base.???.gr .") if -f "$ENV{'HOME'}/$pvm_executable_base.001.gr";
exit($return_val);
EOSCRIPT2
	close(EXEC) || die "Failed closing $executable\n";
	chmod 0755, $executable;
    }
}

# that...  that's all, folks!
&tidy_up();
exit $Status; # will still be 0 if all went well
\end{code}

%************************************************************************
%*									*
\section[Driver-do-one-file]{How to process a single input file}
%*									*
%************************************************************************

\begin{code}
sub ProcessInputFile {
    local($ifile) = @_;	  # input file name
    local($ifile_root);	  # root of or basename of input file
    local($ofile_target); # ultimate output file we hope to produce
			  # from input file (need to know for recomp
			  # checking purposes)
    local($hifile_target);# ditto (but .hi file)
\end{code}

Handle the weirdity of input from stdin.
\begin{code}
    if ($ifile ne '-') {
	($ifile_root  = $ifile) =~ s/\.[^\.\/]+$//;
	$ofile_target = # may be reset later...
			($Specific_output_file ne '' && ! $Do_lnkr)
			? $Specific_output_file
			: &odir_ify($ifile_root, 'o');
	$hifile_target= ($Specific_hi_file ne '')
			? $Specific_hi_file
			: "$ifile_root.$HiSuffix"; # ToDo: odirify?
			# NB: may change if $ifile_root isn't module name (??)
    } else {
	$ifile = "$Tmp_prefix.hs"; # we know that's where we put the input
	$ifile_root   = '_stdin';
	$ofile_target = '_stdout'; # gratuitous?
	$hifile_target= '_stdout'; # ditto?
    }
\end{code}

We need to decide what phases of the compilation system we will run
over this file.  The defaults are the ones established when processing
flags.  (That established what the last phase run for all files is.)

We do the pre-recompilation-checker phases here; the rest later.
\begin{code}
\end{code}

Look at the suffix and decide what initial phases of compilation may
be dropped off for this file.  Also the rather boring business of
which files are coming-in/going-out.

Again, we'll do the post-recompilation-checker parts of this later.
\begin{code}
    local($do_lit2pgm)	= ($ifile =~ /\.lhs$/) ? 1 : 0;
    local($do_hscpp)	= 1; # but "hscpp" might really be "cat"
    local($do_hsc)	= 1;
    local($do_cc)	= ( $Do_cc != -1) # i.e., it was set explicitly
			  ? $Do_cc
			  : ( ($HscOut eq '-C=') ? 1 : 0 );
    local($do_as)	= $Do_as;

    # names of the files to stuff between phases
    # defaults are temporaries
    local($in_lit2pgm)	  = $ifile;
    local($lit2pgm_hscpp) = "$Tmp_prefix.lpp";
    local($hscpp_hsc)	  = "$Tmp_prefix.cpp";
    local($hsc_out)	  = ( $HscOut eq '-C=' ) ? "$Tmp_prefix.hc" : "$Tmp_prefix.s" ;
    local($hsc_hi)	  = "$Tmp_prefix.hi";
    local($cc_as_o)	  = "${Tmp_prefix}_o.s"; # temporary for raw .s file if opt C
    local($cc_as)	  = "$Tmp_prefix.s";	 # mangled or hsc-produced .s code
    local($as_out)	  = $ofile_target;

    local($is_hc_file) = 1; #Is the C code .hc or .c? Assume .hc for now

    if ($ifile =~ /\.lhs$/) {
	; # nothing to change
    } elsif ($ifile =~ /\.hs$/) {
    	$do_lit2pgm = 0;
	$lit2pgm_hscpp = $ifile;
    } elsif ($ifile =~ /\.hc$/ || $ifile =~ /_hc$/ ) { # || $ifile =~ /\.$Isuffix$/o) # ToDo: better
    	$do_lit2pgm = 0; $do_hscpp = 0; $do_hsc = 0; $do_cc = 1;
	$hsc_out = $ifile;    
    } elsif ($ifile =~ /\.c$/) {
    	$do_lit2pgm = 0; $do_hscpp = 0; $do_hsc = 0; $do_cc = 1;
	$hsc_out = $ifile; $is_hc_file = 0;
    } elsif ($ifile =~ /\.s$/) {
    	$do_lit2pgm = 0; $do_hscpp = 0; $do_hsc = 0; $do_cc = 0;
	$cc_as = $ifile;    
    } else { # don't know what it is, but nothing to do herein...
    	$do_lit2pgm = 0; $do_hscpp = 0; $do_hsc = 0; $do_cc = 0; $do_as = 0;
    }

    # OK, have a bash on the first two phases:
    &runLit2pgm($in_lit2pgm, $lit2pgm_hscpp)
	if $do_lit2pgm;

    &runHscpp($in_lit2pgm, $lit2pgm_hscpp, $hscpp_hsc)
	if $do_hscpp;
\end{code}

We now think about whether to run hsc/cc or not (when hsc produces .s
stuff, it effectively takes the place of both phases).

To get the output file name right: for each phase that we are {\em
not} going to run, set its input (i.e., the output of its preceding
phase) to @"$ifile_root.<suffix>"@.
\begin{code}
    local($going_interactive) = $HscOut eq '-N=' || $ifile_root eq '_stdin';

    if (! $do_cc && ! $do_as) { # stopping after hsc
	$hsc_out = ($Specific_output_file ne '')
		 ? $Specific_output_file
		 : &odir_ify($ifile_root, ($HscOut eq '-C=') ? 'hc' : 's');

	$ofile_target = $hsc_out; # reset
    }

    if (! $do_as) { # stopping after gcc (or hsc)
	$cc_as = ($Specific_output_file ne '')
		 ? $Specific_output_file
		 : &odir_ify($ifile_root, ( $Only_preprocess_C ) ? 'i' : 's');

	$ofile_target = $cc_as; # reset
    }

\end{code}


Now the Haskell compiler, C compiler, and assembler

\begin{code}
   if ($do_hsc) {
	&runHscAndProcessInterfaces( $ifile, $hscpp_hsc, $ifile_root, 
				     $ofile_target, $hifile_target);
    }

    if ($do_cc) {
	&runGcc    ($is_hc_file, $hsc_out, $cc_as_o);
	&runMangler($is_hc_file, $cc_as_o, $cc_as, $ifile_root);
    }

    &split_asm_file($cc_as)  if $do_as && $SplitObjFiles;

    &runAs($as_out, $ifile_root) if $do_as;
\end{code}

Finally, decide what to queue up for linker input.
\begin{code}
    # tentatively assume we will eventually produce linker input:
    push(@Link_file, &odir_ify($ifile_root, 'o'));

#ToDo:    local($or_isuf) = ($Isuffix eq '') ? '' : "|$Isuffix";

    if ( $ifile !~ /\.(lhs|hs|hc|c|s)$/ && $ifile !~ /_hc$/ ) {
	print STDERR "$Pgm: don't recognise suffix on `$ifile'; passing it through to linker\n"
	    if $ifile !~ /\.a$/;

	# oops; we tentatively pushed the wrong thing; fix & do the right thing
	pop(@Link_file); push(@Link_file, $ifile);
    }

} # end of ProcessInputFile
\end{code}

%************************************************************************
%*									*
\section[Driver-run-phases]{Routines to run the various phases}
%*									*
%************************************************************************

\begin{code}
sub runLit2pgm {
    local($in_lit2pgm, $lit2pgm_hscpp) = @_;

    local($to_do) = "echo '#line 1 \"$in_lit2pgm\"' > $lit2pgm_hscpp && ".
		    "$Unlit @Unlit_flags $in_lit2pgm -  >> $lit2pgm_hscpp";
    @Files_to_tidy = ( $lit2pgm_hscpp );

    &run_something($to_do, 'literate pre-processor');
}
\end{code}

\begin{code}
sub runHscpp {
    local($in_lit2pgm, $lit2pgm_hscpp, $hscpp_hsc) = @_;

    local($to_do);

    if ($HsCpp eq $Cat) {
	$to_do = "echo '#line 1 \"$in_lit2pgm\"' > $hscpp_hsc && ".
			"$HsCpp $lit2pgm_hscpp >> $hscpp_hsc";
	@Files_to_tidy = ( $hscpp_hsc );
	&run_something($to_do, 'Ineffective C pre-processor');
    } else {
	local($includes) = '-I' . join(' -I',@Include_dir);
	$to_do = "echo '#line 1 \"$in_lit2pgm\"' > $hscpp_hsc && ".
			"$HsCpp $Verbose $genSPECS_flag @HsCpp_flags -D__HASKELL1__=$Haskell1Version -D__GLASGOW_HASKELL__=$GhcVersionInfo $includes $lit2pgm_hscpp >> $hscpp_hsc";
	@Files_to_tidy = ( $hscpp_hsc );
	&run_something($to_do, 'Haskellised C pre-processor');
    }
}
\end{code}

\begin{code}
sub runHscAndProcessInterfaces {
    local($ifile, $hscpp_hsc, $ifiel_root, $ofile_target, $hifile_target) = @_;

	# $ifile 		is the original input file
	# $hscpp_hsc		post-unlit, post-cpp, etc., input file
	# $ifile_root		input filename minus suffix
	# $ofile_target		the output file that we ultimately hope to produce
	# $hifile_target	the .hi file ... (ditto)
	
    local($source_unchanged) = 1;

# Check if the source file is up to date relative to the target; in
#  that case we say "source is unchanged" and let the compiler bale out
# early if the import usage information allows it.

    ($i_dev,$i_ino,$i_mode,$i_nlink,$i_uid,$i_gid,$i_rdev,$i_size,
     $i_atime,$i_mtime,$i_ctime,$i_blksize,$i_blocks) = stat($ifile);

    if ( ! -f $ofile_target ) {
	print STDERR "$Pgm:compile:Output file $ofile_target doesn't exist\n";
	$source_unchanged = 0;
    }

    ($o_dev,$o_ino,$o_mode,$o_nlink,$o_uid,$o_gid,$o_rdev,$o_size,
     $o_atime,$o_mtime,$o_ctime,$o_blksize,$o_blocks) = stat(_); # stat info from -f test

    if ( ! -f $hifile_target ) {
	print STDERR "$Pgm:compile:Interface file $hifile_target doesn't exist\n";
	$source_unchanged = 0;
    }

    ($hi_dev,$hi_ino,$hi_mode,$hi_nlink,$hi_uid,$hi_gid,$hi_rdev,$hi_size,
     $hi_atime,$hi_mtime,$hi_ctime,$hi_blksize,$hi_blocks) = stat(_); # stat info from -f test

    if ($i_mtime > $o_mtime) {
	print STDERR "$Pgm:recompile:Input file $ifile newer than $ofile_target\n";
	$source_unchanged = 0;
    }

    # So if source_unchanged is still "1", we pass on the good news to the compiler
    # The -recomp flag can disable this, forcing recompilation
    if ($Do_recomp_chkr && $source_unchanged) {
	push(@HsC_flags, '-fsource-unchanged');	
    }	

# Run the compiler

    &runHsc($ifile_root, $hsc_out, $hsc_hi, $going_interactive);

# See if it baled out early, saying nothing needed doing.  
# We work this out by seeing if it created an output .hi file

    if ( ! -f $hsc_hi ) {
	# Doesn't exist, so we baled out early.
	# Tell the C compiler and assembler not to run
	$do_cc = 0; $do_as = 0;

	# Update dependency info
	&run_something("touch $ofile_target", "Touch $ofile_target, to propagate dependencies");

    } else {	

# Didn't bale out early (new .hi file) so we thunder on
    
    	# If non-interactive, heave in the consistency info at the end
    	# NB: pretty hackish (depends on how $output is set)
    	if ( ! $going_interactive ) {
	    if ( $HscOut eq '-C=' ) {
	    $to_do = "echo 'static char ghc_hsc_ID[] = \"\@(#)hsc $ifile\t$HsC_major_version.$HsC_minor_version,$HsC_consist_options\";' >> $hsc_out";
    
	    } elsif ( $HscOut eq '-S=' ) {
		local($consist) = "hsc.$ifile.$HsC_major_version.$HsC_minor_version.$HsC_consist_options";
		$consist =~ s/,/./g;
		$consist =~ s/\//./g;
		$consist =~ s/-/_/g;
		$consist =~ s/[^A-Za-z0-9_.]/ZZ/g; # ToDo: properly?
		$to_do = "echo '\n\t.text\n$consist:' >> $hsc_out";
	    }
	    &run_something($to_do, 'Pin on Haskell consistency info');	
    	}   


	# Interface-handling is important enough to live off by itself
	require('ghc-iface.prl')
	    || &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-iface.prl!\n");
	
	&postprocessHiFile($hsc_hi, $hifile_target, $going_interactive);
	
	# save a copy of the .hc file, even if we are carrying on...
	if ($HscOut eq '-C=' && $do_cc && $Keep_hc_file_too) {
	    local($to_do) = "$Rm $ifile_root.hc; $Cp $hsc_out $ifile_root.hc";
	    &run_something($to_do, 'Saving copy of .hc file');
	}
	
	# save a copy of the .s file, even if we are carrying on...
	if ($HscOut eq '-S=' && $do_as && $Keep_s_file_too) {
	    local($to_do) = "$Rm $ifile_root.s; $Cp $hsc_out $ifile_root.s";
	    &run_something($to_do, 'Saving copy of .s file');
	}
	
	# if we're going to split up object files,
	# we inject split markers into the .hc file now
	if ( $HscOut eq '-C=' && $SplitObjFiles ) {
	    &inject_split_markers ( $hsc_out );
        }
    }
}
\end{code}


\begin{code}
sub runHsc {
    local($ifile_root, $hsc_out, $hsc_hi, $going_interactive) = @_;

    # prepend comma to HsP flags (so hsc can tell them apart...)
    foreach $a ( @HsP_flags ) { $a = ",$a" unless $a =~ /^,/; }

    &makeHiMap() unless $HiMapDone;
#    print STDERR "HiIncludes: $HiIncludeString\n";
    push(@HsC_flags, "-himap=$HiIncludeString");
#    push(@HsC_flags, "-himap=$HiMapFile");

    # here, we may produce .hc/.s and/or .hi files
    local($output) = '';
    @Files_to_tidy = ();

    if ( $going_interactive ) {
	# don't need .hi unless going to show it on stdout:
	$ProduceHi = '-nohifile=' if ! $HiOnStdout;
	$do_cc = 0; $do_as = 0; $Do_lnkr = 0; # and we won't go any further...
    }

    # set up for producing output/.hi; note that flag twiddling
    # may mean that nothing will actually be produced:
    $output = "$ProduceHi$hsc_hi $HscOut$hsc_out";
    @Files_to_tidy = ( $hsc_hi, $hsc_out );

    # if we're compiling foo.hs, we want the GC stats to end up in foo.stat
    if ( $CollectingGCstats ) {
	push(@HsC_rts_flags, "-S$ifile_root.stat");
	push(@Files_to_tidy, "$ifile_root.stat");
    }

    if ( $CollectGhcTimings ) { # assume $RTS_style eq 'ghc'
	# emit nofibbish time/bytes-alloc stats to stderr;
	# see later .stat file post-processing
	push(@HsC_rts_flags, "-s$Tmp_prefix.stat");
	push(@Files_to_tidy, "$Tmp_prefix.stat");
    }

    local($dump) = '';
    if ($Specific_dump_file ne '') {
	$dump = "2>> $Specific_dump_file";
	$Using_dump_file = 1;
    }

    local($to_do);
    $to_do = "$HsC @HsP_flags ,$hscpp_hsc $dump @HsC_flags $CoreLint $Verbose $output +RTS @HsC_rts_flags";
    &run_something($to_do, 'Haskell compiler');

    # finish business w/ nofibbish time/bytes-alloc stats
    &process_ghc_timings() if $CollectGhcTimings;
}
\end{code}

Use \tr{@Import_dir} and \tr{@SysImport_dir} to make a tmp file
of (module-name, pathname) pairs, one per line, separated by a space.
\begin{code}
%HiMap     = ();
$HiMapDone = 0;
$HiMapFile = '';
$HiIncludeString = ();		# dir1:dir2:dir3, to pass to GHC

sub makeHiMap {

    # collect in %HiMap; write later; also used elsewhere in driver

    local($mod, $path, $d, $e);
    
    foreach $d ( @Import_dir ) {
	if ($HiIncludeString) { $HiIncludeString = "$HiIncludeString:$d";
	} else { $HiIncludeString = $d; }

	opendir(DIR, $d) || &tidy_up_and_die(1,"$Pgm: error when reading directory: $d\n");
	local(@entry) = readdir(DIR);
	foreach $e ( @entry ) {
	    next unless $e =~ /\b([A-Z][A-Za-z0-9_]*)\.$HiSuffix$/o;
	    $mod  = $1;
	    $path = "$d/$e";
	    $path =~ s,^\./,,;

	    if ( ! defined($HiMap{$mod}) ) {
		$HiMap{$mod} = $path;
	    } else {
		&already_mapped_err($mod, $HiMap{$mod}, $path);
	    }
	}
	closedir(DIR); # || &tidy_up_and_die(1,"$Pgm: error when closing directory: $d\n");
    }

    foreach $d ( @SysImport_dir ) {
	if ($HiIncludeString) { $HiIncludeString = "$HiIncludeString:$d";
	} else { $HiIncludeString = $d; }

	opendir(DIR, $d) || &tidy_up_and_die(1,"$Pgm: error when reading directory: $d\n");
	local(@entry) = readdir(DIR);
	foreach $e ( @entry ) {
	    next unless $e =~ /([A-Z][A-Za-z0-9_]*)\.$SysHiSuffix$/o;
	    next if $NoImplicitPrelude && $e =~ /Prelude\.$SysHiSuffix$/o;

	    $mod  = $1;
	    $path = "$d/$e";
	    $path =~ s,^\./,,;

	    if ( ! defined($HiMap{$mod}) ) {
		$HiMap{$mod} = $path;
	    } elsif ( $mod ne 'Main' )  { # saves useless warnings...
		&already_mapped_err($mod, $HiMap{$mod}, $path);
	    }
	}
	closedir(DIR); # || &tidy_up_and_die(1,"$Pgm: error when closing directory: $d\n");
    }

    $HiMapFile = "$Tmp_prefix.himap";
    unlink($HiMapFile);
    open(HIMAP, "> $HiMapFile") || &tidy_up_and_die(1,"$Pgm: can't open $HiMapFile\n");
    foreach $d (keys %HiMap) {
	print HIMAP $d, ' ', $HiMap{$d}, "\n";
    }
    close(HIMAP) || &tidy_up_and_die(1,"$Pgm: error when closing $HiMapFile\n");

    $HiMapDone = 1;
}

sub already_mapped_err {
    local($mod, $mapped_to, $path) = @_;

    # OK, it isn't really an error if $mapped_to and $path turn
    # out to be the same thing.
    ($m_dev,$m_ino,$m_mode,$m_nlink,$m_uid,$m_gid,$m_rdev,$m_size,
     $m_atime,$m_mtime,$m_ctime,$m_blksize,$m_blocks) = stat($mapped_to);
    ($p_dev,$p_ino,$p_mode,$p_nlink,$p_uid,$p_gid,$p_rdev,$p_size,
     $p_atime,$p_mtime,$p_ctime,$p_blksize,$p_blocks) = stat($path);

    return if $m_ino == $p_ino; # same inode number

    print STDERR "$Pgm: module $mod already mapped to $mapped_to";
    print STDERR ";\n\tignoring: $path\n";
}
\end{code}

%************************************************************************
%*									*
\section[Driver-misc-utils]{Miscellaneous utilities}
%*									*
%************************************************************************

%************************************************************************
%*									*
\subsection[Driver-odir-ify]{@odir_ify@: Mangle filename if \tr{-odir} set}
%*									*
%************************************************************************

\begin{code}
sub osuf_ify {
    local($ofile,$def_suffix) = @_;

    return(($Osuffix eq '') ? "$ofile.$def_suffix" : "$ofile.$Osuffix" );
}

sub odir_ify {
    local($orig_file, $def_suffix) = @_;
    if ($Specific_output_dir eq '') {   # do nothing
    	&osuf_ify($orig_file, $def_suffix);
    } else {
	local ($orig_file_only);
	($orig_file_only = $orig_file) =~ s|.*/||;
	&osuf_ify("$Specific_output_dir/$orig_file_only",$def_suffix);
    }
}
\end{code}

\begin{code}
sub runGcc {
    local($is_hc_file, $hsc_out, $cc_as_o) = @_;

    local($includes) = '-I' . join(' -I', @Include_dir);
    local($cc);
    local($s_output);
    local($c_flags) = "@CcBoth_flags";
    local($ddebug_flag) = ( $DEBUGging ) ? '-DDEBUG' : '';

    # "input" files to use that are not in some weird directory;
    # to help C compilers grok .hc files [ToDo: de-hackify]
    local($cc_help)   = "ghc$$.c";
    local($cc_help_s) = "ghc$$.s";

    $cc       = $CcRegd;
    $s_output = ($is_hc_file || $TargetPlatform =~ /^(hppa|i386)/) ? $cc_as_o : $cc_as;
    $c_flags .= " @CcRegd_flags";
    $c_flags .= ($is_hc_file) ? " @CcRegd_flags_hc"  : " @CcRegd_flags_c";

    # C compiler won't like the .hc extension.  So we create
    # a tmp .c file which #include's the needful.
    open(TMP, "> $cc_help") || &tidy_up_and_die(1,"$Pgm: failed to open `$cc_help' (to write)\n");
    if ( $is_hc_file ) {
	print TMP <<EOINCL;
#ifdef __STG_GCC_REGS__
# if ! (defined(MAIN_REG_MAP) || defined(MARK_REG_MAP) || defined(SCAN_REG_MAP) || defined(SCAV_REG_MAP) || defined(FLUSH_REG_MAP))
#  define MAIN_REG_MAP
# endif
#endif
#include "stgdefs.h"
EOINCL
	# user may have asked for #includes to be injected...
	print TMP @CcInjects if $#CcInjects >= 0;
    }
    # heave in the consistency info
    print TMP "static char ghc_cc_ID[] = \"\@(#)cc $ifile\t$Cc_major_version.$Cc_minor_version,$Cc_consist_options\";\n";

    # and #include the real source
    print TMP "#include \"$hsc_out\"\n";
    close(TMP) || &tidy_up_and_die(1,"Failed writing to $cc_help\n");

    local($to_do) = "$cc $Verbose $ddebug_flag $c_flags @Cpp_define -D__HASKELL1__=$Haskell1Version $includes $cc_help > $Tmp_prefix.ccout 2>&1 && ( if [ $cc_help_s != $s_output ] ; then mv $cc_help_s $s_output ; else exit 0 ; fi )";
    # note: __GLASGOW_HASKELL__ is pointedly *not* #defined at the C level.
    if ( $Only_preprocess_C ) { # HACK ALERT!
	$to_do =~ s/ -S\b//g;
    }
    @Files_to_tidy = ( $cc_help, $cc_help_s, $s_output );
    $PostprocessCcOutput = 1;	# hack, dear hack...
    &run_something($to_do, 'C compiler');
    $PostprocessCcOutput = 0;
    unlink($cc_help, $cc_help_s);
}
\end{code}

\begin{code}
sub runMangler {
    local($is_hc_file, $cc_as_o, $cc_as, $ifile_root) = @_;

    if ( $is_hc_file ) {
	# dynamically load assembler-fiddling code, which we are about to use:
	require('ghc-asm.prl')
	|| &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-asm.prl!\n");
    }

    print STDERR `cat $cc_as_o` if $Dump_raw_asm; # to stderr, before mangling

    if ($is_hc_file) {
	# post-process the assembler [.hc files only]
	&mangle_asm($cc_as_o, $cc_as);

#OLD: for sanity:
#OLD:	local($target) = 'oops';
#OLD:	$target = '-alpha'	if $TargetPlatform =~ /^alpha-/;
#OLD:	$target = '-hppa'	if $TargetPlatform =~ /^hppa/;
#OLD:	$target = '-old-asm' 	if $TargetPlatform =~ /^i386-/;
#OLD:	$target = '-m68k'	if $TargetPlatform =~ /^m68k-/;
#OLD:	$target = '-mips'	if $TargetPlatform =~ /^mips-/;
#OLD:	$target = ''		if $TargetPlatform =~ /^powerpc-/;
#OLD:	$target = '-solaris'	if $TargetPlatform =~ /^sparc-sun-solaris2/;
#OLD:	$target = '-sparc'	if $TargetPlatform =~ /^sparc-sun-sunos4/;
#OLD:
#OLD:	if ( $target ne '' ) {
#OLD:	    require("ghc-asm$target.prl")
#OLD:	    || &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-asm$target.prl!\n");
#OLD:	    &mangle_asm($cc_as_o, "$cc_as-2"); # the OLD one!
#OLD:	    &run_something("$Cmp -s $cc_as-2 $cc_as || $Diff $cc_as-2 $cc_as 1>&2 || exit 0",
#OLD:		"Diff'ing old and new mangled .s files"); # NB: to stderr
#OLD:	}

    } elsif ($TargetPlatform =~ /^hppa/) {
	# minor mangling of non-threaded files for hp-pa only
	require('ghc-asm.prl')
	|| &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-asm-hppa.prl!\n");
	&mini_mangle_asm_hppa($cc_as_o, $cc_as);

    } elsif ($TargetPlatform =~ /^i386/) {
	# extremely-minor OFFENSIVE mangling of non-threaded just one file
	require('ghc-asm.prl')
	|| &tidy_up_and_die(1,"$Pgm: panic: can't load ghc-asm.prl!\n");
	&mini_mangle_asm_i386($cc_as_o, $cc_as);
    }

    # save a copy of the .s file, even if we are carrying on...
    if ($do_as && $Keep_s_file_too) {
	local($to_do) = "$Rm $ifile_root.s; $Cp $cc_as $ifile_root.s";
	&run_something($to_do, 'Saving copy of .s file');
    }
}
\end{code}

\begin{code}
sub runAs {
    local($as_out, $ifile_root) = @_;

    local($asmblr) = ( $As ) ? $As : $CcRegd;

    if ( ! $SplitObjFiles ) {
	local($to_do)  = "$asmblr -o $as_out -c @As_flags $cc_as";
	@Files_to_tidy = ( $as_out );
	&run_something($to_do, 'Unix assembler');

    } else { # more complicated split-ification...

	# must assemble files $Tmp_prefix__[1 .. $NoOfSplitFiles].s

	for ($f = 1; $f <= $NoOfSplitFiles; $f++ ) {
	    local($split_out) = &odir_ify("${ifile_root}__${f}",'o');
	    local($to_do) = "$asmblr -o $split_out -c @As_flags ${Tmp_prefix}__${f}.s";
	    @Files_to_tidy = ( $split_out );

	    &run_something($to_do, 'Unix assembler');
	}
    }
}
\end{code}

%************************************************************************
%*									*
\subsection[Driver-run-something]{@run_something@: Run a phase}
%*									*
%************************************************************************

\begin{code}
sub run_something {
    local($str_to_do, $tidy_name) = @_;

    print STDERR "\n$tidy_name:\n\t" if $Verbose;
    print STDERR "$str_to_do\n" if $Verbose;

    if ($Using_dump_file) {
        open(DUMP, ">> $Specific_dump_file")
	    || &tidy_up_and_die(1,"$Pgm: failed to open `$Specific_dump_file'\n");
	print DUMP "\nCompilation Dump for: $str_to_do\n\n";
  	close(DUMP) 
	    || &tidy_up_and_die(1,"$Pgm: failed closing `$Specific_dump_file'\n");
    }

    local($return_val) = 0;
    system("$Time $str_to_do");
    $return_val = $?;

    if ( $PostprocessCcOutput ) { # hack, continued
	open(CCOUT, "< $Tmp_prefix.ccout")
	    || &tidy_up_and_die(1,"$Pgm: failed to open `$Tmp_prefix.ccout'\n");
	while ( <CCOUT> ) {
    	    next if /attribute directive ignored/;
	    next if /call-clobbered/;
	    next if /from .*COptRegs\.lh/;
	    next if /from .*(stg|rts)defs\.h:/;
	    next if /from ghc\d+.c:\d+:/;
	    next if /from .*\.lc/;
	    next if /from .*SMinternal\.l?h/;
	    next if /ANSI C does not support \`long long\'/;
	    next if /warning:.*was declared \`extern\' and later \`static\'/;
	    next if /warning: assignment discards \`const\' from pointer target type/;
	    next if /: At top level:$/;
	    next if /: In function \`.*\':$/;
	    next if /\`ghc_cc_ID\' defined but not used/;
	    print STDERR $_;
	}
	close(CCOUT) || &tidy_up_and_die(1,"$Pgm: failed closing `$Tmp_prefix.ccout'\n");
    }

    if ($return_val != 0) {
        if ($Using_dump_file) {
	    print STDERR "Compilation Errors dumped in $Specific_dump_file\n";
	}

	&tidy_up_and_die($return_val, '');
    }
    $Using_dump_file = 0;
}
\end{code}

%************************************************************************
%*									*
\subsection[Driver-ghctiming]{Emit nofibbish GHC timings}
%*									*
%************************************************************************

NB: nearly the same as in @runstdtest@ script.

\begin{code}
sub process_ghc_timings {
    local($StatsFile) = "$Tmp_prefix.stat";
    local($SysSpecificTiming) = 'ghc';

    open(STATS, $StatsFile) || die "Failed when opening $StatsFile\n";
    local($tot_live) = 0; # for calculating avg residency

    while (<STATS>) {
	$tot_live += $1 if /^\s*\d+\s+\d+\s+\d+\.\d+\%\s+(\d+)\s+\d+\.\d+\%/;

	$BytesAlloc = $1 if /^\s*([0-9,]+) bytes allocated in the heap/;

	if ( /^\s*([0-9,]+) bytes maximum residency .* (\d+) sample/ ) {
	    $MaxResidency = $1; $ResidencySamples = $2;
	}

	$GCs = $1 if /^\s*([0-9,]+) garbage collections? performed/;

	if ( /^\s*INIT\s+time\s*(\d+\.\d\d)s\s*\(\s*(\d+\.\d\d)s elapsed\)/ ) {
	    $InitTime = $1; $InitElapsed = $2;
	} elsif ( /^\s*MUT\s+time\s*(\d+\.\d\d)s\s*\(\s*(\d+\.\d\d)s elapsed\)/ ) {
	    $MutTime = $1; $MutElapsed = $2;
	} elsif ( /^\s*GC\s+time\s*(\d+\.\d\d)s\s*\(\s*(\d+\.\d\d)s elapsed\)/ ) {
	    $GcTime = $1; $GcElapsed = $2;
	}
    }
    close(STATS) || die "Failed when closing $StatsFile\n";
    if ( defined($ResidencySamples) && $ResidencySamples > 0 ) {
	$AvgResidency = int ($tot_live / $ResidencySamples) ;
    }

    # warn about what we didn't find
    print STDERR "Warning: BytesAlloc not found in stats file\n" unless defined($BytesAlloc);
    print STDERR "Warning: GCs not found in stats file\n" unless defined($GCs);
    print STDERR "Warning: InitTime not found in stats file\n" unless defined($InitTime);
    print STDERR "Warning: InitElapsed not found in stats file\n" unless defined($InitElapsed);
    print STDERR "Warning: MutTime not found in stats file\n" unless defined($MutTime);
    print STDERR "Warning: MutElapsed not found in stats file\n" unless defined($MutElapsed);
    print STDERR "Warning: GcTime inot found in stats file\n" unless defined($GcTime);
    print STDERR "Warning: GcElapsed not found in stats file\n" unless defined($GcElapsed);

    # things we didn't necessarily expect to find
    $MaxResidency     = 0 unless defined($MaxResidency);
    $AvgResidency     = 0 unless defined($AvgResidency);
    $ResidencySamples = 0 unless defined($ResidencySamples);

    # a bit of tidying
    $BytesAlloc =~ s/,//g;
    $MaxResidency =~ s/,//g;
    $GCs =~ s/,//g;
    $InitTime =~ s/,//g;
    $InitElapsed =~ s/,//g;
    $MutTime =~ s/,//g;
    $MutElapsed =~ s/,//g;
    $GcTime =~ s/,//g;
    $GcElapsed =~ s/,//g;

    # print out what we found
    print STDERR "<<$SysSpecificTiming: ",
	"$BytesAlloc bytes, $GCs GCs, $AvgResidency/$MaxResidency avg/max bytes residency ($ResidencySamples samples), $InitTime INIT ($InitElapsed elapsed), $MutTime MUT ($MutElapsed elapsed), $GcTime GC ($GcElapsed elapsed)",
	" :$SysSpecificTiming>>\n";

    # OK, party over
    unlink $StatsFile;
}
\end{code}

%************************************************************************
%*									*
\subsection[Driver-dying]{@tidy_up@ and @tidy_up_and_die@: Dying gracefully}
%*									*
%************************************************************************

\begin{code}
sub tidy_up {
    local($to_do) = "\n$Rm $Tmp_prefix*";
    if ( $Tmp_prefix !~ /^\s*$/ ) {
	print STDERR "$to_do\n" if $Verbose;
	system($to_do);
    }
}

sub tidy_up_and_die {
    local($return_val, $msg) = @_;

    # delete any files to tidy
    print STDERR "deleting... @Files_to_tidy\n" if $Verbose && $#Files_to_tidy >= 0;
    unlink @Files_to_tidy if $#Files_to_tidy >= 0;

    &tidy_up();
    print STDERR $msg;
    exit (($return_val == 0) ? 0 : 1);
}
\end{code}

%************************************************************************
%*									*
\subsection[Driver-arg-with-arg]{@grab_arg_arg@: Do an argument with an argument}
%*									*
%************************************************************************

Some command-line arguments take an argument, e.g.,
\tr{-Rmax-heapsize} expects a number to follow.  This can either be
given a part of the same argument (\tr{-Rmax-heapsize8M}) or as the
next argument (\tr{-Rmax-heapsize 8M}).  We allow both cases.

Note: no error-checking; \tr{-Rmax-heapsize -Rgc-stats} will silently
gobble the second argument (and probably set the heapsize to something
nonsensical).
\begin{code}
sub grab_arg_arg {
    local($option, $rest_of_arg) = @_;
    
    if ($rest_of_arg) {
	return($rest_of_arg);
    } elsif ($#ARGV >= 0) {
	local($temp) = $ARGV[0]; shift(@ARGV); 
	return($temp);
    } else {
	print STDERR "$Pgm: no argument following $option option\n";
	$Status++;
    }
}
\end{code}

\begin{code}
sub isntAntiFlag {
    local($flag) = @_;
    local($f);

#Not in HsC_antiflag ## NO!: and not already in HsC_flags

    foreach $f ( @HsC_antiflags ) {
	return(0) if $flag eq $f;
    }
#    foreach $f ( @HsC_flags ) {
#	return(0) if $flag eq $f;
#    }
    return(1);
}

sub squashHscFlag {  # pretty terrible
    local($flag) = @_;
    local($f);

    foreach $f ( @HsC_flags ) {
	if ($flag eq $f) { $f = ''; }
    }
}

sub add_Hsc_flags {
    local(@flags) = @_;
    local($f);

    foreach $f ( @flags ) {
	push( @HsC_flags, $f ) if &isntAntiFlag($f);
    }
}
\end{code}

