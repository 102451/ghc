==================== Typechecked ====================
Succeeded{-rd,x-}{i} =
    _/\_ a_tr8i b_tr8j -> \ tpl_B1 ->
	Succeeded{-rd,x-}{i} {_@_ a_tr8i _@_ b_tr8j tpl_B1}
Failed{-rc,x-}{i} =
    _/\_ a_tr8i b_tr8j -> \ tpl_B1 ->
	Failed{-rc,x-}{i} {_@_ a_tr8i _@_ b_tr8j tpl_B1}
MkDigraph{-r8y,x-}{i} =
    _/\_ vertex_tr8t -> \ tpl_B1 ->
	MkDigraph{-r8y,x-}{i} {_@_ vertex_tr8t tpl_B1}
AbsBinds
[ta14k]
[d.Eq_a14z]
[([ta14k], isRecursiveCycle{-r6D,x-}, isRecursiveCycle_a14f)]
    d.Eq_a14D = d.Eq_a14z
    d.Eq_a14E = d.Eq_a14z
    d.Eq_a14B =
	PrelTup.$d9{-rDa,p-} [ta14k, ta14k] [d.Eq_a14D, d.Eq_a14E]
    elem_a1fZ = PrelList.elem{-rDi,p-} (ta14k, ta14k) d.Eq_a14B
    isRecursiveCycle_a14f [vertex_r8c] edges_r8d
			  = (vertex_r8c, vertex_r8c) elem_a1fZ edges_r8d
    isRecursiveCycle_a14f cycle_r8f edges_r8g
			  = PrelBase.True{-5E,w-}{i}
AbsBinds
[ta14Q, ta14R, ta14S]
[d.Eq_a15J, d.Ord_a15K]
[([ta14R, ta14Q, ta14S], lookupVertex{-r6C,x-}, lookupVertex_a14N)]
    d.Eq_a15M = d.Eq_a15J
    ==_a1gh = PrelBase.=={-8Y,p-} ta14Q d.Eq_a15M
    lookupVertex_a14N flat_info_r84 vertex_r85
		      = PrelList.head{-rEs,p-} ta14S code_list_r87
		      where
			  {- nonrec -}
			  AbsBinds [] [] [([], code_list_r87, code_list_a14W)]
			      code_list_a14W
				  = [code_r8a |
					 (vertex'_r89, _, _, code_r8a) <- flat_info_r84, vertex_r85
											 ==_a1gh vertex'_r89]
			  {- nonrec -}
			  {- nonrec -}
AbsBinds
[ta165, ta168, ta169]
[d.Eq_a17S, d.Ord_a17T]
[([ta168, ta169, ta165], mkEdges{-r6B,x-}, mkEdges_a162)]
    d.Ord_a17P = d.Ord_a17T
    d.MonadZero_a17Q = PrelBase.$d24{-ri3,p-}
    mkEdges_a162 vertices_r7M flat_info_r7N
		 = [(source_vertex_r7X, target_vertex_r82) |
			(source_vertex_r7X, _, used_names_r7Y, _) <- flat_info_r7N, target_name_r80 <- Set.setToList{-rge,p-}
													   ta168 used_names_r7Y, target_vertex_r82 <- vertices_defining_a1gi target_name_r80
																					     flat_info_r7N]
		 where
		     {- nonrec -}
		     AbsBinds
		     [ta16x, ta16C, ta16F, aa16H, ta16K]
		     [d.Ord_a16W, d.MonadZero_a172]
		     [([ta16x, ta16C, ta16F, aa16H, ta16K],
		       vertices_defining_r7P,
		       vertices_defining_a16b)]
			 d.Monad_a16Y =
			     PrelBase.scsel_MonadZeroPrelBaseMonad{-a1gn,p-} aa16H
				 d.MonadZero_a172
			 elementOf_a1gm = Set.elementOf{-rg7,p-} ta16K d.Ord_a16W
			 >>=_a1gl = PrelBase.>>={-811,p-} aa16H d.Monad_a16Y
			 d.Monad_a170 = d.Monad_a16Y
			 return_a1gk = PrelBase.return{-816,p-} aa16H d.Monad_a170
			 zero_a1gj = PrelBase.zero{-810,p-} aa16H d.MonadZero_a172
			 vertices_defining_a16b name_r7R flat_info_r7S
						= [vertex_r7U |
						       (vertex_r7U, names_defined_r7V, _, _) <- flat_info_r7S, name_r7R
													       elementOf_a1gm names_defined_r7V]
		     {- nonrec -}
		     vertices_defining_a1gi =
			 vertices_defining_r7P
			     [ta165, Set.Set{-rg4,p-} ta168, ta169, PrelBase.[]{-3j,W-}, ta168]
			     [d.Ord_a17P, d.MonadZero_a17Q]
		     {- nonrec -}
AbsBinds
[ta18a, ta18b, ta18c]
[]
[([ta18b, ta18c, ta18a], mkVertices{-r6A,x-}, mkVertices_a187)]
    mkVertices_a187 info_r7I
		    = [vertex_r7K | (vertex_r7K, _, _, _) <- info_r7I]
AbsBinds
[ta18P]
[d.Eq_a196]
[([ta18P], isCyclic{-r6y,x-}, isCyclic_a18M)]
    d.Eq_a19a = d.Eq_a196
    d.Eq_a19b = d.Eq_a196
    d.Eq_a198 =
	PrelTup.$d9{-rDa,p-} [ta18P, ta18P] [d.Eq_a19a, d.Eq_a19b]
    elem_a1go = PrelList.elem{-rDi,p-} (ta18P, ta18P) d.Eq_a198
    isCyclic_a18M edges_r7r [v_r7s]
		  = (v_r7s, v_r7s) elem_a1go edges_r7r
    isCyclic_a18M edges_r7u vs_r7v = PrelBase.True{-5E,w-}{i}
AbsBinds [ta1au] [d.Eq_a1aw] [([ta1au], dfs{-r6E,x-}, dfs_a19d)]
    elem_a1gp = PrelList.elem{-rDi,p-} ta1au d.Eq_a1aw
    dfs_a19d r_r7e (vs_r7f, ns_r7g) PrelBase.[]{-5i,w-}{i}
	     = (vs_r7f, ns_r7g)
    dfs_a19d r_r7i
	     (vs_r7j, ns_r7k)
	     (x_r7l PrelBase.:{-55,w-}{i} xs_r7m)
	     | x_r7l elem_a1gp vs_r7j = dfs_a19d r_r7i (vs_r7j, ns_r7k) xs_r7m
	     | PrelBase.otherwise{-818,p-}
	     = dfs_a19d r_r7i
			(vs'_r7o,
			 ++_a1g7 ta1au (PrelBase.:{-55,w-}{i} ta1au x_r7l ns'_r7p) ns_r7k)
			xs_r7m
	     where
		 {- nonrec -}
		 AbsBinds [] [] [([], vs'_r7o, vs'_a19Z), ([], ns'_r7p, ns'_a1a0)]
		     (vs'_a19Z, ns'_a1a0)
			 = dfs_a19d r_r7i
				    (PrelBase.:{-55,w-}{i} ta1au x_r7l vs_r7j,
				     PrelBase.[]{-5i,w-}{i} ta1au)
				    r_r7i x_r7l
		 {- nonrec -}
		 {- nonrec -}
AbsBinds
[ta1aG]
[d.Eq_a1dR]
[([ta1aG], stronglyConnComp{-r6x,x-}, stronglyConnComp_a1aD)]
    d.Eq_a1dP = d.Eq_a1dR
    d.Eq_a1dM = d.Eq_a1dR
    d.Eq_a1dT = d.Eq_a1dR
    dfs_a1gq = dfs{-r6E,x-} ta1aG d.Eq_a1dT
    d.Eq_a1dN = d.Eq_a1dR
    stronglyConnComp_a1aD es_r6H vs_r6I
			  = PrelTup.snd{-rDg,p-}
				[[ta1aG], [[ta1aG]]] span_tree_a1gr new_range_a1gt reversed_edges_r6K
								    (PrelBase.[]{-5i,w-}{i} ta1aG,
								     PrelBase.[]{-5i,w-}{i} [ta1aG])
								    PrelTup.snd{-rDg,p-}
									[[ta1aG], [ta1aG]] dfs_a1gq new_range_a1gs es_r6H
												    (PrelBase.[]{-5i,w-}{i}
													 ta1aG,
												     PrelBase.[]{-5i,w-}{i}
													 ta1aG)
												    vs_r6I
			  where
			      {- rec -}
			      AbsBinds
			      [ta1bV]
			      [d.Eq_a1bX]
			      [([ta1bV], span_tree_r6N, span_tree_a1aK)]
				  elem_a1gv = PrelList.elem{-rDi,p-} ta1bV d.Eq_a1bX
				  d.Eq_a1bZ = d.Eq_a1bX
				  dfs_a1gu = dfs{-r6E,x-} ta1bV d.Eq_a1bZ
				  span_tree_a1aK r_r71 (vs_r72, ns_r73) PrelBase.[]{-5i,w-}{i}
						 = (vs_r72, ns_r73)
				  span_tree_a1aK r_r75
						 (vs_r76, ns_r77)
						 (x_r78 PrelBase.:{-55,w-}{i} xs_r79)
						 | x_r78 elem_a1gv vs_r76
						 = span_tree_a1aK r_r75 (vs_r76, ns_r77) xs_r79
						 | PrelBase.otherwise{-818,p-}
						 = span_tree_a1aK r_r75
								  (vs'_r7b,
								   PrelBase.:{-55,w-}{i} [ta1bV]
								       (PrelBase.:{-55,w-}{i} ta1bV
									    x_r78 ns'_r7c)
								       ns_r77)
								  xs_r79
						 where
						     {- nonrec -}
						     AbsBinds
						     []
						     []
						     [([], vs'_r7b, vs'_a1bw), ([],
										ns'_r7c,
										ns'_a1bx)]
							 (vs'_a1bw, ns'_a1bx)
							     = dfs_a1gu r_r75
									(PrelBase.:{-55,w-}{i} ta1bV
									     x_r78 vs_r76,
									 PrelBase.[]{-5i,w-}{i}
									     ta1bV)
									r_r75 x_r78
						     {- nonrec -}
						     {- nonrec -}
			      {- nonrec -}
			      span_tree_a1gr = span_tree_r6N ta1aG d.Eq_a1dP
			      {- nonrec -}
			      {- rec -}
			      AbsBinds
			      [ta1cx, ta1cA]
			      [d.Eq_a1cC]
			      [([ta1cx, ta1cA], new_range_r6M, new_range_a1c1)]
				  ==_a1gw = PrelBase.=={-8Y,p-} ta1cx d.Eq_a1cC
				  new_range_a1c1 PrelBase.[]{-5i,w-}{i} w_r6U
						 = PrelBase.[]{-5i,w-}{i} ta1cA
				  new_range_a1c1 ((x_r6W, y_r6X) PrelBase.:{-55,w-}{i} xys_r6Y)
						 w_r6Z
						 = if x_r6W ==_a1gw w_r6Z then
						       PrelBase.:{-55,w-}{i} ta1cA
							   y_r6X (new_range_a1c1 xys_r6Y w_r6Z)
						   else
						       new_range_a1c1 xys_r6Y w_r6Z
			      {- nonrec -}
			      new_range_a1gt = new_range_r6M [ta1aG, ta1aG] d.Eq_a1dM
			      new_range_a1gs = new_range_r6M [ta1aG, ta1aG] d.Eq_a1dN
			      {- nonrec -}
			      {- nonrec -}
			      AbsBinds [ta1cR] [] [([ta1cR], swap_r6L, swap_a1cI)]
				  swap_a1cI (x_r6R, y_r6S) = (y_r6S, x_r6R)
			      {- nonrec -}
			      {- nonrec -}
			      {- nonrec -}
			      AbsBinds [] [] [([], reversed_edges_r6K, reversed_edges_a1cU)]
				  reversed_edges_a1cU
				      = map_a1g8 [Edge{-r8x,x-} ta1aG, Edge{-r8x,x-} ta1aG] swap_r6L
												ta1aG
											    es_r6H
			      {- nonrec -}
			      {- nonrec -}
AbsBinds
[ta1e4]
[d.Eq_a1eX]
[([ta1e4], topSort{-r6z,x-}, topSort_a1e1)]
    d.Eq_a1f5 = d.Eq_a1eX
    isCyclic_a1gy = isCyclic{-r6y,x-} ta1e4 d.Eq_a1f5
    d.Eq_a1f7 = d.Eq_a1eX
    stronglyConnComp_a1gx = stronglyConnComp{-r6x,x-} ta1e4 d.Eq_a1f7
    topSort_a1e1 edges_r7x vertices_r7y
		 = case cycles_r7B of
		     PrelBase.[]{-5i,w-}{i}
		     -> Succeeded{-rd,x-}{i} [[ta1e4], [[ta1e4]]] [v_r7F |
								       [v_r7F] <- singletons_r7C]
		     _ -> Failed{-rc,x-}{i} [[ta1e4], [[ta1e4]]] cycles_r7B
		 where
		     {- nonrec -}
		     AbsBinds [] [] [([], sccs_r7A, sccs_a1e8)]
			 sccs_a1e8 = stronglyConnComp_a1gx edges_r7x vertices_r7y
		     {- nonrec -}
		     {- nonrec -}
		     {- nonrec -}
		     AbsBinds
		     []
		     []
		     [([], cycles_r7B, cycles_a1ef), ([],
						      singletons_r7C,
						      singletons_a1eg)]
			 (cycles_a1ef, singletons_a1eg)
			     = List.partition{-rhs,p-} [ta1e4] isCyclic_a1gy edges_r7x sccs_r7A
		     {- nonrec -}
		     {- nonrec -}
AbsBinds [ta1fd] [] [([ta1fd], mkDigraph{-r6F,x-}, mkDigraph_a1f9)]
    mkDigraph_a1f9 = MkDigraph{-r8y,x-}{i} ta1fd
AbsBinds
[ta1fI, ta1fJ]
[]
[([ta1fI, ta1fJ], $d1{-r1gg,x-}, d.Eval_a1fk)]
    d.Eval_a1fk = ({-dict-} [] [])
AbsBinds [ta1fK] [] [([ta1fK], $d2{-r1gf,x-}, d.Eval_a1fq)]
    d.Eval_a1fq = ({-dict-} [] [])
d.Monad_a1fs = PrelBase.$d25{-ri4,p-}
>>=_a1gb = PrelBase.>>={-811,p-} PrelBase.[]{-3j,W-} d.Monad_a1fs
d.Monad_a1fv = d.Monad_a1fs
return_a1ga =
    PrelBase.return{-816,p-} PrelBase.[]{-3j,W-} d.Monad_a1fv
d.MonadZero_a1fx = PrelBase.$d24{-ri3,p-}
zero_a1g9 =
    PrelBase.zero{-810,p-} PrelBase.[]{-3j,W-} d.MonadZero_a1fx
d.Functor_a1fA = PrelBase.$d26{-ri5,p-}
map_a1g8 = PrelBase.map{-rn5,p-} PrelBase.[]{-3j,W-} d.Functor_a1fA
d.MonadPlus_a1fD = PrelBase.$d23{-ri2,p-}
++_a1g7 = PrelBase.++{-rn8,p-} PrelBase.[]{-3j,W-} d.MonadPlus_a1fD
>>=_a1g6 = >>=_a1gb
return_a1g5 = return_a1ga
>>=_a1g4 = >>=_a1gb
return_a1g3 = return_a1ga
>>=_a1g2 = >>=_a1gb
return_a1g1 = return_a1ga
zero_a1g0 = zero_a1g9

ghc: module version changed to 1; reason: no old .hi file
_interface_ ShouldSucceed 1
_instance_modules_
ArrBase IO PrelNum
_usages_
List 1 :: partition 1;
PrelBase 1 :: $d15 1 $d16 1 $d2 1 $d23 1 $d24 1 $d25 1 $d26 1 $d27 1 $d28 1 $d33 1 $d35 1 $d38 1 $d40 1 $d42 1 $d45 1 $d46 1 $d47 1 $d50 1 $d52 1 $d7 1 $d8 1 $m/= 1 $m< 1 $m<= 1 $m> 1 $m>= 1 $m>> 1 $mcompare 1 $mmax 1 $mmin 1 otherwise 1 Eq 1 Eval 1 Functor 1 Monad 1 MonadPlus 1 MonadZero 1 Ord 1 Ordering 1;
PrelList 1 :: elem 1 head 1;
PrelNum 1 :: $d17 1 $d18 1;
PrelTup 1 :: $d11 1 $d13 1 $d15 1 $d49 1 $d51 1 $d9 1 snd 1;
Set 1 :: $d1 1 $d2 1 elementOf 1 setToList 1 Set 1;
_exports_
ShouldSucceed dfs isCyclic isRecursiveCycle lookupVertex mkDigraph mkEdges mkVertices stronglyConnComp topSort Cycle Digraph(MkDigraph) Edge FlattenedDependencyInfo MaybeErr(Succeeded Failed);
_instances_
instance _forall_ [a b] => {PrelBase.Eval (MaybeErr a b)} = $d1;
instance _forall_ [vertex] => {PrelBase.Eval (Digraph vertex)} = $d2;
_declarations_
1 $d1 _:_ _forall_ [a b] => {PrelBase.Eval (MaybeErr a b)} ;;
1 $d2 _:_ _forall_ [vertex] => {PrelBase.Eval (Digraph vertex)} ;;
1 type Cycle vertex = [vertex] ;
1 data Digraph vertex = MkDigraph [vertex] ;
1 type Edge vertex = (vertex, vertex) ;
1 type FlattenedDependencyInfo vertex name code = [(vertex, Set.Set name, Set.Set name, code)] ;
1 data MaybeErr a b = Succeeded a |  Failed b ;
1 dfs _:_ _forall_ [ta] {PrelBase.Eq ta} => (ta -> [ta]) -> ([ta], [ta]) -> [ta] -> ([ta], [ta]) ;;
1 isCyclic _:_ _forall_ [ta] {PrelBase.Eq ta} => [Edge ta] -> [ta] -> PrelBase.Bool ;;
1 isRecursiveCycle _:_ _forall_ [ta] {PrelBase.Eq ta} => Cycle ta -> [Edge ta] -> PrelBase.Bool ;;
1 lookupVertex _:_ _forall_ [ta tb tc] {PrelBase.Eq tb, PrelBase.Ord ta} => FlattenedDependencyInfo tb ta tc -> tb -> tc ;;
1 mkDigraph _:_ _forall_ [ta] => [ta] -> Digraph ta ;;
1 mkEdges _:_ _forall_ [ta tb tc] {PrelBase.Eq tc, PrelBase.Ord ta} => [tc] -> FlattenedDependencyInfo tc ta tb -> [Edge tc] ;;
1 mkVertices _:_ _forall_ [ta tb tc] => FlattenedDependencyInfo tc ta tb -> [tc] ;;
1 stronglyConnComp _:_ _forall_ [ta] {PrelBase.Eq ta} => [Edge ta] -> [ta] -> [[ta]] ;;
1 topSort _:_ _forall_ [ta] {PrelBase.Eq ta} => [Edge ta] -> [ta] -> MaybeErr [ta] [[ta]] ;;
