_interface_ TheUtils 2
_instance_modules_
ArrBase IO PrelNum
_usages_
PrelBase 1 :: $d1 1 $d11 1 $d14 1 $d15 1 $d16 1 $d17 1 $d18 1 $d19 1 $d2 1 $d21 1 $d22 1 $d23 1 $d24 1 $d25 1 $d26 1 $d27 1 $d3 1 $d32 1 $d33 1 $d34 1 $d36 1 $d37 1 $d38 1 $d39 1 $d41 1 $d42 1 $d44 1 $d45 1 $d46 1 $d48 1 $d49 1 $d50 1 $d51 1 $d53 1 $d54 1 $d55 1 $d57 1 $d6 1 $d7 1 $d8 1 $m* 1 $m+ 1 $m++ 1 $m- 1 $m/= 1 $m< 1 $m<= 1 $m== 1 $m> 1 $m>= 1 $m>> 1 $m>>= 1 $mabs 1 $mcompare 1 $mfromInt 1 $mfromInteger 1 $mmap 1 $mmax 1 $mmin 1 $mnegate 1 $mreturn 1 $mshowList 1 $mshowsPrec 1 $msignum 1 $mzero 1 && 1 . 1 not 1 otherwise 1 show 1 || 1 Eq 1 Eval 1 Functor 1 Maybe 1 Monad 1 MonadPlus 1 MonadZero 1 Num 1 Ord 1 Ordering 1 Ordering 1 Show 1 String 1;
PrelList 1 :: repeat 1 reverse 1 span 1 take 1;
PrelNum 1 :: $d10 1 $d16 1 $d17 1 $d18 1 $d29 1 $d33 1 $d34 1 $d35 1;
PrelTup 1 :: $d10 1 $d13 1 $d14 1 $d3 1 $d4 1 $d49 1 $d50 1 $d9 1;
Pretty 1 :: $d1 1 $d2 1 hsep 1 int 1 sep 1 text 1 Doc 1;
_exports_
TheUtils appEager assertPanic assertPprPanic assoc assocDefault assocDefaultUsing assocUsing cmpList cmpPString endsWith equivClasses hasNoDups isIn isSingleton isn'tIn lengthExceeds mapAccumB mapAccumL mapAccumR mapAndUnzip mapAndUnzip3 mapEager nOfThem naturalMergeSortLe panic panic# pprError pprPanic pprPanic# pprTrace removeDups returnEager runEager runs sortLt startsWith thenCmp thenEager transitiveClosure unzipWith zipEqual zipLazy zipWith3Equal zipWith4Equal zipWithEqual Eager Ord3(cmp);
_fixities_
infixr 9 thenCmp;
_instances_
instance {Ord3 PrelBase.Int} = $d1;
instance _forall_ [a] {Ord3 a} => {Ord3 (PrelBase.Maybe a)} = $d2;
instance _forall_ [a] {Ord3 a} => {Ord3 [a]} = $d3;
_declarations_
2 $d1 _:_ {Ord3 PrelBase.Int} ;;
1 $d2 _:_ _forall_ [a] {Ord3 a} => {Ord3 (PrelBase.Maybe a)} ;;
1 $d3 _:_ _forall_ [a] {Ord3 a} => {Ord3 [a]} ;;
1 $mcmp _:_ _forall_ [a] {Ord3 a} => a -> a -> GHC.Int# ;;
2 type Eager rvB rvC = (rvC -> rvB) -> rvB ;
2 class Ord3 rvx where {cmp :: rvx -> rvx -> GHC.Int#} ;
1 appEager _:_ _forall_ [a b] => Eager b a -> (a -> b) -> b ;;
1 assertPanic _:_ _forall_ [a] => PrelBase.String -> PrelBase.Int -> a ;;
2 assertPprPanic _:_ _forall_ [a] => PrelBase.String -> PrelBase.Int -> Pretty.Doc -> a ;;
1 assoc _:_ _forall_ [a b] {PrelBase.Eq a} => PrelBase.String -> [(a, b)] -> a -> b ;;
1 assocDefault _:_ _forall_ [a b] {PrelBase.Eq a} => b -> [(a, b)] -> a -> b ;;
1 assocDefaultUsing _:_ _forall_ [a b] => (a -> a -> PrelBase.Bool) -> b -> [(a, b)] -> a -> b ;;
1 assocUsing _:_ _forall_ [a b] => (a -> a -> PrelBase.Bool) -> PrelBase.String -> [(a, b)] -> a -> b ;;
1 cmpList _:_ _forall_ [a] => (a -> a -> GHC.Int#) -> [a] -> [a] -> GHC.Int# ;;
1 endsWith _:_ PrelBase.String -> PrelBase.String -> PrelBase.Maybe PrelBase.String ;;
1 equivClasses _:_ _forall_ [a] => (a -> a -> GHC.Int#) -> [a] -> [[a]] ;;
1 hasNoDups _:_ _forall_ [a] {PrelBase.Eq a} => [a] -> PrelBase.Bool ;;
1 isIn _:_ _forall_ [a] {PrelBase.Eq a} => PrelBase.String -> a -> [a] -> PrelBase.Bool ;;
1 isSingleton _:_ _forall_ [a] => [a] -> PrelBase.Bool ;;
1 isn'tIn _:_ _forall_ [a] {PrelBase.Eq a} => PrelBase.String -> a -> [a] -> PrelBase.Bool ;;
1 lengthExceeds _:_ _forall_ [a] => [a] -> PrelBase.Int -> PrelBase.Bool ;;
1 mapAccumB _:_ _forall_ [a b c d] => (b -> c -> a -> (b, c, d)) -> b -> c -> [a] -> (b, c, [d]) ;;
1 mapAccumL _:_ _forall_ [a b c] => (b -> a -> (b, c)) -> b -> [a] -> (b, [c]) ;;
1 mapAccumR _:_ _forall_ [a b c] => (b -> a -> (b, c)) -> b -> [a] -> (b, [c]) ;;
1 mapAndUnzip _:_ _forall_ [a b c] => (a -> (b, c)) -> [a] -> ([b], [c]) ;;
1 mapAndUnzip3 _:_ _forall_ [a b c d] => (a -> (b, c, d)) -> [a] -> ([b], [c], [d]) ;;
1 mapEager _:_ _forall_ [a b c] => (a -> (c -> b) -> b) -> [a] -> ([c] -> b) -> b ;;
1 nOfThem _:_ _forall_ [a] => PrelBase.Int -> a -> [a] ;;
1 naturalMergeSortLe _:_ _forall_ [a] => (a -> a -> PrelBase.Bool) -> [a] -> [a] ;;
1 panic _:_ _forall_ [a] => [PrelBase.Char] -> a ;;
1 panic# _:_ PrelBase.String -> GHC.Int# ;;
1 pprError _:_ _forall_ [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b ;;
1 pprPanic _:_ _forall_ [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b ;;
1 pprPanic# _:_ _forall_ [a] {PrelBase.Show a} => [PrelBase.Char] -> a -> GHC.Int# ;;
1 pprTrace _:_ _forall_ [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b -> b ;;
1 removeDups _:_ _forall_ [a] => (a -> a -> GHC.Int#) -> [a] -> ([a], [[a]]) ;;
1 returnEager _:_ _forall_ [a b] => b -> (b -> a) -> a ;;
1 runEager _:_ _forall_ [a] => Eager a a -> a ;;
1 runs _:_ _forall_ [a] => (a -> a -> PrelBase.Bool) -> [a] -> [[a]] ;;
1 sortLt _:_ _forall_ [a] => (a -> a -> PrelBase.Bool) -> [a] -> [a] ;;
1 startsWith _:_ PrelBase.String -> PrelBase.String -> PrelBase.Maybe PrelBase.String ;;
1 thenCmp _:_ GHC.Int# -> GHC.Int# -> GHC.Int# ;;
1 thenEager _:_ _forall_ [a b c] => Eager b a -> (a -> (c -> b) -> b) -> (c -> b) -> b ;;
1 transitiveClosure _:_ _forall_ [a] => (a -> [a]) -> (a -> a -> PrelBase.Bool) -> [a] -> [a] ;;
1 unzipWith _:_ _forall_ [a b c] => (a -> b -> c) -> [(a, b)] -> [c] ;;
1 zipEqual _:_ _forall_ [a b] => PrelBase.String -> [a] -> [b] -> [(a, b)] ;;
1 zipLazy _:_ _forall_ [a b] => [a] -> [b] -> [(a, b)] ;;
1 zipWith3Equal _:_ _forall_ [a b c d] => PrelBase.String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d] ;;
1 zipWith4Equal _:_ _forall_ [a b c d e] => PrelBase.String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e] ;;
1 zipWithEqual _:_ _forall_ [a b c] => PrelBase.String -> (a -> b -> c) -> [a] -> [b] -> [c] ;;
