__interface TheUtils 2 0 where
import PrelBase 1 :: Int 1 Maybe 1;
__instimport PrelArr ; __instimport IO ; __instimport PrelNum ;
__export TheUtils appEager assertPanic assertPprPanic assoc assocDefault assocDefaultUsing assocUsing cmpList cmpPString endsWith equivClasses hasNoDups isIn isSingleton isn'tIn lengthExceeds mapAccumB mapAccumL mapAccumR mapAndUnzip mapAndUnzip3 mapEager nOfThem naturalMergeSortLe panic panic# pprError pprPanic pprPanic# pprTrace removeDups returnEager runEager runs sortLt startsWith thenCmp thenEager transitiveClosure unzipWith zipEqual zipLazy zipWith3Equal zipWith4Equal zipWithEqual Eager Ord3{cmp};

instance {Ord3 PrelBase.Int} = _fOrdc;
instance __forall [a] {Ord3 a} => {Ord3 (PrelBase.Maybe a)} = _fOrda;
instance __forall [a] {Ord3 a} => {Ord3 [a]} = _fOrdb;

2 _fOrdc :: {Ord3 PrelBase.Int} ;
1 _fOrda :: __forall [a] {Ord3 a} => {Ord3 (PrelBase.Maybe a)} ;
1 _fOrdb :: __forall [a] {Ord3 a} => {Ord3 [a]} ;
1 _mcmp :: __forall [a] {Ord3 a} => a -> a -> GHC.Int# ;
2 type Eager rvB rvC = (rvC -> rvB) -> rvB ;
2 class Ord3 rvx where {cmp :: rvx -> rvx -> GHC.Int#} ;
1 appEager :: __forall [a b] => Eager b a -> (a -> b) -> b ;
1 assertPanic :: __forall [a] => PrelBase.String -> PrelBase.Int -> a ;
2 assertPprPanic :: __forall [a] => PrelBase.String -> PrelBase.Int -> Pretty.Doc -> a ;
1 assoc :: __forall [a b] {PrelBase.Eq a} => PrelBase.String -> [(a, b)] -> a -> b ;
1 assocDefault :: __forall [a b] {PrelBase.Eq a} => b -> [(a, b)] -> a -> b ;
1 assocDefaultUsing :: __forall [a b] => (a -> a -> PrelBase.Bool) -> b -> [(a, b)] -> a -> b ;
1 assocUsing :: __forall [a b] => (a -> a -> PrelBase.Bool) -> PrelBase.String -> [(a, b)] -> a -> b ;
1 cmpList :: __forall [a] => (a -> a -> GHC.Int#) -> [a] -> [a] -> GHC.Int# ;
1 endsWith :: PrelBase.String -> PrelBase.String -> PrelBase.Maybe PrelBase.String ;
1 equivClasses :: __forall [a] => (a -> a -> GHC.Int#) -> [a] -> [[a]] ;
1 hasNoDups :: __forall [a] {PrelBase.Eq a} => [a] -> PrelBase.Bool ;
1 infixr 9 thenCmp ;
1 isIn :: __forall [a] {PrelBase.Eq a} => PrelBase.String -> a -> [a] -> PrelBase.Bool ;
1 isSingleton :: __forall [a] => [a] -> PrelBase.Bool ;
1 isn'tIn :: __forall [a] {PrelBase.Eq a} => PrelBase.String -> a -> [a] -> PrelBase.Bool ;
1 lengthExceeds :: __forall [a] => [a] -> PrelBase.Int -> PrelBase.Bool ;
1 mapAccumB :: __forall [a b c d] => (b -> c -> a -> (b, c, d)) -> b -> c -> [a] -> (b, c, [d]) ;
1 mapAccumL :: __forall [a b c] => (b -> a -> (b, c)) -> b -> [a] -> (b, [c]) ;
1 mapAccumR :: __forall [a b c] => (b -> a -> (b, c)) -> b -> [a] -> (b, [c]) ;
1 mapAndUnzip :: __forall [a b c] => (a -> (b, c)) -> [a] -> ([b], [c]) ;
1 mapAndUnzip3 :: __forall [a b c d] => (a -> (b, c, d)) -> [a] -> ([b], [c], [d]) ;
1 mapEager :: __forall [a b c] => (a -> (c -> b) -> b) -> [a] -> ([c] -> b) -> b ;
1 nOfThem :: __forall [a] => PrelBase.Int -> a -> [a] ;
1 naturalMergeSortLe :: __forall [a] => (a -> a -> PrelBase.Bool) -> [a] -> [a] ;
1 panic :: __forall [a] => [PrelBase.Char] -> a ;
1 panic# :: PrelBase.String -> GHC.Int# ;
1 pprError :: __forall [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b ;
1 pprPanic :: __forall [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b ;
1 pprPanic# :: __forall [a] {PrelBase.Show a} => [PrelBase.Char] -> a -> GHC.Int# ;
1 pprTrace :: __forall [a b] {PrelBase.Show a} => [PrelBase.Char] -> a -> b -> b ;
1 removeDups :: __forall [a] => (a -> a -> GHC.Int#) -> [a] -> ([a], [[a]]) ;
1 returnEager :: __forall [a b] => b -> (b -> a) -> a ;
1 runEager :: __forall [a] => Eager a a -> a ;
1 runs :: __forall [a] => (a -> a -> PrelBase.Bool) -> [a] -> [[a]] ;
1 sortLt :: __forall [a] => (a -> a -> PrelBase.Bool) -> [a] -> [a] ;
1 startsWith :: PrelBase.String -> PrelBase.String -> PrelBase.Maybe PrelBase.String ;
1 thenCmp :: GHC.Int# -> GHC.Int# -> GHC.Int# ;
1 thenEager :: __forall [a b c] => Eager b a -> (a -> (c -> b) -> b) -> (c -> b) -> b ;
1 transitiveClosure :: __forall [a] => (a -> [a]) -> (a -> a -> PrelBase.Bool) -> [a] -> [a] ;
1 unzipWith :: __forall [a b c] => (a -> b -> c) -> [(a, b)] -> [c] ;
1 zipEqual :: __forall [a b] => PrelBase.String -> [a] -> [b] -> [(a, b)] ;
1 zipLazy :: __forall [a b] => [a] -> [b] -> [(a, b)] ;
1 zipWith3Equal :: __forall [a b c d] => PrelBase.String -> (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d] ;
1 zipWith4Equal :: __forall [a b c d e] => PrelBase.String -> (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e] ;
1 zipWithEqual :: __forall [a b c] => PrelBase.String -> (a -> b -> c) -> [a] -> [b] -> [c] ;
