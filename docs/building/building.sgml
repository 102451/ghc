<!DOCTYPE Article PUBLIC "-//OASIS//DTD DocBook V3.1//EN">

<Article id="building-guide">

<ArtHeader>

<Title>Building the Glasgow Functional Programming Tools Suite</Title>
<Author><OtherName>The GHC Team</OtherName></Author>
<Address><Email>glasgow-haskell-&lcub;users,bugs&rcub;@haskell.org</Email></Address>
<PubDate>November 2001</PubDate>

    <abstract>
      <para>The Glasgow fptools suite is a collection of Functional
      Programming related tools, including the Glasgow Haskell
      Compiler (GHC).  The source code for the whole suite is kept in
      a single CVS repository and shares a common build and
      installation system.</para>

      <para>This guide is intended for people who want to build or
      modify programs from the Glasgow <Literal>fptools</Literal>
      suite (as distinct from those who merely want to
      <Emphasis>run</Emphasis> them). Installation instructions are
      now provided in the user guide.</para>

      <para>The bulk of this guide applies to building on Unix
      systems; see <XRef LinkEnd="winbuild"> for Windows notes.</para>
    </abstract>

  </artheader>


  <sect1 id="sec-getting">
    <title>Getting the Glasgow <Literal>fptools</Literal> suite</title>

    <para>Building the Glasgow tools <Emphasis>can</Emphasis> be
    complicated, mostly because there are so many permutations of
    what/why/how, e.g., ``Build Happy with HBC, everything else with
    GHC, leave out profiling, and test it all on the `real' NoFib
    programs.''  Yeeps!</para>

    <para>Happily, such complications don't apply to most people.  A
    few common ``strategies'' serve most purposes.  Pick one and
    proceed as suggested:</para>

<VariableList>

<VarListEntry>
<Term><IndexTerm><Primary>Binary distribution</Primary></IndexTerm>Binary distribution.</Term>
<ListItem>
<para>
If your only purpose is to install some of the
<Literal>fptools</Literal> suite then the easiest thing to do is to
get a binary distribution. In the binary distribution everything is
pre-compiled for your particular machine architecture and operating
system, so all you should have to do is install the binaries and
libraries in suitable places. The user guide describes how to do this.
</para>

<para>
A binary distribution may not work for you for two reasons.  First, we
may not have built the suite for the particular architecture/OS
platform you want. That may be due to lack of time and energy (in
which case you can get a source distribution and build from it; see
below).  Alternatively, it may be because we haven't yet ported the
suite to your architecture, in which case you are considerably worse
off.
</para>

<para>
The second reason a binary distribution may not be what you want is
if you want to read or modify the souce code.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><IndexTerm><Primary>Source distribution</Primary></IndexTerm>Source distribution.</Term>
<ListItem>
<para>
You have a supported
platform, but (a)&nbsp;you like the warm fuzzy feeling of compiling things
yourself; (b)&nbsp;you want to build something ``extra''&mdash;e.g., a set of
libraries with strictness-analysis turned off; or (c)&nbsp;you want to hack
on GHC yourself.
</para>

<para>
A source distribution contains complete sources for one or more
projects in the <Literal>fptools</Literal> suite.  Not only that, but
the more awkward machine-independent steps are done for you.  For
example, if you don't have
<Command>happy</Command><IndexTerm><Primary>happy</Primary></IndexTerm>
you'll find it convenient that the source distribution contains the
result of running <Command>happy</Command> on the parser
specifications.  If you don't want to alter the parser then this saves
you having to find and install <Command>happy</Command>. You will
still need a working version of GHC (preferably version 4.08+) on your
machine in order to compile (most of) the sources, however.
</para>

</ListItem></VarListEntry>

      <varlistentry>
	<term>The CVS repository.</term>
	<indexterm><primary>CVS repository</primary>
	</indexterm>
	<listitem>
	  <para>We make releases infrequently.  If you want more
          up-to-the minute (but less tested) source code then you need
          to get access to our CVS repository.</para>

	  <para>All the <Literal>fptools</Literal> source code is held
          in a CVS repository. CVS is a pretty good source-code
          control system, and best of all it works over the
          network.</para>

	  <para>The repository holds source code only. It holds no
          mechanically generated files at all.  So if you check out a
          source tree from CVS you will need to install every utility
          so that you can build all the derived files from
          scratch.</para>

	  <para>More information about our CVS repository can be found
          in <xref linkend="sec-cvs">.</para>

	</listitem>
      </varlistentry>

      <varlistentry>
	<term>Build GHC from intermediate C <Filename>.hc</Filename> files<IndexTerm><Primary>hc files</Primary></IndexTerm>:</term>
	<listitem>
	  <para>You need a working GHC to use a source distribution.
          What if you don't have a working GHC? Then you may be able
          to bootstrap up from the intermediate C
          (<filename>.hc</filename>) files that we provide.  Building
          GHC on an unsupported platform falls into this category.
          Beware: this route is not for the faint hearted!  Please see
          <Xref LinkEnd="sec-booting-from-C">.</para>

	  <para>Once you have built GHC, you can build the other
          Glasgow tools with it.</para>

	  <para>In theory, you can (could?) build GHC with another
          Haskell compiler (e.g., HBC). We haven't tried to do this
          for ages and it almost certainly doesn't work any more (for
          tedious reasons).</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>If you are going to do any building from sources (either
    from a source distribution or the CVS repository) then you need to
    read all of this manual in detail.</para>
  </sect1>

  <sect1 id="sec-cvs">
    <title>Using the CVS repository</title>

    <para>We use <ulink url="http://www.cvshome.org/">CVS</ulink> (Concurrent Version System) to keep track of our
    sources for various software projects. CVS lets several people
    work on the same software at the same time, allowing changes to be
    checked in incrementally. </para>

    <para>This section is a set of guidelines for how to use our CVS
    repository, and will probably evolve in time. The main thing to
    remember is that most mistakes can be undone, but if there's
    anything you're not sure about feel free to bug the local CVS
    meister (namely Jeff Lewis
    <email>jlewis@galconn.com</email>). </para>

    <sect2 id="cvs-access">
      <title>Getting access to the CVS Repository</title>

      <para>You can access the repository in one of two ways:
      read-only (<xref linkend="cvs-read-only">), or read-write (<xref
      linkend="cvs-read-write">).</para>

      <sect3 id="cvs-read-only">
	<title>Remote Read-only CVS Access</title>

	<para>Read-only access is available to anyone - there's no
        need to ask us first.  With read-only CVS access you can do
        anything except commit changes to the repository.  You can
        make changes to your local tree, and still use CVS's merge
        facility to keep your tree up to date, and you can generate
        patches using 'cvs diff' in order to send to us for
        inclusion. </para>

	<para>To get read-only access to the repository:</para>

	<orderedlist>
	  <listitem>
	    <para>Make sure that <application>cvs</application> is
            installed on your machine.</para>
	  </listitem>
	  <listitem>
	    <para>Set your <literal>$CVSROOT</literal> environment variable to
            <literal>:pserver:anoncvs@glass.cse.ogi.edu:/cvs</literal></para>
	  </listitem>
	  <listitem>
            <para>Run the command</para>
<programlisting>
    $ cvs login
</programlisting>
	    <para>The password is simply <literal>cvs</literal>.  This
            sets up a file in your home directory called
            <literal>.cvspass</literal>, which squirrels away the
            dummy password, so you only need to do this step once.</para>
	  </listitem>

	  <listitem>
	    <para>Now go to <xref linkend="cvs-first">.</para>
	  </listitem>
	</orderedlist>
      </sect3>

      <sect3 id="cvs-read-write">
	<title>Remote Read-Write CVS Access</title>

	<para>We generally supply read-write access to folk doing
        serious development on some part of the source tree, when
        going through us would be a pain. If you're developing some
        feature, or think you have the time and inclination to fix
        bugs in our sources, feel free to ask for read-write
        access. There is a certain amount of responsibility that goes
        with commit privileges; we are more likely to grant you access
        if you've demonstrated your competence by sending us patches
        via mail in the past.</para>

	<para>To get remote read-write CVS access, you need to do the
	following steps.</para>

	<orderedlist>
	  <listitem>
	    <para>Make sure that <literal>cvs</literal> and
            <literal>ssh</literal> are both installed on your
            machine.</para>
	  </listitem>

	  <listitem>
	    <para>Generate a DSA private-key/public-key pair, thus:</para>
<screen>
     $ ssh-keygen -d
</screen>
	    <para>(<literal>ssh-keygen</literal> comes with
            <literal>ssh</literal>.)  Running <literal>ssh-keygen
            -d</literal> creates the private and public keys in
            <literal>$HOME/.ssh/id_dsa</literal> and
            <literal>$HOME/.ssh/id_dsa.pub</literal> respectively
            (assuming you accept the standard defaults).</para>

	    <para><literal>ssh-keygen -d</literal> will only work if
            you have Version 2 <literal>ssh</literal> installed; it
            will fail harmlessly otherwise.  If you only have Version
            1 you can instead generate an RSA key pair using plain</para>
<screen>
    $ ssh-keygen
</screen>

	    <para>Doing so creates the private and public RSA keys in
            <literal>$HOME/.ssh/identity</literal> and
            <literal>$HOME/.ssh/identity.pub</literal>
            respectively.</para>

            <para>[Deprecated.]  Incidentally, you can force a Version
            2 <literal>ssh</literal> to use the Version 1 protocol by
            creating <literal>$HOME/config</literal> with the
            following in it:</para>
<screen>
   BatchMode Yes

   Host cvs.haskell.org
   Protocol 1
</screen>

	    <para>In both cases, <literal>ssh-keygen</literal> will
            ask for a <firstterm>passphrase</firstterm>.  The
            passphrase is a password that protects your private key.
            In response to the 'Enter passphrase' question, you can
            either:</para>
	    <itemizedlist>
	      <listitem>
		<para>[Recommended.]  Enter a passphrase, which you
                will quote each time you use CVS.
                <literal>ssh-agent</literal> makes this entirely
                un-tiresome.</para>
	      </listitem>
	      <listitem>
		<para>[Deprecated.] Just hit return (i.e. use an empty
                passphrase); then you won't need to quote the
                passphrase when using CVS.  The downside is that
                anyone who can see into your <literal>.ssh</literal>
                directory, and thereby get your private key, can mess
                up the repository.  So you must keep the
                <literal>.ssh</literal> directory with draconian
                no-access permissions.</para>
	      </listitem>
	    </itemizedlist>

	    <para>[Windows users. To protect your
            <literal>.ssh</literal> from access by anyone else,
            right-click your <literal>.ssh</literal> directory, and
            select <literal>Properties</literal>.  If you are not on
            the access control list, add yourself, and give yourself
            full permissions (the second panel).  Remove everyone else
            from the access control list.  Don't leave them there but
            deny them access, because 'they' may be a list that
            includes you!]</para>
	  </listitem>

	  <listitem>
	    <para>Send a message to to the CVS repository
            administrator (currently Jeff Lewis
            <email>jeff@galconn.com</email>), containing:</para>
	    <itemizedlist>
	      <listitem>
		<para>Your desired user-name.</para>
	      </listitem>
	      <listitem>
		<para>Your <literal>.ssh/id_dsa.pub</literal> (or
                <literal>.ssh/identity.pub</literal>).</para>
	      </listitem>
	    </itemizedlist>
	    <para>He will set up your account.</para>
	  </listitem>

	  <listitem>
	    <para>Set the following environment variables:</para>
	    <itemizedlist>
	      <listitem>
		<para><literal>$CVS_RSH</literal> to
		<literal>ssh</literal></para>
	      </listitem>
	      <listitem>
		<para><literal>$CVSROOT</literal> to
		<literal>:ext:</literal><replaceable>your-username</replaceable><literal>@cvs.haskell.org:/home/cvs/root</literal></para>
	      </listitem>
	    </itemizedlist>
	  </listitem>

	</orderedlist>

	<para>The <literal>CVSROOT</literal> environment variable will
        be recorded in the checked-out tree, so you don't need to set
        this every time either. Ignore the instructions for setting
        <literal>CVSROOT</literal> below. </para>

	<para>Caveats:</para>

	<itemizedlist>
	  <listitem>
	    <para>Setting your <literal>CVS_RSH</literal> to
            <literal>ssh</literal> assumes that your CVS client
            understands how to execute shell script
            (&quot;#!&quot;s,really), which is what
            <literal>ssh</literal> is. This may not be the case on
            some platforms (read: Win32), so in that case set
            <literal>CVS_RSH</literal> to
            <literal>ssh1</literal>.</para>
	  </listitem>
	</itemizedlist>

	<para>[Experts.]  Once your account is set up, you can get
        access from other machines without bothering Jeff, thus:</para>
	<orderedlist>
	  <listitem>
	    <para>Generate a public/private key pair on the new
            machine.</para>
	  </listitem>
	  <listitem>
	    <para>Use ssh to log in to
            <literal>cvs.haskell.org</literal>, from your old
            machine.</para>
	  </listitem>
	  <listitem>
	    <para>Add the public key for the new machine to the file
            <literal>$HOME/ssh/authorized_keys</literal> on
            <literal>cvs.haskell.org</literal>.
            (<literal>authorized_keys2</literal>, I think, for Version
            2 protocol.)</para>
	  </listitem>
	  <listitem>
	    <para>Make sure that the new version of
            <literal>authorized_keys</literal> still has 600 file
            permissions.</para>
	  </listitem>
	</orderedlist>
      </sect3>
    </sect2>

    <sect2 id="cvs-first">
      <title>Checking Out a Source Tree</title>

      <itemizedlist>
	<listitem>
	  <para>Make sure you set your <literal>CVSROOT</literal>
          environment variable according to either of the remote
          methods above. The Approved Way to check out a source tree
          is as follows:</para>

<screen>
    $ cvs checkout fpconfig
</screen>

	  <para>At this point you have a new directory called
          <literal>fptools</literal> which contains the basic stuff
          for the fptools suite, including the configuration files and
          some other junk. </para>

<screen>
    $ mv fptools <replaceable>directory</replaceable>
</screen>

	  <para>You can call the fptools directory whatever you like,
          CVS won't mind. </para>
	  
	  <para> NB: after you've read the CVS manual you might be
          tempted to try</para>
<screen>
    $ cvs checkout -d <replaceable>directory</replaceable> fpconfig
</screen>

	  <para>instead of checking out <literal>fpconfig</literal>
          and then renaming it.  But this doesn't work, and will
          result in checking out the entire repository instead of just
          the <literal>fpconfig</literal> bit.</para>
<screen>
    $ cd <replaceable>directory</replaceable>
    $ cvs checkout ghc hslibs
</screen>

	  <para>The second command here checks out the relevant
          modules you want to work on. For a GHC build, for instance,
          you need at least the <literal>ghc</literal> and
          <literal>hslibs</literal> modules (for a full list of the
          projects available, see <xref linkend="projects">).</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="cvs-committing">
      <title>Committing Changes</title>

      <para>This is only if you have read-write access to the
      repository. For anoncvs users, CVS will issue a &quot;read-only
      repository&quot; error if you try to commit changes.</para>

      <itemizedlist>
	<listitem>
	  <para>Build the software, if necessary. Unless you're just
          working on documentation, you'll probably want to build the
          software in order to test any changes you make.</para>
	</listitem>

	<listitem>
	  <para>Make changes. Preferably small ones first.</para>
	</listitem>

	<listitem>
	  <para>Test them. You can see exactly what changes you've
          made by using the <literal>cvs diff</literal> command:</para>
<screen>
$ cvs diff
</screen>
	  <para>lists all the changes (using the
          <literal>diff</literal> command) in and below the current
          directory. In emacs, <literal>C-c C-v =</literal> runs
          <literal>cvs diff</literal> on the current buffer and shows
          you the results.</para>
	</listitem>

      <listitem>
	  <para>Before checking in a change, you need to update your
          source tree:</para>

<screen>
$ cd fptools
$ cvs update
</screen>
	  <para>This pulls in any changes that other people have made,
          and merges them with yours. If there are any conflicts, CVS
          will tell you, and you'll have to resolve them before you
          can check your changes in. The documentation describes what
          to do in the event of a conflict.</para>

	  <para>It's not always necessary to do a full cvs update
          before checking in a change, since CVS will always tell you
          if you try to check in a file that someone else has changed.
          However, you should still update at regular intervals to
          avoid making changes that don't work in conjuction with
          changes that someone else made. Keeping an eye on what goes
          by on the mailing list can help here.</para>
	</listitem>

	<listitem>
	  <para>When you're happy that your change isn't going to
          break anything, check it in. For a one-file change:</para>

<screen>
$ cvs commit <replaceable>filename</replaceable>
</screen>

	  <para>CVS will then pop up an editor for you to enter a
          &quot;commit message&quot;, this is just a short description
          of what your change does, and will be kept in the history of
          the file.</para>

	  <para>If you're using emacs, simply load up the file into a
          buffer and type <literal>C-x C-q</literal>, and emacs will
          prompt for a commit message and then check in the file for
          you.</para>

	  <para>For a multiple-file change, things are a bit
          trickier. There are several ways to do this, but this is the
          way I find easiest. First type the commit message into a
          temporary file. Then either</para>

<screen>
$ cvs commit -F <replaceable>commit-message</replaceable> <replaceable>file_1</replaceable> .... <replaceable>file_n</replaceable>
</screen>

	  <para>or, if nothing else has changed in this part of the
          source tree, </para>

<screen>
$ cvs commit -F <replaceable>commit-message</replaceable> <replaceable>directory</replaceable>
</screen>

          <para>where <replaceable>directory</replaceable> is a common
          parent directory for all your changes, and
          <replaceable>commit-message</replaceable> is the name of the
          file containing the commit message.</para>

	  <para>Shortly afterwards, you'll get some mail from the
          relevant mailing list saying which files changed, and giving
          the commit message. For a multiple-file change, you should
          still get only <emphasis>one</emphasis> message.</para>
	</listitem>
      </itemizedlist>
    </sect2>

    <sect2 id="cvs-update">
      <title>Updating Your Source Tree</title>

      <para>It can be tempting to cvs update just part of a source
      tree to bring in some changes that someone else has made, or
      before committing your own changes. This is NOT RECOMMENDED!
      Quite often changes in one part of the tree are dependent on
      changes in another part of the tree (the
      <literal>mk/*.mk</literal> files are a good example where
      problems crop up quite often). Having an inconsistent tree is a
      major cause of headaches. </para>

      <para>So, to avoid a lot of hassle, follow this recipe for
      updating your tree: </para>

<screen>
$ cd fptools
$ cvs update -Pd 2&gt;&amp;1 | tee log</screen>

      <para>Look at the log file, and fix any conflicts (denoted by a
      <quote>C</quote> in the first column). If you're using multiple
      build trees, then for every build tree you have pointing at this
      source tree, you need to update the links in case any new files
      have appeared: </para>

<screen>
$ cd <replaceable>build-tree</replaceable>
$ lndir <replaceable>source-tree</replaceable>
</screen>

      <para>Some files might have been removed, so you need to remove
      the links pointing to these non-existent files:</para>

<screen>
$ find . -xtype l -exec rm '{}' \;
</screen>

      <para>To be <emphasis>really</emphasis> safe, you should do
      </para>

<screen>$ gmake all</screen>

      <para>from the top-level, to update the dependencies and build
      any changed files. </para>
    </sect2>

    <sect2 id="cvs-tags">
      <title>GHC Tag Policy</title>

      <para>If you want to check out a particular version of GHC,
      you'll need to know how we tag versions in the repository.  The
      policy (as of 4.04) is:</para>

      <itemizedlist>
	<listitem>
	  <para>The tree is branched before every major release.  The
          branch tag is <literal>ghc-x-xx-branch</literal>, where
          <literal>x-xx</literal> is the version number of the release
          with the <literal>'.'</literal> replaced by a
          <literal>'-'</literal>.  For example, the 4.04 release lives
          on <literal>ghc-4-04-branch</literal>.</para>
	</listitem>

	<listitem>
	  <para>The release itself is tagged with
          <literal>ghc-x-xx</literal> (on the branch).  eg. 4.06 is
          called <literal>ghc-4-06</literal>.</para>
	</listitem>

	<listitem>
	  <para>We didn't always follow these guidelines, so to see
          what tags there are for previous versions, do <literal>cvs
          log</literal> on a file that's been around for a while (like
          <literal>fptools/ghc/README</literal>).</para>
	</listitem>
      </itemizedlist>

      <para>So, to check out a fresh GHC 4.06 tree you would
      do:</para>

<screen>
     $ cvs co -r ghc-4-06 fpconfig
     $ cd fptools
     $ cvs co -r ghc-4-06 ghc hslibs
</screen>
    </sect2>

    <sect2 id="cvs-hints">
      <title>General Hints</title>

      <itemizedlist>
	<listitem>
	  <para>As a general rule: commit changes in small units,
          preferably addressing one issue or implementing a single
          feature.  Provide a descriptive log message so that the
          repository records exactly which changes were required to
          implement a given feature/fix a bug. I've found this
          <emphasis>very</emphasis> useful in the past for finding out
          when a particular bug was introduced: you can just wind back
          the CVS tree until the bug disappears.</para>
	</listitem>

	<listitem>
	  <para>Keep the sources at least *buildable* at any given
          time. No doubt bugs will creep in, but it's quite easy to
          ensure that any change made at least leaves the tree in a
          buildable state. We do nightly builds of GHC to keep an eye
          on what things work/don't work each day and how we're doing
          in relation to previous verions. This idea is truely wrecked
          if the compiler won't build in the first place!</para>
	</listitem>

	<listitem>
	  <para>To check out extra bits into an already-checked-out
          tree, use the following procedure.  Suppose you have a
          checked-out fptools tree containing just ghc, and you want
          to add nofib to it:</para>

<screen>
$ cd fptools
$ cvs checkout nofib
</screen>

	  <para>or: </para>

<screen>
$ cd fptools
$ cvs update -d nofib
</screen>
	  
	  <para>(the -d flag tells update to create a new
          directory). If you just want part of the nofib suite, you
          can do </para>

<screen>
$ cd fptools
$ cvs checkout nofib/spectral
</screen>

	  <para>This works because <literal>nofib</literal> is a
          module in its own right, and spectral is a subdirectory of
          the nofib module. The path argument to checkout must always
          start with a module name. There's no equivalent form of this
          command using <literal>update</literal>.</para>
	</listitem>
      </itemizedlist>
    </sect2>
  </sect1>

  <sect1 id="projects">
    <title>What projects are there?</title>

    <para>The <literal>fptools</literal> suite consists of several
    <firstterm>projects</firstterm>, most of which can be downloaded,
    built and installed individually.  Each project corresponds to a
    subdirectory in the source tree, and if checking out from CVS then
    each project can be checked out individually by sitting in the top
    level of your source tree and typing <command>cvs checkout
    <replaceable>project</replaceable></command>.</para>

    <para>Here is a list of the projects currently available:</para>

    <variablelist>
      <varlistentry>
	<term><literal>ghc</literal></term>
	<indexterm><primary><literal>ghc</literal></primary>
	<secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink url="http://www.haskell.org/ghc/">Glasgow
	  Haskell Compiler</ulink> (minus libraries).  Absolutely
	  required for building GHC.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>glafp-utils</literal></term>
	<indexterm><primary><literal>glafp-utils</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>Utility programs, some of which are used by the
	  build/installation system.  Required for pretty much
	  everything.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>green-card</literal></term>
	<indexterm><primary><literal>green-card</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink
	  url="http://www.haskell.org/greencard/">Green Card</ulink>
	  system for generating Haskell foreign function
	  interfaces.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>haggis</literal></term>
	<indexterm><primary><literal>haggis</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink
	  url="http://www.dcs.gla.ac.uk/fp/software/haggis/">Haggis</ulink>
	  Haskell GUI framework.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>happy</literal></term>
	<indexterm><primary><literal>happy</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink
	  url="http://www.haskell.org/happy/">Happy</ulink> Parser
	  generator.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>hdirect</literal></term>
	<indexterm><primary><literal>hdirect</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink
	  url="http://www.haskell.org/hdirect/">H/Direct</ulink>
	  Haskell interoperability tool.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>hood</literal></term>
	<indexterm><primary><literal>hood</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The <ulink url="http://www.haskell.org/hood/">Haskell
	  Object Observation Debugger</ulink>.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>hslibs</literal></term>
	<indexterm><primary><literal>hslibs</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>GHC's libraries.  Required for building GHC.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>libraries</literal></term>
	<indexterm><primary><literal></literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>Hierarchical Haskell library suite
	  (experimental).</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>mhms</literal></term>
	<indexterm><primary><literal></literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The Modular Haskell Metric System.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>nofib</literal></term>
	<indexterm><primary><literal>nofib</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>The NoFib suite: A collection of Haskell programs used
	  primarily for benchmarking.</para>
	</listitem>
      </varlistentry>

      <varlistentry>
	<term><literal>testsuite</literal></term>
	<indexterm><primary><literal>testsuite</literal></primary><secondary>project</secondary></indexterm>
	<listitem>
	  <para>A testing framework, including GHC's regression test
	  suite.</para>
	</listitem>
      </varlistentry>
    </variablelist>

    <para>So, to build GHC you need at least the
    <literal>ghc</literal> and <literal>hslibs</literal> projects (a
    GHC source distribution will already include the bits you
    need).</para>
  </sect1>

  <sect1 id="sec-build-checks">
    <title>Things to check before you start</title>

    <para>Here's a list of things to check before you get
    started.</para>

    <orderedlist>

      <listitem>
	<indexterm><primary>Disk space needed</primary></indexterm>
	<para>Disk space needed: from about 100Mb for a basic GHC
	build, up to probably 500Mb for a GHC build with everything
	included (libraries built several different ways,
	etc.).</para>
      </listitem>

      <listitem>
	<para>Use an appropriate machine, compilers, and things.
        SPARC boxes, PCs running Linux or FreeBSD, and Alphas running
        OSF/1 are all fully supported.  Win32 and HP boxes are in
        pretty good shape.  PCs running Solaris, DEC Alphas running
        Linux or some BSD variant, MIPS and AIX boxes will need some
        minimal porting effort before they work (as of 4.06).  <xref
        linkend="sec-port-info"> gives the full run-down on ports or
        lack thereof.</para>
      </listitem>

      <listitem>
	<para>Be sure that the ``pre-supposed'' utilities are
        installed.  <Xref LinkEnd="sec-pre-supposed">
        elaborates.</para>
      </listitem>

      <listitem>
	<para>If you have any problem when building or installing the
        Glasgow tools, please check the ``known pitfalls'' (<Xref
        LinkEnd="sec-build-pitfalls">).  Also check the FAQ for the
        version you're building, which should be available from the
        relevant download page on the <ULink
        URL="http://www.haskell.org/ghc/" >GHC web
        site</ULink>.</para>

	<indexterm><primary>known bugs</primary></indexterm>
	<indexterm><primary>bugs, known</primary></indexterm>

	<para>If you feel there is still some shortcoming in our
        procedure or instructions, please report it.</para>

	<para>For GHC, please see the bug-reporting section of the GHC
        Users' Guide (separate document), to maximise the usefulness
        of your report.</para>

	<indexterm><primary>bugs</primary><secondary>seporting</secondary></indexterm>

	<para>If in doubt, please send a message to
<email>glasgow-haskell-bugs@haskell.org</email>.
<indexterm><primary>bugs</primary><secondary>mailing
list</secondary></indexterm></para>

      </listitem>
    </orderedlist>
  </sect1>

<Sect1 id="sec-port-info">
<Title>What machines the Glasgow tools run on
</Title>

<para>
<IndexTerm><Primary>ports, GHC</Primary></IndexTerm>
<IndexTerm><Primary>GHC ports</Primary></IndexTerm>
<IndexTerm><Primary>supported platforms</Primary></IndexTerm>
<IndexTerm><Primary>platforms, supported</Primary></IndexTerm>
The main question is whether or not the Haskell compiler (GHC) runs on
your platform.
</para>

<para>
A ``platform'' is a architecture/manufacturer/operating-system
combination, such as <Literal>sparc-sun-solaris2</Literal>.  Other common ones are
<Literal>alpha-dec-osf2</Literal>, <Literal>hppa1.1-hp-hpux9</Literal>, <Literal>i386-unknown-linux</Literal>,
<Literal>i386-unknown-solaris2</Literal>, <Literal>i386-unknown-freebsd</Literal>,
<Literal>i386-unknown-cygwin32</Literal>, <Literal>m68k-sun-sunos4</Literal>, <Literal>mips-sgi-irix5</Literal>,
<Literal>sparc-sun-sunos4</Literal>, <Literal>sparc-sun-solaris2</Literal>, <Literal>powerpc-ibm-aix</Literal>.
</para>

<para>
Bear in mind that certain ``bundles'', e.g. parallel Haskell, may not
work on all machines for which basic Haskell compiling is supported.
</para>

<para>
Some libraries may only work on a limited number of platforms; for
example, a sockets library is of no use unless the operating system
supports the underlying BSDisms.
</para>

<Sect2>
<Title>What platforms the Haskell compiler (GHC) runs on</Title>

<para>
<IndexTerm><Primary>fully-supported platforms</Primary></IndexTerm>
<IndexTerm><Primary>native-code generator</Primary></IndexTerm>
<IndexTerm><Primary>registerised ports</Primary></IndexTerm>
<IndexTerm><Primary>unregisterised ports</Primary></IndexTerm>
The GHC hierarchy of Porting Goodness: (a)&nbsp;Best is a native-code
generator; (b)&nbsp;next best is a ``registerised''
port; (c)&nbsp;the bare minimum is an ``unregisterised'' port.
(``Unregisterised'' is so terrible that we won't say more about it).
</para>

<para>
We use Sparcs running Solaris 2.7 and x86 boxes running FreeBSD and
Linux, so those are the best supported platforms, unsurprisingly.
</para>

<para>
Here's everything that's known about GHC ports.  We identify platforms
by their ``canonical'' CPU/Manufacturer/OS triple.
</para>

      <variablelist>

	<varlistentry>
	  <term>alpha-dec-{osf,linux,freebsd,openbsd,netbsd}:</term>
	  <indexterm><primary>alpha-dec-osf</primary></indexterm>
	  <indexterm><primary>alpha-dec-linux</primary></indexterm>
	  <indexterm><primary>alpha-dec-freebsd</primary></indexterm>
	  <indexterm><primary>alpha-dec-openbsd</primary></indexterm>
	  <indexterm><primary>alpha-dec-netbsd</primary></indexterm>
	  
	  <listitem>
	    <para>The OSF port is currently working (as of GHC version
	    5.02.1) and well supported.  The native code generator is
	    currently non-working.  Other operating systems will
	    require some minor porting.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>sparc-sun-sunos4</term>
	  <indexterm><primary>sparc-sun-sunos4</primary></indexterm>
	  <listitem>
	    <para>Probably works with minor tweaks, hasn't been tested
	    for a while.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>sparc-sun-solaris2</term>
	  <indexterm><primary>sparc-sun-solaris2</primary></indexterm>
	  <listitem>
	    <para>Fully supported, including native-code
	    generator.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>hppa1.1-hp-hpux (HP-PA boxes running HPUX 9.x)</term>
	  <indexterm><primary>hppa1.1-hp-hpux</primary></indexterm>
	  <listitem>
	    <para>Works registerised.  No native-code
	    generator.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>i386-unknown-linux (PCs running Linux, ELF binary format)</term>
	  <indexterm><primary>i386-*-linux</primary></indexterm>
	  <listitem>
	    <para>GHC works registerised and has a native code
            generator.  You <Emphasis>must</Emphasis> have GCC 2.7.x
            or later.  NOTE about <literal>glibc</literal> versions:
            GHC binaries built on a system running <literal>glibc
            2.0</literal> won't work on a system running
            <literal>glibc 2.1</literal>, and vice versa.  In general,
            don't expect compatibility between
            <literal>glibc</literal> versions, even if the shared
            library version hasn't changed.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>i386-unknown-freebsd (PCs running FreeBSD 2.2
or higher)</term>
	  <indexterm><primary>i386-unknown-freebsd</primary></indexterm>
	  <listitem>
	    <para>GHC works registerised.  Pre-built packages are
            available in the native package format, so if you just
            need binaries you're better off just installing the
            package.</para>
	  </listitem>
	</varlistentry>
	
	<varlistentry>
	  <term>i386-unknown-{netbsd,openbsd) (PCs running NetBSD
	    and OpenBSD)</term>
	  <indexterm><primary>i386-unknown-netbsd</primary></indexterm> 
	  <indexterm><primary>i386-unknown-openbsd</primary></indexterm> 
	  <listitem>
	    <para>Will require some minor porting effort, but should
	    work registerised.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>i386-unknown-cygwin32:</term>
	  <indexterm><primary>i386-unknown-cygwin32</primary></indexterm>
	  <listitem>
	    <para>Fully supported under Win9x/NT, including a native
            code generator. Requires the <Literal>cygwin32</Literal>
            compatibility library and a healthy collection of GNU
            tools (i.e., gcc, GNU ld, bash etc.).</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>mips-sgi-irix5</term>
	  <indexterm><primary>mips-sgi-irix[5-6]</primary></indexterm>
	  <listitem>
	    <para>Port currently doesn't work, needs some minimal
            porting effort.  As usual, we don't have access to
            machines and there hasn't been an overwhelming demand for
            this port, but feel free to get in touch.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>powerpc-ibm-aix</term>
	  <indexterm><primary>powerpc-ibm-aix</primary></indexterm>
	  <ListItem>
	    <para>Port currently doesn't work, needs some minimal
            porting effort.  As usual, we don't have access to
            machines and there hasn't been an overwhelming demand for
            this port, but feel free to get in touch.</para>
	  </listitem>
	</varlistentry>

	<varlistentry>
	  <term>powerpc-apple-darwin</term>
	  <indexterm><primary>powerpc-apple-darwin</primary></indexterm> 
	  <listitem>
	    <para>Works, unregisterised only at the moment.</para>
	  </listitem>
	</varlistentry>
      </variablelist>

      <para>Various other systems have had GHC ported to them in the
      distant past, including various Motorola 68k boxes.  The 68k
      support still remains, but porting to one of these systems will
      certainly be a non-trivial task.</para>
    </sect2>

    <sect2>
      <title>What machines the other tools run on</title>

      <para>Unless you hear otherwise, the other tools work if GHC
      works.</para>
    </sect2>
  </sect1>


<Sect1 id="sec-pre-supposed">
<Title>Installing pre-supposed utilities

<IndexTerm><Primary>pre-supposed utilities</Primary></IndexTerm>
<IndexTerm><Primary>utilities, pre-supposed</Primary></IndexTerm></Title>

<para>
Here are the gory details about some utility programs you may need;
<Command>perl</Command>, <Command>gcc</Command> and
<command>happy</command> are the only important
ones. (PVM<IndexTerm><Primary>PVM</Primary></IndexTerm> is important
if you're going for Parallel Haskell.)  The
<Command>configure</Command><IndexTerm><Primary>configure</Primary></IndexTerm>
script will tell you if you are missing something.
</para>

<para>
<VariableList>

<VarListEntry>
<Term>Perl:</Term>
<IndexTerm><Primary>pre-supposed: Perl</Primary></IndexTerm>
<IndexTerm><Primary>Perl, pre-supposed</Primary></IndexTerm>
<ListItem>
<para>
<Emphasis>You have to have Perl to proceed!</Emphasis>
It is pretty easy to install.
</para>

<para>
Perl&nbsp;5 is required.  For Win32 platforms, you should use the binary
supplied in the InstallShield (copy it to <filename>/bin</filename>).
The Cygwin-supplied Perl seems not to work.
</para>

<para>
Perl should be put somewhere so that it can be invoked by the
<Literal>&num;!</Literal> script-invoking mechanism. The full
pathname may need to be less than 32 characters long on some
systems.
</para>

</ListItem></VarListEntry>
<VarListEntry>
<Term>GNU C (<Command>gcc</Command>):</Term>
<IndexTerm><Primary>pre-supposed: GCC (GNU C compiler)</Primary></IndexTerm>
<IndexTerm><Primary>GCC (GNU C compiler), pre-supposed</Primary></IndexTerm>
<ListItem>

<para>
We recommend using GCC version 2.95.2 on all platforms.  Failing that,
version 2.7.2 is stable on most platforms.  Earlier versions of GCC
can be assumed not to work, and versions in between 2.7.2 and 2.95.2
(including <command>egcs</command>) have varying degrees of stability
depending on the platform.
</para>

<para>
If your GCC dies with ``internal error'' on some GHC source file,
please let us know, so we can report it and get things improved.
(Exception: on iX86 boxes&mdash;you may need to fiddle with GHC's
<Option>-monly-N-regs</Option> option; see the User's Guide)
</para>
</ListItem></VarListEntry>

<varlistentry>
<term>Happy:</term>
<indexterm><primary>Happy</primary></indexterm>
<listitem>
<para>Happy is a parser generator tool for Haskell, and is used to
generate GHC's parsers.  Happy is written in Haskell, and is a project
in the CVS repository (<literal>fptools/happy</literal>).  It can be
built from source, but bear in mind that you'll need GHC installed in
order to build it.  To avoid the chicken/egg problem, install a binary
distribtion of either Happy or GHC to get started.  Happy
distributions are available from <ulink
url="http://www.haskell.org/happy/">Happy's Web Page</ulink>.
</para>
</listitem>
</varlistentry>

<VarListEntry>
<Term>Autoconf:</Term>
<IndexTerm><Primary>pre-supposed: Autoconf</Primary></IndexTerm>
<IndexTerm><Primary>Autoconf, pre-supposed</Primary></IndexTerm>
<ListItem>
<para>
GNU Autoconf is needed if you intend to build from the CVS sources, it
is <Emphasis>not</Emphasis> needed if you just intend to build a
standard source distribution.
</para>

<para>
Autoconf builds the <Command>configure</Command> script from
<Filename>configure.in</Filename> and <Filename>aclocal.m4</Filename>.
If you modify either of these files, you'll need
<command>autoconf</command> to rebuild <Filename>configure</Filename>.
</para>

</ListItem></VarListEntry>
<VarListEntry>
<Term><Command>sed</Command></Term>
<IndexTerm><Primary>pre-supposed: sed</Primary></IndexTerm>
<IndexTerm><Primary>sed, pre-supposed</Primary></IndexTerm>
<ListItem>
<para>
You need a working <Command>sed</Command> if you are going to build
from sources.  The build-configuration stuff needs it.  GNU sed
version 2.0.4 is no good!  It has a bug in it that is tickled by the
build-configuration.  2.0.5 is OK. Others are probably OK too
(assuming we don't create too elaborate configure scripts.)
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
One <Literal>fptools</Literal> project is worth a quick note at this
point, because it is useful for all the others:
<Literal>glafp-utils</Literal> contains several utilities which aren't
particularly Glasgow-ish, but Occasionally Indispensable.  Like
<Command>lndir</Command> for creating symbolic link trees.
</para>

<Sect2 id="pre-supposed-gph-tools">
<Title>Tools for building parallel GHC (GPH)
</Title>

<para>
<VariableList>

<VarListEntry>
<Term>PVM version 3:</Term>
<IndexTerm><Primary>pre-supposed: PVM3 (Parallel Virtual Machine)</Primary></IndexTerm>
<IndexTerm><Primary>PVM3 (Parallel Virtual Machine), pre-supposed</Primary></IndexTerm>
<ListItem>

<para>
PVM is the Parallel Virtual Machine on which Parallel Haskell programs
run.  (You only need this if you plan to run Parallel Haskell.
Concurent Haskell, which runs concurrent threads on a uniprocessor
doesn't need it.)  Underneath PVM, you can have (for example) a
network of workstations (slow) or a multiprocessor box (faster).
</para>

<para>
The current version of PVM is 3.3.11; we use 3.3.7.  It is readily
available on the net; I think I got it from
<Literal>research.att.com</Literal>, in <Filename>netlib</Filename>.
</para>

<para>
A PVM installation is slightly quirky, but easy to do.  Just follow
the <Filename>Readme</Filename> instructions.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Command>bash</Command>:</Term>
<IndexTerm><Primary>bash, presupposed (Parallel Haskell only)</Primary></IndexTerm>
<ListItem>
<para>
Sadly, the <Command>gr2ps</Command> script, used to convert ``parallelism profiles''
to PostScript, is written in Bash (GNU's Bourne Again shell).
This bug will be fixed (someday).
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

</Sect2>

<Sect2 id="pre-supposed-doc-tools">
<Title>Tools for building the Documentation
</Title>

<para>
The following additional tools are required if you want to format the
documentation that comes with the <Literal>fptools</Literal> projects:
</para>

<para>
<VariableList>

<VarListEntry>
<Term>DocBook:</Term>
<IndexTerm><Primary>pre-supposed: DocBook</Primary></IndexTerm>
<IndexTerm><Primary>DocBook, pre-supposed</Primary></IndexTerm>
<ListItem>
<para>
All our documentation is written in SGML, using the DocBook DTD.
Instructions on installing and configuring the DocBook tools are in the
installation guide (in the GHC user guide).
</para>

</ListItem></VarListEntry>
<VarListEntry>
<Term>TeX:</Term>
<IndexTerm><Primary>pre-supposed: TeX</Primary></IndexTerm>
<IndexTerm><Primary>TeX, pre-supposed</Primary></IndexTerm>
<ListItem>
<para>
A decent TeX distribution is required if you want to produce printable
documentation.  We recomment teTeX, which includes just about
everything you need.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

      <para>
	In order to actually build any documentation, you need to set
	<constant>SGMLDocWays</constant> in your
	<filename>build.mk</filename>. Valid values to add to this
	list are: <literal>dvi</literal>, <literal>ps</literal>,
	<literal>pdf</literal>, <literal>html</literal>, and
	<literal>rtf</literal>.
      </para>
      
</Sect2>

<Sect2 id="pre-supposed-other-tools">
<Title>Other useful tools
</Title>

<VariableList>
<VarListEntry>
<Term>Flex:</Term>
<IndexTerm><Primary>pre-supposed: flex</Primary></IndexTerm> 
<IndexTerm><Primary>flex, pre-supposed</Primary></IndexTerm>
<ListItem>

<para>
This is a quite-a-bit-better-than-Lex lexer.  Used to build a couple
of utilities in <Literal>glafp-utils</Literal>.  Depending on your
operating system, the supplied <Command>lex</Command> may or may not
work; you should get the GNU version.
</para>
</ListItem></VarListEntry>
</VariableList>

</Sect2>

</Sect1>

<Sect1 id="sec-building-from-source">
<Title>Building from source

<IndexTerm><Primary>Building from source</Primary></IndexTerm>
<IndexTerm><Primary>Source, building from</Primary></IndexTerm></Title>

<para>
You've been rash enough to want to build some of
the Glasgow Functional Programming tools (GHC, Happy,
nofib, etc.) from source.  You've slurped the source,
from the CVS repository or from a source distribution, and
now you're sitting looking at a huge mound of bits, wondering
what to do next.
</para>

<para>
Gingerly, you type <Command>make</Command>.  Wrong already!
</para>

<para>
This rest of this guide is intended for duffers like me, who aren't
really interested in Makefiles and systems configurations, but who
need a mental model of the interlocking pieces so that they can make
them work, extend them consistently when adding new software, and lay
hands on them gently when they don't work.
</para>

<Sect2 id="sec-source-tree">
<Title>Your source tree
</Title>

<para>
The source code is held in your <Emphasis>source tree</Emphasis>.
The root directory of your source tree <Emphasis>must</Emphasis>
contain the following directories and files:
</para>

<para>

<ItemizedList>
<ListItem>

<para>
<Filename>Makefile</Filename>: the root Makefile.
</para>
</ListItem>
<ListItem>

<para>
<Filename>mk/</Filename>: the directory that contains the
main Makefile code, shared by all the
<Literal>fptools</Literal> software.
</para>
</ListItem>
<ListItem>

<para>
 <Filename>configure.in</Filename>, <Filename>config.sub</Filename>, <Filename>config.guess</Filename>:
these files support the configuration process.
</para>
</ListItem>
<ListItem>

<para>
 <Filename>install-sh</Filename>.
</para>
</ListItem>

</ItemizedList>

</para>

<para>
All the other directories are individual <Emphasis>projects</Emphasis> of the
<Literal>fptools</Literal> system&mdash;for example, the Glasgow Haskell Compiler
(<Literal>ghc</Literal>), the Happy parser generator (<Literal>happy</Literal>), the <Literal>nofib</Literal> benchmark
suite, and so on.  You can have zero or more of these.  Needless to
say, some of them are needed to build others.
</para>

<para>
The important thing to remember is that even if you want only one
project (<Literal>happy</Literal>, say), you must have a source tree whose root
directory contains <Filename>Makefile</Filename>, <Filename>mk/</Filename>, <Filename>configure.in</Filename>, and the
project(s) you want (<Filename>happy/</Filename> in this case).  You cannot get by with
just the <Filename>happy/</Filename> directory.
</para>

</Sect2>

<Sect2>
<Title>Build trees
<IndexTerm><Primary>build trees</Primary></IndexTerm>
<IndexTerm><Primary>link trees, for building</Primary></IndexTerm></Title>

<para>
While you can build a system in the source tree, we don't recommend it.
We often want to build multiple versions of our software
for different architectures, or with different options (e.g. profiling).
It's very desirable to share a single copy of the source code among
all these builds.
</para>

<para>
So for every source tree we have zero or more <Emphasis>build trees</Emphasis>.  Each
build tree is initially an exact copy of the source tree, except that
each file is a symbolic link to the source file, rather than being a
copy of the source file.  There are ``standard'' Unix utilities that
make such copies, so standard that they go by different names:
<Command>lndir</Command><IndexTerm><Primary>lndir</Primary></IndexTerm>, <Command>mkshadowdir</Command><IndexTerm><Primary>mkshadowdir</Primary></IndexTerm> are two (If you
don't have either, the source distribution includes sources for the
X11 <Command>lndir</Command>&mdash;check out <Filename>fptools/glafp-utils/lndir</Filename>). See <Xref LinkEnd="sec-storysofar"> for a typical invocation.
</para>

<para>
The build tree does not need to be anywhere near the source tree in
the file system.  Indeed, one advantage of separating the build tree
from the source is that the build tree can be placed in a
non-backed-up partition, saving your systems support people from
backing up untold megabytes of easily-regenerated, and
rapidly-changing, gubbins.  The golden rule is that (with a single
exception&mdash;<XRef LinkEnd="sec-build-config">)
<Emphasis>absolutely everything in the build tree is either a symbolic
link to the source tree, or else is mechanically generated</Emphasis>.
It should be perfectly OK for your build tree to vanish overnight; an
hour or two compiling and you're on the road again.
</para>

<para>
You need to be a bit careful, though, that any new files you create
(if you do any development work) are in the source tree, not a build tree!
</para>

<para>
Remember, that the source files in the build tree are <Emphasis>symbolic
links</Emphasis> to the files in the source tree.  (The build tree soon
accumulates lots of built files like <Filename>Foo.o</Filename>, as well.)  You
can <Emphasis>delete</Emphasis> a source file from the build tree without affecting
the source tree (though it's an odd thing to do).  On the other hand,
if you <Emphasis>edit</Emphasis> a source file from the build tree, you'll edit the
source-tree file directly.  (You can set up Emacs so that if you edit
a source file from the build tree, Emacs will silently create an
edited copy of the source file in the build tree, leaving the source
file unchanged; but the danger is that you think you've edited the
source file whereas actually all you've done is edit the build-tree
copy.  More commonly you do want to edit the source file.)
</para>

<para>
Like the source tree, the top level of your build tree must be (a
linked copy of) the root directory of the <Literal>fptools</Literal> suite.  Inside
Makefiles, the root of your build tree is called
<Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant><IndexTerm><Primary>FPTOOLS&lowbar;TOP</Primary></IndexTerm>.  In the rest of this document path
names are relative to <Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant> unless otherwise stated.  For
example, the file <Filename>ghc/mk/target.mk</Filename> is actually
<Filename><Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>/ghc/mk/target.mk</Filename>.
</para>

</Sect2>

<Sect2 id="sec-build-config">
<Title>Getting the build you want
</Title>

<para>
When you build <Literal>fptools</Literal> you will be compiling code on a particular
<Emphasis>host platform</Emphasis>, to run on a particular <Emphasis>target platform</Emphasis>
(usually the same as the host platform)<IndexTerm><Primary>platform</Primary></IndexTerm>.  The
difficulty is that there are minor differences between different
platforms; minor, but enough that the code needs to be a bit different
for each.  There are some big differences too: for a different
architecture we need to build GHC with a different native-code
generator.
</para>

<para>
There are also knobs you can turn to control how the <Literal>fptools</Literal>
software is built.  For example, you might want to build GHC optimised
(so that it runs fast) or unoptimised (so that you can compile it fast
after you've modified it.  Or, you might want to compile it with
debugging on (so that extra consistency-checking code gets included)
or off.  And so on.
</para>

<para>
All of this stuff is called the <Emphasis>configuration</Emphasis> of your build.
You set the configuration using a three-step process.
<VariableList>

<VarListEntry>
<Term>Step 1: get ready for configuration.</Term>
<ListItem>
	      <para>Change directory to
              <Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant> and
              issue the command
              <Command>autoconf</Command><IndexTerm><Primary>autoconf</Primary></IndexTerm>
              (with no arguments). This GNU program converts
              <Filename><Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>/configure.in</Filename>
              to a shell script called
              <Filename><Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>/configure</Filename>.
              </para>

	      <para>Some projects, including GHC, have their own
              configure script.  If there's an
              <Constant>&dollar;(FPTOOLS&lowbar;TOP)/&lt;project&gt;/configure.in</Constant>,
              then you need to run <command>autoconf</command> in that
              directory too.</para>

	      <para>Both these steps are completely
              platform-independent; they just mean that the
              human-written file (<Filename>configure.in</Filename>)
              can be short, although the resulting shell script,
              <Command>configure</Command>, and
              <Filename>mk/config.h.in</Filename>, are long.</para>

	      <para>In case you don't have <Command>autoconf</Command>
              we distribute the results, <Command>configure</Command>,
              and <Filename>mk/config.h.in</Filename>, with the source
              distribution.  They aren't kept in the repository,
              though.</para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term>Step 2: system configuration.</term>
	    <listitem>
	      <para>Runs the newly-created
	      <Command>configure</Command> script, thus:</para>

<ProgramListing>
./configure <optional><parameter>args</parameter></optional>
</ProgramListing>

	      <para><Command>configure</Command>'s mission is to
              scurry round your computer working out what architecture
              it has, what operating system, whether it has the
              <Function>vfork</Function> system call, where
              <Command>yacc</Command> is kept, whether
              <Command>gcc</Command> is available, where various
              obscure <Literal>&num;include</Literal> files are,
              whether it's a leap year, and what the systems manager
              had for lunch.  It communicates these snippets of
              information in two ways:</para>

	      <itemizedlist>
		<listitem>

		  <para>It translates
                  <Filename>mk/config.mk.in</Filename><IndexTerm><Primary>config.mk.in</Primary></IndexTerm>
                  to
                  <Filename>mk/config.mk</Filename><IndexTerm><Primary>config.mk</Primary></IndexTerm>,
                  substituting for things between
                  ``<Literal>@</Literal>'' brackets.  So,
                  ``<Literal>@HaveGcc@</Literal>'' will be replaced by
                  ``<Literal>YES</Literal>'' or
                  ``<Literal>NO</Literal>'' depending on what
                  <Command>configure</Command> finds.
                  <Filename>mk/config.mk</Filename> is included by
                  every Makefile (directly or indirectly), so the
                  configuration information is thereby communicated to
                  all Makefiles.</para>
		</ListItem>

		<listitem>
		  <para> It translates
                  <Filename>mk/config.h.in</Filename><IndexTerm><Primary>config.h.in</Primary></IndexTerm>
                  to
                  <Filename>mk/config.h</Filename><IndexTerm><Primary>config.h</Primary></IndexTerm>.
                  The latter is <Literal>&num;include</Literal>d by
                  various C programs, which can thereby make use of
                  configuration information.</para>
		</listitem>
	      </itemizedlist>

	      <para><command>configure</command> takes some optional
	      arguments.  Use <literal>./configure --help</literal> to
	      get a list of the available arguments.  Here are some of
	      the ones you might need:</para>

	      <variablelist>
		<varlistentry>
		  <term><literal>--with-ghc=<parameter>path</parameter></literal></term>
		  <indexterm><primary><literal>--with-ghc</literal></primary>
		  </indexterm>
		  <listitem>
		    <para>Specifies the path to an installed GHC which
		    you would like to use.  This compiler will be used
		    for compiling GHC-specific code (eg. GHC itself).
		    This option <emphasis>cannot</emphasis> be
		    specified using <filename>build.mk</filename> (see
		    later), because <command>configure</command> needs
		    to auto-detect the version of GHC you're using.
		    The default is to look for a compiler named
		    <literal>ghc</literal> in your path.</para>
		  </listitem>
		</varlistentry>
		  
		<varlistentry>
		  <term><literal>--with-hc=<parameter>path</parameter></literal></term>
		  <indexterm><primary><literal>--with-hc</literal></primary>
		  </indexterm>
		  <listitem>
		    <para>Specifies the path to any installed Haskell
		    compiler.  This compiler will be used for
		    compiling generic Haskell code.  The default is to
		    use <literal>ghc</literal>.</para>
		  </listitem>
		</varlistentry>

		<varlistentry>
		  <term><literal>--with-gcc=<parameter>path</parameter></literal></term>
		  <indexterm><primary><literal>--with-gcc</literal></primary>
		  </indexterm>
		  <listitem>
		    <para>Specifies the path to the installed
		    GCC. This compiler will be used to compile all C
		    files, <emphasis>except</emphasis> any generated
		    by the installed Haskell compiler, which will have
		    its own idea of which C compiler (if any) to use.
		    The default is to use <literal>gcc</literal>.</para>
		  </listitem>
		</varlistentry>
	      </variablelist>

	      <para><command>configure</command> caches the results of
              its run in <Filename>config.cache</Filename>.  Quite
              often you don't want that; you're running
              <Command>configure</Command> a second time because
              something has changed.  In that case, simply delete
              <Filename>config.cache</Filename>.</para>
	    </listitem>
	  </varlistentry>

<VarListEntry>
<Term>Step 3: build configuration.</Term>
<ListItem>
<para>
Next, you say how this build of <Literal>fptools</Literal> is to differ from the
standard defaults by creating a new file <Filename>mk/build.mk</Filename><IndexTerm><Primary>build.mk</Primary></IndexTerm>
<Emphasis>in the build tree</Emphasis>.  This file is the one and only file you edit
in the build tree, precisely because it says how this build differs
from the source.  (Just in case your build tree does die, you might
want to keep a private directory of <Filename>build.mk</Filename> files, and use a
symbolic link in each build tree to point to the appropriate one.)  So
<Filename>mk/build.mk</Filename> never exists in the source tree&mdash;you create one in
each build tree from the template.  We'll discuss what to put in it
shortly.  
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
And that's it for configuration. Simple, eh?
</para>

      <para>What do you put in your build-specific configuration file
      <filename>mk/build.mk</filename>?  <Emphasis>For almost all
      purposes all you will do is put make variable definitions that
      override those in</Emphasis>
      <filename>mk/config.mk.in</filename>.  The whole point of
      <filename>mk/config.mk.in</filename>&mdash;and its derived
      counterpart <filename>mk/config.mk</filename>&mdash;is to define
      the build configuration. It is heavily commented, as you will
      see if you look at it.  So generally, what you do is look at
      <filename>mk/config.mk.in</filename>, and add definitions in
      <filename>mk/build.mk</filename> that override any of the
      <filename>config.mk</filename> definitions that you want to
      change.  (The override occurs because the main boilerplate file,
      <filename>mk/boilerplate.mk</filename><IndexTerm><Primary>boilerplate.mk</Primary></IndexTerm>,
      includes <filename>build.mk</filename> after
      <filename>config.mk</filename>.)</para>

      <para>For example, <filename>config.mk.in</filename> contains
      the definition:</para>

<ProgramListing>
GhcHcOpts=-O -Rghc-timing
</ProgramListing>

      <para>The accompanying comment explains that this is the list of
      flags passed to GHC when building GHC itself.  For doing
      development, it is wise to add <literal>-DDEBUG</literal>, to
      enable debugging code.  So you would add the following to
      <filename>build.mk</filename>:</para>

      <para>or, if you prefer,</para>

<ProgramListing>
GhcHcOpts += -DDEBUG
</ProgramListing>

      <para>GNU <Command>make</Command> allows existing definitions to
      have new text appended using the ``<Literal>+=</Literal>''
      operator, which is quite a convenient feature.)</para>

      <para>If you want to remove the <literal>-O</literal> as well (a
      good idea when developing, because the turn-around cycle gets a
      lot quicker), you can just override
      <literal>GhcLibHcOpts</literal> altogether:</para>

<ProgramListing>
GhcHcOpts=-DDEBUG -Rghc-timing
</ProgramListing>

      <para>When reading <filename>config.mk.in</filename>, remember
      that anything between ``@...@'' signs is going to be substituted
      by <Command>configure</Command> later.  You
      <Emphasis>can</Emphasis> override the resulting definition if
      you want, but you need to be a bit surer what you are doing.
      For example, there's a line that says:</para>

<ProgramListing>
YACC = @YaccCmd@
</ProgramListing>

      <para>This defines the Make variables <Constant>YACC</Constant>
      to the pathname for a <Command>yacc</Command> that
      <Command>configure</Command> finds somewhere.  If you have your
      own pet <Command>yacc</Command> you want to use instead, that's
      fine. Just add this line to <filename>mk/build.mk</filename>:</para>

<ProgramListing>
YACC = myyacc
</ProgramListing>

      <para>You do not <Emphasis>have</Emphasis> to have a
      <filename>mk/build.mk</filename> file at all; if you don't,
      you'll get all the default settings from
      <filename>mk/config.mk.in</filename>.</para>

      <para>You can also use <filename>build.mk</filename> to override
      anything that <Command>configure</Command> got wrong.  One place
      where this happens often is with the definition of
      <Constant>FPTOOLS&lowbar;TOP&lowbar;ABS</Constant>: this
      variable is supposed to be the canonical path to the top of your
      source tree, but if your system uses an automounter then the
      correct directory is hard to find automatically.  If you find
      that <Command>configure</Command> has got it wrong, just put the
      correct definition in <filename>build.mk</filename>.</para>

</Sect2>

    <sect2 id="sec-storysofar">
      <title>The story so far</title>

      <para>Let's summarise the steps you need to carry to get
      yourself a fully-configured build tree from scratch.</para>

      <orderedlist>
	<listitem>
	  <para> Get your source tree from somewhere (CVS repository
          or source distribution).  Say you call the root directory
          <filename>myfptools</filename> (it does not have to be
          called <filename>fptools</filename>).  Make sure that you
          have the essential files (see <XRef
          LinkEnd="sec-source-tree">).</para>
	</listitem>

	<listitem>

	  <para>(Optional) Use <Command>lndir</Command> or
	  <Command>mkshadowdir</Command> to create a build tree.</para>

<programlisting>
$ cd myfptools
$ mkshadowdir . /scratch/joe-bloggs/myfptools-sun4
</programlisting>

	  <para>(N.B. <Command>mkshadowdir</Command>'s first argument
          is taken relative to its second.) You probably want to give
          the build tree a name that suggests its main defining
          characteristic (in your mind at least), in case you later
          add others.</para>
	</listitem>

	<listitem>
	  <para>Change directory to the build tree.  Everything is
          going to happen there now.</para>

<programlisting>
$ cd /scratch/joe-bloggs/myfptools-sun4
</programlisting>

	</listitem>

	<listitem>
	  <para>Prepare for system configuration:</para>

<programlisting>
$ autoconf
</programlisting>

	  <para>(You can skip this step if you are starting from a
          source distribution, and you already have
          <filename>configure</filename> and
          <filename>mk/config.h.in</filename>.)</para>

	  <para>Some projects, including GHC itself, have their own
	  configure scripts, so it is necessary to run autoconf again
	  in the appropriate subdirectories. eg:</para>

<programlisting>
$ (cd ghc; autoconf)
</programlisting>
	</listitem>

	<listitem>
	  <para>Do system configuration:</para>

<programlisting>
$ ./configure
</programlisting>

	  <para>Don't forget to check whether you need to add any
	  arguments to <literal>configure</literal>; for example, a
	  common requirement is to specify which GHC to use with
	  <option>--with-ghc=<replaceable>ghc</replaceable></option>.</para>
	</listitem>

	<listitem>
	  <para>Create the file <filename>mk/build.mk</filename>,
          adding definitions for your desired configuration
          options.</para>

<programlisting>
$ emacs mk/build.mk
</programlisting>
	</listitem>
      </orderedlist>

      <para>You can make subsequent changes to
      <filename>mk/build.mk</filename> as often as you like.  You do
      not have to run any further configuration programs to make these
      changes take effect. In theory you should, however, say
      <Command>gmake clean</Command>, <Command>gmake all</Command>,
      because configuration option changes could affect
      anything&mdash;but in practice you are likely to know what's
      affected.</para>
    </sect2>

    <sect2>
      <Title>Making things</Title>

      <para>At this point you have made yourself a fully-configured
      build tree, so you are ready to start building real
      things.</para>

      <para>The first thing you need to know is that <Emphasis>you
      must use GNU <Command>make</Command>, usually called
      <Command>gmake</Command>, not standard Unix
      <Command>make</Command></Emphasis>.  If you use standard Unix
      <Command>make</Command> you will get all sorts of error messages
      (but no damage) because the <Literal>fptools</Literal>
      <Command>Makefiles</Command> use GNU <Command>make</Command>'s
      facilities extensively.</para>

      <para>To just build the whole thing, <command>cd</command> to
      the top of your <literal>fptools</literal> tree and type
      <command>gmake</command>.  This will prepare the tree and build
      the various projects in the correct order.</para>

    </Sect2>

    <Sect2 id="sec-standard-targets">
      <Title>Standard Targets</title>
      <IndexTerm><Primary>targets, standard makefile</Primary></IndexTerm>
      <IndexTerm><Primary>makefile targets</Primary></IndexTerm>

      <para>In any directory you should be able to make the following:

<VariableList>

<VarListEntry>
<Term><Literal>boot</Literal>:</Term>
<ListItem>
<para>does the one-off preparation required to get ready for the real
work.  Notably, it does <Command>gmake depend</Command> in all
directories that contain programs.  It also builds the necessary tools
for compilation to proceed.</para>

<para>Invoking the <literal>boot</literal> target explicitly is not
normally necessary.  From the top-level <literal>fptools</literal>
directory, invoking <literal>gmake</literal> causes <literal>gmake
boot all</literal> to be invoked in each of the project
subdirectories, in the order specified by
<literal>&dollar;(AllTargets)</literal> in
<literal>config.mk</literal>.</para>

<para>If you're working in a subdirectory somewhere and need to update
the dependencies, <literal>gmake boot</literal> is a good way to do it.</para>

</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>all</Literal>:</Term>
<ListItem>
<para>
makes all the final target(s) for this Makefile.
Depending on which directory you are in a ``final target'' may be an
executable program, a library archive, a shell script, or a Postscript
file.  Typing <Command>gmake</Command> alone is generally the same as typing <Command>gmake all</Command>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>install</Literal>:</Term>
<ListItem>
<para>
installs the things built by <Literal>all</Literal> (except for the documentation).  Where does it
install them?  That is specified by
<filename>mk/config.mk.in</filename>; you can override it in
<filename>mk/build.mk</filename>, or by running
<command>configure</command> with command-line arguments like
<literal>--bindir=/home/simonpj/bin</literal>;  see <literal>./configure
--help</literal> for the full details.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>install-docs</Literal>:</Term>
<ListItem>
<para>
installs the documentation. Otherwise behaves just like <literal>install</literal>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>uninstall</Literal>:</Term>
<ListItem>
<para>
reverses the effect of <Literal>install</Literal>.
</para>
</ListItem></VarListEntry>

<VarListEntry>
<Term><Literal>clean</Literal>:</Term>
<ListItem>
<para>
Delete all files from the current directory that are normally created
by building the program.  Don't delete the files that record the
configuration, or files generated by <Command>gmake boot</Command>.
Also preserve files that could be made by building, but normally
aren't because the distribution comes with them.</para>
</ListItem></VarListEntry>

<varlistentry>
<term><literal>distclean</literal>:</term>
<listitem>
<para>Delete all files from the current directory that are created by
configuring or building the program. If you have unpacked the source
and built the program without creating any other files, <literal>make
distclean</literal> should leave only the files that were in the
distribution.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><literal>mostlyclean</literal>:</term>
<listitem>
<para>Like <literal>clean</literal>, but may refrain from deleting a
few files that people normally don't want to recompile.</para>
</listitem>
</varlistentry>

<VarListEntry>
<Term><Literal>maintainer-clean</Literal>:</Term>
<ListItem>
<para>
Delete everything from the current directory that can be reconstructed
with this Makefile.  This typically includes everything deleted by
<literal>distclean</literal>, plus more: C source files produced by
Bison, tags tables, Info files, and so on.</para>

<para>One exception, however: <literal>make maintainer-clean</literal>
should not delete <filename>configure</filename> even if
<filename>configure</filename> can be remade using a rule in the
<filename>Makefile</filename>. More generally, <literal>make
maintainer-clean</literal> should not delete anything that needs to
exist in order to run <filename>configure</filename> and then begin to
build the program.</para>
</listitem>
</varlistentry>

<VarListEntry>
<Term><Literal>check</Literal>:</Term>
<ListItem>
<para>
run the test suite.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
All of these standard targets automatically recurse into
sub-directories.  Certain other standard targets do not:
</para>

<para>
<VariableList>

<VarListEntry>
<Term><Literal>configure</Literal>:</Term>
<ListItem>
<para>
is only available in the root directory
<Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>; it has been discussed in <XRef LinkEnd="sec-build-config">.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>depend</Literal>:</Term>
<ListItem>
<para>
make a <filename>.depend</filename> file in each directory that needs
it. This <filename>.depend</filename> file contains mechanically-generated dependency
information; for example, suppose a directory contains a Haskell 
source module <filename>Foo.lhs</filename> which imports another module <Literal>Baz</Literal>.
Then the generated <filename>.depend</filename> file will contain the dependency:
</para>

<para>

<ProgramListing>
Foo.o : Baz.hi
</ProgramListing>

</para>

<para>
which says that the object file <filename>Foo.o</filename> depends on the interface file
<filename>Baz.hi</filename> generated by compiling module <Literal>Baz</Literal>.  The <filename>.depend</filename> file is
automatically included by every Makefile.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>binary-dist</Literal>:</Term>
<ListItem>
<para>
make a binary distribution.  This is the
target we use to build the binary distributions of GHC and Happy.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>dist</Literal>:</Term>
<ListItem>
<para>
make a source distribution.  Note that this target does &ldquo;make
distclean&rdquo; as part of its work; don't use it if you want to keep
what you've built.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
Most <filename>Makefile</filename>s have targets other than these.  You can discover them by looking in the <filename>Makefile</filename> itself.
</para>

</Sect2>

<sect2>
<title>Using a project from the build tree</title>
<para>
If you want to build GHC (say) and just use it direct from the build
tree without doing <literal>make install</literal> first, you can run
the in-place driver script:
<filename>ghc/compiler/ghc-inplace</filename>.
</para>

<para> Do <emphasis>NOT</emphasis> use
<filename>ghc/compiler/ghc</filename>, or
<filename>ghc/compiler/ghc-5.xx</filename>, as these are the scripts
intended for installation, and contain hard-wired paths to the
installed libraries, rather than the libraries in the build tree.
</para>

<para>
Happy can similarly be run from the build tree, using
<filename>happy/src/happy-inplace</filename>.
</para>
</sect2>

<Sect2>
<Title>Fast Making <IndexTerm><Primary>fastmake</Primary></IndexTerm>
<IndexTerm><Primary>dependencies, omitting</Primary></IndexTerm>
<IndexTerm><Primary>FAST, makefile
variable</Primary></IndexTerm></Title>

<para>
Sometimes the dependencies get in the way: if you've made a small
change to one file, and you're absolutely sure that it won't affect
anything else, but you know that <Command>make</Command> is going to rebuild everything
anyway, the following hack may be useful:
</para>

<para>

<ProgramListing>
gmake FAST=YES 
</ProgramListing>

</para>

<para>
This tells the make system to ignore dependencies and just build what
you tell it to.  In other words, it's equivalent to temporarily
removing the <filename>.depend</filename> file in the current directory (where
<Command>mkdependHS</Command> and friends store their dependency information).
</para>

<para>
A bit of history: GHC used to come with a <Command>fastmake</Command> script that did
the above job, but GNU make provides the features we need to do it
without resorting to a script.  Also, we've found that fastmaking is
less useful since the advent of GHC's recompilation checker (see the
User's Guide section on "Separate Compilation").
</para>

</Sect2>

</Sect1>

<Sect1 id="sec-makefile-arch">
<Title>The <filename>Makefile</filename> architecture
<IndexTerm><Primary>makefile architecture</Primary></IndexTerm></Title>

<para>
<Command>make</Command> is great if everything works&mdash;you type <Command>gmake install</Command> and
lo! the right things get compiled and installed in the right places.
Our goal is to make this happen often, but somehow it often doesn't;
instead some weird error message eventually emerges from the bowels of
a directory you didn't know existed.
</para>

<para>
The purpose of this section is to give you a road-map to help you figure
out what is going right and what is going wrong.
</para>

<Sect2>
<Title>A small project</Title>

<para>
To get started, let us look at the <filename>Makefile</filename> for an imaginary small
<Literal>fptools</Literal> project, <Literal>small</Literal>.  Each project in <Literal>fptools</Literal> has its own
directory in <Constant>FPTOOLS&lowbar;TOP</Constant>, so the <Literal>small</Literal> project will have its own
directory <Constant>FPOOLS&lowbar;TOP/small/</Constant>.  Inside the <filename>small/</filename> directory there
will be a <filename>Makefile</filename>, looking something like this:
</para>

<para>
<IndexTerm><Primary>Makefile, minimal</Primary></IndexTerm>

<ProgramListing>
#     Makefile for fptools project "small"

TOP = ..
include $(TOP)/mk/boilerplate.mk

SRCS = $(wildcard *.lhs) $(wildcard *.c)
HS_PROG = small

include $(TOP)/target.mk
</ProgramListing>

</para>

<para>
This <filename>Makefile</filename> has three sections:
</para>

<para>

<OrderedList>
<ListItem>

<para>
 The first section includes
<FOOTNOTE>

<para>
One of the most important
features of GNU <Command>make</Command> that we use is the ability for a <filename>Makefile</filename> to
include another named file, very like <Command>cpp</Command>'s <Literal>&num;include</Literal>
directive.
</para>

</FOOTNOTE>
 a file of ``boilerplate'' code from the level
above (which in this case will be
<filename><Constant>FPTOOLS&lowbar;TOP</Constant>/mk/boilerplate.mk</filename><IndexTerm><Primary>boilerplate.mk</Primary></IndexTerm>).  As its name
suggests, <filename>boilerplate.mk</filename> consists of a large quantity of standard
<filename>Makefile</filename> code.  We discuss this boilerplate in more detail in
<XRef LinkEnd="sec-boiler">.
<IndexTerm><Primary>include, directive in Makefiles</Primary></IndexTerm>
<IndexTerm><Primary>Makefile inclusion</Primary></IndexTerm>

Before the <Literal>include</Literal> statement, you must define the <Command>make</Command> variable
<Constant>TOP</Constant><IndexTerm><Primary>TOP</Primary></IndexTerm> to be the directory containing the <filename>mk</filename> directory in
which the <filename>boilerplate.mk</filename> file is.  It is <Emphasis>not</Emphasis> OK to simply say


<ProgramListing>
include ../mk/boilerplate.mk  # NO NO NO
</ProgramListing>


Why?  Because the <filename>boilerplate.mk</filename> file needs to know where it is, so
that it can, in turn, <Literal>include</Literal> other files.  (Unfortunately, when an
<Literal>include</Literal>d file does an <Literal>include</Literal>, the filename is treated relative to
the directory in which <Command>gmake</Command> is being run, not the directory in
which the <Literal>include</Literal>d sits.)  In general, <Emphasis>every file <filename>foo.mk</filename>
assumes that <filename><Constant>&dollar;(TOP)</Constant>/mk/foo.mk</filename> refers to itself.</Emphasis> It is up to the
<filename>Makefile</filename> doing the <Literal>include</Literal> to ensure this is the case.

Files intended for inclusion in other <filename>Makefile</filename>s are written to have
the following property: <Emphasis>after <filename>foo.mk</filename> is <Literal>include</Literal>d, it leaves
<Constant>TOP</Constant> containing the same value as it had just before the <Literal>include</Literal>
statement</Emphasis>.  In our example, this invariant guarantees that the
<Literal>include</Literal> for <filename>target.mk</filename> will look in the same directory as that for
<filename>boilerplate.mk</filename>.

</para>
</ListItem>
<ListItem>

<para>
 The second section defines the following standard <Command>make</Command>
variables: <Constant>SRCS</Constant><IndexTerm><Primary>SRCS</Primary></IndexTerm> (the source files from which is to be
built), and <Constant>HS&lowbar;PROG</Constant><IndexTerm><Primary>HS&lowbar;PROG</Primary></IndexTerm> (the executable binary to be
built).  We will discuss in more detail what the ``standard
variables'' are, and how they affect what happens, in <XRef LinkEnd="sec-targets">.

The definition for <Constant>SRCS</Constant> uses the useful GNU <Command>make</Command> construct
<Literal>&dollar;(wildcard&nbsp;$pat$)</Literal><IndexTerm><Primary>wildcard</Primary></IndexTerm>, which expands to a list of all
the files matching the pattern <Literal>pat</Literal> in the current directory.  In
this example, <Constant>SRCS</Constant> is set to the list of all the <filename>.lhs</filename> and <filename>.c</filename>
files in the directory.  (Let's suppose there is one of each,
<filename>Foo.lhs</filename> and <filename>Baz.c</filename>.)

</para>
</ListItem>
<ListItem>

<para>
 The last section includes a second file of standard code,
called <filename>target.mk</filename><IndexTerm><Primary>target.mk</Primary></IndexTerm>.  It contains the rules that tell
<Command>gmake</Command> how to make the standard targets (<Xref LinkEnd="sec-standard-targets">).  Why, you ask,
can't this standard code be part of <filename>boilerplate.mk</filename>?  Good question.
We discuss the reason later, in <Xref LinkEnd="sec-boiler-arch">.

You do not <Emphasis>have</Emphasis> to <Literal>include</Literal> the <filename>target.mk</filename> file.  Instead, you
can write rules of your own for all the standard targets.  Usually,
though, you will find quite a big payoff from using the canned rules
in <filename>target.mk</filename>; the price tag is that you have to understand what
canned rules get enabled, and what they do (<Xref LinkEnd="sec-targets">).

</para>
</ListItem>

</OrderedList>

</para>

<para>
In our example <filename>Makefile</filename>, most of the work is done by the two
<Literal>include</Literal>d files.  When you say <Command>gmake all</Command>, the following things
happen:
</para>

<para>

<ItemizedList>
<ListItem>

<para>
 <Command>gmake</Command> figures out that the object files are <filename>Foo.o</filename> and
<filename>Baz.o</filename>.

</para>
</ListItem>
<ListItem>

<para>
 It uses a boilerplate pattern rule to compile <filename>Foo.lhs</filename> to
<filename>Foo.o</filename> using a Haskell compiler.  (Which one?  That is set in the
build configuration.)

</para>
</ListItem>
<ListItem>

<para>
 It uses another standard pattern rule to compile <filename>Baz.c</filename> to
<filename>Baz.o</filename>, using a C compiler.  (Ditto.)

</para>
</ListItem>
<ListItem>

<para>
 It links the resulting <filename>.o</filename> files together to make <Literal>small</Literal>,
using the Haskell compiler to do the link step.  (Why not use <Command>ld</Command>?
Because the Haskell compiler knows what standard libraries to link in.
How did <Command>gmake</Command> know to use the Haskell compiler to do the link,
rather than the C compiler?  Because we set the variable <Constant>HS&lowbar;PROG</Constant>
rather than <Constant>C&lowbar;PROG</Constant>.)

</para>
</ListItem>

</ItemizedList>

</para>

<para>
All <filename>Makefile</filename>s should follow the above three-section format.
</para>

</Sect2>

<Sect2>
<Title>A larger project</Title>

<para>
Larger projects are usually structured into a number of sub-directories,
each of which has its own <filename>Makefile</filename>.  (In very large projects, this
sub-structure might be iterated recursively, though that is rare.)
To give you the idea, here's part of the directory structure for
the (rather large) GHC project:
</para>

<para>

<Screen>
$(FPTOOLS_TOP)/ghc/
  Makefile
  mk/
    boilerplate.mk
    rules.mk
   docs/
    Makefile
    ...source files for documentation...
   driver/
    Makefile
    ...source files for driver...
   compiler/
    Makefile
    parser/...source files for parser...
    renamer/...source files for renamer...
    ...etc...
</Screen>

</para>

<para>
The sub-directories <filename>docs</filename>, <filename>driver</filename>, <filename>compiler</filename>, and so on, each
contains a sub-component of GHC, and each has its own <filename>Makefile</filename>.
There must also be a <filename>Makefile</filename> in <filename><Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>/ghc</filename>.  It does most
of its work by recursively invoking <Command>gmake</Command> on the <filename>Makefile</filename>s in the
sub-directories.  We say that <filename>ghc/Makefile</filename> is a <Emphasis>non-leaf
<filename>Makefile</filename></Emphasis>, because it does little except organise its children,
while the <filename>Makefile</filename>s in the sub-directories are all <Emphasis>leaf
<filename>Makefile</filename>s</Emphasis>.  (In principle the sub-directories might themselves
contain a non-leaf <filename>Makefile</filename> and several sub-sub-directories, but
that does not happen in GHC.)
</para>

<para>
The <filename>Makefile</filename> in <filename>ghc/compiler</filename> is considered a leaf <filename>Makefile</filename> even
though the <filename>ghc/compiler</filename> has sub-directories, because these sub-directories
do not themselves have <filename>Makefile</filename>s in them.  They are just used to structure
the collection of modules that make up GHC, but all are managed by the
single <filename>Makefile</filename> in <filename>ghc/compiler</filename>.
</para>

<para>
You will notice that <filename>ghc/</filename> also contains a directory <filename>ghc/mk/</filename>.  It
contains GHC-specific <filename>Makefile</filename> boilerplate code.  More precisely:
</para>

<para>

<ItemizedList>
<ListItem>

<para>
 <filename>ghc/mk/boilerplate.mk</filename> is included at the top of
<filename>ghc/Makefile</filename>, and of all the leaf <filename>Makefile</filename>s in the
sub-directories.  It in turn <Literal>include</Literal>s the main boilerplate file
<filename>mk/boilerplate.mk</filename>.


</para>
</ListItem>
<ListItem>

<para>
 <filename>ghc/mk/target.mk</filename> is <Literal>include</Literal>d at the bottom of
<filename>ghc/Makefile</filename>, and of all the leaf <filename>Makefile</filename>s in the
sub-directories.  It in turn <Literal>include</Literal>s the file <filename>mk/target.mk</filename>.

</para>
</ListItem>

</ItemizedList>

</para>

<para>
So these two files are the place to look for GHC-wide customisation
of the standard boilerplate.
</para>

</Sect2>

<Sect2 id="sec-boiler-arch">
<Title>Boilerplate architecture
<IndexTerm><Primary>boilerplate architecture</Primary></IndexTerm>
</Title>

<para>
Every <filename>Makefile</filename> includes a <filename>boilerplate.mk</filename><IndexTerm><Primary>boilerplate.mk</Primary></IndexTerm> file
at the top, and <filename>target.mk</filename><IndexTerm><Primary>target.mk</Primary></IndexTerm> file at the bottom.  In
this section we discuss what is in these files, and why there have to
be two of them.  In general:
</para>

<para>

<ItemizedList>
<ListItem>

<para>
 <filename>boilerplate.mk</filename> consists of:

<ItemizedList>
<ListItem>

<para>
 <Emphasis>Definitions of millions of <Command>make</Command> variables</Emphasis> that
collectively specify the build configuration.  Examples:
<Constant>HC&lowbar;OPTS</Constant><IndexTerm><Primary>HC&lowbar;OPTS</Primary></IndexTerm>, the options to feed to the Haskell compiler;
<Constant>NoFibSubDirs</Constant><IndexTerm><Primary>NoFibSubDirs</Primary></IndexTerm>, the sub-directories to enable within the
<Literal>nofib</Literal> project; <Constant>GhcWithHc</Constant><IndexTerm><Primary>GhcWithHc</Primary></IndexTerm>, the name of the Haskell
compiler to use when compiling GHC in the <Literal>ghc</Literal> project.  
</para>
</ListItem>
<ListItem>

<para>
<Emphasis>Standard pattern rules</Emphasis> that tell <Command>gmake</Command> how to construct one
file from another.
</para>
</ListItem>

</ItemizedList>


<filename>boilerplate.mk</filename> needs to be <Literal>include</Literal>d at the <Emphasis>top</Emphasis>
of each <filename>Makefile</filename>, so that the user can replace the
boilerplate definitions or pattern rules by simply giving a new
definition or pattern rule in the <filename>Makefile</filename>.  <Command>gmake</Command>
simply takes the last definition as the definitive one.

Instead of <Emphasis>replacing</Emphasis> boilerplate definitions, it is also quite
common to <Emphasis>augment</Emphasis> them. For example, a <filename>Makefile</filename> might say:


<ProgramListing>
SRC_HC_OPTS += -O
</ProgramListing>


thereby adding ``<Option>-O</Option>'' to the end of <Constant>SRC&lowbar;HC&lowbar;OPTS</Constant><IndexTerm><Primary>SRC&lowbar;HC&lowbar;OPTS</Primary></IndexTerm>.

</para>
</ListItem>
<ListItem>

<para>
 <filename>target.mk</filename> contains <Command>make</Command> rules for the standard
targets described in <Xref LinkEnd="sec-standard-targets">.  These rules are selectively included,
depending on the setting of certain <Command>make</Command> variables.  These
variables are usually set in the middle section of the
<filename>Makefile</filename> between the two <Literal>include</Literal>s.

<filename>target.mk</filename> must be included at the end (rather than being part of
<filename>boilerplate.mk</filename>) for several tiresome reasons:


<ItemizedList>
<ListItem>

<para>
 <Command>gmake</Command> commits target and dependency lists earlier than
it should.  For example, <FIlename>target.mk</FIlename> has a rule that looks like
this: 


<ProgramListing>
$(HS_PROG) : $(OBJS)
      $(HC) $(LD_OPTS) $&#60; -o $@
</ProgramListing>


If this rule was in <filename>boilerplate.mk</filename> then <Constant>&dollar;(HS&lowbar;PROG)</Constant><IndexTerm><Primary>HS&lowbar;PROG</Primary></IndexTerm>
and <Constant>&dollar;(OBJS)</Constant><IndexTerm><Primary>OBJS</Primary></IndexTerm> would not have their final values at the
moment <Command>gmake</Command> encountered the rule.  Alas, <Command>gmake</Command> takes a snapshot
of their current values, and wires that snapshot into the rule.  (In
contrast, the commands executed when the rule ``fires'' are only
substituted at the moment of firing.)  So, the rule must follow the
definitions given in the <filename>Makefile</filename> itself.

</para>
</ListItem>
<ListItem>

<para>
 Unlike pattern rules, ordinary rules cannot be overriden or
replaced by subsequent rules for the same target (at least, not without an
error message).  Including ordinary rules in <filename>boilerplate.mk</filename> would
prevent the user from writing rules for specific targets in specific cases.

</para>
</ListItem>
<ListItem>

<para>
 There are a couple of other reasons I've forgotten, but it doesn't
matter too much.
</para>
</ListItem>

</ItemizedList>

</para>
</ListItem>

</ItemizedList>

</para>

</Sect2>

<Sect2 id="sec-boiler">
<Title>The main <filename>mk/boilerplate.mk</filename> file

<IndexTerm><Primary>boilerplate.mk</Primary></IndexTerm></Title>

<para>
If you look at <filename><Constant>&dollar;(FPTOOLS&lowbar;TOP)</Constant>/mk/boilerplate.mk</filename> you will find
that it consists of the following sections, each held in a separate
file: 
</para>

<para>
<VariableList>

<VarListEntry>
<Term><filename>config.mk</filename><IndexTerm><Primary>config.mk</Primary></IndexTerm></Term>
<ListItem>
<para>
is the build configuration file we
discussed at length in <Xref LinkEnd="sec-build-config">.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><filename>paths.mk</filename><IndexTerm><Primary>paths.mk</Primary></IndexTerm></Term>
<ListItem>
<para>
defines <Command>make</Command> variables for
pathnames and file lists.  In particular, it gives definitions for:
</para>

<para>
<VariableList>

<VarListEntry>
<Term><Constant>SRCS</Constant><IndexTerm><Primary>SRCS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
all source files in the current directory.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>HS&lowbar;SRCS</Constant><IndexTerm><Primary>HS&lowbar;SRCS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
all Haskell source files in the current directory.
It is derived from <Constant>&dollar;(SRCS)</Constant>, so if you override <Constant>SRCS</Constant> with a new value
<Constant>HS&lowbar;SRCS</Constant> will follow suit.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>C&lowbar;SRCS</Constant><IndexTerm><Primary>C&lowbar;SRCS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
similarly for C source files.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>HS&lowbar;OBJS</Constant><IndexTerm><Primary>HS&lowbar;OBJS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
the <filename>.o</filename> files derived from <Constant>&dollar;(HS&lowbar;SRCS)</Constant>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>C&lowbar;OBJS</Constant><IndexTerm><Primary>C&lowbar;OBJS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
similarly for <Constant>&dollar;(C&lowbar;SRCS)</Constant>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>OBJS</Constant><IndexTerm><Primary>OBJS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
the concatenation of <Constant>&dollar;(HS&lowbar;OBJS)</Constant> and <Constant>&dollar;(C&lowbar;OBJS)</Constant>.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
Any or all of these definitions can easily be overriden by giving new
definitions in your <filename>Makefile</filename>.  For example, if there are things in
the current directory that look like source files but aren't, then
you'll need to set <Constant>SRCS</Constant> manually in your <filename>Makefile</filename>.  The other
definitions will then work from this new definition.
</para>

<para>
What, exactly, does <filename>paths.mk</filename> consider a ``source file'' to be?  It's
based on the file's suffix (e.g. <filename>.hs</filename>, <filename>.lhs</filename>, <filename>.c</filename>, <filename>.lc</filename>, etc), but
this is the kind of detail that changes, so rather than
enumerate the source suffices here the best thing to do is to look in
<filename>paths.mk</filename>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><filename>opts.mk</filename><IndexTerm><Primary>opts.mk</Primary></IndexTerm></Term>
<ListItem>
<para>
defines <Command>make</Command> variables for option
strings to pass to each program. For example, it defines
<Constant>HC&lowbar;OPTS</Constant><IndexTerm><Primary>HC&lowbar;OPTS</Primary></IndexTerm>, the option strings to pass to the Haskell
compiler.  See <Xref LinkEnd="sec-suffix">.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><filename>suffix.mk</filename><IndexTerm><Primary>suffix.mk</Primary></IndexTerm></Term>
<ListItem>
<para>
defines standard pattern rules&mdash;see <Xref LinkEnd="sec-suffix">.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
Any of the variables and pattern rules defined by the boilerplate file
can easily be overridden in any particular <filename>Makefile</filename>, because the
boilerplate <Literal>include</Literal> comes first.  Definitions after this <Literal>include</Literal>
directive simply override the default ones in <filename>boilerplate.mk</filename>.
</para>

</Sect2>

<Sect2 id="sec-suffix">
<Title>Pattern rules and options

<IndexTerm><Primary>Pattern rules</Primary></IndexTerm></Title>

<para>
The file <filename>suffix.mk</filename><IndexTerm><Primary>suffix.mk</Primary></IndexTerm> defines standard <Emphasis>pattern
rules</Emphasis> that say how to build one kind of file from another, for
example, how to build a <filename>.o</filename> file from a <filename>.c</filename> file.  (GNU <Command>make</Command>'s
<Emphasis>pattern rules</Emphasis> are more powerful and easier to use than Unix
<Command>make</Command>'s <Emphasis>suffix rules</Emphasis>.)
</para>

<para>
Almost all the rules look something like this:
</para>

<para>

<ProgramListing>
%.o : %.c
      $(RM) $@
      $(CC) $(CC_OPTS) -c $&#60; -o $@
</ProgramListing>

</para>

<para>
Here's how to understand the rule.  It says that
<Emphasis>something</Emphasis><filename>.o</filename> (say <filename>Foo.o</filename>) can be built from
<Emphasis>something</Emphasis><filename>.c</filename> (<filename>Foo.c</filename>), by invoking the C compiler
(path name held in <Constant>&dollar;(CC)</Constant>), passing to it the options
<Constant>&dollar;(CC&lowbar;OPTS)</Constant> and the rule's dependent file of the rule
<Literal>&dollar;&lt;</Literal> (<filename>Foo.c</filename> in this case), and putting the result in
the rule's target <Literal>&dollar;@</Literal> (<filename>Foo.o</filename> in this case).
</para>

<para>
Every program is held in a <Command>make</Command> variable defined in
<filename>mk/config.mk</filename>&mdash;look in <filename>mk/config.mk</filename> for the
complete list.  One important one is the Haskell compiler, which is
called <Constant>&dollar;(HC)</Constant>.
</para>

<para>
Every program's options are are held in a <Command>make</Command> variables called
<Constant>&lt;prog&gt;&lowbar;OPTS</Constant>.  the <Constant>&lt;prog&gt;&lowbar;OPTS</Constant> variables are defined in
<filename>mk/opts.mk</filename>.  Almost all of them are defined like this:
</para>

<para>

<ProgramListing>
CC_OPTS = $(SRC_CC_OPTS) $(WAY$(_way)_CC_OPTS) $($*_CC_OPTS) $(EXTRA_CC_OPTS)
</ProgramListing>

</para>

<para>
The four variables from which <Constant>CC&lowbar;OPTS</Constant> is built have the following meaning:
</para>

<para>
<VariableList>

<VarListEntry>
<Term><Constant>SRC&lowbar;CC&lowbar;OPTS</Constant><IndexTerm><Primary>SRC&lowbar;CC&lowbar;OPTS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
options passed to all C
compilations.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>WAY&lowbar;&lt;way&gt;&lowbar;CC&lowbar;OPTS</Constant>:</Term>
<ListItem>
<para>
options passed to C
compilations for way <Literal>&lt;way&gt;</Literal>. For example,
<Constant>WAY&lowbar;mp&lowbar;CC&lowbar;OPTS</Constant> gives options to pass to the C compiler when
compiling way <Literal>mp</Literal>.  The variable <Constant>WAY&lowbar;CC&lowbar;OPTS</Constant> holds
options to pass to the C compiler when compiling the standard way.
(<Xref LinkEnd="sec-ways"> dicusses multi-way
compilation.)  
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>&lt;module&gt;&lowbar;CC&lowbar;OPTS</Constant>:</Term>
<ListItem>
<para>
options to
pass to the C compiler that are specific to module <Literal>&lt;module&gt;</Literal>.  For example, <Constant>SMap&lowbar;CC&lowbar;OPTS</Constant> gives the specific options
to pass to the C compiler when compiling <filename>SMap.c</filename>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>EXTRA&lowbar;CC&lowbar;OPTS</Constant><IndexTerm><Primary>EXTRA&lowbar;CC&lowbar;OPTS</Primary></IndexTerm>:</Term>
<ListItem>
<para>
extra options to pass to all
C compilations.  This is intended for command line use, thus:
</para>

<para>

<ProgramListing>
gmake libHS.a EXTRA_CC_OPTS="-v"
</ProgramListing>

</para>
</ListItem></VarListEntry>
</VariableList>
</para>

</Sect2>

<Sect2 id="sec-targets">
<Title>The main <filename>mk/target.mk</filename> file

<IndexTerm><Primary>target.mk</Primary></IndexTerm></Title>

<para>
<filename>target.mk</filename> contains canned rules for all the standard targets
described in <Xref LinkEnd="sec-standard-targets">.  It is complicated by the fact that you don't want all of
these rules to be active in every <filename>Makefile</filename>.  Rather than have a
plethora of tiny files which you can include selectively, there is a
single file, <filename>target.mk</filename>, which selectively includes rules based on
whether you have defined certain variables in your <filename>Makefile</filename>.  This
section explains what rules you get, what variables control them, and
what the rules do.  Hopefully, you will also get enough of an idea of
what is supposed to happen that you can read and understand any weird
special cases yourself.
</para>

<para>
<VariableList>

<VarListEntry>
<Term><Constant>HS&lowbar;PROG</Constant><IndexTerm><Primary>HS&lowbar;PROG</Primary></IndexTerm>.</Term>
<ListItem>
<para>
If <Constant>HS&lowbar;PROG</Constant> is defined, you get
rules with the following targets:
<VariableList>

<VarListEntry>
<Term><filename>HS&lowbar;PROG</filename><IndexTerm><Primary>HS&lowbar;PROG</Primary></IndexTerm></Term>
<ListItem>
<para>
itself.  This rule links <Constant>&dollar;(OBJS)</Constant>
with the Haskell runtime system to get an executable called
<Constant>&dollar;(HS&lowbar;PROG)</Constant>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Literal>install</Literal><IndexTerm><Primary>install</Primary></IndexTerm></Term>
<ListItem>
<para>
installs <Constant>&dollar;(HS&lowbar;PROG)</Constant>
in <Constant>&dollar;(bindir)</Constant>.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>C&lowbar;PROG</Constant><IndexTerm><Primary>C&lowbar;PROG</Primary></IndexTerm></Term>
<ListItem>
<para>
is similar to <Constant>HS&lowbar;PROG</Constant>, except that
the link step links <Constant>&dollar;(C&lowbar;OBJS)</Constant> with the C runtime system.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>LIBRARY</Constant><IndexTerm><Primary>LIBRARY</Primary></IndexTerm></Term>
<ListItem>
<para>
is similar to <Constant>HS&lowbar;PROG</Constant>, except that
it links <Constant>&dollar;(LIB&lowbar;OBJS)</Constant> to make the library archive <Constant>&dollar;(LIBRARY)</Constant>, and
<Literal>install</Literal> installs it in <Constant>&dollar;(libdir)</Constant>.
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>LIB&lowbar;DATA</Constant><IndexTerm><Primary>LIB&lowbar;DATA</Primary></IndexTerm></Term>
<ListItem>
<para>
&hellip;
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>LIB&lowbar;EXEC</Constant><IndexTerm><Primary>LIB&lowbar;EXEC</Primary></IndexTerm></Term>
<ListItem>
<para>
&hellip;
</para>
</ListItem></VarListEntry>
<VarListEntry>
<Term><Constant>HS&lowbar;SRCS</Constant><IndexTerm><Primary>HS&lowbar;SRCS</Primary></IndexTerm>, <Constant>C&lowbar;SRCS</Constant><IndexTerm><Primary>C&lowbar;SRCS</Primary></IndexTerm>.</Term>
<ListItem>
<para>
If <Constant>HS&lowbar;SRCS</Constant>
is defined and non-empty, a rule for the target <Literal>depend</Literal> is included,
which generates dependency information for Haskell programs.
Similarly for <Constant>C&lowbar;SRCS</Constant>.
</para>
</ListItem></VarListEntry>
</VariableList>
</para>

<para>
All of these rules are ``double-colon'' rules, thus
</para>

<para>

<ProgramListing>
install :: $(HS_PROG)
      ...how to install it...
</ProgramListing>

</para>

<para>
GNU <Command>make</Command> treats double-colon rules as separate entities.  If there
are several double-colon rules for the same target it takes each in
turn and fires it if its dependencies say to do so.  This means that
you can, for example, define both <Constant>HS&lowbar;PROG</Constant> and <Constant>LIBRARY</Constant>, which will
generate two rules for <Literal>install</Literal>.  When you type <Command>gmake install</Command> both
rules will be fired, and both the program and the library will be
installed, just as you wanted.
</para>

</Sect2>

<Sect2 id="sec-subdirs">
<Title>Recursion

<IndexTerm><Primary>recursion, in makefiles</Primary></IndexTerm>
<IndexTerm><Primary>Makefile, recursing into subdirectories</Primary></IndexTerm></Title>

<para>
In leaf <filename>Makefile</filename>s the variable <Constant>SUBDIRS</Constant><IndexTerm><Primary>SUBDIRS</Primary></IndexTerm> is undefined.
In non-leaf <filename>Makefile</filename>s, <Constant>SUBDIRS</Constant> is set to the list of
sub-directories that contain subordinate <filename>Makefile</filename>s.  <Emphasis>It is up to
you to set <Constant>SUBDIRS</Constant> in the <filename>Makefile</filename>.</Emphasis> There is no automation here&mdash;<Constant>SUBDIRS</Constant> is too important to automate.
</para>

<para>
When <Constant>SUBDIRS</Constant> is defined, <filename>target.mk</filename> includes a rather
neat rule for the standard targets (<Xref LinkEnd="sec-standard-targets"> that simply invokes
<Command>make</Command> recursively in each of the sub-directories.
</para>

<para>
<Emphasis>These recursive invocations are guaranteed to occur in the order
in which the list of directories is specified in <Constant>SUBDIRS</Constant>. </Emphasis>This
guarantee can be important.  For example, when you say <Command>gmake boot</Command> it
can be important that the recursive invocation of <Command>make boot</Command> is done
in one sub-directory (the include files, say) before another (the
source files).  Generally, put the most independent sub-directory
first, and the most dependent last.
</para>

</Sect2>

<Sect2 id="sec-ways">
<Title>Way management

<IndexTerm><Primary>way management</Primary></IndexTerm></Title>

<para>
We sometimes want to build essentially the same system in several
different ``ways''.  For example, we want to build GHC's <Literal>Prelude</Literal>
libraries with and without profiling, with and without concurrency,
and so on, so that there is an appropriately-built library archive to
link with when the user compiles his program.  It would be possible to
have a completely separate build tree for each such ``way'', but it
would be horribly bureaucratic, especially since often only parts of
the build tree need to be constructed in multiple ways.
</para>

<para>
Instead, the <filename>target.mk</filename><IndexTerm><Primary>target.mk</Primary></IndexTerm> contains some clever magic to
allow you to build several versions of a system; and to control
locally how many versions are built and how they differ.  This section
explains the magic.
</para>

<para>
The files for a particular way are distinguished by munging the
suffix.  The ``normal way'' is always built, and its files have the
standard suffices <filename>.o</filename>, <filename>.hi</filename>, and so on.  In addition, you can build
one or more extra ways, each distinguished by a <Emphasis>way tag</Emphasis>.  The
object files and interface files for one of these extra ways are
distinguished by their suffix.  For example, way <Literal>mp</Literal> has files
<filename>.mp&lowbar;o</filename> and <filename>.mp&lowbar;hi</filename>.  Library archives have their way tag the other
side of the dot, for boring reasons; thus, <filename>libHS&lowbar;mp.a</filename>.
</para>

<para>
A <Command>make</Command> variable called <Constant>way</Constant> holds the current way tag.  <Emphasis><Constant>way</Constant>
is only ever set on the command line of a recursive invocation of
<Command>gmake</Command>.</Emphasis> It is never set inside a <filename>Makefile</filename>.  So it is a global
constant for any one invocation of <Command>gmake</Command>.  Two other <Command>make</Command>
variables, <Constant>way&lowbar;</Constant> and <Constant>&lowbar;way</Constant> are immediately derived from <Constant>&dollar;(way)</Constant> and
never altered.  If <Constant>way</Constant> is not set, then neither are <Constant>way&lowbar;</Constant> and
<Constant>&lowbar;way</Constant>, and the invocation of <Command>make</Command> will build the ``normal way''.
If <Constant>way</Constant> is set, then the other two variables are set in sympathy.
For example, if <Constant>&dollar;(way)</Constant> is ``<Literal>mp</Literal>'', then <Constant>way&lowbar;</Constant> is set to ``<Literal>mp&lowbar;</Literal>''
and <Constant>&lowbar;way</Constant> is set to ``<Literal>&lowbar;mp</Literal>''.  These three variables are then used
when constructing file names.
</para>

<para>
So how does <Command>make</Command> ever get recursively invoked with <Constant>way</Constant> set?  There
are two ways in which this happens:
</para>

<para>

<ItemizedList>
<ListItem>

<para>
 For some (but not all) of the standard targets, when in a leaf
sub-directory, <Command>make</Command> is recursively invoked for each way tag in
<Constant>&dollar;(WAYS)</Constant>.  You set <Constant>WAYS</Constant> to the list of way tags you want these
targets built for.  The mechanism here is very much like the recursive
invocation of <Command>make</Command> in sub-directories (<Xref LinkEnd="sec-subdirs">).

It is up to you to set <Constant>WAYS</Constant> in your <filename>Makefile</filename>; this is how you
control what ways will get built.  
</para>
</ListItem>
<ListItem>

<para>
 For a useful collection of
targets (such as <filename>libHS&lowbar;mp.a</filename>, <filename>Foo.mp&lowbar;o</filename>) there is a rule which
recursively invokes <Command>make</Command> to make the specified target, setting the
<Constant>way</Constant> variable.  So if you say <Command>gmake Foo.mp&lowbar;o</Command> you should see a
recursive invocation <Command>gmake Foo.mp&lowbar;o way=mp</Command>, and <Emphasis>in this
recursive invocation the pattern rule for compiling a Haskell file
into a <filename>.o</filename> file will match</Emphasis>.  The key pattern rules (in <filename>suffix.mk</filename>)
look like this:


<ProgramListing>
%.$(way_)o : %.lhs
      $(HC) $(HC_OPTS) $&#60; -o $@
</ProgramListing>


Neat, eh?
</para>
</ListItem>

</ItemizedList>

</para>

</Sect2>

<Sect2>
<Title>When the canned rule isn't right</Title>

<para>
Sometimes the canned rule just doesn't do the right thing.  For
example, in the <Literal>nofib</Literal> suite we want the link step to print out
timing information.  The thing to do here is <Emphasis>not</Emphasis> to define
<Constant>HS&lowbar;PROG</Constant> or <Constant>C&lowbar;PROG</Constant>, and instead define a special purpose rule in
your own <filename>Makefile</filename>.  By using different variable names you will avoid
the canned rules being included, and conflicting with yours.
</para>

</Sect2>

</Sect1>

<Sect1 id="sec-booting-from-C">
<Title>Booting/porting from C (<filename>.hc</filename>) files

<IndexTerm><Primary>building GHC from .hc files</Primary></IndexTerm>
<IndexTerm><Primary>booting GHC from .hc files</Primary></IndexTerm>
<IndexTerm><Primary>porting GHC</Primary></IndexTerm></Title>

<para>
This section is for people trying to get GHC going by using the supplied
intermediate C (<filename>.hc</filename>) files.  This would probably be
because no binaries have been provided, or because the machine is not ``fully
supported''.
</para>

<para>
The intermediate C files are normally made available together with a source
release, please check the announce message for exact directions of where to
find them. If we haven't made them available or you can't find them, please
ask.
</para>

<para>
Assuming you've got them, unpack them on top of a fresh source tree.  This
will place matching <filename>.hc</filename> files next to the corresponding
Haskell source in the compiler subdirectory <filename>ghc</filename> and in
the language package of hslibs (i.e., in <filename>hslibs/lang</filename>).
Then follow the `normal' instructions in <Xref
LinkEnd="sec-building-from-source"> for setting up a build tree.
</para>

<para>
The actual build process is fully automated by the
<filename>hc-build</filename> script located in the
<filename>distrib</filename> directory.  If you eventually want to install GHC
into the directory <filename>INSTALL_DIRECTORY</filename>, the following
command will execute the whole build process (it won't install yet):
</para>
<Screen>
foo% distrib/hc-build --prefix=INSTALL_DIRECTORY
</Screen>
<IndexTerm><Primary>--hc-build</Primary></IndexTerm>
<para>
By default, the installation directory is <filename>/usr/local</filename>.  If
that is what you want, you may omit the argument to
<filename>hc-build</filename>.  Generally, any option given to
<filename>hc-build</filename> is passed through to the configuration script
<filename>configure</filename>.  If <filename>hc-build</filename>
successfully completes the build process, you can install the resulting
system, as normal, with
</para>
<Screen>
foo% make install
</Screen>

<para>
That's the mechanics of the boot process, but, of course, if you're
trying to boot on a platform that is not supported and significantly
`different' from any of the supported ones, this is only the start of
the adventure&hellip;(ToDo: porting tips&mdash;stuff to look out for, etc.)
</para>

</Sect1>

<Sect1 id="sec-build-pitfalls">
<Title>Known pitfalls in building Glasgow Haskell

<IndexTerm><Primary>problems, building</Primary></IndexTerm>
<IndexTerm><Primary>pitfalls, in building</Primary></IndexTerm>
<IndexTerm><Primary>building pitfalls</Primary></IndexTerm></Title>

<para>
WARNINGS about pitfalls and known ``problems'':
</para>

<para>

<OrderedList>
<ListItem>

<para>
One difficulty that comes up from time to time is running out of space
in <literal>TMPDIR</literal>.  (It is impossible for the configuration stuff to
compensate for the vagaries of different sysadmin approaches to temp
space.)
<IndexTerm><Primary>tmp, running out of space in</Primary></IndexTerm>

The quickest way around it is <Command>setenv TMPDIR /usr/tmp</Command><IndexTerm><Primary>TMPDIR</Primary></IndexTerm> or
even <Command>setenv TMPDIR .</Command> (or the equivalent incantation with your shell
of choice).

The best way around it is to say

<ProgramListing>
export TMPDIR=&#60;dir&#62;
</ProgramListing>

in your <filename>build.mk</filename> file.
Then GHC and the other <Literal>fptools</Literal> programs will use the appropriate directory
in all cases.


</para>
</ListItem>
<ListItem>

<para>
In compiling some support-code bits, e.g., in <filename>ghc/rts/gmp</filename> and even
in <filename>ghc/lib</filename>, you may get a few C-compiler warnings.  We think these
are OK.

</para>
</ListItem>
<ListItem>

<para>
When compiling via C, you'll sometimes get ``warning: assignment from
incompatible pointer type'' out of GCC.  Harmless.

</para>
</ListItem>
<ListItem>

<para>
Similarly, <Command>ar</Command>chiving warning messages like the following are not
a problem:

<Screen>
ar: filename GlaIOMonad__1_2s.o truncated to GlaIOMonad_
ar: filename GlaIOMonad__2_2s.o truncated to GlaIOMonad_
...
</Screen>


</para>
</ListItem>
<ListItem>

<para>
 In compiling the compiler proper (in <filename>compiler/</filename>), you <Emphasis>may</Emphasis>
get an ``Out of heap space'' error message.  These can vary with the
vagaries of different systems, it seems.  The solution is simple:


<ItemizedList>
<ListItem>

<para>
 If you're compiling with GHC 4.00 or later, then the
<Emphasis>maximum</Emphasis> heap size must have been reached.  This
is somewhat unlikely, since the maximum is set to 64M by default.
Anyway, you can raise it with the
<Option>-optCrts-M&lt;size&gt;</Option> flag (add this flag to
<Constant>&lt;module&gt;&lowbar;HC&lowbar;OPTS</Constant>
<Command>make</Command> variable in the appropriate
<filename>Makefile</filename>).

</para>
</ListItem>
<ListItem>

<para>
 For GHC &#60; 4.00, add a suitable <Option>-H</Option> flag to the <filename>Makefile</filename>, as
above.

</para>
</ListItem>

</ItemizedList>


and try again: <Command>gmake</Command>.  (see <Xref LinkEnd="sec-suffix"> for information about
<Constant>&lt;module&gt;&lowbar;HC&lowbar;OPTS</Constant>.)

Alternatively, just cut to the chase:

<Screen>
% cd ghc/compiler
% make EXTRA_HC_OPTS=-optCrts-M128M
</Screen>


</para>
</ListItem>
<ListItem>

<para>
If you try to compile some Haskell, and you get errors from GCC about
lots of things from <filename>/usr/include/math.h</filename>, then your GCC was
mis-installed.  <Command>fixincludes</Command> wasn't run when it should've been.

As <Command>fixincludes</Command> is now automagically run as part of GCC installation,
this bug also suggests that you have an old GCC.


</para>
</ListItem>
<ListItem>

<para>
You <Emphasis>may</Emphasis> need to re-<Command>ranlib</Command><IndexTerm><Primary>ranlib</Primary></IndexTerm> your libraries (on Sun4s).


<Screen>
% cd $(libdir)/ghc-x.xx/sparc-sun-sunos4
% foreach i ( `find . -name '*.a' -print` ) # or other-shell equiv...
?    ranlib $i
?    # or, on some machines: ar s $i
? end
</Screen>


We'd be interested to know if this is still necessary.


</para>
</ListItem>
<ListItem>

<para>
GHC's sources go through <Command>cpp</Command> before being compiled, and <Command>cpp</Command> varies
a bit from one Unix to another.  One particular gotcha is macro calls
like this:


<ProgramListing>
SLIT("Hello, world")
</ProgramListing>


Some <Command>cpp</Command>s treat the comma inside the string as separating two macro
arguments, so you get


<Screen>
:731: macro `SLIT' used with too many (2) args
</Screen>


Alas, <Command>cpp</Command> doesn't tell you the offending file!

Workaround: don't put weird things in string args to <Command>cpp</Command> macros.
</para>
</ListItem>

</OrderedList>

</para>

</Sect1>


<Sect1 id="winbuild"><Title>Notes for building under Windows</Title>

<para>
This section summarises how to get the utilities you need on your
Win95/98/NT/2000 machine to use CVS and build GHC. Similar notes for
installing and running GHC may be found in the user guide. In general,
Win95/Win98 behave the same, and WinNT/Win2k behave the same.
You should read the GHC installation guide sections on Windows (in the user
guide) before continuing to read these notes.
</para>

<para>
Because of various hard-wired infelicities, you need to copy
<Filename>bash.exe</Filename> (from GHC's <Filename>extra-bin</Filename>
directory), and <Filename>perl.exe</Filename> and
<Filename>cat.exe</Filename> (from GHC's <Filename>bin</Filename> directory)
to <Filename>/bin</Filename> (discover where your Cygwin root directory is
by typign <Command>mount</Command>).
</para>

<para>
Before you start, you need to make sure that the user environment variable
<Constant>MAKE_MODE</Constant> is set to <Literal>UNIX</Literal>. If you
don't do this you get very weird messages when you type
<Command>make</Command>, such as:
</para>
<Screen>
/c: /c: No such file or directory</Screen>

<Sect2><Title>Configuring ssh</Title>

<ItemizedList>

<ListItem>
<para>
Generate a key, by running <filename>c:/user/local/bin/ssh-keygen1</filename>.
  This generates a public key in <filename>.ssh/identity.pub</filename>, and a
  private key in <filename>.ssh/identity</filename>
</para>

<para>
  In response to the 'Enter passphrase' question, just hit
  return (i.e. use an empty passphrase).  The passphrase is
  a password that protects your private key.  But it's a pain
  to type this passphrase everytime you use <Command>ssh</Command>, so the best
  thing to do is simply to protect your <filename>.ssh</filename> directory, and
  <filename>.ssh/identity</filename> from access by anyone else.  To do this 
  right-click your <filename>.ssh</filename> directory, and select Properties.
  If you are not on the access control list, add yourself, and
  give yourself full permissions (the second panel).  
  Remove everyone else from the access control list.  (Don't
  leave them there but deny them access, because 'they' may be
  a list that includes you!)
</para>

<para>
  If you have problems running <Command>ssh-keygen1</Command>
  from within <Command>bash</Command>, start up <filename>cmd.exe</filename> and run it as follows:
</para>

<Screen>
c:\tmp> set CYGWIN32=tty
c:\tmp> c:/user/local/bin/ssh-keygen1
</Screen>
</ListItem>

<ListItem>
<para>
If you don't have an account on <Literal>cvs.haskell.org</Literal>, send 
  your <filename>.ssh/identity.pub</filename> to the CVS repository administrator
  (currently Jeff Lewis <Email>jlewis@galconn.com</Email>).  He will set up
  your account.
</para>

<para>
  If you do have an account on <Literal>cvs.haskell.org</Literal>, use TeraTerm
  to logon to it. Once in, copy the
  key that <Command>ssh-keygen1</Command> deposited in <filename>/.ssh/identity.pub</filename> into
  your <filename>~/.ssh/authorized_keys</filename>. Make sure that the new version
  of <filename>authorized_keys</filename> still has 600 file permission.
</para>
</ListItem>

</ItemizedList>

</Sect2>


<Sect2><Title>Configuring CVS</Title>

<ItemizedList>

<ListItem>
<para>
From the System control panel,
set the following <Emphasis>user</Emphasis> environment variables (see the GHC user guide)
</para>

<ItemizedList>
<ListItem>
<para>
<Constant>HOME</Constant>: points to your home directory.  This is where CVS
will look for its <filename>.cvsrc</filename> file.
</para>
</ListItem>

<ListItem>
<para>
<Constant>CVS_RSH</Constant>: <filename>c:/path_to_ghc/extra-bin/ssh</filename>
</para>
</ListItem>

<ListItem>
<para>
<Constant>CVSROOT</Constant>: <Literal>:ext:username@cvs.haskell.org:/home/cvs/root</Literal>,
where <Literal>username</Literal> is your userid
</para>
</ListItem>

<ListItem>
<para>
<Constant>CVSEDITOR</Constant>: <filename>bin/gnuclient.exe</filename> if you want to use an Emacs buffer for typing in those long commit messages.
</para>
</ListItem>

<ListItem>
<para>
<Constant>SHELL</Constant>: To use bash as the shell in Emacs, you need to
set this to point to <Filename>bash.exe</Filename>.
</para>
</ListItem>

</ItemizedList>
</ListItem>

<ListItem>
<para>
Put the following in <filename>$HOME/.cvsrc</filename>:
</para>

<ProgramListing>
checkout -P
release -d
update -P
diff -u
</ProgramListing>

<para>
These are the default options for the specified CVS commands,
and represent better defaults than the usual ones.  (Feel
free to change them.)
</para>

<para>
Filenames starting with <filename>.</filename> were illegal in 
the 8.3 DOS filesystem, but that restriction should have
been lifted by now (i.e., you're using VFAT or later filesystems.) If
you're still having problems creating it, don't worry; <filename>.cvsrc</filename> is entirely
optional.
</para>
</ListItem>

<ListItem>
<para>
Try doing <Command>cvs co fpconfig</Command>. All being well, bytes should
start to trickle through, leaving a directory <filename>fptools</filename>
in your current directory.  (You can <Command>rm</Command> it if you don't
want to keep it.) The following messages appear to be harmless:
</para>

<Screen>
setsockopt IPTOS_LOWDELAY: Invalid argument
setsockopt IPTOS_THROUGHPUT: Invalid argument
</Screen>

<para>
At this point I found that CVS tried to invoke a little dialogue with
me (along the lines of `do you want to talk to this host?'), but
for some reason bombed out.  This was from a bash shell running in Emacs.
I solved this by invoking a Cygnus shell, and running CVS from there.
Once things are dialogue free, it seems to work OK from within Emacs.
</para>
</ListItem>

<ListItem>
<para>
If you want to check out part of large tree, proceed as follows:
</para>

<ProgramListing>
cvs -f checkout -l papers
cd papers
cvs update cpr
</ProgramListing>

<para>
This sequence checks out the <Literal>papers</Literal> module, but none
of its sub-directories.
The "<Option>-l</Option>" flag says not to check out sub-directories.
The "<Option>-f</Option>" flag says not to read the <filename>.cvsrc</filename> file
whose <Option>-P</Option> default (don't check out empty directories) is
in this case bogus.
</para>

<para>
The <Command>cvs update</Command> command sucks in a named sub-directory.
</para>
</ListItem>

</ItemizedList>

<para>
There is a very nice graphical front-end to CVS for Win32 platforms,
with a UI that people will be familiar with, at 
<ULink URL="http://www.wincvs.org/">wincvs.org</ULink>.
I have not tried it yet.
</para>

</Sect2>


    <Sect2><Title>Building GHC</Title>
      
      <ItemizedList>

	<ListItem>
	  <para>
	    You should give the option
	    <option>--host=i386-unknown-mingw32</option> to
	    <command>autoconf</command>, so that it doesn't try to
	    build for Cygwin (unless that's what you really
	    want). Since it's possible to get into trouble using the
	    wrong C compiler, it's wise either to avoid installing
	    Cygwin gcc, or to explicitly specify
	    <option>--with-gcc=/mingw/bin/gcc</option>.
	  </para>
	</ListItem>

<ListItem>
<para>
You have to run <Command>autoconf</Command> both in <filename>fptools</filename>
and in <filename>fptools/ghc</filename>.  If you omit the latter step you'll
get an error when you run <filename>./configure</filename>:
</para>

<Screen>
...lots of stuff...
creating mk/config.h
mk/config.h is unchanged
configuring in ghc
running /bin/sh ./configure  --cache-file=.././config.cache --srcdir=.
./configure: ./configure: No such file or directory
configure: error: ./configure failed for ghc
</Screen>
</ListItem>

<ListItem>
<para>
You need <filename>ghc</filename> to be in your <Constant>PATH</Constant> before you run
<Command>configure</Command>. The InstallShield tells you the path
when you install it.
</para>
</ListItem>

</ItemizedList>

</Sect2>

    <sect2>
      <title>Building the Windows InstallShield&reg; Installer</title>

      <para>
	This section is intended for GHC developers only; no-one else
	should need to build an InstallShield.
      </para>

      <para>
	Having built a second-stage tree and done <command>make
	install</command> on it, open the InstallShield
	(<filename>.ism</filename>) file. Open the Project screen, and
	then the Project subfolder of the Path variables folder, and
	set <literal>SourceFiles</literal> to the top of your
	tree. You might also need to set <literal>GHCBITS</literal> to
	point to the tree of various external bits that are added into
	the IS mix. You should then be able to build an InstallShield.
      </para>

      <sect3>
	<title>Extra features of the InstallShield</title>

	<para>
	  The InstallShield has some IS-specific twiddles:

	  <itemizedlist>
	    <listitem>
	      <para>
		Two registry entries are set under
		<literal>HKEY_LOCAL_MACHINE\SOFTWARE\GHC</literal>:
		<literal>Path</literal> and
		<literal>Version</literal>, which record respectively
		the directory in which GHC was installed, and the
		version number.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		The InstallShield adds some entries to the Program
		menu, for GHCi and for the documentation. See under
		Setup Design and the individual components (each
		component can add entries to the menu).
	      </para>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>
      
      <sect3>
	<title>External add-ins</title>

	<para>
	  The external add-ins consist of Mingwin gcc and Mingwin
	  Perl. The layout of the add-ins tree is as follows:

	  <screen>
extra-bin/
  gcc.exe
  perl.exe    (Mingwin perl)
  perl56.dll
gcc-lib/
  Mingwin gcc binaries, libraries and headers
include/
  Mingwin includes
</screen>
	  </para>
	</sect3>
      
    </sect2>

</Sect1>

</Article>
